use clap::{App, AppSettings, Arg, SubCommand};
use default_boxed::DefaultBoxed;

#[derive(DefaultBoxed)]
struct Outer<'a, 'b> {
    inner: HeapApp<'a, 'b>,
}

struct HeapApp<'a, 'b> {
    app: App<'a, 'b>,
}

impl<'a, 'b> Default for HeapApp<'a, 'b> {
    fn default() -> Self {
        let mut app = App::new("iam1")
            .setting(clap::AppSettings::ColoredHelp)
            .author("Sebastian Thiel <byronimo@gmail.com>")
            .version("0.1.0-20200617")
            .about("Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls.")
            .after_help("All documentation details can be found at <TODO figure out URL>")
            .arg(Arg::with_name("scope")
                .long("scope")
                .help("Specify the authentication method should be executed in. Each scope requires the user to grant this application permission to use it. If unset, it defaults to the shortest scope url for a particular method.")
                .multiple(true)
                .takes_value(true))
            .arg(Arg::with_name("folder")
                .long("config-dir")
                .help("A directory into which we will store our persistent data. Defaults to a user-writable directory that we will create during the first invocation." )
                .multiple(false)
                .takes_value(true))
            .arg(Arg::with_name("debug")
                .long("debug")
                .help("Provide more output to aid with debugging")
                .multiple(false)
                .takes_value(false));
        let mut iam_policies0 = SubCommand::with_name("iam_policies")
            .setting(AppSettings::ColoredHelp)
            .about("methods: lint_policy and query_auditable_services");
        {
            let mcmd = SubCommand::with_name("lint_policy").about("Lints, or validates, an IAM policy. Currently checks the\ngoogle.iam.v1.Binding.condition field, which contains a condition\nexpression for a role binding.\n\nSuccessful calls to this method always return an HTTP `200 OK` status code,\neven if the linter detects an issue in the IAM policy.");
            iam_policies0 = iam_policies0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("query_auditable_services").about("Returns a list of services that allow you to opt into audit logs that are\nnot generated by default.\n\nTo learn more about audit logs, see the [Logging\ndocumentation](https://cloud.google.com/logging/docs/audit).");
            iam_policies0 = iam_policies0.subcommand(mcmd);
        }
        let mut organizations0 = SubCommand::with_name("organizations")
            .setting(AppSettings::ColoredHelp)
            .about("sub-resources: roles");
        let mut permissions0 = SubCommand::with_name("permissions")
            .setting(AppSettings::ColoredHelp)
            .about("methods: query_testable_permissions");
        {
            let mcmd = SubCommand::with_name("query_testable_permissions").about("Lists every permission that you can test on a resource. A permission is\ntestable if you can check whether a member has that permission on the\nresource.");
            permissions0 = permissions0.subcommand(mcmd);
        }
        let mut projects0 = SubCommand::with_name("projects")
            .setting(AppSettings::ColoredHelp)
            .about("sub-resources: roles and service_accounts");
        let mut roles0 = SubCommand::with_name("roles")
            .setting(AppSettings::ColoredHelp)
            .about("methods: get, list and query_grantable_roles");
        {
            let mcmd = SubCommand::with_name("get").about("Gets the definition of a Role.");
            roles0 = roles0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("list").about("Lists every predefined Role that IAM supports, or every custom role\nthat is defined for an organization or project.");
            roles0 = roles0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("query_grantable_roles").about("Lists roles that can be granted on a Google Cloud resource. A role is\ngrantable if the IAM policy for the resource can contain bindings to the\nrole.");
            roles0 = roles0.subcommand(mcmd);
        }
        let mut roles1 = SubCommand::with_name("roles")
            .setting(AppSettings::ColoredHelp)
            .about("methods: create, delete, get, list, patch and undelete");
        {
            let mcmd = SubCommand::with_name("create").about("Creates a new custom Role.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("delete").about("Deletes a custom Role.\n\nWhen you delete a custom role, the following changes occur immediately:\n\n* You cannot bind a member to the custom role in an IAM\nPolicy.\n* Existing bindings to the custom role are not changed, but they have no\neffect.\n* By default, the response from ListRoles does not include the custom\nrole.\n\nYou have 7 days to undelete the custom role. After 7 days, the following\nchanges occur:\n\n* The custom role is permanently deleted and cannot be recovered.\n* If an IAM policy contains a binding to the custom role, the binding is\npermanently removed.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("get").about("Gets the definition of a Role.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("list").about("Lists every predefined Role that IAM supports, or every custom role\nthat is defined for an organization or project.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd =
                SubCommand::with_name("patch").about("Updates the definition of a custom Role.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("undelete").about("Undeletes a custom Role.");
            roles1 = roles1.subcommand(mcmd);
        }
        let mut roles1 = SubCommand::with_name("roles")
            .setting(AppSettings::ColoredHelp)
            .about("methods: create, delete, get, list, patch and undelete");
        {
            let mcmd = SubCommand::with_name("create").about("Creates a new custom Role.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("delete").about("Deletes a custom Role.\n\nWhen you delete a custom role, the following changes occur immediately:\n\n* You cannot bind a member to the custom role in an IAM\nPolicy.\n* Existing bindings to the custom role are not changed, but they have no\neffect.\n* By default, the response from ListRoles does not include the custom\nrole.\n\nYou have 7 days to undelete the custom role. After 7 days, the following\nchanges occur:\n\n* The custom role is permanently deleted and cannot be recovered.\n* If an IAM policy contains a binding to the custom role, the binding is\npermanently removed.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("get").about("Gets the definition of a Role.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("list").about("Lists every predefined Role that IAM supports, or every custom role\nthat is defined for an organization or project.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd =
                SubCommand::with_name("patch").about("Updates the definition of a custom Role.");
            roles1 = roles1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("undelete").about("Undeletes a custom Role.");
            roles1 = roles1.subcommand(mcmd);
        }
        let mut service_accounts1 = SubCommand::with_name("service_accounts")
                        .setting(AppSettings::ColoredHelp)
                        .about("methods: create, delete, disable, enable, get, get_iam_policy, list, patch, set_iam_policy, sign_blob, sign_jwt, test_iam_permissions, undelete and update");
        {
            let mcmd = SubCommand::with_name("create").about("Creates a ServiceAccount.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("delete").about("Deletes a ServiceAccount.\n\n**Warning:** After you delete a service account, you might not be able to\nundelete it. If you know that you need to re-enable the service account in\nthe future, use DisableServiceAccount instead.\n\nIf you delete a service account, IAM permanently removes the service\naccount 30 days later. Google Cloud cannot recover the service account\nafter it is permanently removed, even if you file a support request.\n\nTo help avoid unplanned outages, we recommend that you disable the service\naccount before you delete it. Use DisableServiceAccount to disable the\nservice account, then wait at least 24 hours and watch for unintended\nconsequences. If there are no unintended consequences, you can delete the\nservice account.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("disable").about("Disables a ServiceAccount immediately.\n\nIf an application uses the service account to authenticate, that\napplication can no longer call Google APIs or access Google Cloud\nresources. Existing access tokens for the service account are rejected, and\nrequests for new access tokens will fail.\n\nTo re-enable the service account, use EnableServiceAccount. After you\nre-enable the service account, its existing access tokens will be accepted,\nand you can request new access tokens.\n\nTo help avoid unplanned outages, we recommend that you disable the service\naccount before you delete it. Use this method to disable the service\naccount, then wait at least 24 hours and watch for unintended consequences.\nIf there are no unintended consequences, you can delete the service account\nwith DeleteServiceAccount.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("enable").about("Enables a ServiceAccount that was disabled by\nDisableServiceAccount.\n\nIf the service account is already enabled, then this method has no effect.\n\nIf the service account was disabled by other means—for example, if Google\ndisabled the service account because it was compromised—you cannot use this\nmethod to enable the service account.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("get").about("Gets a ServiceAccount.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("get_iam_policy").about("Gets the IAM policy that is attached to a ServiceAccount. This IAM\npolicy specifies which members have access to the service account.\n\nThis method does not tell you whether the service account has been granted\nany roles on other resources. To check whether a service account has role\ngrants on a resource, use the `getIamPolicy` method for that resource. For\nexample, to view the role grants for a project, call the Resource Manager\nAPI\'s\n[`projects.getIamPolicy`](https://cloud.google.com/resource-manager/reference/rest/v1/projects/getIamPolicy)\nmethod.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("list")
                .about("Lists every ServiceAccount that belongs to a specific project.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("patch").about("Patches a ServiceAccount.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("set_iam_policy").about("Sets the IAM policy that is attached to a ServiceAccount.\n\nUse this method to grant or revoke access to the service account. For\nexample, you could grant a member the ability to impersonate the service\naccount.\n\nThis method does not enable the service account to access other resources.\nTo grant roles to a service account on a resource, follow these steps:\n\n1. Call the resource\'s `getIamPolicy` method to get its current IAM policy.\n2. Edit the policy so that it binds the service account to an IAM role for\nthe resource.\n3. Call the resource\'s `setIamPolicy` method to update its IAM policy.\n\nFor detailed instructions, see\n[Granting roles to a service account for specific\nresources](https://cloud.google.com/iam/help/service-accounts/granting-access-to-service-accounts).");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_blob").about("**Note:** We are in the process of deprecating this method. Use the\n[`signBlob`](https://cloud.google.com/iam/help/rest-credentials/v1/projects.serviceAccounts/signBlob)\nmethod in the IAM Service Account Credentials API instead.\n\nSigns a blob using the system-managed private key for a ServiceAccount.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_jwt").about("**Note:** We are in the process of deprecating this method. Use the\n[`signJwt`](https://cloud.google.com/iam/help/rest-credentials/v1/projects.serviceAccounts/signJwt)\nmethod in the IAM Service Account Credentials API instead.\n\nSigns a JSON Web Token (JWT) using the system-managed private key for a\nServiceAccount.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("test_iam_permissions").about(
                "Tests whether the caller has the specified permissions on a\nServiceAccount.",
            );
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("undelete").about("Restores a deleted ServiceAccount.\n\n**Important:** It is not always possible to restore a deleted service\naccount. Use this method only as a last resort.\n\nAfter you delete a service account, IAM permanently removes the service\naccount 30 days later. There is no way to restore a deleted service account\nthat has been permanently removed.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("update").about("**Note:** We are in the process of deprecating this method. Use\nPatchServiceAccount instead.\n\nUpdates a ServiceAccount.\n\nYou can update only the `display_name` and `description` fields.");
            service_accounts1 = service_accounts1.subcommand(mcmd);
        }
        let mut keys2 = SubCommand::with_name("keys")
            .setting(AppSettings::ColoredHelp)
            .about("methods: create, delete, get, list and upload");
        {
            let mcmd = SubCommand::with_name("create").about("Creates a ServiceAccountKey.");
            keys2 = keys2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("delete").about("Deletes a ServiceAccountKey.");
            keys2 = keys2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("get").about("Gets a ServiceAccountKey.");
            keys2 = keys2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("list")
                .about("Lists every ServiceAccountKey for a service account.");
            keys2 = keys2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("upload")
                .about("Creates a ServiceAccountKey, using a public key that you provide.");
            keys2 = keys2.subcommand(mcmd);
        }
        service_accounts1 = service_accounts1.subcommand(keys2);
        projects0 = projects0.subcommand(service_accounts1);
        projects0 = projects0.subcommand(roles1);
        organizations0 = organizations0.subcommand(roles1);
        app = app.subcommand(roles0);
        app = app.subcommand(projects0);
        app = app.subcommand(permissions0);
        app = app.subcommand(organizations0);
        app = app.subcommand(iam_policies0);

        Self { app }
    }
}
use google_iam1 as api;

fn main() {
    // TODO: set homedir afterwards, once the address is unmovable, or use Pin for the very first time
    // to allow a self-referential structure :D!
    let _home_dir = dirs::config_dir()
        .expect("configuration directory can be obtained")
        .join("google-service-cli");
    let outer = Outer::default_boxed();
    let app = outer.inner.app;
    let _matches = app.get_matches();
}
