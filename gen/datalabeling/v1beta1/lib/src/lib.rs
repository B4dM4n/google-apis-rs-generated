#![doc = "# Resources and Methods\n    * [projects](resources/projects/struct.ProjectsActions.html)\n      * [annotation_spec_sets](resources/projects/annotation_spec_sets/struct.AnnotationSpecSetsActions.html)\n        * [*create*](resources/projects/annotation_spec_sets/struct.CreateRequestBuilder.html), [*delete*](resources/projects/annotation_spec_sets/struct.DeleteRequestBuilder.html), [*get*](resources/projects/annotation_spec_sets/struct.GetRequestBuilder.html), [*list*](resources/projects/annotation_spec_sets/struct.ListRequestBuilder.html)\n      * [datasets](resources/projects/datasets/struct.DatasetsActions.html)\n        * [*create*](resources/projects/datasets/struct.CreateRequestBuilder.html), [*delete*](resources/projects/datasets/struct.DeleteRequestBuilder.html), [*exportData*](resources/projects/datasets/struct.ExportDataRequestBuilder.html), [*get*](resources/projects/datasets/struct.GetRequestBuilder.html), [*importData*](resources/projects/datasets/struct.ImportDataRequestBuilder.html), [*list*](resources/projects/datasets/struct.ListRequestBuilder.html)\n        * [annotated_datasets](resources/projects/datasets/annotated_datasets/struct.AnnotatedDatasetsActions.html)\n          * [*delete*](resources/projects/datasets/annotated_datasets/struct.DeleteRequestBuilder.html), [*get*](resources/projects/datasets/annotated_datasets/struct.GetRequestBuilder.html), [*list*](resources/projects/datasets/annotated_datasets/struct.ListRequestBuilder.html)\n          * [data_items](resources/projects/datasets/annotated_datasets/data_items/struct.DataItemsActions.html)\n            * [*get*](resources/projects/datasets/annotated_datasets/data_items/struct.GetRequestBuilder.html), [*list*](resources/projects/datasets/annotated_datasets/data_items/struct.ListRequestBuilder.html)\n          * [examples](resources/projects/datasets/annotated_datasets/examples/struct.ExamplesActions.html)\n            * [*get*](resources/projects/datasets/annotated_datasets/examples/struct.GetRequestBuilder.html), [*list*](resources/projects/datasets/annotated_datasets/examples/struct.ListRequestBuilder.html)\n          * [feedback_threads](resources/projects/datasets/annotated_datasets/feedback_threads/struct.FeedbackThreadsActions.html)\n            * [*delete*](resources/projects/datasets/annotated_datasets/feedback_threads/struct.DeleteRequestBuilder.html), [*get*](resources/projects/datasets/annotated_datasets/feedback_threads/struct.GetRequestBuilder.html), [*list*](resources/projects/datasets/annotated_datasets/feedback_threads/struct.ListRequestBuilder.html)\n            * [feedback_messages](resources/projects/datasets/annotated_datasets/feedback_threads/feedback_messages/struct.FeedbackMessagesActions.html)\n              * [*create*](resources/projects/datasets/annotated_datasets/feedback_threads/feedback_messages/struct.CreateRequestBuilder.html), [*delete*](resources/projects/datasets/annotated_datasets/feedback_threads/feedback_messages/struct.DeleteRequestBuilder.html), [*get*](resources/projects/datasets/annotated_datasets/feedback_threads/feedback_messages/struct.GetRequestBuilder.html), [*list*](resources/projects/datasets/annotated_datasets/feedback_threads/feedback_messages/struct.ListRequestBuilder.html)\n        * [data_items](resources/projects/datasets/data_items/struct.DataItemsActions.html)\n          * [*get*](resources/projects/datasets/data_items/struct.GetRequestBuilder.html), [*list*](resources/projects/datasets/data_items/struct.ListRequestBuilder.html)\n        * [evaluations](resources/projects/datasets/evaluations/struct.EvaluationsActions.html)\n          * [*get*](resources/projects/datasets/evaluations/struct.GetRequestBuilder.html)\n          * [example_comparisons](resources/projects/datasets/evaluations/example_comparisons/struct.ExampleComparisonsActions.html)\n            * [*search*](resources/projects/datasets/evaluations/example_comparisons/struct.SearchRequestBuilder.html)\n        * [image](resources/projects/datasets/image/struct.ImageActions.html)\n          * [*label*](resources/projects/datasets/image/struct.LabelRequestBuilder.html)\n        * [text](resources/projects/datasets/text/struct.TextActions.html)\n          * [*label*](resources/projects/datasets/text/struct.LabelRequestBuilder.html)\n        * [video](resources/projects/datasets/video/struct.VideoActions.html)\n          * [*label*](resources/projects/datasets/video/struct.LabelRequestBuilder.html)\n      * [evaluation_jobs](resources/projects/evaluation_jobs/struct.EvaluationJobsActions.html)\n        * [*create*](resources/projects/evaluation_jobs/struct.CreateRequestBuilder.html), [*delete*](resources/projects/evaluation_jobs/struct.DeleteRequestBuilder.html), [*get*](resources/projects/evaluation_jobs/struct.GetRequestBuilder.html), [*list*](resources/projects/evaluation_jobs/struct.ListRequestBuilder.html), [*patch*](resources/projects/evaluation_jobs/struct.PatchRequestBuilder.html), [*pause*](resources/projects/evaluation_jobs/struct.PauseRequestBuilder.html), [*resume*](resources/projects/evaluation_jobs/struct.ResumeRequestBuilder.html)\n      * [evaluations](resources/projects/evaluations/struct.EvaluationsActions.html)\n        * [*search*](resources/projects/evaluations/struct.SearchRequestBuilder.html)\n      * [instructions](resources/projects/instructions/struct.InstructionsActions.html)\n        * [*create*](resources/projects/instructions/struct.CreateRequestBuilder.html), [*delete*](resources/projects/instructions/struct.DeleteRequestBuilder.html), [*get*](resources/projects/instructions/struct.GetRequestBuilder.html), [*list*](resources/projects/instructions/struct.ListRequestBuilder.html)\n      * [operations](resources/projects/operations/struct.OperationsActions.html)\n        * [*cancel*](resources/projects/operations/struct.CancelRequestBuilder.html), [*delete*](resources/projects/operations/struct.DeleteRequestBuilder.html), [*get*](resources/projects/operations/struct.GetRequestBuilder.html), [*list*](resources/projects/operations/struct.ListRequestBuilder.html)\n"]
pub mod scopes {
    #[doc = "See, edit, configure, and delete your Google Cloud data and see the email address for your Google Account.\n\n`https://www.googleapis.com/auth/cloud-platform`"]
    pub const CLOUD_PLATFORM: &str = "https://www.googleapis.com/auth/cloud-platform";
}
pub mod schemas {
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Alpha1CreateInstructionMetadata {
        #[doc = "Timestamp when create instruction request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "The name of the created Instruction. projects/{project_id}/instructions/{instruction_id}"]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction: ::std::option::Option<String>,
        #[doc = "Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1CreateInstructionMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1CreateInstructionMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Alpha1ExportDataOperationMetadata {
        #[doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Output only. Timestamp when export dataset request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The name of dataset to be exported. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1ExportDataOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1ExportDataOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1ExportDataOperationResponse {
        #[doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Ouptut only. The name of dataset. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples exported successfully."]
        #[serde(
            rename = "exportCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub export_count: ::std::option::Option<i32>,
        #[doc = "Output only. Statistic infos of labels in the exported dataset."]
        #[serde(
            rename = "labelStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_stats:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Alpha1LabelStats>,
        #[doc = "Output only. output_config in the ExportData request."]
        #[serde(
            rename = "outputConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Alpha1OutputConfig>,
        #[doc = "Output only. Total number of examples requested to export"]
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1ExportDataOperationResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1ExportDataOperationResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1GcsDestination {
        #[doc = "Required. The format of the gcs destination. Only \"text/csv\" and \"application/json\" are supported."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Required. The output uri of destination file."]
        #[serde(
            rename = "outputUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Alpha1GcsDestination {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Alpha1GcsDestination {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1GcsFolderDestination {
        #[doc = "Required. Cloud Storage directory to export data to."]
        #[serde(
            rename = "outputFolderUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_folder_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1GcsFolderDestination
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Alpha1GcsFolderDestination {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig {
        #[doc = "Optional. A human-readable description for AnnotatedDataset. The description can be up to 10000 characters long."]
        #[serde(
            rename = "annotatedDatasetDescription",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset_description: ::std::option::Option<String>,
        #[doc = "Required. A human-readable name for AnnotatedDataset defined by users. Maximum of 64 characters ."]
        #[serde(
            rename = "annotatedDatasetDisplayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset_display_name: ::std::option::Option<String>,
        #[doc = "Optional. If you want your own labeling contributors to manage and work on this labeling request, you can set these contributors here. We will give them access to the question types in crowdcompute. Note that these emails must be registered in crowdcompute worker UI: https://crowd-compute.appspot.com/"]
        #[serde(
            rename = "contributorEmails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contributor_emails: ::std::option::Option<Vec<String>>,
        #[doc = "Required. Instruction resource name."]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction: ::std::option::Option<String>,
        #[doc = "Optional. A human-readable label used to logically group labeling tasks. This string must match the regular expression `[a-zA-Z\\\\d_-]{0,128}`."]
        #[serde(
            rename = "labelGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_group: ::std::option::Option<String>,
        #[doc = "Optional. The Language of this question, as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Default value is en-US. Only need to set this when task is language related. For example, French text classification."]
        #[serde(
            rename = "languageCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_code: ::std::option::Option<String>,
        #[doc = "Optional. Maximum duration for contributors to answer a question. Maximum is 3600 seconds. Default is 3600 seconds."]
        #[serde(
            rename = "questionDuration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub question_duration: ::std::option::Option<String>,
        #[doc = "Optional. Replication of questions. Each question will be sent to up to this number of contributors to label. Aggregated answers will be returned. Default is set to 1. For image related labeling, valid values are 1, 3, 5."]
        #[serde(
            rename = "replicaCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub replica_count: ::std::option::Option<i32>,
        #[doc = "Email of the user who started the labeling task and should be notified by email. If empty no notification will be sent."]
        #[serde(
            rename = "userEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_email_address: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Alpha1ImportDataOperationMetadata {
        #[doc = "Output only. Timestamp when import dataset request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The name of imported dataset. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1ImportDataOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1ImportDataOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1ImportDataOperationResponse {
        #[doc = "Ouptut only. The name of imported dataset."]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples imported successfully."]
        #[serde(
            rename = "importCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub import_count: ::std::option::Option<i32>,
        #[doc = "Output only. Total number of examples requested to import"]
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1ImportDataOperationResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1ImportDataOperationResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelImageBoundingBoxOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelImageBoundingBoxOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelImageBoundingBoxOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelImageBoundingPolyOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelImageBoundingPolyOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelImageBoundingPolyOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelImageClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelImageClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelImageClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelImageOrientedBoundingBoxOperationMetadata {
        #[doc = "Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelImageOrientedBoundingBoxOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelImageOrientedBoundingBoxOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelImagePolylineOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelImagePolylineOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelImagePolylineOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelImageSegmentationOperationMetadata {
        #[doc = "Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelImageSegmentationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelImageSegmentationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelOperationMetadata { # [doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."] # [serde (rename = "annotatedDataset" , default , skip_serializing_if = "std::option::Option::is_none")] pub annotated_dataset : :: std :: option :: Option < String > , # [doc = "Output only. Timestamp when labeling request was created."] # [serde (rename = "createTime" , default , skip_serializing_if = "std::option::Option::is_none")] pub create_time : :: std :: option :: Option < String > , # [doc = "Output only. The name of dataset to be labeled. \"projects/*/datasets/*\""] # [serde (rename = "dataset" , default , skip_serializing_if = "std::option::Option::is_none")] pub dataset : :: std :: option :: Option < String > , # [doc = "Details of label image bounding box operation."] # [serde (rename = "imageBoundingBoxDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_bounding_box_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelImageBoundingBoxOperationMetadata > , # [doc = "Details of label image bounding poly operation."] # [serde (rename = "imageBoundingPolyDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_bounding_poly_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelImageBoundingPolyOperationMetadata > , # [doc = "Details of label image classification operation."] # [serde (rename = "imageClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelImageClassificationOperationMetadata > , # [doc = "Details of label image oriented bounding box operation."] # [serde (rename = "imageOrientedBoundingBoxDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_oriented_bounding_box_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelImageOrientedBoundingBoxOperationMetadata > , # [doc = "Details of label image polyline operation."] # [serde (rename = "imagePolylineDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_polyline_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelImagePolylineOperationMetadata > , # [doc = "Details of label image segmentation operation."] # [serde (rename = "imageSegmentationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_segmentation_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelImageSegmentationOperationMetadata > , # [doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."] # [serde (rename = "partialFailures" , default , skip_serializing_if = "std::option::Option::is_none")] pub partial_failures : :: std :: option :: Option < Vec < crate :: schemas :: GoogleRpcStatus > > , # [doc = "Output only. Progress of label operation. Range: [0, 100]."] # [serde (rename = "progressPercent" , default , skip_serializing_if = "std::option::Option::is_none")] pub progress_percent : :: std :: option :: Option < i32 > , # [doc = "Details of label text classification operation."] # [serde (rename = "textClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub text_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelTextClassificationOperationMetadata > , # [doc = "Details of label text entity extraction operation."] # [serde (rename = "textEntityExtractionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub text_entity_extraction_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelTextEntityExtractionOperationMetadata > , # [doc = "Details of label video classification operation."] # [serde (rename = "videoClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelVideoClassificationOperationMetadata > , # [doc = "Details of label video event operation."] # [serde (rename = "videoEventDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_event_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelVideoEventOperationMetadata > , # [doc = "Details of label video object detection operation."] # [serde (rename = "videoObjectDetectionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_object_detection_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelVideoObjectDetectionOperationMetadata > , # [doc = "Details of label video object tracking operation."] # [serde (rename = "videoObjectTrackingDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_object_tracking_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Alpha1LabelVideoObjectTrackingOperationMetadata > , }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelStats {
        #[doc = "Map of each annotation spec's example count. Key is the annotation spec name and value is the number of examples for that annotation spec. If the annotated dataset does not have annotation spec, the map will return a pair where the key is empty string and value is the total number of annotations."]
        #[serde(
            rename = "exampleCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub example_count: ::std::option::Option<::std::collections::BTreeMap<String, i64>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Alpha1LabelStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Alpha1LabelStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelTextClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelTextClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelTextClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelTextEntityExtractionOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelTextEntityExtractionOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelTextEntityExtractionOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelVideoClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelVideoClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelVideoClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelVideoEventOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelVideoEventOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelVideoEventOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelVideoObjectDetectionOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelVideoObjectDetectionOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelVideoObjectDetectionOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1LabelVideoObjectTrackingOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Alpha1LabelVideoObjectTrackingOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Alpha1LabelVideoObjectTrackingOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Alpha1OutputConfig {
        #[doc = "Output to a file in Cloud Storage. Should be used for labeling output other than image segmentation."]
        #[serde(
            rename = "gcsDestination",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_destination:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Alpha1GcsDestination>,
        #[doc = "Output to a folder in Cloud Storage. Should be used for image segmentation or document de-identification labeling outputs."]
        #[serde(
            rename = "gcsFolderDestination",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_folder_destination: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Alpha1GcsFolderDestination,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Alpha1OutputConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Alpha1OutputConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1AnnotatedDataset {
        #[doc = "Output only. Source of the annotation."]
        #[serde(
            rename = "annotationSource",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_source: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource,
        >,
        #[doc = "Output only. Type of the annotation. It is specified when starting labeling task."]
        #[serde(
            rename = "annotationType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_type: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType,
        >,
        #[doc = "Output only. The names of any related resources that are blocking changes to the annotated dataset."]
        #[serde(
            rename = "blockingResources",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub blocking_resources: ::std::option::Option<Vec<String>>,
        #[doc = "Output only. Number of examples that have annotation in the annotated dataset."]
        #[serde(
            rename = "completedExampleCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub completed_example_count: ::std::option::Option<i64>,
        #[doc = "Output only. Time the AnnotatedDataset was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The description of the AnnotatedDataset. It is specified in HumanAnnotationConfig when user starts a labeling task. Maximum of 10000 characters."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Output only. The display name of the AnnotatedDataset. It is specified in HumanAnnotationConfig when user starts a labeling task. Maximum of 64 characters."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples in the annotated dataset."]
        #[serde(
            rename = "exampleCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub example_count: ::std::option::Option<i64>,
        #[doc = "Output only. Per label statistics."]
        #[serde(
            rename = "labelStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_stats:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1LabelStats>,
        #[doc = "Output only. Additional information about AnnotatedDataset."]
        #[serde(
            rename = "metadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metadata: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotatedDatasetMetadata,
        >,
        #[doc = "Output only. AnnotatedDataset resource name in format of: projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/ {annotated_dataset_id}"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1AnnotatedDataset {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1AnnotatedDataset {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource {
        AnnotationSourceUnspecified,
        #[doc = "Answer is provided by a human contributor."]
        Operator,
    }
    impl GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource :: AnnotationSourceUnspecified => "ANNOTATION_SOURCE_UNSPECIFIED" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource :: Operator => "OPERATOR" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource, ()>
        {
            Ok (match s { "ANNOTATION_SOURCE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource :: AnnotationSourceUnspecified , "OPERATOR" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource :: Operator , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ANNOTATION_SOURCE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource :: AnnotationSourceUnspecified , "OPERATOR" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource :: Operator , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationSource
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType {
        AnnotationTypeUnspecified,
        #[doc = "General classification. Allowed for continuous evaluation."]
        GeneralClassificationAnnotation,
        #[doc = "Bounding box annotations in an image. A form of image object detection. Allowed for continuous evaluation."]
        ImageBoundingBoxAnnotation,
        #[doc = "Bounding poly annotations in an image."]
        ImageBoundingPolyAnnotation,
        #[doc = "Classification annotations in an image. Allowed for continuous evaluation."]
        ImageClassificationAnnotation,
        #[doc = "Oriented bounding box. The box does not have to be parallel to horizontal line."]
        ImageOrientedBoundingBoxAnnotation,
        #[doc = "Polyline annotations in an image."]
        ImagePolylineAnnotation,
        #[doc = "Segmentation annotations in an image."]
        ImageSegmentationAnnotation,
        #[doc = "Classification for text. Allowed for continuous evaluation."]
        TextClassificationAnnotation,
        #[doc = "Entity extraction for text."]
        TextEntityExtractionAnnotation,
        #[doc = "Video event annotation."]
        VideoEventAnnotation,
        #[doc = "Video object detection annotation."]
        VideoObjectDetectionAnnotation,
        #[doc = "Video object tracking annotation."]
        VideoObjectTrackingAnnotation,
        #[doc = "Classification annotations in video shots."]
        VideoShotsClassificationAnnotation,
    }
    impl GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: AnnotationTypeUnspecified => "ANNOTATION_TYPE_UNSPECIFIED" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: GeneralClassificationAnnotation => "GENERAL_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageBoundingBoxAnnotation => "IMAGE_BOUNDING_BOX_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageBoundingPolyAnnotation => "IMAGE_BOUNDING_POLY_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageClassificationAnnotation => "IMAGE_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageOrientedBoundingBoxAnnotation => "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImagePolylineAnnotation => "IMAGE_POLYLINE_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageSegmentationAnnotation => "IMAGE_SEGMENTATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: TextClassificationAnnotation => "TEXT_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: TextEntityExtractionAnnotation => "TEXT_ENTITY_EXTRACTION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoEventAnnotation => "VIDEO_EVENT_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoObjectDetectionAnnotation => "VIDEO_OBJECT_DETECTION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoObjectTrackingAnnotation => "VIDEO_OBJECT_TRACKING_ANNOTATION" , GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoShotsClassificationAnnotation => "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType, ()>
        {
            Ok (match s { "ANNOTATION_TYPE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: AnnotationTypeUnspecified , "GENERAL_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: GeneralClassificationAnnotation , "IMAGE_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageBoundingBoxAnnotation , "IMAGE_BOUNDING_POLY_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageBoundingPolyAnnotation , "IMAGE_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageClassificationAnnotation , "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageOrientedBoundingBoxAnnotation , "IMAGE_POLYLINE_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImagePolylineAnnotation , "IMAGE_SEGMENTATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageSegmentationAnnotation , "TEXT_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: TextClassificationAnnotation , "TEXT_ENTITY_EXTRACTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: TextEntityExtractionAnnotation , "VIDEO_EVENT_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoEventAnnotation , "VIDEO_OBJECT_DETECTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoObjectDetectionAnnotation , "VIDEO_OBJECT_TRACKING_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoObjectTrackingAnnotation , "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoShotsClassificationAnnotation , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ANNOTATION_TYPE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: AnnotationTypeUnspecified , "GENERAL_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: GeneralClassificationAnnotation , "IMAGE_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageBoundingBoxAnnotation , "IMAGE_BOUNDING_POLY_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageBoundingPolyAnnotation , "IMAGE_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageClassificationAnnotation , "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageOrientedBoundingBoxAnnotation , "IMAGE_POLYLINE_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImagePolylineAnnotation , "IMAGE_SEGMENTATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: ImageSegmentationAnnotation , "TEXT_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: TextClassificationAnnotation , "TEXT_ENTITY_EXTRACTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: TextEntityExtractionAnnotation , "VIDEO_EVENT_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoEventAnnotation , "VIDEO_OBJECT_DETECTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoObjectDetectionAnnotation , "VIDEO_OBJECT_TRACKING_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoObjectTrackingAnnotation , "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType :: VideoShotsClassificationAnnotation , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetAnnotationType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1AnnotatedDatasetMetadata {
        #[doc = "Configuration for image bounding box and bounding poly task."]
        #[serde(
            rename = "boundingPolyConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bounding_poly_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1BoundingPolyConfig>,
        #[doc = "Configuration for video event labeling task."]
        #[serde(
            rename = "eventConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1EventConfig>,
        #[doc = "HumanAnnotationConfig used when requesting the human labeling task for this AnnotatedDataset."]
        #[serde(
            rename = "humanAnnotationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub human_annotation_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
        #[doc = "Configuration for image classification task."]
        #[serde(
            rename = "imageClassificationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_classification_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ImageClassificationConfig,
        >,
        #[doc = "Configuration for video object detection task."]
        #[serde(
            rename = "objectDetectionConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_detection_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ObjectDetectionConfig,
        >,
        #[doc = "Configuration for video object tracking task."]
        #[serde(
            rename = "objectTrackingConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_tracking_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ObjectTrackingConfig,
        >,
        #[doc = "Configuration for image polyline task."]
        #[serde(
            rename = "polylineConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub polyline_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1PolylineConfig>,
        #[doc = "Configuration for image segmentation task."]
        #[serde(
            rename = "segmentationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub segmentation_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1SegmentationConfig>,
        #[doc = "Configuration for text classification task."]
        #[serde(
            rename = "textClassificationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_classification_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1TextClassificationConfig,
        >,
        #[doc = "Configuration for text entity extraction task."]
        #[serde(
            rename = "textEntityExtractionConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_entity_extraction_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1TextEntityExtractionConfig,
        >,
        #[doc = "Configuration for video classification task."]
        #[serde(
            rename = "videoClassificationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_classification_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1VideoClassificationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1AnnotatedDatasetMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1Annotation {
        #[doc = "Output only. Annotation metadata, including information like votes for labels."]
        #[serde(
            rename = "annotationMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_metadata:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationMetadata>,
        #[doc = "Output only. Sentiment for this annotation."]
        #[serde(
            rename = "annotationSentiment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_sentiment: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment,
        >,
        #[doc = "Output only. The source of the annotation."]
        #[serde(
            rename = "annotationSource",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_source: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource,
        >,
        #[doc = "Output only. This is the actual annotation value, e.g classification, bounding box values are stored here."]
        #[serde(
            rename = "annotationValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_value:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationValue>,
        #[doc = "Output only. Unique name of this annotation, format is: projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/{annotated_dataset}/examples/{example_id}/annotations/{annotation_id}"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Annotation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Annotation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment {
        AnnotationSentimentUnspecified,
        #[doc = "This annotation describes negatively about the data."]
        Negative,
        #[doc = "This label describes positively about the data."]
        Positive,
    }
    impl GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: AnnotationSentimentUnspecified => "ANNOTATION_SENTIMENT_UNSPECIFIED" , GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: Negative => "NEGATIVE" , GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: Positive => "POSITIVE" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment, ()>
        {
            Ok (match s { "ANNOTATION_SENTIMENT_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: AnnotationSentimentUnspecified , "NEGATIVE" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: Negative , "POSITIVE" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: Positive , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ANNOTATION_SENTIMENT_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: AnnotationSentimentUnspecified , "NEGATIVE" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: Negative , "POSITIVE" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment :: Positive , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSentiment
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource {
        AnnotationSourceUnspecified,
        #[doc = "Answer is provided by a human contributor."]
        Operator,
    }
    impl GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource :: AnnotationSourceUnspecified => "ANNOTATION_SOURCE_UNSPECIFIED" , GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource :: Operator => "OPERATOR" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource, ()>
        {
            Ok (match s { "ANNOTATION_SOURCE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource :: AnnotationSourceUnspecified , "OPERATOR" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource :: Operator , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ANNOTATION_SOURCE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource :: AnnotationSourceUnspecified , "OPERATOR" => GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource :: Operator , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1AnnotationAnnotationSource
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1AnnotationMetadata {
        #[doc = "Metadata related to human labeling."]
        #[serde(
            rename = "operatorMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_metadata:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1OperatorMetadata>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1AnnotationMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1AnnotationMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1AnnotationSpec {
        #[doc = "Optional. User-provided description of the annotation specification. The description can be up to 10,000 characters long."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Required. The display name of the AnnotationSpec. Maximum of 64 characters."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Output only. This is the integer index of the AnnotationSpec. The index for the whole AnnotationSpecSet is sequential starting from 0. For example, an AnnotationSpecSet with classes `dog` and `cat`, might contain one AnnotationSpec with `{ display_name: \"dog\", index: 0 }` and one AnnotationSpec with `{ display_name: \"cat\", index: 1 }`. This is especially useful for model training as it encodes the string labels into numeric values."]
        #[serde(
            rename = "index",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub index: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1AnnotationSpec {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1AnnotationSpec {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1AnnotationSpecSet {
        #[doc = "Required. The array of AnnotationSpecs that you define when you create the AnnotationSpecSet. These are the possible labels for the labeling task."]
        #[serde(
            rename = "annotationSpecs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_specs: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        >,
        #[doc = "Output only. The names of any related resources that are blocking changes to the annotation spec set."]
        #[serde(
            rename = "blockingResources",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub blocking_resources: ::std::option::Option<Vec<String>>,
        #[doc = "Optional. User-provided description of the annotation specification set. The description can be up to 10,000 characters long."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Required. The display name for AnnotationSpecSet that you define when you create it. Maximum of 64 characters."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Output only. The AnnotationSpecSet resource name in the following format: \"projects/{project_id}/annotationSpecSets/{annotation_spec_set_id}\""]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1AnnotationSpecSet {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1AnnotationSpecSet {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1AnnotationSpecSetConfig {
        #[doc = "Optional. If allow_multi_label is true, contributors are able to choose multiple labels from one annotation spec set."]
        #[serde(
            rename = "allowMultiLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub allow_multi_label: ::std::option::Option<bool>,
        #[doc = "Required. Annotation spec set resource name."]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1AnnotationSpecSetConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1AnnotationSpecSetConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1AnnotationValue {
        #[doc = "Annotation value for image bounding box, oriented bounding box and polygon cases."]
        #[serde(
            rename = "imageBoundingPolyAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_bounding_poly_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ImageBoundingPolyAnnotation,
        >,
        #[doc = "Annotation value for image classification case."]
        #[serde(
            rename = "imageClassificationAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_classification_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ImageClassificationAnnotation,
        >,
        #[doc = "Annotation value for image polyline cases. Polyline here is different from BoundingPoly. It is formed by line segments connected to each other but not closed form(Bounding Poly). The line segments can cross each other."]
        #[serde(
            rename = "imagePolylineAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_polyline_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ImagePolylineAnnotation,
        >,
        #[doc = "Annotation value for image segmentation."]
        #[serde(
            rename = "imageSegmentationAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_segmentation_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ImageSegmentationAnnotation,
        >,
        #[doc = "Annotation value for text classification case."]
        #[serde(
            rename = "textClassificationAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_classification_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1TextClassificationAnnotation,
        >,
        #[doc = "Annotation value for text entity extraction case."]
        #[serde(
            rename = "textEntityExtractionAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_entity_extraction_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1TextEntityExtractionAnnotation,
        >,
        #[doc = "Annotation value for video classification case."]
        #[serde(
            rename = "videoClassificationAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_classification_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1VideoClassificationAnnotation,
        >,
        #[doc = "Annotation value for video event case."]
        #[serde(
            rename = "videoEventAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_event_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1VideoEventAnnotation,
        >,
        #[doc = "Annotation value for video object detection and tracking case."]
        #[serde(
            rename = "videoObjectTrackingAnnotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_object_tracking_annotation: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1VideoObjectTrackingAnnotation,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1AnnotationValue {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1AnnotationValue {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Beta1Attempt {
        #[serde(
            rename = "attemptTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attempt_time: ::std::option::Option<String>,
        #[doc = "Details of errors that occurred."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Attempt {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Attempt {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1BigQuerySource {
        #[doc = "Required. BigQuery URI to a table, up to 2,000 characters long. If you specify the URI of a table that does not exist, Data Labeling Service creates a table at the URI with the correct schema when you create your EvaluationJob. If you specify the URI of a table that already exists, it must have the [correct schema](/ml-engine/docs/continuous-evaluation/create-job#table-schema). Provide the table URI in the following format: \"bq://{your_project_id}/ {your_dataset_name}/{your_table_name}\" [Learn more](/ml-engine/docs/continuous-evaluation/create-job#table-schema)."]
        #[serde(
            rename = "inputUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1BigQuerySource {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1BigQuerySource {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1BoundingBoxEvaluationOptions {
        #[doc = "Minimum [intersection-over-union (IOU)](/vision/automl/object-detection/docs/evaluate#intersection-over-union) required for 2 bounding boxes to be considered a match. This must be a number between 0 and 1."]
        #[serde(
            rename = "iouThreshold",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub iou_threshold: ::std::option::Option<f32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1BoundingBoxEvaluationOptions
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1BoundingBoxEvaluationOptions
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1BoundingPoly {
        #[doc = "The bounding polygon vertices."]
        #[serde(
            rename = "vertices",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vertices:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Vertex>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1BoundingPoly {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1BoundingPoly {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1BoundingPolyConfig {
        #[doc = "Required. Annotation spec set resource name."]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
        #[doc = "Optional. Instruction message showed on contributors UI."]
        #[serde(
            rename = "instructionMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction_message: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1BoundingPolyConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1BoundingPolyConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ClassificationMetadata {
        #[doc = "Whether the classification task is multi-label or not."]
        #[serde(
            rename = "isMultiLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_multi_label: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ClassificationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ClassificationMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ClassificationMetrics {
        #[doc = "Confusion matrix of predicted labels vs. ground truth labels."]
        #[serde(
            rename = "confusionMatrix",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub confusion_matrix:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1ConfusionMatrix>,
        #[doc = "Precision-recall curve based on ground truth labels, predicted labels, and scores for the predicted labels."]
        #[serde(
            rename = "prCurve",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pr_curve: ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1PrCurve>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ClassificationMetrics
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ClassificationMetrics {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ConfidenceMetricsEntry {
        #[doc = "Threshold used for this entry. For classification tasks, this is a classification threshold: a predicted label is categorized as positive or negative (in the context of this point on the PR curve) based on whether the label's score meets this threshold. For image object detection (bounding box) tasks, this is the [intersection-over-union (IOU)](/vision/automl/object-detection/docs/evaluate#intersection-over-union) threshold for the context of this point on the PR curve."]
        #[serde(
            rename = "confidenceThreshold",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub confidence_threshold: ::std::option::Option<f32>,
        #[doc = "Harmonic mean of recall and precision."]
        #[serde(
            rename = "f1Score",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub f_1_score: ::std::option::Option<f32>,
        #[doc = "The harmonic mean of recall_at1 and precision_at1."]
        #[serde(
            rename = "f1ScoreAt1",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub f_1_score_at_1: ::std::option::Option<f32>,
        #[doc = "The harmonic mean of recall_at5 and precision_at5."]
        #[serde(
            rename = "f1ScoreAt5",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub f_1_score_at_5: ::std::option::Option<f32>,
        #[doc = "Precision value."]
        #[serde(
            rename = "precision",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub precision: ::std::option::Option<f32>,
        #[doc = "Precision value for entries with label that has highest score."]
        #[serde(
            rename = "precisionAt1",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub precision_at_1: ::std::option::Option<f32>,
        #[doc = "Precision value for entries with label that has highest 5 scores."]
        #[serde(
            rename = "precisionAt5",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub precision_at_5: ::std::option::Option<f32>,
        #[doc = "Recall value."]
        #[serde(
            rename = "recall",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recall: ::std::option::Option<f32>,
        #[doc = "Recall value for entries with label that has highest score."]
        #[serde(
            rename = "recallAt1",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recall_at_1: ::std::option::Option<f32>,
        #[doc = "Recall value for entries with label that has highest 5 scores."]
        #[serde(
            rename = "recallAt5",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recall_at_5: ::std::option::Option<f32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ConfidenceMetricsEntry
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ConfidenceMetricsEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ConfusionMatrix {
        #[serde(
            rename = "row",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub row: ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Row>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ConfusionMatrix {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ConfusionMatrix {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ConfusionMatrixEntry {
        #[doc = "The annotation spec of a predicted label."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[doc = "Number of items predicted to have this label. (The ground truth label for these items is the `Row.annotationSpec` of this entry's parent.)"]
        #[serde(
            rename = "itemCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ConfusionMatrixEntry {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ConfusionMatrixEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1CreateAnnotationSpecSetRequest {
        #[doc = "Required. Annotation spec set to create. Annotation specs must be included. Only one annotation spec will be accepted for annotation specs with same display_name."]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSet>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1CreateAnnotationSpecSetRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1CreateAnnotationSpecSetRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1CreateDatasetRequest {
        #[doc = "Required. The dataset to be created."]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1Dataset>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1CreateDatasetRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1CreateDatasetRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Beta1CreateEvaluationJobRequest {
        #[doc = "Required. The evaluation job to create."]
        #[serde(
            rename = "job",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub job: ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1CreateEvaluationJobRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1CreateEvaluationJobRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Beta1CreateInstructionMetadata {
        #[doc = "Timestamp when create instruction request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "The name of the created Instruction. projects/{project_id}/instructions/{instruction_id}"]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction: ::std::option::Option<String>,
        #[doc = "Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1CreateInstructionMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1CreateInstructionMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1CreateInstructionRequest {
        #[doc = "Required. Instruction of how to perform the labeling task."]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1Instruction>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1CreateInstructionRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1CreateInstructionRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1CsvInstruction {
        #[doc = "CSV file for the instruction. Only gcs path is allowed."]
        #[serde(
            rename = "gcsFileUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_file_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1CsvInstruction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1CsvInstruction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1DataItem {
        #[doc = "The image payload, a container of the image bytes/uri."]
        #[serde(
            rename = "imagePayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_payload:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1ImagePayload>,
        #[doc = "Output only. Name of the data item, in format of: projects/{project_id}/datasets/{dataset_id}/dataItems/{data_item_id}"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The text payload, a container of text content."]
        #[serde(
            rename = "textPayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_payload:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1TextPayload>,
        #[doc = "The video payload, a container of the video uri."]
        #[serde(
            rename = "videoPayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_payload:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1VideoPayload>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1DataItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1DataItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1Dataset {
        #[doc = "Output only. The names of any related resources that are blocking changes to the dataset."]
        #[serde(
            rename = "blockingResources",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub blocking_resources: ::std::option::Option<Vec<String>>,
        #[doc = "Output only. Time the dataset is created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The number of data items in the dataset."]
        #[serde(
            rename = "dataItemCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub data_item_count: ::std::option::Option<i64>,
        #[doc = "Optional. User-provided description of the annotation specification set. The description can be up to 10000 characters long."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Required. The display name of the dataset. Maximum of 64 characters."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Output only. This is populated with the original input configs where ImportData is called. It is available only after the clients import data to this dataset."]
        #[serde(
            rename = "inputConfigs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_configs:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1InputConfig>>,
        #[doc = "Last time that the Dataset is migrated to AI Platform V2. If any of the AnnotatedDataset is migrated, the last_migration_time in Dataset is also updated."]
        #[serde(
            rename = "lastMigrateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_migrate_time: ::std::option::Option<String>,
        #[doc = "Output only. Dataset resource name, format is: projects/{project_id}/datasets/{dataset_id}"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Dataset {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Dataset {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1Evaluation {
        #[doc = "Output only. Type of task that the model version being evaluated performs, as defined in the evaluationJobConfig.inputConfig.annotationType field of the evaluation job that created this evaluation."]
        #[serde(
            rename = "annotationType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_type: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType,
        >,
        #[doc = "Output only. Options used in the evaluation job that created this evaluation."]
        #[serde(
            rename = "config",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationConfig>,
        #[doc = "Output only. Timestamp for when this evaluation was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The number of items in the ground truth dataset that were used for this evaluation. Only populated when the evaulation is for certain AnnotationTypes."]
        #[serde(
            rename = "evaluatedItemCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub evaluated_item_count: ::std::option::Option<i64>,
        #[doc = "Output only. Timestamp for when the evaluation job that created this evaluation ran."]
        #[serde(
            rename = "evaluationJobRunTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub evaluation_job_run_time: ::std::option::Option<String>,
        #[doc = "Output only. Metrics comparing predictions to ground truth labels."]
        #[serde(
            rename = "evaluationMetrics",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub evaluation_metrics:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationMetrics>,
        #[doc = "Output only. Resource name of an evaluation. The name has the following format: \"projects/{project_id}/datasets/{dataset_id}/evaluations/ {evaluation_id}'"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Evaluation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Evaluation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType {
        AnnotationTypeUnspecified,
        #[doc = "General classification. Allowed for continuous evaluation."]
        GeneralClassificationAnnotation,
        #[doc = "Bounding box annotations in an image. A form of image object detection. Allowed for continuous evaluation."]
        ImageBoundingBoxAnnotation,
        #[doc = "Bounding poly annotations in an image."]
        ImageBoundingPolyAnnotation,
        #[doc = "Classification annotations in an image. Allowed for continuous evaluation."]
        ImageClassificationAnnotation,
        #[doc = "Oriented bounding box. The box does not have to be parallel to horizontal line."]
        ImageOrientedBoundingBoxAnnotation,
        #[doc = "Polyline annotations in an image."]
        ImagePolylineAnnotation,
        #[doc = "Segmentation annotations in an image."]
        ImageSegmentationAnnotation,
        #[doc = "Classification for text. Allowed for continuous evaluation."]
        TextClassificationAnnotation,
        #[doc = "Entity extraction for text."]
        TextEntityExtractionAnnotation,
        #[doc = "Video event annotation."]
        VideoEventAnnotation,
        #[doc = "Video object detection annotation."]
        VideoObjectDetectionAnnotation,
        #[doc = "Video object tracking annotation."]
        VideoObjectTrackingAnnotation,
        #[doc = "Classification annotations in video shots."]
        VideoShotsClassificationAnnotation,
    }
    impl GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: AnnotationTypeUnspecified => "ANNOTATION_TYPE_UNSPECIFIED" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: GeneralClassificationAnnotation => "GENERAL_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageBoundingBoxAnnotation => "IMAGE_BOUNDING_BOX_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageBoundingPolyAnnotation => "IMAGE_BOUNDING_POLY_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageClassificationAnnotation => "IMAGE_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageOrientedBoundingBoxAnnotation => "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImagePolylineAnnotation => "IMAGE_POLYLINE_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageSegmentationAnnotation => "IMAGE_SEGMENTATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: TextClassificationAnnotation => "TEXT_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: TextEntityExtractionAnnotation => "TEXT_ENTITY_EXTRACTION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoEventAnnotation => "VIDEO_EVENT_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoObjectDetectionAnnotation => "VIDEO_OBJECT_DETECTION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoObjectTrackingAnnotation => "VIDEO_OBJECT_TRACKING_ANNOTATION" , GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoShotsClassificationAnnotation => "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType, ()>
        {
            Ok (match s { "ANNOTATION_TYPE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: AnnotationTypeUnspecified , "GENERAL_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: GeneralClassificationAnnotation , "IMAGE_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageBoundingBoxAnnotation , "IMAGE_BOUNDING_POLY_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageBoundingPolyAnnotation , "IMAGE_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageClassificationAnnotation , "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageOrientedBoundingBoxAnnotation , "IMAGE_POLYLINE_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImagePolylineAnnotation , "IMAGE_SEGMENTATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageSegmentationAnnotation , "TEXT_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: TextClassificationAnnotation , "TEXT_ENTITY_EXTRACTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: TextEntityExtractionAnnotation , "VIDEO_EVENT_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoEventAnnotation , "VIDEO_OBJECT_DETECTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoObjectDetectionAnnotation , "VIDEO_OBJECT_TRACKING_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoObjectTrackingAnnotation , "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoShotsClassificationAnnotation , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ANNOTATION_TYPE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: AnnotationTypeUnspecified , "GENERAL_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: GeneralClassificationAnnotation , "IMAGE_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageBoundingBoxAnnotation , "IMAGE_BOUNDING_POLY_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageBoundingPolyAnnotation , "IMAGE_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageClassificationAnnotation , "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageOrientedBoundingBoxAnnotation , "IMAGE_POLYLINE_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImagePolylineAnnotation , "IMAGE_SEGMENTATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: ImageSegmentationAnnotation , "TEXT_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: TextClassificationAnnotation , "TEXT_ENTITY_EXTRACTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: TextEntityExtractionAnnotation , "VIDEO_EVENT_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoEventAnnotation , "VIDEO_OBJECT_DETECTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoObjectDetectionAnnotation , "VIDEO_OBJECT_TRACKING_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoObjectTrackingAnnotation , "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType :: VideoShotsClassificationAnnotation , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1EvaluationAnnotationType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1EvaluationConfig {
        #[doc = "Only specify this field if the related model performs image object detection (`IMAGE_BOUNDING_BOX_ANNOTATION`). Describes how to evaluate bounding boxes."]
        #[serde(
            rename = "boundingBoxEvaluationOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bounding_box_evaluation_options: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1BoundingBoxEvaluationOptions,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1EvaluationConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1EvaluationConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Beta1EvaluationJob {
        #[doc = "Required. Name of the AnnotationSpecSet describing all the labels that your machine learning model outputs. You must create this resource before you create an evaluation job and provide its name in the following format: \"projects/{project_id}/annotationSpecSets/{annotation_spec_set_id}\""]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
        #[doc = "Output only. Every time the evaluation job runs and an error occurs, the failed attempt is appended to this array."]
        #[serde(
            rename = "attempts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attempts:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Attempt>>,
        #[doc = "Output only. Timestamp of when this evaluation job was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Required. Description of the job. The description can be up to 25,000 characters long."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Required. Configuration details for the evaluation job."]
        #[serde(
            rename = "evaluationJobConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub evaluation_job_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJobConfig,
        >,
        #[doc = "Required. Whether you want Data Labeling Service to provide ground truth labels for prediction input. If you want the service to assign human labelers to annotate your data, set this to `true`. If you want to provide your own ground truth labels in the evaluation job's BigQuery table, set this to `false`."]
        #[serde(
            rename = "labelMissingGroundTruth",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_missing_ground_truth: ::std::option::Option<bool>,
        #[doc = "Required. The [AI Platform Prediction model version](/ml-engine/docs/prediction-overview) to be evaluated. Prediction input and output is sampled from this model version. When creating an evaluation job, specify the model version in the following format: \"projects/{project_id}/models/{model_name}/versions/{version_name}\" There can only be one evaluation job per model version."]
        #[serde(
            rename = "modelVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub model_version: ::std::option::Option<String>,
        #[doc = "Output only. After you create a job, Data Labeling Service assigns a name to the job with the following format: \"projects/{project_id}/evaluationJobs/ {evaluation_job_id}\""]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Required. Describes the interval at which the job runs. This interval must be at least 1 day, and it is rounded to the nearest day. For example, if you specify a 50-hour interval, the job runs every 2 days. You can provide the schedule in [crontab format](/scheduler/docs/configuring/cron-job-schedules) or in an [English-like format](/appengine/docs/standard/python/config/cronref#schedule_format). Regardless of what you specify, the job will run at 10:00 AM UTC. Only the interval from this schedule is used, not the specific time of day."]
        #[serde(
            rename = "schedule",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub schedule: ::std::option::Option<String>,
        #[doc = "Output only. Describes the current state of the job."]
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJobState>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1EvaluationJob {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1EvaluationJob {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        #[doc = "The job is not sampling prediction input and output into your BigQuery table and it will not run according to its schedule. You can resume the job."]
        Paused,
        #[doc = "The job is currently running. When the job runs, Data Labeling Service does several things: 1. If you have configured your job to use Data Labeling Service for ground truth labeling, the service creates a Dataset and a labeling task for all data sampled since the last time the job ran. Human labelers provide ground truth labels for your data. Human labeling may take hours, or even days, depending on how much data has been sampled. The job remains in the `RUNNING` state during this time, and it can even be running multiple times in parallel if it gets triggered again (for example 24 hours later) before the earlier run has completed. When human labelers have finished labeling the data, the next step occurs. If you have configured your job to provide your own ground truth labels, Data Labeling Service still creates a Dataset for newly sampled data, but it expects that you have already added ground truth labels to the BigQuery table by this time. The next step occurs immediately. 2. Data Labeling Service creates an Evaluation by comparing your model version's predictions with the ground truth labels. If the job remains in this state for a long time, it continues to sample prediction data into your BigQuery table and will run again at the next interval, even if it causes the job to run multiple times in parallel."]
        Running,
        #[doc = "The job is scheduled to run at the configured interval. You can pause or delete the job. When the job is in this state, it samples prediction input and output from your model version into your BigQuery table as predictions occur."]
        Scheduled,
        StateUnspecified,
        #[doc = "The job has this state right before it is deleted."]
        Stopped,
    }
    impl GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudDatalabelingV1Beta1EvaluationJobState::Paused => "PAUSED",
                GoogleCloudDatalabelingV1Beta1EvaluationJobState::Running => "RUNNING",
                GoogleCloudDatalabelingV1Beta1EvaluationJobState::Scheduled => "SCHEDULED",
                GoogleCloudDatalabelingV1Beta1EvaluationJobState::StateUnspecified => {
                    "STATE_UNSPECIFIED"
                }
                GoogleCloudDatalabelingV1Beta1EvaluationJobState::Stopped => "STOPPED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1EvaluationJobState, ()> {
            Ok(match s {
                "PAUSED" => GoogleCloudDatalabelingV1Beta1EvaluationJobState::Paused,
                "RUNNING" => GoogleCloudDatalabelingV1Beta1EvaluationJobState::Running,
                "SCHEDULED" => GoogleCloudDatalabelingV1Beta1EvaluationJobState::Scheduled,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1EvaluationJobState::StateUnspecified
                }
                "STOPPED" => GoogleCloudDatalabelingV1Beta1EvaluationJobState::Stopped,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "PAUSED" => GoogleCloudDatalabelingV1Beta1EvaluationJobState::Paused,
                "RUNNING" => GoogleCloudDatalabelingV1Beta1EvaluationJobState::Running,
                "SCHEDULED" => GoogleCloudDatalabelingV1Beta1EvaluationJobState::Scheduled,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1EvaluationJobState::StateUnspecified
                }
                "STOPPED" => GoogleCloudDatalabelingV1Beta1EvaluationJobState::Stopped,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1EvaluationJobState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1EvaluationJobAlertConfig {
        #[doc = "Required. An email address to send alerts to."]
        #[serde(
            rename = "email",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email: ::std::option::Option<String>,
        #[doc = "Required. A number between 0 and 1 that describes a minimum mean average precision threshold. When the evaluation job runs, if it calculates that your model version's predictions from the recent interval have meanAveragePrecision below this threshold, then it sends an alert to your specified email."]
        #[serde(
            rename = "minAcceptableMeanAveragePrecision",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub min_acceptable_mean_average_precision: ::std::option::Option<f64>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1EvaluationJobAlertConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1EvaluationJobAlertConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1EvaluationJobConfig {
        #[doc = "Required. Prediction keys that tell Data Labeling Service where to find the data for evaluation in your BigQuery table. When the service samples prediction input and output from your model version and saves it to BigQuery, the data gets stored as JSON strings in the BigQuery table. These keys tell Data Labeling Service how to parse the JSON. You can provide the following entries in this field: * `data_json_key`: the data key for prediction input. You must provide either this key or `reference_json_key`. * `reference_json_key`: the data reference key for prediction input. You must provide either this key or `data_json_key`. * `label_json_key`: the label key for prediction output. Required. * `label_score_json_key`: the score key for prediction output. Required. * `bounding_box_json_key`: the bounding box key for prediction output. Required if your model version perform image object detection. Learn [how to configure prediction keys](/ml-engine/docs/continuous-evaluation/create-job#prediction-keys)."]
        #[serde(
            rename = "bigqueryImportKeys",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bigquery_import_keys:
            ::std::option::Option<::std::collections::BTreeMap<String, String>>,
        #[doc = "Specify this field if your model version performs image object detection (bounding box detection). `annotationSpecSet` in this configuration must match EvaluationJob.annotationSpecSet."]
        #[serde(
            rename = "boundingPolyConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bounding_poly_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1BoundingPolyConfig>,
        #[doc = "Required. Details for calculating evaluation metrics and creating Evaulations. If your model version performs image object detection, you must specify the `boundingBoxEvaluationOptions` field within this configuration. Otherwise, provide an empty object for this configuration."]
        #[serde(
            rename = "evaluationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub evaluation_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationConfig>,
        #[doc = "Optional. Configuration details for evaluation job alerts. Specify this field if you want to receive email alerts if the evaluation job finds that your predictions have low mean average precision during a run."]
        #[serde(
            rename = "evaluationJobAlertConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub evaluation_job_alert_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJobAlertConfig,
        >,
        #[doc = "Required. The maximum number of predictions to sample and save to BigQuery during each evaluation interval. This limit overrides `example_sample_percentage`: even if the service has not sampled enough predictions to fulfill `example_sample_perecentage` during an interval, it stops sampling predictions when it meets this limit."]
        #[serde(
            rename = "exampleCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub example_count: ::std::option::Option<i32>,
        #[doc = "Required. Fraction of predictions to sample and save to BigQuery during each evaluation interval. For example, 0.1 means 10% of predictions served by your model version get saved to BigQuery."]
        #[serde(
            rename = "exampleSamplePercentage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub example_sample_percentage: ::std::option::Option<f64>,
        #[doc = "Optional. Details for human annotation of your data. If you set labelMissingGroundTruth to `true` for this evaluation job, then you must specify this field. If you plan to provide your own ground truth labels, then omit this field. Note that you must create an Instruction resource before you can specify this field. Provide the name of the instruction resource in the `instruction` field within this configuration."]
        #[serde(
            rename = "humanAnnotationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub human_annotation_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
        #[doc = "Specify this field if your model version performs image classification or general classification. `annotationSpecSet` in this configuration must match EvaluationJob.annotationSpecSet. `allowMultiLabel` in this configuration must match `classificationMetadata.isMultiLabel` in input_config."]
        #[serde(
            rename = "imageClassificationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_classification_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ImageClassificationConfig,
        >,
        #[doc = "Rquired. Details for the sampled prediction input. Within this configuration, there are requirements for several fields: * `dataType` must be one of `IMAGE`, `TEXT`, or `GENERAL_DATA`. * `annotationType` must be one of `IMAGE_CLASSIFICATION_ANNOTATION`, `TEXT_CLASSIFICATION_ANNOTATION`, `GENERAL_CLASSIFICATION_ANNOTATION`, or `IMAGE_BOUNDING_BOX_ANNOTATION` (image object detection). * If your machine learning model performs classification, you must specify `classificationMetadata.isMultiLabel`. * You must specify `bigquerySource` (not `gcsSource`)."]
        #[serde(
            rename = "inputConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1InputConfig>,
        #[doc = "Specify this field if your model version performs text classification. `annotationSpecSet` in this configuration must match EvaluationJob.annotationSpecSet. `allowMultiLabel` in this configuration must match `classificationMetadata.isMultiLabel` in input_config."]
        #[serde(
            rename = "textClassificationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_classification_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1TextClassificationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1EvaluationJobConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1EvaluationJobConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1EvaluationMetrics {
        #[serde(
            rename = "classificationMetrics",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub classification_metrics: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ClassificationMetrics,
        >,
        #[serde(
            rename = "objectDetectionMetrics",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_detection_metrics: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ObjectDetectionMetrics,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1EvaluationMetrics {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1EvaluationMetrics {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1EventConfig {
        #[doc = "Required. The list of annotation spec set resource name. Similar to video classification, we support selecting event from multiple AnnotationSpecSet at the same time."]
        #[serde(
            rename = "annotationSpecSets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_sets: ::std::option::Option<Vec<String>>,
        #[doc = "Videos will be cut to smaller clips to make it easier for labelers to work on. Users can configure is field in seconds, if not set, default value is 60s."]
        #[serde(
            rename = "clipLength",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub clip_length: ::std::option::Option<i32>,
        #[doc = "The overlap length between different video clips. Users can configure is field in seconds, if not set, default value is 1s."]
        #[serde(
            rename = "overlapLength",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub overlap_length: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1EventConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1EventConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1Example {
        #[doc = "Output only. Annotations for the piece of data in Example. One piece of data can have multiple annotations."]
        #[serde(
            rename = "annotations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotations:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Annotation>>,
        #[doc = "The image payload, a container of the image bytes/uri."]
        #[serde(
            rename = "imagePayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_payload:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1ImagePayload>,
        #[doc = "Output only. Name of the example, in format of: projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/ {annotated_dataset_id}/examples/{example_id}"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The text payload, a container of the text content."]
        #[serde(
            rename = "textPayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_payload:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1TextPayload>,
        #[doc = "The video payload, a container of the video uri."]
        #[serde(
            rename = "videoPayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_payload:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1VideoPayload>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Example {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Example {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ExampleComparison {
        #[doc = "The ground truth output for the input."]
        #[serde(
            rename = "groundTruthExample",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ground_truth_example:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1Example>,
        #[doc = "Predictions by the model for the input."]
        #[serde(
            rename = "modelCreatedExamples",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub model_created_examples:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Example>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ExampleComparison {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ExampleComparison {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Beta1ExportDataOperationMetadata {
        #[doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Output only. Timestamp when export dataset request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The name of dataset to be exported. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ExportDataOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ExportDataOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ExportDataOperationResponse {
        #[doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Ouptut only. The name of dataset. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples exported successfully."]
        #[serde(
            rename = "exportCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub export_count: ::std::option::Option<i32>,
        #[doc = "Output only. Statistic infos of labels in the exported dataset."]
        #[serde(
            rename = "labelStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_stats:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1LabelStats>,
        #[doc = "Output only. output_config in the ExportData request."]
        #[serde(
            rename = "outputConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1OutputConfig>,
        #[doc = "Output only. Total number of examples requested to export"]
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ExportDataOperationResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ExportDataOperationResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ExportDataRequest {
        #[doc = "Required. Annotated dataset resource name. DataItem in Dataset and their annotations in specified annotated dataset will be exported. It's in format of projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/ {annotated_dataset_id}"]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Optional. Filter is not supported at this moment."]
        #[serde(
            rename = "filter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter: ::std::option::Option<String>,
        #[doc = "Required. Specify the output destination."]
        #[serde(
            rename = "outputConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1OutputConfig>,
        #[doc = "Email of the user who started the export task and should be notified by email. If empty no notification will be sent."]
        #[serde(
            rename = "userEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_email_address: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ExportDataRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ExportDataRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1FeedbackMessage {
        #[doc = "String content of the feedback. Maximum of 10000 characters."]
        #[serde(
            rename = "body",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub body: ::std::option::Option<String>,
        #[doc = "Create time."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "The image storing this feedback if the feedback is an image representing operator's comments."]
        #[serde(
            rename = "image",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "Name of the feedback message in a feedback thread. Format: 'project/{project_id}/datasets/{dataset_id}/annotatedDatasets/{annotated_dataset_id}/feedbackThreads/{feedback_thread_id}/feedbackMessage/{feedback_message_id}'"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "operatorFeedbackMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_feedback_metadata: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1OperatorFeedbackMetadata,
        >,
        #[serde(
            rename = "requesterFeedbackMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub requester_feedback_metadata: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1RequesterFeedbackMetadata,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1FeedbackMessage {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1FeedbackMessage {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1FeedbackThread {
        #[doc = "Metadata regarding the feedback thread."]
        #[serde(
            rename = "feedbackThreadMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feedback_thread_metadata: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadata,
        >,
        #[doc = "Name of the feedback thread. Format: 'project/{project_id}/datasets/{dataset_id}/annotatedDatasets/{annotated_dataset_id}/feedbackThreads/{feedback_thread_id}'"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1FeedbackThread {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1FeedbackThread {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadata {
        #[doc = "When the thread is created"]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "When the thread is last updated."]
        #[serde(
            rename = "lastUpdateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_update_time: ::std::option::Option<String>,
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus,
        >,
        #[doc = "An image thumbnail of this thread."]
        #[serde(
            rename = "thumbnail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thumbnail: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus {
        FeedbackThreadStatusUnspecified,
        #[doc = "Feedback thread is created with no reply;"]
        New,
        #[doc = "Feedback thread is replied at least once;"]
        Replied,
    }
    impl GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: FeedbackThreadStatusUnspecified => "FEEDBACK_THREAD_STATUS_UNSPECIFIED" , GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: New => "NEW" , GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: Replied => "REPLIED" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus, ()>
        {
            Ok (match s { "FEEDBACK_THREAD_STATUS_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: FeedbackThreadStatusUnspecified , "NEW" => GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: New , "REPLIED" => GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: Replied , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "FEEDBACK_THREAD_STATUS_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: FeedbackThreadStatusUnspecified , "NEW" => GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: New , "REPLIED" => GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus :: Replied , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1FeedbackThreadMetadataStatus
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1GcsDestination {
        #[doc = "Required. The format of the gcs destination. Only \"text/csv\" and \"application/json\" are supported."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Required. The output uri of destination file."]
        #[serde(
            rename = "outputUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1GcsDestination {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1GcsDestination {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1GcsFolderDestination {
        #[doc = "Required. Cloud Storage directory to export data to."]
        #[serde(
            rename = "outputFolderUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_folder_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1GcsFolderDestination {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1GcsFolderDestination {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1GcsSource {
        #[doc = "Required. The input URI of source file. This must be a Cloud Storage path (`gs://...`)."]
        #[serde(
            rename = "inputUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_uri: ::std::option::Option<String>,
        #[doc = "Required. The format of the source file. Only \"text/csv\" is supported."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1GcsSource {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1GcsSource {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig {
        #[doc = "Optional. A human-readable description for AnnotatedDataset. The description can be up to 10000 characters long."]
        #[serde(
            rename = "annotatedDatasetDescription",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset_description: ::std::option::Option<String>,
        #[doc = "Required. A human-readable name for AnnotatedDataset defined by users. Maximum of 64 characters ."]
        #[serde(
            rename = "annotatedDatasetDisplayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset_display_name: ::std::option::Option<String>,
        #[doc = "Optional. If you want your own labeling contributors to manage and work on this labeling request, you can set these contributors here. We will give them access to the question types in crowdcompute. Note that these emails must be registered in crowdcompute worker UI: https://crowd-compute.appspot.com/"]
        #[serde(
            rename = "contributorEmails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contributor_emails: ::std::option::Option<Vec<String>>,
        #[doc = "Required. Instruction resource name."]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction: ::std::option::Option<String>,
        #[doc = "Optional. A human-readable label used to logically group labeling tasks. This string must match the regular expression `[a-zA-Z\\\\d_-]{0,128}`."]
        #[serde(
            rename = "labelGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_group: ::std::option::Option<String>,
        #[doc = "Optional. The Language of this question, as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Default value is en-US. Only need to set this when task is language related. For example, French text classification."]
        #[serde(
            rename = "languageCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_code: ::std::option::Option<String>,
        #[doc = "Optional. Maximum duration for contributors to answer a question. Maximum is 3600 seconds. Default is 3600 seconds."]
        #[serde(
            rename = "questionDuration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub question_duration: ::std::option::Option<String>,
        #[doc = "Optional. Replication of questions. Each question will be sent to up to this number of contributors to label. Aggregated answers will be returned. Default is set to 1. For image related labeling, valid values are 1, 3, 5."]
        #[serde(
            rename = "replicaCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub replica_count: ::std::option::Option<i32>,
        #[doc = "Email of the user who started the labeling task and should be notified by email. If empty no notification will be sent."]
        #[serde(
            rename = "userEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_email_address: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ImageBoundingPolyAnnotation {
        #[doc = "Label of object in this bounding polygon."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[serde(
            rename = "boundingPoly",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bounding_poly:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1BoundingPoly>,
        #[serde(
            rename = "normalizedBoundingPoly",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub normalized_bounding_poly: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1NormalizedBoundingPoly,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ImageBoundingPolyAnnotation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ImageBoundingPolyAnnotation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ImageClassificationAnnotation {
        #[doc = "Label of image."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ImageClassificationAnnotation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ImageClassificationAnnotation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ImageClassificationConfig { # [doc = "Optional. If allow_multi_label is true, contributors are able to choose multiple labels for one image."] # [serde (rename = "allowMultiLabel" , default , skip_serializing_if = "std::option::Option::is_none")] pub allow_multi_label : :: std :: option :: Option < bool > , # [doc = "Required. Annotation spec set resource name."] # [serde (rename = "annotationSpecSet" , default , skip_serializing_if = "std::option::Option::is_none")] pub annotation_spec_set : :: std :: option :: Option < String > , # [doc = "Optional. The type of how to aggregate answers."] # [serde (rename = "answerAggregationType" , default , skip_serializing_if = "std::option::Option::is_none")] pub answer_aggregation_type : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType > , }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType {
        #[doc = "Majority vote to aggregate answers."]
        MajorityVote,
        #[doc = "Preserve all answers by crowd compute."]
        NoAggregation,
        StringAggregationTypeUnspecified,
        #[doc = "Unanimous answers will be adopted."]
        UnanimousVote,
    }
    impl GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: MajorityVote => "MAJORITY_VOTE" , GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: NoAggregation => "NO_AGGREGATION" , GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: StringAggregationTypeUnspecified => "STRING_AGGREGATION_TYPE_UNSPECIFIED" , GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: UnanimousVote => "UNANIMOUS_VOTE" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType,
            (),
        > {
            Ok (match s { "MAJORITY_VOTE" => GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: MajorityVote , "NO_AGGREGATION" => GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: NoAggregation , "STRING_AGGREGATION_TYPE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: StringAggregationTypeUnspecified , "UNANIMOUS_VOTE" => GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: UnanimousVote , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "MAJORITY_VOTE" => GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: MajorityVote , "NO_AGGREGATION" => GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: NoAggregation , "STRING_AGGREGATION_TYPE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: StringAggregationTypeUnspecified , "UNANIMOUS_VOTE" => GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType :: UnanimousVote , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ImageClassificationConfigAnswerAggregationType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ImagePayload {
        #[doc = "A byte string of a thumbnail image."]
        #[serde(
            rename = "imageThumbnail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_thumbnail: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "Image uri from the user bucket."]
        #[serde(
            rename = "imageUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_uri: ::std::option::Option<String>,
        #[doc = "Image format."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Signed uri of the image file in the service bucket."]
        #[serde(
            rename = "signedUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub signed_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ImagePayload {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ImagePayload {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ImagePolylineAnnotation {
        #[doc = "Label of this polyline."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[serde(
            rename = "normalizedPolyline",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub normalized_polyline:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1NormalizedPolyline>,
        #[serde(
            rename = "polyline",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub polyline: ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1Polyline>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ImagePolylineAnnotation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ImagePolylineAnnotation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ImageSegmentationAnnotation {
        #[doc = "The mapping between rgb color and annotation spec. The key is the rgb color represented in format of rgb(0, 0, 0). The value is the AnnotationSpec."]
        #[serde(
            rename = "annotationColors",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_colors: ::std::option::Option<
            ::std::collections::BTreeMap<
                String,
                crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec,
            >,
        >,
        #[doc = "A byte string of a full image's color map."]
        #[serde(
            rename = "imageBytes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_bytes: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "Image format."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ImageSegmentationAnnotation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ImageSegmentationAnnotation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Beta1ImportDataOperationMetadata {
        #[doc = "Output only. Timestamp when import dataset request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The name of imported dataset. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ImportDataOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ImportDataOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ImportDataOperationResponse {
        #[doc = "Ouptut only. The name of imported dataset."]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples imported successfully."]
        #[serde(
            rename = "importCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub import_count: ::std::option::Option<i32>,
        #[doc = "Output only. Total number of examples requested to import"]
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ImportDataOperationResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ImportDataOperationResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ImportDataRequest {
        #[doc = "Required. Specify the input source of the data."]
        #[serde(
            rename = "inputConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1InputConfig>,
        #[doc = "Email of the user who started the import task and should be notified by email. If empty no notification will be sent."]
        #[serde(
            rename = "userEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_email_address: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ImportDataRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ImportDataRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1InputConfig {
        #[doc = "Optional. The type of annotation to be performed on this data. You must specify this field if you are using this InputConfig in an EvaluationJob."]
        #[serde(
            rename = "annotationType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_type: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType,
        >,
        #[doc = "Source located in BigQuery. You must specify this field if you are using this InputConfig in an EvaluationJob."]
        #[serde(
            rename = "bigquerySource",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bigquery_source:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1BigQuerySource>,
        #[doc = "Optional. Metadata about annotations for the input. You must specify this field if you are using this InputConfig in an EvaluationJob for a model version that performs classification."]
        #[serde(
            rename = "classificationMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub classification_metadata: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ClassificationMetadata,
        >,
        #[doc = "Required. Data type must be specifed when user tries to import data."]
        #[serde(
            rename = "dataType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_type: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1InputConfigDataType,
        >,
        #[doc = "Source located in Cloud Storage."]
        #[serde(
            rename = "gcsSource",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_source:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1GcsSource>,
        #[doc = "Required for text import, as language code must be specified."]
        #[serde(
            rename = "textMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_metadata:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1TextMetadata>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1InputConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1InputConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType {
        AnnotationTypeUnspecified,
        #[doc = "General classification. Allowed for continuous evaluation."]
        GeneralClassificationAnnotation,
        #[doc = "Bounding box annotations in an image. A form of image object detection. Allowed for continuous evaluation."]
        ImageBoundingBoxAnnotation,
        #[doc = "Bounding poly annotations in an image."]
        ImageBoundingPolyAnnotation,
        #[doc = "Classification annotations in an image. Allowed for continuous evaluation."]
        ImageClassificationAnnotation,
        #[doc = "Oriented bounding box. The box does not have to be parallel to horizontal line."]
        ImageOrientedBoundingBoxAnnotation,
        #[doc = "Polyline annotations in an image."]
        ImagePolylineAnnotation,
        #[doc = "Segmentation annotations in an image."]
        ImageSegmentationAnnotation,
        #[doc = "Classification for text. Allowed for continuous evaluation."]
        TextClassificationAnnotation,
        #[doc = "Entity extraction for text."]
        TextEntityExtractionAnnotation,
        #[doc = "Video event annotation."]
        VideoEventAnnotation,
        #[doc = "Video object detection annotation."]
        VideoObjectDetectionAnnotation,
        #[doc = "Video object tracking annotation."]
        VideoObjectTrackingAnnotation,
        #[doc = "Classification annotations in video shots."]
        VideoShotsClassificationAnnotation,
    }
    impl GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: AnnotationTypeUnspecified => "ANNOTATION_TYPE_UNSPECIFIED" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: GeneralClassificationAnnotation => "GENERAL_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageBoundingBoxAnnotation => "IMAGE_BOUNDING_BOX_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageBoundingPolyAnnotation => "IMAGE_BOUNDING_POLY_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageClassificationAnnotation => "IMAGE_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageOrientedBoundingBoxAnnotation => "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImagePolylineAnnotation => "IMAGE_POLYLINE_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageSegmentationAnnotation => "IMAGE_SEGMENTATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: TextClassificationAnnotation => "TEXT_CLASSIFICATION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: TextEntityExtractionAnnotation => "TEXT_ENTITY_EXTRACTION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoEventAnnotation => "VIDEO_EVENT_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoObjectDetectionAnnotation => "VIDEO_OBJECT_DETECTION_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoObjectTrackingAnnotation => "VIDEO_OBJECT_TRACKING_ANNOTATION" , GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoShotsClassificationAnnotation => "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType, ()>
        {
            Ok (match s { "ANNOTATION_TYPE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: AnnotationTypeUnspecified , "GENERAL_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: GeneralClassificationAnnotation , "IMAGE_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageBoundingBoxAnnotation , "IMAGE_BOUNDING_POLY_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageBoundingPolyAnnotation , "IMAGE_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageClassificationAnnotation , "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageOrientedBoundingBoxAnnotation , "IMAGE_POLYLINE_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImagePolylineAnnotation , "IMAGE_SEGMENTATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageSegmentationAnnotation , "TEXT_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: TextClassificationAnnotation , "TEXT_ENTITY_EXTRACTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: TextEntityExtractionAnnotation , "VIDEO_EVENT_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoEventAnnotation , "VIDEO_OBJECT_DETECTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoObjectDetectionAnnotation , "VIDEO_OBJECT_TRACKING_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoObjectTrackingAnnotation , "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoShotsClassificationAnnotation , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ANNOTATION_TYPE_UNSPECIFIED" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: AnnotationTypeUnspecified , "GENERAL_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: GeneralClassificationAnnotation , "IMAGE_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageBoundingBoxAnnotation , "IMAGE_BOUNDING_POLY_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageBoundingPolyAnnotation , "IMAGE_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageClassificationAnnotation , "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageOrientedBoundingBoxAnnotation , "IMAGE_POLYLINE_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImagePolylineAnnotation , "IMAGE_SEGMENTATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: ImageSegmentationAnnotation , "TEXT_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: TextClassificationAnnotation , "TEXT_ENTITY_EXTRACTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: TextEntityExtractionAnnotation , "VIDEO_EVENT_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoEventAnnotation , "VIDEO_OBJECT_DETECTION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoObjectDetectionAnnotation , "VIDEO_OBJECT_TRACKING_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoObjectTrackingAnnotation , "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION" => GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType :: VideoShotsClassificationAnnotation , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1InputConfigAnnotationType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        #[doc = "Data type is unspecified."]
        DataTypeUnspecified,
        #[doc = "Allowed for continuous evaluation."]
        GeneralData,
        #[doc = "Allowed for continuous evaluation."]
        Image,
        #[doc = "Allowed for continuous evaluation."]
        Text,
        #[doc = "Video data type."]
        Video,
    }
    impl GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudDatalabelingV1Beta1InputConfigDataType::DataTypeUnspecified => {
                    "DATA_TYPE_UNSPECIFIED"
                }
                GoogleCloudDatalabelingV1Beta1InputConfigDataType::GeneralData => "GENERAL_DATA",
                GoogleCloudDatalabelingV1Beta1InputConfigDataType::Image => "IMAGE",
                GoogleCloudDatalabelingV1Beta1InputConfigDataType::Text => "TEXT",
                GoogleCloudDatalabelingV1Beta1InputConfigDataType::Video => "VIDEO",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1InputConfigDataType, ()> {
            Ok(match s {
                "DATA_TYPE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1InputConfigDataType::DataTypeUnspecified
                }
                "GENERAL_DATA" => GoogleCloudDatalabelingV1Beta1InputConfigDataType::GeneralData,
                "IMAGE" => GoogleCloudDatalabelingV1Beta1InputConfigDataType::Image,
                "TEXT" => GoogleCloudDatalabelingV1Beta1InputConfigDataType::Text,
                "VIDEO" => GoogleCloudDatalabelingV1Beta1InputConfigDataType::Video,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DATA_TYPE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1InputConfigDataType::DataTypeUnspecified
                }
                "GENERAL_DATA" => GoogleCloudDatalabelingV1Beta1InputConfigDataType::GeneralData,
                "IMAGE" => GoogleCloudDatalabelingV1Beta1InputConfigDataType::Image,
                "TEXT" => GoogleCloudDatalabelingV1Beta1InputConfigDataType::Text,
                "VIDEO" => GoogleCloudDatalabelingV1Beta1InputConfigDataType::Video,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1InputConfigDataType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1Instruction {
        #[doc = "Output only. The names of any related resources that are blocking changes to the instruction."]
        #[serde(
            rename = "blockingResources",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub blocking_resources: ::std::option::Option<Vec<String>>,
        #[doc = "Output only. Creation time of instruction."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Deprecated: this instruction format is not supported any more. Instruction from a CSV file, such as for classification task. The CSV file should have exact two columns, in the following format: * The first column is labeled data, such as an image reference, text. * The second column is comma separated labels associated with data."]
        #[serde(
            rename = "csvInstruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub csv_instruction:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1CsvInstruction>,
        #[doc = "Required. The data type of this instruction."]
        #[serde(
            rename = "dataType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_type: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1InstructionDataType,
        >,
        #[doc = "Optional. User-provided description of the instruction. The description can be up to 10000 characters long."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Required. The display name of the instruction. Maximum of 64 characters."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Output only. Instruction resource name, format: projects/{project_id}/instructions/{instruction_id}"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Instruction from a PDF document. The PDF should be in a Cloud Storage bucket."]
        #[serde(
            rename = "pdfInstruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pdf_instruction:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1PdfInstruction>,
        #[doc = "Output only. Last update time of instruction."]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Instruction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Instruction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1InstructionDataType {
        #[doc = "Data type is unspecified."]
        DataTypeUnspecified,
        #[doc = "Allowed for continuous evaluation."]
        GeneralData,
        #[doc = "Allowed for continuous evaluation."]
        Image,
        #[doc = "Allowed for continuous evaluation."]
        Text,
        #[doc = "Video data type."]
        Video,
    }
    impl GoogleCloudDatalabelingV1Beta1InstructionDataType {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudDatalabelingV1Beta1InstructionDataType::DataTypeUnspecified => {
                    "DATA_TYPE_UNSPECIFIED"
                }
                GoogleCloudDatalabelingV1Beta1InstructionDataType::GeneralData => "GENERAL_DATA",
                GoogleCloudDatalabelingV1Beta1InstructionDataType::Image => "IMAGE",
                GoogleCloudDatalabelingV1Beta1InstructionDataType::Text => "TEXT",
                GoogleCloudDatalabelingV1Beta1InstructionDataType::Video => "VIDEO",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1InstructionDataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1InstructionDataType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1InstructionDataType, ()> {
            Ok(match s {
                "DATA_TYPE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1InstructionDataType::DataTypeUnspecified
                }
                "GENERAL_DATA" => GoogleCloudDatalabelingV1Beta1InstructionDataType::GeneralData,
                "IMAGE" => GoogleCloudDatalabelingV1Beta1InstructionDataType::Image,
                "TEXT" => GoogleCloudDatalabelingV1Beta1InstructionDataType::Text,
                "VIDEO" => GoogleCloudDatalabelingV1Beta1InstructionDataType::Video,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1InstructionDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1InstructionDataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1InstructionDataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DATA_TYPE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1InstructionDataType::DataTypeUnspecified
                }
                "GENERAL_DATA" => GoogleCloudDatalabelingV1Beta1InstructionDataType::GeneralData,
                "IMAGE" => GoogleCloudDatalabelingV1Beta1InstructionDataType::Image,
                "TEXT" => GoogleCloudDatalabelingV1Beta1InstructionDataType::Text,
                "VIDEO" => GoogleCloudDatalabelingV1Beta1InstructionDataType::Video,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1InstructionDataType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1InstructionDataType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelImageBoundingBoxOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelImageBoundingBoxOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelImageBoundingBoxOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelImageBoundingPolyOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelImageBoundingPolyOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelImageBoundingPolyOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelImageClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelImageClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelImageClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelImageOrientedBoundingBoxOperationMetadata {
        #[doc = "Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelImageOrientedBoundingBoxOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelImageOrientedBoundingBoxOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelImagePolylineOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelImagePolylineOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelImagePolylineOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelImageRequest {
        #[doc = "Required. Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
        #[doc = "Configuration for bounding box and bounding poly task. One of image_classification_config, bounding_poly_config, polyline_config and segmentation_config are required."]
        #[serde(
            rename = "boundingPolyConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bounding_poly_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1BoundingPolyConfig>,
        #[doc = "Required. The type of image labeling task."]
        #[serde(
            rename = "feature",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feature: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature,
        >,
        #[doc = "Configuration for image classification task. One of image_classification_config, bounding_poly_config, polyline_config and segmentation_config are required."]
        #[serde(
            rename = "imageClassificationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_classification_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ImageClassificationConfig,
        >,
        #[doc = "Configuration for polyline task. One of image_classification_config, bounding_poly_config, polyline_config and segmentation_config are required."]
        #[serde(
            rename = "polylineConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub polyline_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1PolylineConfig>,
        #[doc = "Configuration for segmentation task. One of image_classification_config, bounding_poly_config, polyline_config and segmentation_config are required."]
        #[serde(
            rename = "segmentationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub segmentation_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1SegmentationConfig>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1LabelImageRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1LabelImageRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature {
        #[doc = "Label image with bounding boxes for labels."]
        BoundingBox,
        #[doc = "Label images with bounding poly. A bounding poly is a plane figure that is bounded by a finite chain of straight line segments closing in a loop."]
        BoundingPoly,
        #[doc = "Label whole image with one or more of labels."]
        Classification,
        FeatureUnspecified,
        #[doc = "Label oriented bounding box. The box does not have to be parallel to horizontal line."]
        OrientedBoundingBox,
        #[doc = "Label images with polyline. Polyline is formed by connected line segments which are not in closed form."]
        Polyline,
        #[doc = "Label images with segmentation. Segmentation is different from bounding poly since it is more fine-grained, pixel level annotation."]
        Segmentation,
    }
    impl GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::BoundingBox => {
                    "BOUNDING_BOX"
                }
                GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::BoundingPoly => {
                    "BOUNDING_POLY"
                }
                GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Classification => {
                    "CLASSIFICATION"
                }
                GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::FeatureUnspecified => {
                    "FEATURE_UNSPECIFIED"
                }
                GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::OrientedBoundingBox => {
                    "ORIENTED_BOUNDING_BOX"
                }
                GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Polyline => "POLYLINE",
                GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Segmentation => {
                    "SEGMENTATION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature, ()>
        {
            Ok(match s {
                "BOUNDING_BOX" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::BoundingBox
                }
                "BOUNDING_POLY" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::BoundingPoly
                }
                "CLASSIFICATION" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Classification
                }
                "FEATURE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::FeatureUnspecified
                }
                "ORIENTED_BOUNDING_BOX" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::OrientedBoundingBox
                }
                "POLYLINE" => GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Polyline,
                "SEGMENTATION" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Segmentation
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOUNDING_BOX" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::BoundingBox
                }
                "BOUNDING_POLY" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::BoundingPoly
                }
                "CLASSIFICATION" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Classification
                }
                "FEATURE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::FeatureUnspecified
                }
                "ORIENTED_BOUNDING_BOX" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::OrientedBoundingBox
                }
                "POLYLINE" => GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Polyline,
                "SEGMENTATION" => {
                    GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature::Segmentation
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelImageRequestFeature
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelImageSegmentationOperationMetadata {
        #[doc = "Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelImageSegmentationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelImageSegmentationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Beta1LabelOperationMetadata { # [doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."] # [serde (rename = "annotatedDataset" , default , skip_serializing_if = "std::option::Option::is_none")] pub annotated_dataset : :: std :: option :: Option < String > , # [doc = "Output only. Timestamp when labeling request was created."] # [serde (rename = "createTime" , default , skip_serializing_if = "std::option::Option::is_none")] pub create_time : :: std :: option :: Option < String > , # [doc = "Output only. The name of dataset to be labeled. \"projects/*/datasets/*\""] # [serde (rename = "dataset" , default , skip_serializing_if = "std::option::Option::is_none")] pub dataset : :: std :: option :: Option < String > , # [doc = "Details of label image bounding box operation."] # [serde (rename = "imageBoundingBoxDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_bounding_box_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelImageBoundingBoxOperationMetadata > , # [doc = "Details of label image bounding poly operation."] # [serde (rename = "imageBoundingPolyDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_bounding_poly_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelImageBoundingPolyOperationMetadata > , # [doc = "Details of label image classification operation."] # [serde (rename = "imageClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelImageClassificationOperationMetadata > , # [doc = "Details of label image oriented bounding box operation."] # [serde (rename = "imageOrientedBoundingBoxDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_oriented_bounding_box_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelImageOrientedBoundingBoxOperationMetadata > , # [doc = "Details of label image polyline operation."] # [serde (rename = "imagePolylineDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_polyline_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelImagePolylineOperationMetadata > , # [doc = "Details of label image segmentation operation."] # [serde (rename = "imageSegmentationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_segmentation_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelImageSegmentationOperationMetadata > , # [doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."] # [serde (rename = "partialFailures" , default , skip_serializing_if = "std::option::Option::is_none")] pub partial_failures : :: std :: option :: Option < Vec < crate :: schemas :: GoogleRpcStatus > > , # [doc = "Output only. Progress of label operation. Range: [0, 100]."] # [serde (rename = "progressPercent" , default , skip_serializing_if = "std::option::Option::is_none")] pub progress_percent : :: std :: option :: Option < i32 > , # [doc = "Details of label text classification operation."] # [serde (rename = "textClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub text_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelTextClassificationOperationMetadata > , # [doc = "Details of label text entity extraction operation."] # [serde (rename = "textEntityExtractionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub text_entity_extraction_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelTextEntityExtractionOperationMetadata > , # [doc = "Details of label video classification operation."] # [serde (rename = "videoClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelVideoClassificationOperationMetadata > , # [doc = "Details of label video event operation."] # [serde (rename = "videoEventDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_event_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelVideoEventOperationMetadata > , # [doc = "Details of label video object detection operation."] # [serde (rename = "videoObjectDetectionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_object_detection_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelVideoObjectDetectionOperationMetadata > , # [doc = "Details of label video object tracking operation."] # [serde (rename = "videoObjectTrackingDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_object_tracking_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1Beta1LabelVideoObjectTrackingOperationMetadata > , }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1LabelOperationMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelStats {
        #[doc = "Map of each annotation spec's example count. Key is the annotation spec name and value is the number of examples for that annotation spec. If the annotated dataset does not have annotation spec, the map will return a pair where the key is empty string and value is the total number of annotations."]
        #[serde(
            rename = "exampleCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub example_count: ::std::option::Option<::std::collections::BTreeMap<String, i64>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1LabelStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1LabelStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelTextClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelTextClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelTextClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelTextEntityExtractionOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelTextEntityExtractionOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelTextEntityExtractionOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelTextRequest {
        #[doc = "Required. Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
        #[doc = "Required. The type of text labeling task."]
        #[serde(
            rename = "feature",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feature: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature,
        >,
        #[doc = "Configuration for text classification task. One of text_classification_config and text_entity_extraction_config is required."]
        #[serde(
            rename = "textClassificationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_classification_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1TextClassificationConfig,
        >,
        #[doc = "Configuration for entity extraction task. One of text_classification_config and text_entity_extraction_config is required."]
        #[serde(
            rename = "textEntityExtractionConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_entity_extraction_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1TextEntityExtractionConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1LabelTextRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1LabelTextRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature {
        FeatureUnspecified,
        #[doc = "Label text content to one of more labels."]
        TextClassification,
        #[doc = "Label entities and their span in text."]
        TextEntityExtraction,
    }
    impl GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::FeatureUnspecified => {
                    "FEATURE_UNSPECIFIED"
                }
                GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::TextClassification => {
                    "TEXT_CLASSIFICATION"
                }
                GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::TextEntityExtraction => {
                    "TEXT_ENTITY_EXTRACTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature, ()>
        {
            Ok(match s {
                "FEATURE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::FeatureUnspecified
                }
                "TEXT_CLASSIFICATION" => {
                    GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::TextClassification
                }
                "TEXT_ENTITY_EXTRACTION" => {
                    GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::TextEntityExtraction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FEATURE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::FeatureUnspecified
                }
                "TEXT_CLASSIFICATION" => {
                    GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::TextClassification
                }
                "TEXT_ENTITY_EXTRACTION" => {
                    GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature::TextEntityExtraction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelTextRequestFeature
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelVideoClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelVideoClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelVideoClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelVideoEventOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelVideoEventOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelVideoEventOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelVideoObjectDetectionOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelVideoObjectDetectionOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelVideoObjectDetectionOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelVideoObjectTrackingOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelVideoObjectTrackingOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelVideoObjectTrackingOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1LabelVideoRequest {
        #[doc = "Required. Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1HumanAnnotationConfig,
        >,
        #[doc = "Configuration for video event task. One of video_classification_config, object_detection_config, object_tracking_config and event_config is required."]
        #[serde(
            rename = "eventConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1EventConfig>,
        #[doc = "Required. The type of video labeling task."]
        #[serde(
            rename = "feature",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feature: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature,
        >,
        #[doc = "Configuration for video object detection task. One of video_classification_config, object_detection_config, object_tracking_config and event_config is required."]
        #[serde(
            rename = "objectDetectionConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_detection_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ObjectDetectionConfig,
        >,
        #[doc = "Configuration for video object tracking task. One of video_classification_config, object_detection_config, object_tracking_config and event_config is required."]
        #[serde(
            rename = "objectTrackingConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_tracking_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1ObjectTrackingConfig,
        >,
        #[doc = "Configuration for video classification task. One of video_classification_config, object_detection_config, object_tracking_config and event_config is required."]
        #[serde(
            rename = "videoClassificationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_classification_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1VideoClassificationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1LabelVideoRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1LabelVideoRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature {
        #[doc = "Label whole video or video segment with one or more labels."]
        Classification,
        #[doc = "Label the range of video for the specified events."]
        Event,
        FeatureUnspecified,
        #[doc = "Label objects with bounding box on image frames extracted from the video."]
        ObjectDetection,
        #[doc = "Label and track objects in video."]
        ObjectTracking,
    }
    impl GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::Classification => {
                    "CLASSIFICATION"
                }
                GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::Event => "EVENT",
                GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::FeatureUnspecified => {
                    "FEATURE_UNSPECIFIED"
                }
                GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::ObjectDetection => {
                    "OBJECT_DETECTION"
                }
                GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::ObjectTracking => {
                    "OBJECT_TRACKING"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature, ()>
        {
            Ok(match s {
                "CLASSIFICATION" => {
                    GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::Classification
                }
                "EVENT" => GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::Event,
                "FEATURE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::FeatureUnspecified
                }
                "OBJECT_DETECTION" => {
                    GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::ObjectDetection
                }
                "OBJECT_TRACKING" => {
                    GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::ObjectTracking
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CLASSIFICATION" => {
                    GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::Classification
                }
                "EVENT" => GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::Event,
                "FEATURE_UNSPECIFIED" => {
                    GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::FeatureUnspecified
                }
                "OBJECT_DETECTION" => {
                    GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::ObjectDetection
                }
                "OBJECT_TRACKING" => {
                    GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature::ObjectTracking
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1LabelVideoRequestFeature
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ListAnnotatedDatasetsResponse {
        #[doc = "The list of annotated datasets to return."]
        #[serde(
            rename = "annotatedDatasets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_datasets: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotatedDataset>,
        >,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ListAnnotatedDatasetsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ListAnnotatedDatasetsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ListAnnotationSpecSetsResponse {
        #[doc = "The list of annotation spec sets."]
        #[serde(
            rename = "annotationSpecSets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_sets: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSet>,
        >,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ListAnnotationSpecSetsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ListAnnotationSpecSetsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ListDataItemsResponse {
        #[doc = "The list of data items to return."]
        #[serde(
            rename = "dataItems",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_items:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem>>,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ListDataItemsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ListDataItemsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ListDatasetsResponse {
        #[doc = "The list of datasets to return."]
        #[serde(
            rename = "datasets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub datasets:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Dataset>>,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ListDatasetsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ListDatasetsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1Beta1ListEvaluationJobsResponse {
        #[doc = "The list of evaluation jobs to return."]
        #[serde(
            rename = "evaluationJobs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub evaluation_jobs:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob>>,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ListEvaluationJobsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ListEvaluationJobsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ListExamplesResponse {
        #[doc = "The list of examples to return."]
        #[serde(
            rename = "examples",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub examples:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Example>>,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ListExamplesResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ListExamplesResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ListFeedbackMessagesResponse {
        #[doc = "The list of feedback messages to return."]
        #[serde(
            rename = "feedbackMessages",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feedback_messages: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackMessage>,
        >,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ListFeedbackMessagesResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ListFeedbackMessagesResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ListFeedbackThreadsResponse {
        #[doc = "The list of feedback threads to return."]
        #[serde(
            rename = "feedbackThreads",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feedback_threads: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackThread>,
        >,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ListFeedbackThreadsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ListFeedbackThreadsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ListInstructionsResponse {
        #[doc = "The list of Instructions to return."]
        #[serde(
            rename = "instructions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instructions:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Instruction>>,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ListInstructionsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ListInstructionsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1NormalizedBoundingPoly {
        #[doc = "The bounding polygon normalized vertices."]
        #[serde(
            rename = "normalizedVertices",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub normalized_vertices: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1NormalizedVertex>,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1NormalizedBoundingPoly
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1NormalizedBoundingPoly {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1NormalizedPolyline {
        #[doc = "The normalized polyline vertices."]
        #[serde(
            rename = "normalizedVertices",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub normalized_vertices: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1NormalizedVertex>,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1NormalizedPolyline {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1NormalizedPolyline {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1NormalizedVertex {
        #[doc = "X coordinate."]
        #[serde(
            rename = "x",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub x: ::std::option::Option<f32>,
        #[doc = "Y coordinate."]
        #[serde(
            rename = "y",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub y: ::std::option::Option<f32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1NormalizedVertex {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1NormalizedVertex {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ObjectDetectionConfig {
        #[doc = "Required. Annotation spec set resource name."]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
        #[doc = "Required. Number of frames per second to be extracted from the video."]
        #[serde(
            rename = "extractionFrameRate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub extraction_frame_rate: ::std::option::Option<f64>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ObjectDetectionConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ObjectDetectionConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ObjectDetectionMetrics {
        #[doc = "Precision-recall curve."]
        #[serde(
            rename = "prCurve",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pr_curve: ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1PrCurve>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ObjectDetectionMetrics
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ObjectDetectionMetrics {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ObjectTrackingConfig {
        #[doc = "Required. Annotation spec set resource name."]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
        #[doc = "Videos will be cut to smaller clips to make it easier for labelers to work on. Users can configure is field in seconds, if not set, default value is 20s."]
        #[serde(
            rename = "clipLength",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub clip_length: ::std::option::Option<i32>,
        #[doc = "The overlap length between different video clips. Users can configure is field in seconds, if not set, default value is 0.3s."]
        #[serde(
            rename = "overlapLength",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub overlap_length: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ObjectTrackingConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ObjectTrackingConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ObjectTrackingFrame {
        #[serde(
            rename = "boundingPoly",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bounding_poly:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1BoundingPoly>,
        #[serde(
            rename = "normalizedBoundingPoly",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub normalized_bounding_poly: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1NormalizedBoundingPoly,
        >,
        #[doc = "The time offset of this frame relative to the beginning of the video."]
        #[serde(
            rename = "timeOffset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub time_offset: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1ObjectTrackingFrame {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1ObjectTrackingFrame {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1OperatorFeedbackMetadata {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1OperatorFeedbackMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1OperatorFeedbackMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1OperatorMetadata {
        #[doc = "Comments from contributors."]
        #[serde(
            rename = "comments",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub comments: ::std::option::Option<Vec<String>>,
        #[doc = "The total number of contributors that choose this label."]
        #[serde(
            rename = "labelVotes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_votes: ::std::option::Option<i32>,
        #[doc = "Confidence score corresponding to a label. For examle, if 3 contributors have answered the question and 2 of them agree on the final label, the confidence score will be 0.67 (2/3)."]
        #[serde(
            rename = "score",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub score: ::std::option::Option<f32>,
        #[doc = "The total number of contributors that answer this question."]
        #[serde(
            rename = "totalVotes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_votes: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1OperatorMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1OperatorMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1OutputConfig {
        #[doc = "Output to a file in Cloud Storage. Should be used for labeling output other than image segmentation."]
        #[serde(
            rename = "gcsDestination",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_destination:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1GcsDestination>,
        #[doc = "Output to a folder in Cloud Storage. Should be used for image segmentation or document de-identification labeling outputs."]
        #[serde(
            rename = "gcsFolderDestination",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_folder_destination: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1Beta1GcsFolderDestination,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1OutputConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1OutputConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1PauseEvaluationJobRequest {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1PauseEvaluationJobRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1PauseEvaluationJobRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1PdfInstruction {
        #[doc = "PDF file for the instruction. Only gcs path is allowed."]
        #[serde(
            rename = "gcsFileUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_file_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1PdfInstruction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1PdfInstruction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1Polyline {
        #[doc = "The polyline vertices."]
        #[serde(
            rename = "vertices",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vertices:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Vertex>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Polyline {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Polyline {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1PolylineConfig {
        #[doc = "Required. Annotation spec set resource name."]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
        #[doc = "Optional. Instruction message showed on contributors UI."]
        #[serde(
            rename = "instructionMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction_message: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1PolylineConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1PolylineConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1PrCurve {
        #[doc = "The annotation spec of the label for which the precision-recall curve calculated. If this field is empty, that means the precision-recall curve is an aggregate curve for all labels."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[doc = "Area under the precision-recall curve. Not to be confused with area under a receiver operating characteristic (ROC) curve."]
        #[serde(
            rename = "areaUnderCurve",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub area_under_curve: ::std::option::Option<f32>,
        #[doc = "Entries that make up the precision-recall graph. Each entry is a \"point\" on the graph drawn for a different `confidence_threshold`."]
        #[serde(
            rename = "confidenceMetricsEntries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub confidence_metrics_entries: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1ConfidenceMetricsEntry>,
        >,
        #[doc = "Mean average prcision of this curve."]
        #[serde(
            rename = "meanAveragePrecision",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mean_average_precision: ::std::option::Option<f32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1PrCurve {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1PrCurve {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1RequesterFeedbackMetadata {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1RequesterFeedbackMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1RequesterFeedbackMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1ResumeEvaluationJobRequest {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1ResumeEvaluationJobRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1ResumeEvaluationJobRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1Row {
        #[doc = "The annotation spec of the ground truth label for this row."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[doc = "A list of the confusion matrix entries. One entry for each possible predicted label."]
        #[serde(
            rename = "entries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub entries: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1ConfusionMatrixEntry>,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Row {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Row {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1SearchEvaluationsResponse {
        #[doc = "The list of evaluations matching the search."]
        #[serde(
            rename = "evaluations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub evaluations:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1Evaluation>>,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1SearchEvaluationsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1SearchEvaluationsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsRequest {
        #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
        #[serde(
            rename = "pageSize",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub page_size: ::std::option::Option<i32>,
        #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by the nextPageToken of the response to a previous search rquest. If you don't specify this field, the API call requests the first page of the search."]
        #[serde(
            rename = "pageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsResponse {
        #[doc = "A list of example comparisons matching the search criteria."]
        #[serde(
            rename = "exampleComparisons",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub example_comparisons: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1ExampleComparison>,
        >,
        #[doc = "A token to retrieve next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1SegmentationConfig {
        #[doc = "Required. Annotation spec set resource name. format: projects/{project_id}/annotationSpecSets/{annotation_spec_set_id}"]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
        #[doc = "Instruction message showed on labelers UI."]
        #[serde(
            rename = "instructionMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction_message: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1SegmentationConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1SegmentationConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1SentimentConfig {
        #[doc = "If set to true, contributors will have the option to select sentiment of the label they selected, to mark it as negative or positive label. Default is false."]
        #[serde(
            rename = "enableLabelSentimentSelection",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enable_label_sentiment_selection: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1SentimentConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1SentimentConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1SequentialSegment {
        #[doc = "End position (exclusive)."]
        #[serde(
            rename = "end",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub end: ::std::option::Option<i32>,
        #[doc = "Start position (inclusive)."]
        #[serde(
            rename = "start",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1SequentialSegment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1SequentialSegment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1TextClassificationAnnotation {
        #[doc = "Label of the text."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1TextClassificationAnnotation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1TextClassificationAnnotation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1TextClassificationConfig {
        #[doc = "Optional. If allow_multi_label is true, contributors are able to choose multiple labels for one text segment."]
        #[serde(
            rename = "allowMultiLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub allow_multi_label: ::std::option::Option<bool>,
        #[doc = "Required. Annotation spec set resource name."]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
        #[doc = "Optional. Configs for sentiment selection. We deprecate sentiment analysis in data labeling side as it is incompatible with uCAIP."]
        #[serde(
            rename = "sentimentConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sentiment_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1SentimentConfig>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1TextClassificationConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1TextClassificationConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1TextEntityExtractionAnnotation {
        #[doc = "Label of the text entities."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[doc = "Position of the entity."]
        #[serde(
            rename = "sequentialSegment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sequential_segment:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1SequentialSegment>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1TextEntityExtractionAnnotation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1TextEntityExtractionAnnotation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1TextEntityExtractionConfig {
        #[doc = "Required. Annotation spec set resource name."]
        #[serde(
            rename = "annotationSpecSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1TextEntityExtractionConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1TextEntityExtractionConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1TextMetadata {
        #[doc = "The language of this text, as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Default value is en-US."]
        #[serde(
            rename = "languageCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_code: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1TextMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1TextMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1TextPayload {
        #[doc = "Text content."]
        #[serde(
            rename = "textContent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_content: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1TextPayload {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1TextPayload {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1TimeSegment {
        #[doc = "End of the time segment (exclusive), represented as the duration since the example start."]
        #[serde(
            rename = "endTimeOffset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub end_time_offset: ::std::option::Option<String>,
        #[doc = "Start of the time segment (inclusive), represented as the duration since the example start."]
        #[serde(
            rename = "startTimeOffset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_time_offset: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1TimeSegment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1TimeSegment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1Vertex {
        #[doc = "X coordinate."]
        #[serde(
            rename = "x",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub x: ::std::option::Option<i32>,
        #[doc = "Y coordinate."]
        #[serde(
            rename = "y",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub y: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1Vertex {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1Vertex {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1VideoClassificationAnnotation {
        #[doc = "Label of the segment specified by time_segment."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[doc = "The time segment of the video to which the annotation applies."]
        #[serde(
            rename = "timeSegment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub time_segment:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1TimeSegment>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1VideoClassificationAnnotation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1VideoClassificationAnnotation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1VideoClassificationConfig {
        #[doc = "Required. The list of annotation spec set configs. Since watching a video clip takes much longer time than an image, we support label with multiple AnnotationSpecSet at the same time. Labels in each AnnotationSpecSet will be shown in a group to contributors. Contributors can select one or more (depending on whether to allow multi label) from each group."]
        #[serde(
            rename = "annotationSpecSetConfigs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec_set_configs: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSetConfig>,
        >,
        #[doc = "Optional. Option to apply shot detection on the video."]
        #[serde(
            rename = "applyShotDetection",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub apply_shot_detection: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1VideoClassificationConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1VideoClassificationConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1VideoEventAnnotation {
        #[doc = "Label of the event in this annotation."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[doc = "The time segment of the video to which the annotation applies."]
        #[serde(
            rename = "timeSegment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub time_segment:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1TimeSegment>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1VideoEventAnnotation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1VideoEventAnnotation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1VideoObjectTrackingAnnotation {
        #[doc = "Label of the object tracked in this annotation."]
        #[serde(
            rename = "annotationSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_spec:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpec>,
        #[doc = "The list of frames where this object track appears."]
        #[serde(
            rename = "objectTrackingFrames",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_tracking_frames: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1ObjectTrackingFrame>,
        >,
        #[doc = "The time segment of the video to which object tracking applies."]
        #[serde(
            rename = "timeSegment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub time_segment:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1Beta1TimeSegment>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1Beta1VideoObjectTrackingAnnotation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1Beta1VideoObjectTrackingAnnotation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1VideoPayload {
        #[doc = "FPS of the video."]
        #[serde(
            rename = "frameRate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub frame_rate: ::std::option::Option<f32>,
        #[doc = "Video format."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Signed uri of the video file in the service bucket."]
        #[serde(
            rename = "signedUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub signed_uri: ::std::option::Option<String>,
        #[doc = "The list of video thumbnails."]
        #[serde(
            rename = "videoThumbnails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_thumbnails: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudDatalabelingV1Beta1VideoThumbnail>,
        >,
        #[doc = "Video uri from the user bucket."]
        #[serde(
            rename = "videoUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1VideoPayload {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1VideoPayload {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1Beta1VideoThumbnail {
        #[doc = "A byte string of the video frame."]
        #[serde(
            rename = "thumbnail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thumbnail: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "Time offset relative to the beginning of the video, corresponding to the video frame where the thumbnail has been extracted from."]
        #[serde(
            rename = "timeOffset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub time_offset: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1Beta1VideoThumbnail {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1Beta1VideoThumbnail {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1P1Alpha1CreateInstructionMetadata {
        #[doc = "Timestamp when create instruction request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "The name of the created Instruction. projects/{project_id}/instructions/{instruction_id}"]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction: ::std::option::Option<String>,
        #[doc = "Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1CreateInstructionMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1CreateInstructionMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1P1Alpha1ExportDataOperationMetadata {
        #[doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Output only. Timestamp when export dataset request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The name of dataset to be exported. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1ExportDataOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1ExportDataOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1ExportDataOperationResponse {
        #[doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Ouptut only. The name of dataset. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples exported successfully."]
        #[serde(
            rename = "exportCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub export_count: ::std::option::Option<i32>,
        #[doc = "Output only. Statistic infos of labels in the exported dataset."]
        #[serde(
            rename = "labelStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_stats:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1P1Alpha1LabelStats>,
        #[doc = "Output only. output_config in the ExportData request."]
        #[serde(
            rename = "outputConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1P1Alpha1OutputConfig>,
        #[doc = "Output only. Total number of examples requested to export"]
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1ExportDataOperationResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1ExportDataOperationResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1GcsDestination {
        #[doc = "Required. The format of the gcs destination. Only \"text/csv\" and \"application/json\" are supported."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Required. The output uri of destination file."]
        #[serde(
            rename = "outputUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1P1Alpha1GcsDestination {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1P1Alpha1GcsDestination {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1GcsFolderDestination {
        #[doc = "Required. Cloud Storage directory to export data to."]
        #[serde(
            rename = "outputFolderUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_folder_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1GcsFolderDestination
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1GcsFolderDestination
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1GenerateAnalysisReportOperationMetadata {
        #[doc = "Timestamp when generate report request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "The name of the dataset for which the analysis report is generated. Format: \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1GenerateAnalysisReportOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1GenerateAnalysisReportOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig {
        #[doc = "Optional. A human-readable description for AnnotatedDataset. The description can be up to 10000 characters long."]
        #[serde(
            rename = "annotatedDatasetDescription",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset_description: ::std::option::Option<String>,
        #[doc = "Required. A human-readable name for AnnotatedDataset defined by users. Maximum of 64 characters ."]
        #[serde(
            rename = "annotatedDatasetDisplayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset_display_name: ::std::option::Option<String>,
        #[doc = "Optional. If you want your own labeling contributors to manage and work on this labeling request, you can set these contributors here. We will give them access to the question types in crowdcompute. Note that these emails must be registered in crowdcompute worker UI: https://crowd-compute.appspot.com/"]
        #[serde(
            rename = "contributorEmails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contributor_emails: ::std::option::Option<Vec<String>>,
        #[doc = "Required. Instruction resource name."]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction: ::std::option::Option<String>,
        #[doc = "Optional. A human-readable label used to logically group labeling tasks. This string must match the regular expression `[a-zA-Z\\\\d_-]{0,128}`."]
        #[serde(
            rename = "labelGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_group: ::std::option::Option<String>,
        #[doc = "Optional. The Language of this question, as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Default value is en-US. Only need to set this when task is language related. For example, French text classification."]
        #[serde(
            rename = "languageCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_code: ::std::option::Option<String>,
        #[doc = "Optional. Maximum duration for contributors to answer a question. Maximum is 3600 seconds. Default is 3600 seconds."]
        #[serde(
            rename = "questionDuration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub question_duration: ::std::option::Option<String>,
        #[doc = "Optional. Replication of questions. Each question will be sent to up to this number of contributors to label. Aggregated answers will be returned. Default is set to 1. For image related labeling, valid values are 1, 3, 5."]
        #[serde(
            rename = "replicaCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub replica_count: ::std::option::Option<i32>,
        #[doc = "Email of the user who started the labeling task and should be notified by email. If empty no notification will be sent."]
        #[serde(
            rename = "userEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_email_address: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1P1Alpha1ImportDataOperationMetadata {
        #[doc = "Output only. Timestamp when import dataset request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The name of imported dataset. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1ImportDataOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1ImportDataOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1ImportDataOperationResponse {
        #[doc = "Ouptut only. The name of imported dataset."]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples imported successfully."]
        #[serde(
            rename = "importCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub import_count: ::std::option::Option<i32>,
        #[doc = "Output only. Total number of examples requested to import"]
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1ImportDataOperationResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1ImportDataOperationResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelImageBoundingBoxOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageBoundingBoxOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageBoundingBoxOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelImageBoundingPolyOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageBoundingPolyOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageBoundingPolyOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelImageClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelImageOrientedBoundingBoxOperationMetadata {
        #[doc = "Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageOrientedBoundingBoxOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageOrientedBoundingBoxOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelImagePolylineOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelImagePolylineOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelImagePolylineOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelImageSegmentationOperationMetadata {
        #[doc = "Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageSegmentationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelImageSegmentationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelOperationMetadata { # [doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."] # [serde (rename = "annotatedDataset" , default , skip_serializing_if = "std::option::Option::is_none")] pub annotated_dataset : :: std :: option :: Option < String > , # [doc = "Output only. Timestamp when labeling request was created."] # [serde (rename = "createTime" , default , skip_serializing_if = "std::option::Option::is_none")] pub create_time : :: std :: option :: Option < String > , # [doc = "Output only. The name of dataset to be labeled. \"projects/*/datasets/*\""] # [serde (rename = "dataset" , default , skip_serializing_if = "std::option::Option::is_none")] pub dataset : :: std :: option :: Option < String > , # [doc = "Details of label image bounding box operation."] # [serde (rename = "imageBoundingBoxDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_bounding_box_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelImageBoundingBoxOperationMetadata > , # [doc = "Details of label image bounding poly operation."] # [serde (rename = "imageBoundingPolyDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_bounding_poly_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelImageBoundingPolyOperationMetadata > , # [doc = "Details of label image classification operation."] # [serde (rename = "imageClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelImageClassificationOperationMetadata > , # [doc = "Details of label image oriented bounding box operation."] # [serde (rename = "imageOrientedBoundingBoxDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_oriented_bounding_box_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelImageOrientedBoundingBoxOperationMetadata > , # [doc = "Details of label image polyline operation."] # [serde (rename = "imagePolylineDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_polyline_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelImagePolylineOperationMetadata > , # [doc = "Details of label image segmentation operation."] # [serde (rename = "imageSegmentationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_segmentation_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelImageSegmentationOperationMetadata > , # [doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."] # [serde (rename = "partialFailures" , default , skip_serializing_if = "std::option::Option::is_none")] pub partial_failures : :: std :: option :: Option < Vec < crate :: schemas :: GoogleRpcStatus > > , # [doc = "Output only. Progress of label operation. Range: [0, 100]."] # [serde (rename = "progressPercent" , default , skip_serializing_if = "std::option::Option::is_none")] pub progress_percent : :: std :: option :: Option < i32 > , # [doc = "Details of label text classification operation."] # [serde (rename = "textClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub text_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelTextClassificationOperationMetadata > , # [doc = "Details of label text entity extraction operation."] # [serde (rename = "textEntityExtractionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub text_entity_extraction_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelTextEntityExtractionOperationMetadata > , # [doc = "Details of label video classification operation."] # [serde (rename = "videoClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelVideoClassificationOperationMetadata > , # [doc = "Details of label video event operation."] # [serde (rename = "videoEventDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_event_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelVideoEventOperationMetadata > , # [doc = "Details of label video object detection operation."] # [serde (rename = "videoObjectDetectionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_object_detection_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelVideoObjectDetectionOperationMetadata > , # [doc = "Details of label video object tracking operation."] # [serde (rename = "videoObjectTrackingDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_object_tracking_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P1Alpha1LabelVideoObjectTrackingOperationMetadata > , }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelStats {
        #[doc = "Map of each annotation spec's example count. Key is the annotation spec name and value is the number of examples for that annotation spec. If the annotated dataset does not have annotation spec, the map will return a pair where the key is empty string and value is the total number of annotations."]
        #[serde(
            rename = "exampleCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub example_count: ::std::option::Option<::std::collections::BTreeMap<String, i64>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1P1Alpha1LabelStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1P1Alpha1LabelStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelTextClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelTextClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelTextClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelTextEntityExtractionOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelTextEntityExtractionOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelTextEntityExtractionOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelVideoClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelVideoClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelVideoClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelVideoEventOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelVideoEventOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelVideoEventOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelVideoObjectDetectionOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelVideoObjectDetectionOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelVideoObjectDetectionOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1LabelVideoObjectTrackingOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P1Alpha1LabelVideoObjectTrackingOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P1Alpha1LabelVideoObjectTrackingOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P1Alpha1OutputConfig {
        #[doc = "Output to a file in Cloud Storage. Should be used for labeling output other than image segmentation."]
        #[serde(
            rename = "gcsDestination",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_destination:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1P1Alpha1GcsDestination>,
        #[doc = "Output to a folder in Cloud Storage. Should be used for image segmentation or document de-identification labeling outputs."]
        #[serde(
            rename = "gcsFolderDestination",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_folder_destination: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P1Alpha1GcsFolderDestination,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1P1Alpha1OutputConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1P1Alpha1OutputConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1P2Alpha1CreateInstructionMetadata {
        #[doc = "Timestamp when create instruction request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "The name of the created Instruction. projects/{project_id}/instructions/{instruction_id}"]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction: ::std::option::Option<String>,
        #[doc = "Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1CreateInstructionMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1CreateInstructionMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1P2Alpha1ExportDataOperationMetadata {
        #[doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Output only. Timestamp when export dataset request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The name of dataset to be exported. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1ExportDataOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1ExportDataOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1ExportDataOperationResponse {
        #[doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."]
        #[serde(
            rename = "annotatedDataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset: ::std::option::Option<String>,
        #[doc = "Ouptut only. The name of dataset. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples exported successfully."]
        #[serde(
            rename = "exportCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub export_count: ::std::option::Option<i32>,
        #[doc = "Output only. Statistic infos of labels in the exported dataset."]
        #[serde(
            rename = "labelStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_stats:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1P2Alpha1LabelStats>,
        #[doc = "Output only. output_config in the ExportData request."]
        #[serde(
            rename = "outputConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_config:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1P2Alpha1OutputConfig>,
        #[doc = "Output only. Total number of examples requested to export"]
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1ExportDataOperationResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1ExportDataOperationResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1GcsDestination {
        #[doc = "Required. The format of the gcs destination. Only \"text/csv\" and \"application/json\" are supported."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Required. The output uri of destination file."]
        #[serde(
            rename = "outputUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1P2Alpha1GcsDestination {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1P2Alpha1GcsDestination {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1GcsFolderDestination {
        #[doc = "Required. Cloud Storage directory to export data to."]
        #[serde(
            rename = "outputFolderUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_folder_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1GcsFolderDestination
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1GcsFolderDestination
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig {
        #[doc = "Optional. A human-readable description for AnnotatedDataset. The description can be up to 10000 characters long."]
        #[serde(
            rename = "annotatedDatasetDescription",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset_description: ::std::option::Option<String>,
        #[doc = "Required. A human-readable name for AnnotatedDataset defined by users. Maximum of 64 characters ."]
        #[serde(
            rename = "annotatedDatasetDisplayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotated_dataset_display_name: ::std::option::Option<String>,
        #[doc = "Optional. If you want your own labeling contributors to manage and work on this labeling request, you can set these contributors here. We will give them access to the question types in crowdcompute. Note that these emails must be registered in crowdcompute worker UI: https://crowd-compute.appspot.com/"]
        #[serde(
            rename = "contributorEmails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contributor_emails: ::std::option::Option<Vec<String>>,
        #[doc = "Required. Instruction resource name."]
        #[serde(
            rename = "instruction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instruction: ::std::option::Option<String>,
        #[doc = "Optional. A human-readable label used to logically group labeling tasks. This string must match the regular expression `[a-zA-Z\\\\d_-]{0,128}`."]
        #[serde(
            rename = "labelGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_group: ::std::option::Option<String>,
        #[doc = "Optional. The Language of this question, as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Default value is en-US. Only need to set this when task is language related. For example, French text classification."]
        #[serde(
            rename = "languageCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_code: ::std::option::Option<String>,
        #[doc = "Optional. Maximum duration for contributors to answer a question. Maximum is 3600 seconds. Default is 3600 seconds."]
        #[serde(
            rename = "questionDuration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub question_duration: ::std::option::Option<String>,
        #[doc = "Optional. Replication of questions. Each question will be sent to up to this number of contributors to label. Aggregated answers will be returned. Default is set to 1. For image related labeling, valid values are 1, 3, 5."]
        #[serde(
            rename = "replicaCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub replica_count: ::std::option::Option<i32>,
        #[doc = "Email of the user who started the labeling task and should be notified by email. If empty no notification will be sent."]
        #[serde(
            rename = "userEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_email_address: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1P2Alpha1ImportDataOperationMetadata {
        #[doc = "Output only. Timestamp when import dataset request was created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. The name of imported dataset. \"projects/*/datasets/*\""]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."]
        #[serde(
            rename = "partialFailures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub partial_failures: ::std::option::Option<Vec<crate::schemas::GoogleRpcStatus>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1ImportDataOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1ImportDataOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1ImportDataOperationResponse {
        #[doc = "Ouptut only. The name of imported dataset."]
        #[serde(
            rename = "dataset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dataset: ::std::option::Option<String>,
        #[doc = "Output only. Number of examples imported successfully."]
        #[serde(
            rename = "importCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub import_count: ::std::option::Option<i32>,
        #[doc = "Output only. Total number of examples requested to import"]
        #[serde(
            rename = "totalCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1ImportDataOperationResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1ImportDataOperationResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelImageBoundingBoxOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageBoundingBoxOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageBoundingBoxOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelImageBoundingPolyOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageBoundingPolyOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageBoundingPolyOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelImageClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelImageOrientedBoundingBoxOperationMetadata {
        #[doc = "Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageOrientedBoundingBoxOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageOrientedBoundingBoxOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelImagePolylineOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelImagePolylineOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelImagePolylineOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelImageSegmentationOperationMetadata {
        #[doc = "Basic human annotation config."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageSegmentationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelImageSegmentationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelOperationMetadata { # [doc = "Output only. The name of annotated dataset in format \"projects/*/datasets/*/annotatedDatasets/*\"."] # [serde (rename = "annotatedDataset" , default , skip_serializing_if = "std::option::Option::is_none")] pub annotated_dataset : :: std :: option :: Option < String > , # [doc = "Output only. Timestamp when labeling request was created."] # [serde (rename = "createTime" , default , skip_serializing_if = "std::option::Option::is_none")] pub create_time : :: std :: option :: Option < String > , # [doc = "Output only. The name of dataset to be labeled. \"projects/*/datasets/*\""] # [serde (rename = "dataset" , default , skip_serializing_if = "std::option::Option::is_none")] pub dataset : :: std :: option :: Option < String > , # [doc = "Details of label image bounding box operation."] # [serde (rename = "imageBoundingBoxDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_bounding_box_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelImageBoundingBoxOperationMetadata > , # [doc = "Details of label image bounding poly operation."] # [serde (rename = "imageBoundingPolyDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_bounding_poly_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelImageBoundingPolyOperationMetadata > , # [doc = "Details of label image classification operation."] # [serde (rename = "imageClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelImageClassificationOperationMetadata > , # [doc = "Details of label image oriented bounding box operation."] # [serde (rename = "imageOrientedBoundingBoxDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_oriented_bounding_box_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelImageOrientedBoundingBoxOperationMetadata > , # [doc = "Details of label image polyline operation."] # [serde (rename = "imagePolylineDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_polyline_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelImagePolylineOperationMetadata > , # [doc = "Details of label image segmentation operation."] # [serde (rename = "imageSegmentationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub image_segmentation_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelImageSegmentationOperationMetadata > , # [doc = "Output only. Partial failures encountered. E.g. single files that couldn't be read. Status details field will contain standard GCP error details."] # [serde (rename = "partialFailures" , default , skip_serializing_if = "std::option::Option::is_none")] pub partial_failures : :: std :: option :: Option < Vec < crate :: schemas :: GoogleRpcStatus > > , # [doc = "Output only. Progress of label operation. Range: [0, 100]."] # [serde (rename = "progressPercent" , default , skip_serializing_if = "std::option::Option::is_none")] pub progress_percent : :: std :: option :: Option < i32 > , # [doc = "Details of label text classification operation."] # [serde (rename = "textClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub text_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelTextClassificationOperationMetadata > , # [doc = "Details of label text entity extraction operation."] # [serde (rename = "textEntityExtractionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub text_entity_extraction_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelTextEntityExtractionOperationMetadata > , # [doc = "Details of label video classification operation."] # [serde (rename = "videoClassificationDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_classification_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelVideoClassificationOperationMetadata > , # [doc = "Details of label video event operation."] # [serde (rename = "videoEventDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_event_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelVideoEventOperationMetadata > , # [doc = "Details of label video object detection operation."] # [serde (rename = "videoObjectDetectionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_object_detection_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelVideoObjectDetectionOperationMetadata > , # [doc = "Details of label video object tracking operation."] # [serde (rename = "videoObjectTrackingDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub video_object_tracking_details : :: std :: option :: Option < crate :: schemas :: GoogleCloudDatalabelingV1P2Alpha1LabelVideoObjectTrackingOperationMetadata > , }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelStats {
        #[doc = "Map of each annotation spec's example count. Key is the annotation spec name and value is the number of examples for that annotation spec. If the annotated dataset does not have annotation spec, the map will return a pair where the key is empty string and value is the total number of annotations."]
        #[serde(
            rename = "exampleCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub example_count: ::std::option::Option<::std::collections::BTreeMap<String, i64>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1P2Alpha1LabelStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1P2Alpha1LabelStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelTextClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelTextClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelTextClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelTextEntityExtractionOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelTextEntityExtractionOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelTextEntityExtractionOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelVideoClassificationOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelVideoClassificationOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelVideoClassificationOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelVideoEventOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelVideoEventOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelVideoEventOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelVideoObjectDetectionOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelVideoObjectDetectionOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelVideoObjectDetectionOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1LabelVideoObjectTrackingOperationMetadata {
        #[doc = "Basic human annotation config used in labeling request."]
        #[serde(
            rename = "basicConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub basic_config: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1HumanAnnotationConfig,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudDatalabelingV1P2Alpha1LabelVideoObjectTrackingOperationMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudDatalabelingV1P2Alpha1LabelVideoObjectTrackingOperationMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudDatalabelingV1P2Alpha1OutputConfig {
        #[doc = "Output to a file in Cloud Storage. Should be used for labeling output other than image segmentation."]
        #[serde(
            rename = "gcsDestination",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_destination:
            ::std::option::Option<crate::schemas::GoogleCloudDatalabelingV1P2Alpha1GcsDestination>,
        #[doc = "Output to a folder in Cloud Storage. Should be used for image segmentation or document de-identification labeling outputs."]
        #[serde(
            rename = "gcsFolderDestination",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcs_folder_destination: ::std::option::Option<
            crate::schemas::GoogleCloudDatalabelingV1P2Alpha1GcsFolderDestination,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudDatalabelingV1P2Alpha1OutputConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudDatalabelingV1P2Alpha1OutputConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleLongrunningListOperationsResponse {
        #[doc = "The standard List next-page token."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "A list of operations that matches the specified filter in the request."]
        #[serde(
            rename = "operations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operations: ::std::option::Option<Vec<crate::schemas::GoogleLongrunningOperation>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleLongrunningListOperationsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleLongrunningListOperationsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleLongrunningOperation {
        #[doc = "If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available."]
        #[serde(
            rename = "done",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub done: ::std::option::Option<bool>,
        #[doc = "The error result of the operation in case of failure or cancellation."]
        #[serde(
            rename = "error",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error: ::std::option::Option<crate::schemas::GoogleRpcStatus>,
        #[doc = "Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any."]
        #[serde(
            rename = "metadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metadata:
            ::std::option::Option<::std::collections::BTreeMap<String, ::serde_json::Value>>,
        #[doc = "The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."]
        #[serde(
            rename = "response",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub response:
            ::std::option::Option<::std::collections::BTreeMap<String, ::serde_json::Value>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleLongrunningOperation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleLongrunningOperation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleProtobufEmpty {}
    impl ::google_field_selector::FieldSelector for GoogleProtobufEmpty {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleProtobufEmpty {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleRpcStatus {
        #[doc = "The status code, which should be an enum value of google.rpc.Code."]
        #[serde(
            rename = "code",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub code: ::std::option::Option<i32>,
        #[doc = "A list of messages that carry the error details. There is a common set of message types for APIs to use."]
        #[serde(
            rename = "details",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub details:
            ::std::option::Option<Vec<::std::collections::BTreeMap<String, ::serde_json::Value>>>,
        #[doc = "A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."]
        #[serde(
            rename = "message",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleRpcStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleRpcStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
}
pub mod params {
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Alt {
        #[doc = "Responses with Content-Type of application/json"]
        Json,
        #[doc = "Media download with context-dependent Content-Type"]
        Media,
        #[doc = "Responses with Content-Type of application/x-protobuf"]
        Proto,
    }
    impl Alt {
        pub fn as_str(self) -> &'static str {
            match self {
                Alt::Json => "json",
                Alt::Media => "media",
                Alt::Proto => "proto",
            }
        }
    }
    impl ::std::convert::AsRef<str> for Alt {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for Alt {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<Alt, ()> {
            Ok(match s {
                "json" => Alt::Json,
                "media" => Alt::Media,
                "proto" => Alt::Proto,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for Alt {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Alt {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Alt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "json" => Alt::Json,
                "media" => Alt::Media,
                "proto" => Alt::Proto,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for Alt {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Alt {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Xgafv {
        #[doc = "v1 error format"]
        _1,
        #[doc = "v2 error format"]
        _2,
    }
    impl Xgafv {
        pub fn as_str(self) -> &'static str {
            match self {
                Xgafv::_1 => "1",
                Xgafv::_2 => "2",
            }
        }
    }
    impl ::std::convert::AsRef<str> for Xgafv {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for Xgafv {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<Xgafv, ()> {
            Ok(match s {
                "1" => Xgafv::_1,
                "2" => Xgafv::_2,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for Xgafv {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Xgafv {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Xgafv {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "1" => Xgafv::_1,
                "2" => Xgafv::_2,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for Xgafv {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Xgafv {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
}
pub struct Client {
    reqwest: ::reqwest::blocking::Client,
    auth: Box<dyn ::google_api_auth::GetAccessToken>,
}
impl Client {
    pub fn new<A>(auth: A) -> Self
    where
        A: ::google_api_auth::GetAccessToken + 'static,
    {
        Client::with_reqwest_client(
            auth,
            ::reqwest::blocking::Client::builder()
                .timeout(None)
                .build()
                .unwrap(),
        )
    }
    pub fn with_reqwest_client<A>(auth: A, reqwest: ::reqwest::blocking::Client) -> Self
    where
        A: ::google_api_auth::GetAccessToken + 'static,
    {
        Client {
            reqwest,
            auth: Box::new(auth),
        }
    }
    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
        self.auth.as_ref()
    }
    #[doc = "Actions that can be performed on the projects resource"]
    pub fn projects(&self) -> crate::resources::projects::ProjectsActions {
        crate::resources::projects::ProjectsActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
}
pub mod resources {
    pub mod projects {
        pub mod params {}
        pub struct ProjectsActions<'a> {
            pub(crate) reqwest: &'a reqwest::blocking::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> ProjectsActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Actions that can be performed on the annotation_spec_sets resource"]
            pub fn annotation_spec_sets(
                &self,
            ) -> crate::resources::projects::annotation_spec_sets::AnnotationSpecSetsActions
            {
                crate::resources::projects::annotation_spec_sets::AnnotationSpecSetsActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the datasets resource"]
            pub fn datasets(&self) -> crate::resources::projects::datasets::DatasetsActions {
                crate::resources::projects::datasets::DatasetsActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the evaluation_jobs resource"]
            pub fn evaluation_jobs(
                &self,
            ) -> crate::resources::projects::evaluation_jobs::EvaluationJobsActions {
                crate::resources::projects::evaluation_jobs::EvaluationJobsActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the evaluations resource"]
            pub fn evaluations(
                &self,
            ) -> crate::resources::projects::evaluations::EvaluationsActions {
                crate::resources::projects::evaluations::EvaluationsActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the instructions resource"]
            pub fn instructions(
                &self,
            ) -> crate::resources::projects::instructions::InstructionsActions {
                crate::resources::projects::instructions::InstructionsActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the operations resource"]
            pub fn operations(&self) -> crate::resources::projects::operations::OperationsActions {
                crate::resources::projects::operations::OperationsActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        pub mod annotation_spec_sets {
            pub mod params {}
            pub struct AnnotationSpecSetsActions<'a> {
                pub(crate) reqwest: &'a reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> AnnotationSpecSetsActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Creates an annotation spec set by providing a set of labels."]
                pub fn create(
                    &self,
                    request : crate :: schemas :: GoogleCloudDatalabelingV1Beta1CreateAnnotationSpecSetRequest,
                    parent: impl Into<String>,
                ) -> CreateRequestBuilder {
                    CreateRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                    }
                }
                #[doc = "Deletes an annotation spec set by resource name."]
                pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                    DeleteRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Gets an annotation spec set by resource name."]
                pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                    GetRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Lists annotation spec sets for a project. Pagination is supported."]
                pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                        filter: None,
                        page_size: None,
                        page_token: None,
                    }
                }
            }
            #[doc = "Created via [AnnotationSpecSetsActions::create()](struct.AnnotationSpecSetsActions.html#method.create)"]
            #[derive(Debug, Clone)]
            pub struct CreateRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request:
                    crate::schemas::GoogleCloudDatalabelingV1Beta1CreateAnnotationSpecSetRequest,
                parent: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> CreateRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSet,
                    crate::Error,
                > {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSet,
                    crate::Error,
                > {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/annotationSpecSets");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [AnnotationSpecSetsActions::delete()](struct.AnnotationSpecSetsActions.html#method.delete)"]
            #[derive(Debug, Clone)]
            pub struct DeleteRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> DeleteRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [AnnotationSpecSetsActions::get()](struct.AnnotationSpecSetsActions.html#method.get)"]
            #[derive(Debug, Clone)]
            pub struct GetRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> GetRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSet,
                    crate::Error,
                > {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSet,
                    crate::Error,
                > {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [AnnotationSpecSetsActions::list()](struct.AnnotationSpecSetsActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                parent: String,
                filter: Option<String>,
                page_size: Option<i32>,
                page_token: Option<String>,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "Optional. Filter is not supported at this moment."]
                pub fn filter(mut self, value: impl Into<String>) -> Self {
                    self.filter = Some(value.into());
                    self
                }
                #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListAnnotationSpecSetsResponse.next_page_token of the previous [DataLabelingService.ListAnnotationSpecSets] call. Return first page if empty."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                #[doc = r" populated fields in the yielded items will be determined by the"]
                #[doc = r" `FieldSelector` implementation."]
                pub fn iter_annotation_spec_sets<T>(self) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_annotation_spec_sets_with_fields(fields)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be the default fields populated by"]
                #[doc = r" the server."]
                pub fn iter_annotation_spec_sets_with_default_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSet,
                > {
                    self.iter_annotation_spec_sets_with_fields(None::<String>)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be all fields available. This should"]
                #[doc = r" primarily be used during developement and debugging as fetching"]
                #[doc = r" all fields can be expensive both in bandwidth and server"]
                #[doc = r" resources."]
                pub fn iter_annotation_spec_sets_with_all_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotationSpecSet,
                > {
                    self.iter_annotation_spec_sets_with_fields(Some("*"))
                }
                pub fn iter_annotation_spec_sets_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    self.fields = Some({
                        let mut selector =
                            concat!("nextPageToken,", "annotationSpecSets").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::iter::PageItemIter::new(self, "annotationSpecSets")
                }
                pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_with_fields(fields)
                }
                pub fn iter_with_default_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListAnnotationSpecSetsResponse,
                > {
                    self.iter_with_fields(None::<&str>)
                }
                pub fn iter_with_all_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListAnnotationSpecSetsResponse,
                > {
                    self.iter_with_fields(Some("*"))
                }
                pub fn iter_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::iter::PageIter::new(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListAnnotationSpecSetsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListAnnotationSpecSetsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/annotationSpecSets");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("filter", &self.filter)]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    self._execute()
                }
            }
        }
        pub mod datasets {
            pub mod params {}
            pub struct DatasetsActions<'a> {
                pub(crate) reqwest: &'a reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> DatasetsActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Creates dataset. If success return a Dataset resource."]
                pub fn create(
                    &self,
                    request: crate::schemas::GoogleCloudDatalabelingV1Beta1CreateDatasetRequest,
                    parent: impl Into<String>,
                ) -> CreateRequestBuilder {
                    CreateRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                    }
                }
                #[doc = "Deletes a dataset by resource name."]
                pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                    DeleteRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Exports data and annotations from dataset."]
                pub fn export_data(
                    &self,
                    request: crate::schemas::GoogleCloudDatalabelingV1Beta1ExportDataRequest,
                    name: impl Into<String>,
                ) -> ExportDataRequestBuilder {
                    ExportDataRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Gets dataset by resource name."]
                pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                    GetRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Imports data into dataset based on source locations defined in request. It can be called multiple times for the same dataset. Each dataset can only have one long running operation running on it. For example, no labeling task (also long running operation) can be started while importing is still ongoing. Vice versa."]
                pub fn import_data(
                    &self,
                    request: crate::schemas::GoogleCloudDatalabelingV1Beta1ImportDataRequest,
                    name: impl Into<String>,
                ) -> ImportDataRequestBuilder {
                    ImportDataRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Lists datasets under a project. Pagination is supported."]
                pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                        filter: None,
                        page_size: None,
                        page_token: None,
                    }
                }
                #[doc = "Actions that can be performed on the annotated_datasets resource"]                pub fn annotated_datasets (& self) -> crate :: resources :: projects :: datasets :: annotated_datasets :: AnnotatedDatasetsActions{
                    crate :: resources :: projects :: datasets :: annotated_datasets :: AnnotatedDatasetsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                }
                #[doc = "Actions that can be performed on the data_items resource"]
                pub fn data_items(
                    &self,
                ) -> crate::resources::projects::datasets::data_items::DataItemsActions
                {
                    crate::resources::projects::datasets::data_items::DataItemsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the evaluations resource"]
                pub fn evaluations(
                    &self,
                ) -> crate::resources::projects::datasets::evaluations::EvaluationsActions
                {
                    crate::resources::projects::datasets::evaluations::EvaluationsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the image resource"]
                pub fn image(&self) -> crate::resources::projects::datasets::image::ImageActions {
                    crate::resources::projects::datasets::image::ImageActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the text resource"]
                pub fn text(&self) -> crate::resources::projects::datasets::text::TextActions {
                    crate::resources::projects::datasets::text::TextActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the video resource"]
                pub fn video(&self) -> crate::resources::projects::datasets::video::VideoActions {
                    crate::resources::projects::datasets::video::VideoActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
            }
            #[doc = "Created via [DatasetsActions::create()](struct.DatasetsActions.html#method.create)"]
            #[derive(Debug, Clone)]
            pub struct CreateRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::GoogleCloudDatalabelingV1Beta1CreateDatasetRequest,
                parent: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> CreateRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1Dataset, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1Dataset, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/datasets");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasetsActions::delete()](struct.DatasetsActions.html#method.delete)"]
            #[derive(Debug, Clone)]
            pub struct DeleteRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> DeleteRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasetsActions::export_data()](struct.DatasetsActions.html#method.export_data)"]
            #[derive(Debug, Clone)]
            pub struct ExportDataRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::GoogleCloudDatalabelingV1Beta1ExportDataRequest,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> ExportDataRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str(":exportData");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasetsActions::get()](struct.DatasetsActions.html#method.get)"]
            #[derive(Debug, Clone)]
            pub struct GetRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> GetRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1Dataset, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1Dataset, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasetsActions::import_data()](struct.DatasetsActions.html#method.import_data)"]
            #[derive(Debug, Clone)]
            pub struct ImportDataRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::GoogleCloudDatalabelingV1Beta1ImportDataRequest,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> ImportDataRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str(":importData");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasetsActions::list()](struct.DatasetsActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                parent: String,
                filter: Option<String>,
                page_size: Option<i32>,
                page_token: Option<String>,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "Optional. Filter on dataset is not supported at this moment."]
                pub fn filter(mut self, value: impl Into<String>) -> Self {
                    self.filter = Some(value.into());
                    self
                }
                #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListDatasetsResponse.next_page_token of the previous [DataLabelingService.ListDatasets] call. Returns the first page if empty."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                #[doc = r" populated fields in the yielded items will be determined by the"]
                #[doc = r" `FieldSelector` implementation."]
                pub fn iter_datasets<T>(self) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_datasets_with_fields(fields)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be the default fields populated by"]
                #[doc = r" the server."]
                pub fn iter_datasets_with_default_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1Dataset,
                > {
                    self.iter_datasets_with_fields(None::<String>)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be all fields available. This should"]
                #[doc = r" primarily be used during developement and debugging as fetching"]
                #[doc = r" all fields can be expensive both in bandwidth and server"]
                #[doc = r" resources."]
                pub fn iter_datasets_with_all_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1Dataset,
                > {
                    self.iter_datasets_with_fields(Some("*"))
                }
                pub fn iter_datasets_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    self.fields = Some({
                        let mut selector = concat!("nextPageToken,", "datasets").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::iter::PageItemIter::new(self, "datasets")
                }
                pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_with_fields(fields)
                }
                pub fn iter_with_default_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListDatasetsResponse,
                > {
                    self.iter_with_fields(None::<&str>)
                }
                pub fn iter_with_all_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListDatasetsResponse,
                > {
                    self.iter_with_fields(Some("*"))
                }
                pub fn iter_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::iter::PageIter::new(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListDatasetsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListDatasetsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/datasets");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("filter", &self.filter)]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    self._execute()
                }
            }
            pub mod annotated_datasets {
                pub mod params {}
                pub struct AnnotatedDatasetsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> AnnotatedDatasetsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Deletes an annotated dataset by resource name."]
                    pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                        DeleteRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Gets an annotated dataset by resource name."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Lists annotated datasets for a dataset. Pagination is supported."]
                    pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                        ListRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            filter: None,
                            page_size: None,
                            page_token: None,
                        }
                    }
                    #[doc = "Actions that can be performed on the data_items resource"]                    pub fn data_items (& self) -> crate :: resources :: projects :: datasets :: annotated_datasets :: data_items :: DataItemsActions{
                        crate :: resources :: projects :: datasets :: annotated_datasets :: data_items :: DataItemsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                    #[doc = "Actions that can be performed on the examples resource"]                    pub fn examples (& self) -> crate :: resources :: projects :: datasets :: annotated_datasets :: examples :: ExamplesActions{
                        crate :: resources :: projects :: datasets :: annotated_datasets :: examples :: ExamplesActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                    #[doc = "Actions that can be performed on the feedback_threads resource"]                    pub fn feedback_threads (& self) -> crate :: resources :: projects :: datasets :: annotated_datasets :: feedback_threads :: FeedbackThreadsActions{
                        crate :: resources :: projects :: datasets :: annotated_datasets :: feedback_threads :: FeedbackThreadsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                }
                #[doc = "Created via [AnnotatedDatasetsActions::delete()](struct.AnnotatedDatasetsActions.html#method.delete)"]
                #[derive(Debug, Clone)]
                pub struct DeleteRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> DeleteRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                    {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
                #[doc = "Created via [AnnotatedDatasetsActions::get()](struct.AnnotatedDatasetsActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotatedDataset,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotatedDataset,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
                #[doc = "Created via [AnnotatedDatasetsActions::list()](struct.AnnotatedDatasetsActions.html#method.list)"]
                #[derive(Debug, Clone)]
                pub struct ListRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    parent: String,
                    filter: Option<String>,
                    page_size: Option<i32>,
                    page_token: Option<String>,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> ListRequestBuilder<'a> {
                    #[doc = "Optional. Filter is not supported at this moment."]
                    pub fn filter(mut self, value: impl Into<String>) -> Self {
                        self.filter = Some(value.into());
                        self
                    }
                    #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListAnnotatedDatasetsResponse.next_page_token of the previous [DataLabelingService.ListAnnotatedDatasets] call. Return first page if empty."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                    #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                    #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                    #[doc = r" populated fields in the yielded items will be determined by the"]
                    #[doc = r" `FieldSelector` implementation."]
                    pub fn iter_annotated_datasets<T>(self) -> crate::iter::PageItemIter<Self, T>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.iter_annotated_datasets_with_fields(fields)
                    }
                    #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                    #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                    #[doc = r" fields in `#items_type` will be the default fields populated by"]
                    #[doc = r" the server."]
                    pub fn iter_annotated_datasets_with_default_fields(
                        self,
                    ) -> crate::iter::PageItemIter<
                        Self,
                        crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotatedDataset,
                    > {
                        self.iter_annotated_datasets_with_fields(None::<String>)
                    }
                    #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                    #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                    #[doc = r" fields in `#items_type` will be all fields available. This should"]
                    #[doc = r" primarily be used during developement and debugging as fetching"]
                    #[doc = r" all fields can be expensive both in bandwidth and server"]
                    #[doc = r" resources."]
                    pub fn iter_annotated_datasets_with_all_fields(
                        self,
                    ) -> crate::iter::PageItemIter<
                        Self,
                        crate::schemas::GoogleCloudDatalabelingV1Beta1AnnotatedDataset,
                    > {
                        self.iter_annotated_datasets_with_fields(Some("*"))
                    }
                    pub fn iter_annotated_datasets_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> crate::iter::PageItemIter<Self, T>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: AsRef<str>,
                    {
                        self.fields = Some({
                            let mut selector =
                                concat!("nextPageToken,", "annotatedDatasets").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::iter::PageItemIter::new(self, "annotatedDatasets")
                    }
                    pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.iter_with_fields(fields)
                    }
                    pub fn iter_with_default_fields(
                        self,
                    ) -> crate::iter::PageIter<
                        Self,
                        crate::schemas::GoogleCloudDatalabelingV1Beta1ListAnnotatedDatasetsResponse,
                    > {
                        self.iter_with_fields(None::<&str>)
                    }
                    pub fn iter_with_all_fields(
                        self,
                    ) -> crate::iter::PageIter<
                        Self,
                        crate::schemas::GoogleCloudDatalabelingV1Beta1ListAnnotatedDatasetsResponse,
                    > {
                        self.iter_with_fields(Some("*"))
                    }
                    pub fn iter_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> crate::iter::PageIter<Self, T>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::iter::PageIter::new(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudDatalabelingV1Beta1ListAnnotatedDatasetsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudDatalabelingV1Beta1ListAnnotatedDatasetsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/annotatedDatasets");
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("filter", &self.filter)]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
                impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        self._execute()
                    }
                }
                pub mod data_items {
                    pub mod params {}
                    pub struct DataItemsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> DataItemsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Gets a data item in a dataset by resource name. This API can be called after data are imported into dataset."]
                        pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                            GetRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Lists data items in a dataset. This API can be called after data are imported into dataset. Pagination is supported."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                page_size: None,
                                page_token: None,
                            }
                        }
                    }
                    #[doc = "Created via [DataItemsActions::get()](struct.DataItemsActions.html#method.get)"]
                    #[derive(Debug, Clone)]
                    pub struct GetRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: Option<String>,
                        alt: Option<crate::params::Alt>,
                        callback: Option<String>,
                        fields: Option<String>,
                        key: Option<String>,
                        oauth_token: Option<String>,
                        pretty_print: Option<bool>,
                        quota_user: Option<String>,
                        upload_protocol: Option<String>,
                        upload_type: Option<String>,
                        xgafv: Option<crate::params::Xgafv>,
                    }
                    impl<'a> GetRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields)
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub fn execute_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute()
                        }
                        fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path())?;
                            Ok(crate::error_from_response(req.send()?)?.json()?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://datalabeling.googleapis.com/".to_owned();
                            output.push_str("v1beta1/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            req = req.bearer_auth(
                                self.auth
                                    .access_token()
                                    .map_err(|err| crate::Error::OAuth2(err))?,
                            );
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [DataItemsActions::list()](struct.DataItemsActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: Option<String>,
                        page_size: Option<i32>,
                        page_token: Option<String>,
                        access_token: Option<String>,
                        alt: Option<crate::params::Alt>,
                        callback: Option<String>,
                        fields: Option<String>,
                        key: Option<String>,
                        oauth_token: Option<String>,
                        pretty_print: Option<bool>,
                        quota_user: Option<String>,
                        upload_protocol: Option<String>,
                        upload_type: Option<String>,
                        xgafv: Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Optional. Filter is not supported at this moment."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListDataItemsResponse.next_page_token of the previous [DataLabelingService.ListDataItems] call. Return first page if empty."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                        #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                        #[doc = r" populated fields in the yielded items will be determined by the"]
                        #[doc = r" `FieldSelector` implementation."]
                        pub fn iter_data_items<T>(self) -> crate::iter::PageItemIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.iter_data_items_with_fields(fields)
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                        #[doc = r" fields in `#items_type` will be the default fields populated by"]
                        #[doc = r" the server."]
                        pub fn iter_data_items_with_default_fields(
                            self,
                        ) -> crate::iter::PageItemIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem,
                        > {
                            self.iter_data_items_with_fields(None::<String>)
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                        #[doc = r" fields in `#items_type` will be all fields available. This should"]
                        #[doc = r" primarily be used during developement and debugging as fetching"]
                        #[doc = r" all fields can be expensive both in bandwidth and server"]
                        #[doc = r" resources."]
                        pub fn iter_data_items_with_all_fields(
                            self,
                        ) -> crate::iter::PageItemIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem,
                        > {
                            self.iter_data_items_with_fields(Some("*"))
                        }
                        pub fn iter_data_items_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> crate::iter::PageItemIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: AsRef<str>,
                        {
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "dataItems").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::iter::PageItemIter::new(self, "dataItems")
                        }
                        pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.iter_with_fields(fields)
                        }
                        pub fn iter_with_default_fields(
                            self,
                        ) -> crate::iter::PageIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1ListDataItemsResponse,
                        > {
                            self.iter_with_fields(None::<&str>)
                        }
                        pub fn iter_with_all_fields(
                            self,
                        ) -> crate::iter::PageIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1ListDataItemsResponse,
                        > {
                            self.iter_with_fields(Some("*"))
                        }
                        pub fn iter_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> crate::iter::PageIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::iter::PageIter::new(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields)
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1ListDataItemsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1ListDataItemsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub fn execute_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute()
                        }
                        fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path())?;
                            Ok(crate::error_from_response(req.send()?)?.json()?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://datalabeling.googleapis.com/".to_owned();
                            output.push_str("v1beta1/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/dataItems");
                            output
                        }
                        fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            req = req.bearer_auth(
                                self.auth
                                    .access_token()
                                    .map_err(|err| crate::Error::OAuth2(err))?,
                            );
                            Ok(req)
                        }
                    }
                    impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            self._execute()
                        }
                    }
                }
                pub mod examples {
                    pub mod params {}
                    pub struct ExamplesActions<'a> {
                        pub(crate) reqwest: &'a reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> ExamplesActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Gets an example by resource name, including both data and annotation."]
                        pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                            GetRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                                filter: None,
                            }
                        }
                        #[doc = "Lists examples in an annotated dataset. Pagination is supported."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                page_size: None,
                                page_token: None,
                            }
                        }
                    }
                    #[doc = "Created via [ExamplesActions::get()](struct.ExamplesActions.html#method.get)"]
                    #[derive(Debug, Clone)]
                    pub struct GetRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        filter: Option<String>,
                        access_token: Option<String>,
                        alt: Option<crate::params::Alt>,
                        callback: Option<String>,
                        fields: Option<String>,
                        key: Option<String>,
                        oauth_token: Option<String>,
                        pretty_print: Option<bool>,
                        quota_user: Option<String>,
                        upload_protocol: Option<String>,
                        upload_type: Option<String>,
                        xgafv: Option<crate::params::Xgafv>,
                    }
                    impl<'a> GetRequestBuilder<'a> {
                        #[doc = "Optional. An expression for filtering Examples. Filter by annotation_spec.display_name is supported. Format \"annotation_spec.display_name = {display_name}\""]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields)
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1Example,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1Example,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub fn execute_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute()
                        }
                        fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path())?;
                            Ok(crate::error_from_response(req.send()?)?.json()?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://datalabeling.googleapis.com/".to_owned();
                            output.push_str("v1beta1/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            req = req.bearer_auth(
                                self.auth
                                    .access_token()
                                    .map_err(|err| crate::Error::OAuth2(err))?,
                            );
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [ExamplesActions::list()](struct.ExamplesActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: Option<String>,
                        page_size: Option<i32>,
                        page_token: Option<String>,
                        access_token: Option<String>,
                        alt: Option<crate::params::Alt>,
                        callback: Option<String>,
                        fields: Option<String>,
                        key: Option<String>,
                        oauth_token: Option<String>,
                        pretty_print: Option<bool>,
                        quota_user: Option<String>,
                        upload_protocol: Option<String>,
                        upload_type: Option<String>,
                        xgafv: Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Optional. An expression for filtering Examples. For annotated datasets that have annotation spec set, filter by annotation_spec.display_name is supported. Format \"annotation_spec.display_name = {display_name}\""]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListExamplesResponse.next_page_token of the previous [DataLabelingService.ListExamples] call. Return first page if empty."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                        #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                        #[doc = r" populated fields in the yielded items will be determined by the"]
                        #[doc = r" `FieldSelector` implementation."]
                        pub fn iter_examples<T>(self) -> crate::iter::PageItemIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.iter_examples_with_fields(fields)
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                        #[doc = r" fields in `#items_type` will be the default fields populated by"]
                        #[doc = r" the server."]
                        pub fn iter_examples_with_default_fields(
                            self,
                        ) -> crate::iter::PageItemIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1Example,
                        > {
                            self.iter_examples_with_fields(None::<String>)
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                        #[doc = r" fields in `#items_type` will be all fields available. This should"]
                        #[doc = r" primarily be used during developement and debugging as fetching"]
                        #[doc = r" all fields can be expensive both in bandwidth and server"]
                        #[doc = r" resources."]
                        pub fn iter_examples_with_all_fields(
                            self,
                        ) -> crate::iter::PageItemIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1Example,
                        > {
                            self.iter_examples_with_fields(Some("*"))
                        }
                        pub fn iter_examples_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> crate::iter::PageItemIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: AsRef<str>,
                        {
                            self.fields = Some({
                                let mut selector = concat!("nextPageToken,", "examples").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::iter::PageItemIter::new(self, "examples")
                        }
                        pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.iter_with_fields(fields)
                        }
                        pub fn iter_with_default_fields(
                            self,
                        ) -> crate::iter::PageIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1ListExamplesResponse,
                        > {
                            self.iter_with_fields(None::<&str>)
                        }
                        pub fn iter_with_all_fields(
                            self,
                        ) -> crate::iter::PageIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1ListExamplesResponse,
                        > {
                            self.iter_with_fields(Some("*"))
                        }
                        pub fn iter_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> crate::iter::PageIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::iter::PageIter::new(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields)
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1ListExamplesResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1ListExamplesResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub fn execute_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute()
                        }
                        fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path())?;
                            Ok(crate::error_from_response(req.send()?)?.json()?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://datalabeling.googleapis.com/".to_owned();
                            output.push_str("v1beta1/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/examples");
                            output
                        }
                        fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            req = req.bearer_auth(
                                self.auth
                                    .access_token()
                                    .map_err(|err| crate::Error::OAuth2(err))?,
                            );
                            Ok(req)
                        }
                    }
                    impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            self._execute()
                        }
                    }
                }
                pub mod feedback_threads {
                    pub mod params {}
                    pub struct FeedbackThreadsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> FeedbackThreadsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Delete a FeedbackThread."]
                        pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                            DeleteRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Get a FeedbackThread object."]
                        pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                            GetRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "List FeedbackThreads with pagination."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                page_size: None,
                                page_token: None,
                            }
                        }
                        #[doc = "Actions that can be performed on the feedback_messages resource"]                        pub fn feedback_messages (& self) -> crate :: resources :: projects :: datasets :: annotated_datasets :: feedback_threads :: feedback_messages :: FeedbackMessagesActions{
                            crate :: resources :: projects :: datasets :: annotated_datasets :: feedback_threads :: feedback_messages :: FeedbackMessagesActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                        }
                    }
                    #[doc = "Created via [FeedbackThreadsActions::delete()](struct.FeedbackThreadsActions.html#method.delete)"]
                    #[derive(Debug, Clone)]
                    pub struct DeleteRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: Option<String>,
                        alt: Option<crate::params::Alt>,
                        callback: Option<String>,
                        fields: Option<String>,
                        key: Option<String>,
                        oauth_token: Option<String>,
                        pretty_print: Option<bool>,
                        quota_user: Option<String>,
                        upload_protocol: Option<String>,
                        upload_type: Option<String>,
                        xgafv: Option<crate::params::Xgafv>,
                    }
                    impl<'a> DeleteRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields)
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub fn execute_with_default_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub fn execute_with_all_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub fn execute_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute()
                        }
                        fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path())?;
                            Ok(crate::error_from_response(req.send()?)?.json()?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://datalabeling.googleapis.com/".to_owned();
                            output.push_str("v1beta1/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            req = req.bearer_auth(
                                self.auth
                                    .access_token()
                                    .map_err(|err| crate::Error::OAuth2(err))?,
                            );
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [FeedbackThreadsActions::get()](struct.FeedbackThreadsActions.html#method.get)"]
                    #[derive(Debug, Clone)]
                    pub struct GetRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: Option<String>,
                        alt: Option<crate::params::Alt>,
                        callback: Option<String>,
                        fields: Option<String>,
                        key: Option<String>,
                        oauth_token: Option<String>,
                        pretty_print: Option<bool>,
                        quota_user: Option<String>,
                        upload_protocol: Option<String>,
                        upload_type: Option<String>,
                        xgafv: Option<crate::params::Xgafv>,
                    }
                    impl<'a> GetRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields)
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackThread,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackThread,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub fn execute_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute()
                        }
                        fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path())?;
                            Ok(crate::error_from_response(req.send()?)?.json()?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://datalabeling.googleapis.com/".to_owned();
                            output.push_str("v1beta1/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            req = req.bearer_auth(
                                self.auth
                                    .access_token()
                                    .map_err(|err| crate::Error::OAuth2(err))?,
                            );
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [FeedbackThreadsActions::list()](struct.FeedbackThreadsActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        page_size: Option<i32>,
                        page_token: Option<String>,
                        access_token: Option<String>,
                        alt: Option<crate::params::Alt>,
                        callback: Option<String>,
                        fields: Option<String>,
                        key: Option<String>,
                        oauth_token: Option<String>,
                        pretty_print: Option<bool>,
                        quota_user: Option<String>,
                        upload_protocol: Option<String>,
                        upload_type: Option<String>,
                        xgafv: Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListFeedbackThreads.next_page_token of the previous [DataLabelingService.ListFeedbackThreads] call. Return first page if empty."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                        #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                        #[doc = r" populated fields in the yielded items will be determined by the"]
                        #[doc = r" `FieldSelector` implementation."]
                        pub fn iter_feedback_threads<T>(self) -> crate::iter::PageItemIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.iter_feedback_threads_with_fields(fields)
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                        #[doc = r" fields in `#items_type` will be the default fields populated by"]
                        #[doc = r" the server."]
                        pub fn iter_feedback_threads_with_default_fields(
                            self,
                        ) -> crate::iter::PageItemIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackThread,
                        > {
                            self.iter_feedback_threads_with_fields(None::<String>)
                        }
                        #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                        #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                        #[doc = r" fields in `#items_type` will be all fields available. This should"]
                        #[doc = r" primarily be used during developement and debugging as fetching"]
                        #[doc = r" all fields can be expensive both in bandwidth and server"]
                        #[doc = r" resources."]
                        pub fn iter_feedback_threads_with_all_fields(
                            self,
                        ) -> crate::iter::PageItemIter<
                            Self,
                            crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackThread,
                        > {
                            self.iter_feedback_threads_with_fields(Some("*"))
                        }
                        pub fn iter_feedback_threads_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> crate::iter::PageItemIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: AsRef<str>,
                        {
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "feedbackThreads").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::iter::PageItemIter::new(self, "feedbackThreads")
                        }
                        pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.iter_with_fields(fields)
                        }                        pub fn iter_with_default_fields (self) -> crate :: iter :: PageIter < Self , crate :: schemas :: GoogleCloudDatalabelingV1Beta1ListFeedbackThreadsResponse >{
                            self.iter_with_fields(None::<&str>)
                        }                        pub fn iter_with_all_fields (self) -> crate :: iter :: PageIter < Self , crate :: schemas :: GoogleCloudDatalabelingV1Beta1ListFeedbackThreadsResponse >{
                            self.iter_with_fields(Some("*"))
                        }
                        pub fn iter_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> crate::iter::PageIter<Self, T>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::iter::PageIter::new(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields)
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudDatalabelingV1Beta1ListFeedbackThreadsResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudDatalabelingV1Beta1ListFeedbackThreadsResponse , crate :: Error >{
                            self.execute_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub fn execute_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute()
                        }
                        fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path())?;
                            Ok(crate::error_from_response(req.send()?)?.json()?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://datalabeling.googleapis.com/".to_owned();
                            output.push_str("v1beta1/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/feedbackThreads");
                            output
                        }
                        fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            req = req.bearer_auth(
                                self.auth
                                    .access_token()
                                    .map_err(|err| crate::Error::OAuth2(err))?,
                            );
                            Ok(req)
                        }
                    }
                    impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            self._execute()
                        }
                    }
                    pub mod feedback_messages {
                        pub mod params {}
                        pub struct FeedbackMessagesActions<'a> {
                            pub(crate) reqwest: &'a reqwest::blocking::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        }
                        impl<'a> FeedbackMessagesActions<'a> {
                            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                                self.auth
                            }
                            #[doc = "Create a FeedbackMessage object."]
                            pub fn create(
                                &self,
                                request : crate :: schemas :: GoogleCloudDatalabelingV1Beta1FeedbackMessage,
                                parent: impl Into<String>,
                            ) -> CreateRequestBuilder {
                                CreateRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                }
                            }
                            #[doc = "Delete a FeedbackMessage."]
                            pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                                DeleteRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Get a FeedbackMessage object."]
                            pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                                GetRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "List FeedbackMessages with pagination."]
                            pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                                ListRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                    page_size: None,
                                    page_token: None,
                                }
                            }
                        }
                        #[doc = "Created via [FeedbackMessagesActions::create()](struct.FeedbackMessagesActions.html#method.create)"]
                        #[derive(Debug, Clone)]
                        pub struct CreateRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            request: crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackMessage,
                            parent: String,
                            access_token: Option<String>,
                            alt: Option<crate::params::Alt>,
                            callback: Option<String>,
                            fields: Option<String>,
                            key: Option<String>,
                            oauth_token: Option<String>,
                            pretty_print: Option<bool>,
                            quota_user: Option<String>,
                            upload_protocol: Option<String>,
                            upload_type: Option<String>,
                            xgafv: Option<crate::params::Xgafv>,
                        }
                        impl<'a> CreateRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields)
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub fn execute_with_default_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                            {
                                self.execute_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub fn execute_with_all_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                            {
                                self.execute_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub fn execute_with_fields<T, F>(
                                mut self,
                                fields: Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute()
                            }
                            fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path())?;
                                let req = req.json(&self.request);
                                Ok(crate::error_from_response(req.send()?)?.json()?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://datalabeling.googleapis.com/".to_owned();
                                output.push_str("v1beta1/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/feedbackMessages");
                                output
                            }
                            fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                req = req.bearer_auth(
                                    self.auth
                                        .access_token()
                                        .map_err(|err| crate::Error::OAuth2(err))?,
                                );
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [FeedbackMessagesActions::delete()](struct.FeedbackMessagesActions.html#method.delete)"]
                        #[derive(Debug, Clone)]
                        pub struct DeleteRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            name: String,
                            access_token: Option<String>,
                            alt: Option<crate::params::Alt>,
                            callback: Option<String>,
                            fields: Option<String>,
                            key: Option<String>,
                            oauth_token: Option<String>,
                            pretty_print: Option<bool>,
                            quota_user: Option<String>,
                            upload_protocol: Option<String>,
                            upload_type: Option<String>,
                            xgafv: Option<crate::params::Xgafv>,
                        }
                        impl<'a> DeleteRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields)
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub fn execute_with_default_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                            {
                                self.execute_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub fn execute_with_all_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                            {
                                self.execute_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub fn execute_with_fields<T, F>(
                                mut self,
                                fields: Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute()
                            }
                            fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path())?;
                                Ok(crate::error_from_response(req.send()?)?.json()?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://datalabeling.googleapis.com/".to_owned();
                                output.push_str("v1beta1/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                req = req.bearer_auth(
                                    self.auth
                                        .access_token()
                                        .map_err(|err| crate::Error::OAuth2(err))?,
                                );
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [FeedbackMessagesActions::get()](struct.FeedbackMessagesActions.html#method.get)"]
                        #[derive(Debug, Clone)]
                        pub struct GetRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            name: String,
                            access_token: Option<String>,
                            alt: Option<crate::params::Alt>,
                            callback: Option<String>,
                            fields: Option<String>,
                            key: Option<String>,
                            oauth_token: Option<String>,
                            pretty_print: Option<bool>,
                            quota_user: Option<String>,
                            upload_protocol: Option<String>,
                            upload_type: Option<String>,
                            xgafv: Option<crate::params::Xgafv>,
                        }
                        impl<'a> GetRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields)
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub fn execute_with_default_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackMessage,
                                crate::Error,
                            > {
                                self.execute_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub fn execute_with_all_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackMessage,
                                crate::Error,
                            > {
                                self.execute_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub fn execute_with_fields<T, F>(
                                mut self,
                                fields: Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute()
                            }
                            fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path())?;
                                Ok(crate::error_from_response(req.send()?)?.json()?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://datalabeling.googleapis.com/".to_owned();
                                output.push_str("v1beta1/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                req = req.bearer_auth(
                                    self.auth
                                        .access_token()
                                        .map_err(|err| crate::Error::OAuth2(err))?,
                                );
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [FeedbackMessagesActions::list()](struct.FeedbackMessagesActions.html#method.list)"]
                        #[derive(Debug, Clone)]
                        pub struct ListRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            parent: String,
                            page_size: Option<i32>,
                            page_token: Option<String>,
                            access_token: Option<String>,
                            alt: Option<crate::params::Alt>,
                            callback: Option<String>,
                            fields: Option<String>,
                            key: Option<String>,
                            oauth_token: Option<String>,
                            pretty_print: Option<bool>,
                            quota_user: Option<String>,
                            upload_protocol: Option<String>,
                            upload_type: Option<String>,
                            xgafv: Option<crate::params::Xgafv>,
                        }
                        impl<'a> ListRequestBuilder<'a> {
                            #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                            pub fn page_size(mut self, value: i32) -> Self {
                                self.page_size = Some(value);
                                self
                            }
                            #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListFeedbackMessages.next_page_token of the previous [DataLabelingService.ListFeedbackMessages] call. Return first page if empty."]
                            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                                self.page_token = Some(value.into());
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                            #[doc = r" populated fields in the yielded items will be determined by the"]
                            #[doc = r" `FieldSelector` implementation."]
                            pub fn iter_feedback_messages<T>(
                                self,
                            ) -> crate::iter::PageItemIter<Self, T>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.iter_feedback_messages_with_fields(fields)
                            }
                            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                            #[doc = r" fields in `#items_type` will be the default fields populated by"]
                            #[doc = r" the server."]
                            pub fn iter_feedback_messages_with_default_fields(
                                self,
                            ) -> crate::iter::PageItemIter<
                                Self,
                                crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackMessage,
                            > {
                                self.iter_feedback_messages_with_fields(None::<String>)
                            }
                            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                            #[doc = r" fields in `#items_type` will be all fields available. This should"]
                            #[doc = r" primarily be used during developement and debugging as fetching"]
                            #[doc = r" all fields can be expensive both in bandwidth and server"]
                            #[doc = r" resources."]
                            pub fn iter_feedback_messages_with_all_fields(
                                self,
                            ) -> crate::iter::PageItemIter<
                                Self,
                                crate::schemas::GoogleCloudDatalabelingV1Beta1FeedbackMessage,
                            > {
                                self.iter_feedback_messages_with_fields(Some("*"))
                            }
                            pub fn iter_feedback_messages_with_fields<T, F>(
                                mut self,
                                fields: Option<F>,
                            ) -> crate::iter::PageItemIter<Self, T>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: AsRef<str>,
                            {
                                self.fields = Some({
                                    let mut selector =
                                        concat!("nextPageToken,", "feedbackMessages").to_owned();
                                    let items_fields =
                                        fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                    if !items_fields.is_empty() {
                                        selector.push_str("(");
                                        selector.push_str(items_fields);
                                        selector.push_str(")");
                                    }
                                    selector
                                });
                                crate::iter::PageItemIter::new(self, "feedbackMessages")
                            }
                            pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.iter_with_fields(fields)
                            }                            pub fn iter_with_default_fields (self) -> crate :: iter :: PageIter < Self , crate :: schemas :: GoogleCloudDatalabelingV1Beta1ListFeedbackMessagesResponse >{
                                self.iter_with_fields(None::<&str>)
                            }                            pub fn iter_with_all_fields (self) -> crate :: iter :: PageIter < Self , crate :: schemas :: GoogleCloudDatalabelingV1Beta1ListFeedbackMessagesResponse >{
                                self.iter_with_fields(Some("*"))
                            }
                            pub fn iter_with_fields<T, F>(
                                mut self,
                                fields: Option<F>,
                            ) -> crate::iter::PageIter<Self, T>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: AsRef<str>,
                            {
                                let mut fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                                if !fields.is_empty() {
                                    match fields.chars().rev().nth(0) {
                                        Some(',') | None => {}
                                        _ => fields.push_str(","),
                                    }
                                    fields.push_str("nextPageToken");
                                    self.fields = Some(fields);
                                }
                                crate::iter::PageIter::new(self)
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields)
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudDatalabelingV1Beta1ListFeedbackMessagesResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudDatalabelingV1Beta1ListFeedbackMessagesResponse , crate :: Error >{
                                self.execute_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub fn execute_with_fields<T, F>(
                                mut self,
                                fields: Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute()
                            }
                            fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path())?;
                                Ok(crate::error_from_response(req.send()?)?.json()?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://datalabeling.googleapis.com/".to_owned();
                                output.push_str("v1beta1/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/feedbackMessages");
                                output
                            }
                            fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("pageSize", &self.page_size)]);
                                req = req.query(&[("pageToken", &self.page_token)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                req = req.bearer_auth(
                                    self.auth
                                        .access_token()
                                        .map_err(|err| crate::Error::OAuth2(err))?,
                                );
                                Ok(req)
                            }
                        }
                        impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                            fn set_page_token(&mut self, value: String) {
                                self.page_token = value.into();
                            }
                            fn execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                self._execute()
                            }
                        }
                    }
                }
            }
            pub mod data_items {
                pub mod params {}
                pub struct DataItemsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> DataItemsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Gets a data item in a dataset by resource name. This API can be called after data are imported into dataset."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Lists data items in a dataset. This API can be called after data are imported into dataset. Pagination is supported."]
                    pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                        ListRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            filter: None,
                            page_size: None,
                            page_token: None,
                        }
                    }
                }
                #[doc = "Created via [DataItemsActions::get()](struct.DataItemsActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem, crate::Error>
                    {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
                #[doc = "Created via [DataItemsActions::list()](struct.DataItemsActions.html#method.list)"]
                #[derive(Debug, Clone)]
                pub struct ListRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    parent: String,
                    filter: Option<String>,
                    page_size: Option<i32>,
                    page_token: Option<String>,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> ListRequestBuilder<'a> {
                    #[doc = "Optional. Filter is not supported at this moment."]
                    pub fn filter(mut self, value: impl Into<String>) -> Self {
                        self.filter = Some(value.into());
                        self
                    }
                    #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListDataItemsResponse.next_page_token of the previous [DataLabelingService.ListDataItems] call. Return first page if empty."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                    #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                    #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                    #[doc = r" populated fields in the yielded items will be determined by the"]
                    #[doc = r" `FieldSelector` implementation."]
                    pub fn iter_data_items<T>(self) -> crate::iter::PageItemIter<Self, T>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.iter_data_items_with_fields(fields)
                    }
                    #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                    #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                    #[doc = r" fields in `#items_type` will be the default fields populated by"]
                    #[doc = r" the server."]
                    pub fn iter_data_items_with_default_fields(
                        self,
                    ) -> crate::iter::PageItemIter<
                        Self,
                        crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem,
                    > {
                        self.iter_data_items_with_fields(None::<String>)
                    }
                    #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                    #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                    #[doc = r" fields in `#items_type` will be all fields available. This should"]
                    #[doc = r" primarily be used during developement and debugging as fetching"]
                    #[doc = r" all fields can be expensive both in bandwidth and server"]
                    #[doc = r" resources."]
                    pub fn iter_data_items_with_all_fields(
                        self,
                    ) -> crate::iter::PageItemIter<
                        Self,
                        crate::schemas::GoogleCloudDatalabelingV1Beta1DataItem,
                    > {
                        self.iter_data_items_with_fields(Some("*"))
                    }
                    pub fn iter_data_items_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> crate::iter::PageItemIter<Self, T>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: AsRef<str>,
                    {
                        self.fields = Some({
                            let mut selector = concat!("nextPageToken,", "dataItems").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::iter::PageItemIter::new(self, "dataItems")
                    }
                    pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.iter_with_fields(fields)
                    }
                    pub fn iter_with_default_fields(
                        self,
                    ) -> crate::iter::PageIter<
                        Self,
                        crate::schemas::GoogleCloudDatalabelingV1Beta1ListDataItemsResponse,
                    > {
                        self.iter_with_fields(None::<&str>)
                    }
                    pub fn iter_with_all_fields(
                        self,
                    ) -> crate::iter::PageIter<
                        Self,
                        crate::schemas::GoogleCloudDatalabelingV1Beta1ListDataItemsResponse,
                    > {
                        self.iter_with_fields(Some("*"))
                    }
                    pub fn iter_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> crate::iter::PageIter<Self, T>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::iter::PageIter::new(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudDatalabelingV1Beta1ListDataItemsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudDatalabelingV1Beta1ListDataItemsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/dataItems");
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("filter", &self.filter)]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
                impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        self._execute()
                    }
                }
            }
            pub mod evaluations {
                pub mod params {}
                pub struct EvaluationsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> EvaluationsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Gets an evaluation by resource name (to search, use projects.evaluations.search)."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Actions that can be performed on the example_comparisons resource"]                    pub fn example_comparisons (& self) -> crate :: resources :: projects :: datasets :: evaluations :: example_comparisons :: ExampleComparisonsActions{
                        crate :: resources :: projects :: datasets :: evaluations :: example_comparisons :: ExampleComparisonsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                }
                #[doc = "Created via [EvaluationsActions::get()](struct.EvaluationsActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudDatalabelingV1Beta1Evaluation,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudDatalabelingV1Beta1Evaluation,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
                pub mod example_comparisons {
                    pub mod params {}
                    pub struct ExampleComparisonsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::blocking::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> ExampleComparisonsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Searches example comparisons from an evaluation. The return format is a list of example comparisons that show ground truth and prediction(s) for a single input. Search by providing an evaluation ID."]
                        pub fn search(
                            &self,
                            request : crate :: schemas :: GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsRequest,
                            parent: impl Into<String>,
                        ) -> SearchRequestBuilder {
                            SearchRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                            }
                        }
                    }
                    #[doc = "Created via [ExampleComparisonsActions::search()](struct.ExampleComparisonsActions.html#method.search)"]
                    #[derive(Debug, Clone)]
                    pub struct SearchRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: blocking :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsRequest , parent : String , access_token : Option < String > , alt : Option < crate :: params :: Alt > , callback : Option < String > , fields : Option < String > , key : Option < String > , oauth_token : Option < String > , pretty_print : Option < bool > , quota_user : Option < String > , upload_protocol : Option < String > , upload_type : Option < String > , xgafv : Option < crate :: params :: Xgafv > , }
                    impl<'a> SearchRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields)
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudDatalabelingV1Beta1SearchExampleComparisonsResponse , crate :: Error >{
                            self.execute_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub fn execute_with_fields<T, F>(
                            mut self,
                            fields: Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute()
                        }
                        fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path())?;
                            let req = req.json(&self.request);
                            Ok(crate::error_from_response(req.send()?)?.json()?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://datalabeling.googleapis.com/".to_owned();
                            output.push_str("v1beta1/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/exampleComparisons:search");
                            output
                        }
                        fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            req = req.bearer_auth(
                                self.auth
                                    .access_token()
                                    .map_err(|err| crate::Error::OAuth2(err))?,
                            );
                            Ok(req)
                        }
                    }
                }
            }
            pub mod image {
                pub mod params {}
                pub struct ImageActions<'a> {
                    pub(crate) reqwest: &'a reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> ImageActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Starts a labeling task for image. The type of image labeling task is configured by feature in the request."]
                    pub fn label(
                        &self,
                        request: crate::schemas::GoogleCloudDatalabelingV1Beta1LabelImageRequest,
                        parent: impl Into<String>,
                    ) -> LabelRequestBuilder {
                        LabelRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                        }
                    }
                }
                #[doc = "Created via [ImageActions::label()](struct.ImageActions.html#method.label)"]
                #[derive(Debug, Clone)]
                pub struct LabelRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::GoogleCloudDatalabelingV1Beta1LabelImageRequest,
                    parent: String,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> LabelRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                    {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        let req = req.json(&self.request);
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/image:label");
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
            }
            pub mod text {
                pub mod params {}
                pub struct TextActions<'a> {
                    pub(crate) reqwest: &'a reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> TextActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Starts a labeling task for text. The type of text labeling task is configured by feature in the request."]
                    pub fn label(
                        &self,
                        request: crate::schemas::GoogleCloudDatalabelingV1Beta1LabelTextRequest,
                        parent: impl Into<String>,
                    ) -> LabelRequestBuilder {
                        LabelRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                        }
                    }
                }
                #[doc = "Created via [TextActions::label()](struct.TextActions.html#method.label)"]
                #[derive(Debug, Clone)]
                pub struct LabelRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::GoogleCloudDatalabelingV1Beta1LabelTextRequest,
                    parent: String,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> LabelRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                    {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        let req = req.json(&self.request);
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/text:label");
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
            }
            pub mod video {
                pub mod params {}
                pub struct VideoActions<'a> {
                    pub(crate) reqwest: &'a reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> VideoActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Starts a labeling task for video. The type of video labeling task is configured by feature in the request."]
                    pub fn label(
                        &self,
                        request: crate::schemas::GoogleCloudDatalabelingV1Beta1LabelVideoRequest,
                        parent: impl Into<String>,
                    ) -> LabelRequestBuilder {
                        LabelRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                        }
                    }
                }
                #[doc = "Created via [VideoActions::label()](struct.VideoActions.html#method.label)"]
                #[derive(Debug, Clone)]
                pub struct LabelRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::GoogleCloudDatalabelingV1Beta1LabelVideoRequest,
                    parent: String,
                    access_token: Option<String>,
                    alt: Option<crate::params::Alt>,
                    callback: Option<String>,
                    fields: Option<String>,
                    key: Option<String>,
                    oauth_token: Option<String>,
                    pretty_print: Option<bool>,
                    quota_user: Option<String>,
                    upload_protocol: Option<String>,
                    upload_type: Option<String>,
                    xgafv: Option<crate::params::Xgafv>,
                }
                impl<'a> LabelRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields)
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                    {
                        self.execute_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub fn execute_with_fields<T, F>(
                        mut self,
                        fields: Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute()
                    }
                    fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path())?;
                        let req = req.json(&self.request);
                        Ok(crate::error_from_response(req.send()?)?.json()?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://datalabeling.googleapis.com/".to_owned();
                        output.push_str("v1beta1/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/video:label");
                        output
                    }
                    fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error>
                    {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        req = req.bearer_auth(
                            self.auth
                                .access_token()
                                .map_err(|err| crate::Error::OAuth2(err))?,
                        );
                        Ok(req)
                    }
                }
            }
        }
        pub mod evaluation_jobs {
            pub mod params {}
            pub struct EvaluationJobsActions<'a> {
                pub(crate) reqwest: &'a reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> EvaluationJobsActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Creates an evaluation job."]
                pub fn create(
                    &self,
                    request : crate :: schemas :: GoogleCloudDatalabelingV1Beta1CreateEvaluationJobRequest,
                    parent: impl Into<String>,
                ) -> CreateRequestBuilder {
                    CreateRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                    }
                }
                #[doc = "Stops and deletes an evaluation job."]
                pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                    DeleteRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Gets an evaluation job by resource name."]
                pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                    GetRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Lists all evaluation jobs within a project with possible filters. Pagination is supported."]
                pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                        filter: None,
                        page_size: None,
                        page_token: None,
                    }
                }
                #[doc = "Updates an evaluation job. You can only update certain fields of the job's EvaluationJobConfig: `humanAnnotationConfig.instruction`, `exampleCount`, and `exampleSamplePercentage`. If you want to change any other aspect of the evaluation job, you must delete the job and create a new one."]
                pub fn patch(
                    &self,
                    request: crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob,
                    name: impl Into<String>,
                ) -> PatchRequestBuilder {
                    PatchRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        update_mask: None,
                    }
                }
                #[doc = "Pauses an evaluation job. Pausing an evaluation job that is already in a `PAUSED` state is a no-op."]
                pub fn pause(
                    &self,
                    request : crate :: schemas :: GoogleCloudDatalabelingV1Beta1PauseEvaluationJobRequest,
                    name: impl Into<String>,
                ) -> PauseRequestBuilder {
                    PauseRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Resumes a paused evaluation job. A deleted evaluation job can't be resumed. Resuming a running or scheduled evaluation job is a no-op."]
                pub fn resume(
                    &self,
                    request : crate :: schemas :: GoogleCloudDatalabelingV1Beta1ResumeEvaluationJobRequest,
                    name: impl Into<String>,
                ) -> ResumeRequestBuilder {
                    ResumeRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
            }
            #[doc = "Created via [EvaluationJobsActions::create()](struct.EvaluationJobsActions.html#method.create)"]
            #[derive(Debug, Clone)]
            pub struct CreateRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::GoogleCloudDatalabelingV1Beta1CreateEvaluationJobRequest,
                parent: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> CreateRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/evaluationJobs");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [EvaluationJobsActions::delete()](struct.EvaluationJobsActions.html#method.delete)"]
            #[derive(Debug, Clone)]
            pub struct DeleteRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> DeleteRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [EvaluationJobsActions::get()](struct.EvaluationJobsActions.html#method.get)"]
            #[derive(Debug, Clone)]
            pub struct GetRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> GetRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [EvaluationJobsActions::list()](struct.EvaluationJobsActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                parent: String,
                filter: Option<String>,
                page_size: Option<i32>,
                page_token: Option<String>,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "Optional. You can filter the jobs to list by model_id (also known as model_name, as described in EvaluationJob.modelVersion) or by evaluation job state (as described in EvaluationJob.state). To filter by both criteria, use the `AND` operator or the `OR` operator. For example, you can use the following string for your filter: \"evaluation_job.model_id = {model_name} AND evaluation_job.state = {evaluation_job_state}\""]
                pub fn filter(mut self, value: impl Into<String>) -> Self {
                    self.filter = Some(value.into());
                    self
                }
                #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by the nextPageToken in the response to the previous request. The request returns the first page if this is empty."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                #[doc = r" populated fields in the yielded items will be determined by the"]
                #[doc = r" `FieldSelector` implementation."]
                pub fn iter_evaluation_jobs<T>(self) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_evaluation_jobs_with_fields(fields)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be the default fields populated by"]
                #[doc = r" the server."]
                pub fn iter_evaluation_jobs_with_default_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob,
                > {
                    self.iter_evaluation_jobs_with_fields(None::<String>)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be all fields available. This should"]
                #[doc = r" primarily be used during developement and debugging as fetching"]
                #[doc = r" all fields can be expensive both in bandwidth and server"]
                #[doc = r" resources."]
                pub fn iter_evaluation_jobs_with_all_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob,
                > {
                    self.iter_evaluation_jobs_with_fields(Some("*"))
                }
                pub fn iter_evaluation_jobs_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    self.fields = Some({
                        let mut selector = concat!("nextPageToken,", "evaluationJobs").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::iter::PageItemIter::new(self, "evaluationJobs")
                }
                pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_with_fields(fields)
                }
                pub fn iter_with_default_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListEvaluationJobsResponse,
                > {
                    self.iter_with_fields(None::<&str>)
                }
                pub fn iter_with_all_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListEvaluationJobsResponse,
                > {
                    self.iter_with_fields(Some("*"))
                }
                pub fn iter_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::iter::PageIter::new(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListEvaluationJobsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListEvaluationJobsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/evaluationJobs");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("filter", &self.filter)]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    self._execute()
                }
            }
            #[doc = "Created via [EvaluationJobsActions::patch()](struct.EvaluationJobsActions.html#method.patch)"]
            #[derive(Debug, Clone)]
            pub struct PatchRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob,
                name: String,
                update_mask: Option<String>,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> PatchRequestBuilder<'a> {
                #[doc = "Optional. Mask for which fields to update. You can only provide the following fields: * `evaluationJobConfig.humanAnnotationConfig.instruction` * `evaluationJobConfig.exampleCount` * `evaluationJobConfig.exampleSamplePercentage` You can provide more than one of these fields by separating them with commas."]
                pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                    self.update_mask = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1EvaluationJob, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                    req = req.query(&[("updateMask", &self.update_mask)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [EvaluationJobsActions::pause()](struct.EvaluationJobsActions.html#method.pause)"]
            #[derive(Debug, Clone)]
            pub struct PauseRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::GoogleCloudDatalabelingV1Beta1PauseEvaluationJobRequest,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> PauseRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str(":pause");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [EvaluationJobsActions::resume()](struct.EvaluationJobsActions.html#method.resume)"]
            #[derive(Debug, Clone)]
            pub struct ResumeRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::GoogleCloudDatalabelingV1Beta1ResumeEvaluationJobRequest,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> ResumeRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str(":resume");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
        }
        pub mod evaluations {
            pub mod params {}
            pub struct EvaluationsActions<'a> {
                pub(crate) reqwest: &'a reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> EvaluationsActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Searches evaluations within a project."]
                pub fn search(&self, parent: impl Into<String>) -> SearchRequestBuilder {
                    SearchRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                        filter: None,
                        page_size: None,
                        page_token: None,
                    }
                }
            }
            #[doc = "Created via [EvaluationsActions::search()](struct.EvaluationsActions.html#method.search)"]
            #[derive(Debug, Clone)]
            pub struct SearchRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                parent: String,
                filter: Option<String>,
                page_size: Option<i32>,
                page_token: Option<String>,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> SearchRequestBuilder<'a> {
                #[doc = "Optional. To search evaluations, you can filter by the following: * evaluation_job.evaluation_job_id (the last part of EvaluationJob.name) * evaluation_job.model_id (the {model_name} portion of EvaluationJob.modelVersion) * evaluation_job.evaluation_job_run_time_start (Minimum threshold for the evaluationJobRunTime that created the evaluation) * evaluation_job.evaluation_job_run_time_end (Maximum threshold for the evaluationJobRunTime that created the evaluation) * evaluation_job.job_state (EvaluationJob.state) * annotation_spec.display_name (the Evaluation contains a metric for the annotation spec with this displayName) To filter by multiple critiera, use the `AND` operator or the `OR` operator. The following examples shows a string that filters by several critiera: \"evaluation_job.evaluation_job_id = {evaluation_job_id} AND evaluation_job.model_id = {model_name} AND evaluation_job.evaluation_job_run_time_start = {timestamp_1} AND evaluation_job.evaluation_job_run_time_end = {timestamp_2} AND annotation_spec.display_name = {display_name}\""]
                pub fn filter(mut self, value: impl Into<String>) -> Self {
                    self.filter = Some(value.into());
                    self
                }
                #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by the nextPageToken of the response to a previous search request. If you don't specify this field, the API call requests the first page of the search."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                #[doc = r" populated fields in the yielded items will be determined by the"]
                #[doc = r" `FieldSelector` implementation."]
                pub fn iter_evaluations<T>(self) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_evaluations_with_fields(fields)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be the default fields populated by"]
                #[doc = r" the server."]
                pub fn iter_evaluations_with_default_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1Evaluation,
                > {
                    self.iter_evaluations_with_fields(None::<String>)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be all fields available. This should"]
                #[doc = r" primarily be used during developement and debugging as fetching"]
                #[doc = r" all fields can be expensive both in bandwidth and server"]
                #[doc = r" resources."]
                pub fn iter_evaluations_with_all_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1Evaluation,
                > {
                    self.iter_evaluations_with_fields(Some("*"))
                }
                pub fn iter_evaluations_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    self.fields = Some({
                        let mut selector = concat!("nextPageToken,", "evaluations").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::iter::PageItemIter::new(self, "evaluations")
                }
                pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_with_fields(fields)
                }
                pub fn iter_with_default_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1SearchEvaluationsResponse,
                > {
                    self.iter_with_fields(None::<&str>)
                }
                pub fn iter_with_all_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1SearchEvaluationsResponse,
                > {
                    self.iter_with_fields(Some("*"))
                }
                pub fn iter_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::iter::PageIter::new(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1SearchEvaluationsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1SearchEvaluationsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/evaluations:search");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("filter", &self.filter)]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            impl<'a> crate::iter::IterableMethod for SearchRequestBuilder<'a> {
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    self._execute()
                }
            }
        }
        pub mod instructions {
            pub mod params {}
            pub struct InstructionsActions<'a> {
                pub(crate) reqwest: &'a reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> InstructionsActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Creates an instruction for how data should be labeled."]
                pub fn create(
                    &self,
                    request: crate::schemas::GoogleCloudDatalabelingV1Beta1CreateInstructionRequest,
                    parent: impl Into<String>,
                ) -> CreateRequestBuilder {
                    CreateRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                    }
                }
                #[doc = "Deletes an instruction object by resource name."]
                pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                    DeleteRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Gets an instruction by resource name."]
                pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                    GetRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Lists instructions for a project. Pagination is supported."]
                pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        parent: parent.into(),
                        filter: None,
                        page_size: None,
                        page_token: None,
                    }
                }
            }
            #[doc = "Created via [InstructionsActions::create()](struct.InstructionsActions.html#method.create)"]
            #[derive(Debug, Clone)]
            pub struct CreateRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::GoogleCloudDatalabelingV1Beta1CreateInstructionRequest,
                parent: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> CreateRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    let req = req.json(&self.request);
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/instructions");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [InstructionsActions::delete()](struct.InstructionsActions.html#method.delete)"]
            #[derive(Debug, Clone)]
            pub struct DeleteRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> DeleteRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [InstructionsActions::get()](struct.InstructionsActions.html#method.get)"]
            #[derive(Debug, Clone)]
            pub struct GetRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> GetRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1Instruction, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleCloudDatalabelingV1Beta1Instruction, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [InstructionsActions::list()](struct.InstructionsActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                parent: String,
                filter: Option<String>,
                page_size: Option<i32>,
                page_token: Option<String>,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "Optional. Filter is not supported at this moment."]
                pub fn filter(mut self, value: impl Into<String>) -> Self {
                    self.filter = Some(value.into());
                    self
                }
                #[doc = "Optional. Requested page size. Server may return fewer results than requested. Default value is 100."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "Optional. A token identifying a page of results for the server to return. Typically obtained by ListInstructionsResponse.next_page_token of the previous [DataLabelingService.ListInstructions] call. Return first page if empty."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                #[doc = r" populated fields in the yielded items will be determined by the"]
                #[doc = r" `FieldSelector` implementation."]
                pub fn iter_instructions<T>(self) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_instructions_with_fields(fields)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be the default fields populated by"]
                #[doc = r" the server."]
                pub fn iter_instructions_with_default_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1Instruction,
                > {
                    self.iter_instructions_with_fields(None::<String>)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be all fields available. This should"]
                #[doc = r" primarily be used during developement and debugging as fetching"]
                #[doc = r" all fields can be expensive both in bandwidth and server"]
                #[doc = r" resources."]
                pub fn iter_instructions_with_all_fields(
                    self,
                ) -> crate::iter::PageItemIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1Instruction,
                > {
                    self.iter_instructions_with_fields(Some("*"))
                }
                pub fn iter_instructions_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    self.fields = Some({
                        let mut selector = concat!("nextPageToken,", "instructions").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::iter::PageItemIter::new(self, "instructions")
                }
                pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_with_fields(fields)
                }
                pub fn iter_with_default_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListInstructionsResponse,
                > {
                    self.iter_with_fields(None::<&str>)
                }
                pub fn iter_with_all_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListInstructionsResponse,
                > {
                    self.iter_with_fields(Some("*"))
                }
                pub fn iter_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::iter::PageIter::new(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListInstructionsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<
                    crate::schemas::GoogleCloudDatalabelingV1Beta1ListInstructionsResponse,
                    crate::Error,
                > {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.parent;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/instructions");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("filter", &self.filter)]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    self._execute()
                }
            }
        }
        pub mod operations {
            pub mod params {}
            pub struct OperationsActions<'a> {
                pub(crate) reqwest: &'a reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> OperationsActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`."]
                pub fn cancel(&self, name: impl Into<String>) -> CancelRequestBuilder {
                    CancelRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Deletes a long-running operation. This method indicates that the client is no longer interested in the operation result. It does not cancel the operation. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`."]
                pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                    DeleteRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service."]
                pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                    GetRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`. NOTE: the `name` binding allows API services to override the binding to use different resource name schemes, such as `users/*/operations`. To override the binding, API services can add a binding such as `\"/v1/{name=users/*}/operations\"` to their service configuration. For backwards compatibility, the default name includes the operations collection id, however overriding users must ensure the name binding is the parent resource, without the operations collection id."]
                pub fn list(&self, name: impl Into<String>) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        filter: None,
                        page_size: None,
                        page_token: None,
                    }
                }
            }
            #[doc = "Created via [OperationsActions::cancel()](struct.OperationsActions.html#method.cancel)"]
            #[derive(Debug, Clone)]
            pub struct CancelRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> CancelRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str(":cancel");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [OperationsActions::delete()](struct.OperationsActions.html#method.delete)"]
            #[derive(Debug, Clone)]
            pub struct DeleteRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> DeleteRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error> {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [OperationsActions::get()](struct.OperationsActions.html#method.get)"]
            #[derive(Debug, Clone)]
            pub struct GetRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> GetRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningOperation, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            #[doc = "Created via [OperationsActions::list()](struct.OperationsActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::blocking::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                filter: Option<String>,
                page_size: Option<i32>,
                page_token: Option<String>,
                access_token: Option<String>,
                alt: Option<crate::params::Alt>,
                callback: Option<String>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                upload_protocol: Option<String>,
                upload_type: Option<String>,
                xgafv: Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "The standard list filter."]
                pub fn filter(mut self, value: impl Into<String>) -> Self {
                    self.filter = Some(value.into());
                    self
                }
                #[doc = "The standard list page size."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "The standard list page token."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are chosen by the caller of this"]
                #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
                #[doc = r" populated fields in the yielded items will be determined by the"]
                #[doc = r" `FieldSelector` implementation."]
                pub fn iter_operations<T>(self) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_operations_with_fields(fields)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be the default fields populated by"]
                #[doc = r" the server."]
                pub fn iter_operations_with_default_fields(
                    self,
                ) -> crate::iter::PageItemIter<Self, crate::schemas::GoogleLongrunningOperation>
                {
                    self.iter_operations_with_fields(None::<String>)
                }
                #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
                #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
                #[doc = r" fields in `#items_type` will be all fields available. This should"]
                #[doc = r" primarily be used during developement and debugging as fetching"]
                #[doc = r" all fields can be expensive both in bandwidth and server"]
                #[doc = r" resources."]
                pub fn iter_operations_with_all_fields(
                    self,
                ) -> crate::iter::PageItemIter<Self, crate::schemas::GoogleLongrunningOperation>
                {
                    self.iter_operations_with_fields(Some("*"))
                }
                pub fn iter_operations_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageItemIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    self.fields = Some({
                        let mut selector = concat!("nextPageToken,", "operations").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::iter::PageItemIter::new(self, "operations")
                }
                pub fn iter<T>(self) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.iter_with_fields(fields)
                }
                pub fn iter_with_default_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleLongrunningListOperationsResponse,
                > {
                    self.iter_with_fields(None::<&str>)
                }
                pub fn iter_with_all_fields(
                    self,
                ) -> crate::iter::PageIter<
                    Self,
                    crate::schemas::GoogleLongrunningListOperationsResponse,
                > {
                    self.iter_with_fields(Some("*"))
                }
                pub fn iter_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> crate::iter::PageIter<Self, T>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::iter::PageIter::new(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningListOperationsResponse, crate::Error>
                {
                    self.execute_with_fields(None::<&str>)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GoogleLongrunningListOperationsResponse, crate::Error>
                {
                    self.execute_with_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_with_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path())?;
                    Ok(crate::error_from_response(req.send()?)?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://datalabeling.googleapis.com/".to_owned();
                    output.push_str("v1beta1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/operations");
                    output
                }
                fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::blocking::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("filter", &self.filter)]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    req = req.bearer_auth(
                        self.auth
                            .access_token()
                            .map_err(|err| crate::Error::OAuth2(err))?,
                    );
                    Ok(req)
                }
            }
            impl<'a> crate::iter::IterableMethod for ListRequestBuilder<'a> {
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    self._execute()
                }
            }
        }
    }
}
#[derive(Debug)]
pub enum Error {
    OAuth2(Box<dyn ::std::error::Error + Send + Sync>),
    JSON(::serde_json::Error),
    Reqwest {
        reqwest_err: ::reqwest::Error,
        body: Option<String>,
    },
    Other(Box<dyn ::std::error::Error + Send + Sync>),
}

impl Error {
    pub fn json_error(&self) -> Option<&::serde_json::Error> {
        match self {
            Error::OAuth2(_) => None,
            Error::JSON(err) => Some(err),
            Error::Reqwest { .. } => None,
            Error::Other(_) => None,
        }
    }
}

impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            Error::OAuth2(err) => write!(f, "OAuth2 Error: {}", err),
            Error::JSON(err) => write!(f, "JSON Error: {}", err),
            Error::Reqwest { reqwest_err, body } => {
                write!(f, "Reqwest Error: {}", reqwest_err)?;
                if let Some(body) = body {
                    write!(f, ": {}", body)?;
                }
                Ok(())
            }
            Error::Other(err) => write!(f, "Uknown Error: {}", err),
        }
    }
}

impl ::std::error::Error for Error {}

impl From<::serde_json::Error> for Error {
    fn from(err: ::serde_json::Error) -> Error {
        Error::JSON(err)
    }
}

impl From<::reqwest::Error> for Error {
    fn from(reqwest_err: ::reqwest::Error) -> Error {
        Error::Reqwest {
            reqwest_err,
            body: None,
        }
    }
}

/// Check the response to see if the status code represents an error. If so
/// convert it into the Reqwest variant of Error.
fn error_from_response(
    response: ::reqwest::blocking::Response,
) -> Result<::reqwest::blocking::Response, Error> {
    match response.error_for_status_ref() {
        Err(reqwest_err) => {
            let body = response.text().ok();
            Err(Error::Reqwest { reqwest_err, body })
        }
        Ok(_) => Ok(response),
    }
}
#[allow(dead_code)]
const SIMPLE: &::percent_encoding::AsciiSet = &::percent_encoding::NON_ALPHANUMERIC
    .remove(b'-')
    .remove(b'.')
    .remove(b'_')
    .remove(b'~');

#[allow(dead_code)]
const RESERVED: &::percent_encoding::AsciiSet = &SIMPLE
    .remove(b'%')
    .remove(b':')
    .remove(b'/')
    .remove(b'?')
    .remove(b'#')
    .remove(b'[')
    .remove(b']')
    .remove(b'@')
    .remove(b'!')
    .remove(b'$')
    .remove(b'&')
    .remove(b'\'')
    .remove(b'(')
    .remove(b')')
    .remove(b'*')
    .remove(b'+')
    .remove(b',')
    .remove(b';')
    .remove(b'=');
#[allow(dead_code)]
mod multipart {
    pub(crate) struct RelatedMultiPart {
        parts: Vec<Part>,
        boundary: String,
    }

    impl RelatedMultiPart {
        pub(crate) fn new() -> Self {
            RelatedMultiPart {
                parts: Vec::new(),
                boundary: ::textnonce::TextNonce::sized(68).unwrap().0,
            }
        }

        pub(crate) fn new_part(&mut self, part: Part) {
            self.parts.push(part);
        }

        pub(crate) fn boundary(&self) -> &str {
            &self.boundary
        }

        pub(crate) fn into_reader(self) -> RelatedMultiPartReader {
            let boundary_marker = boundary_marker(&self.boundary);
            RelatedMultiPartReader {
                state: RelatedMultiPartReaderState::WriteBoundary {
                    start: 0,
                    boundary: format!("{}\r\n", &boundary_marker),
                },
                boundary: boundary_marker,
                next_body: None,
                parts: self.parts.into_iter(),
            }
        }
    }

    pub(crate) struct Part {
        content_type: ::mime::Mime,
        body: Box<dyn ::std::io::Read + Send>,
    }

    impl Part {
        pub(crate) fn new(
            content_type: ::mime::Mime,
            body: Box<dyn ::std::io::Read + Send>,
        ) -> Part {
            Part { content_type, body }
        }
    }

    pub(crate) struct RelatedMultiPartReader {
        state: RelatedMultiPartReaderState,
        boundary: String,
        next_body: Option<Box<dyn ::std::io::Read + Send>>,
        parts: std::vec::IntoIter<Part>,
    }

    enum RelatedMultiPartReaderState {
        WriteBoundary {
            start: usize,
            boundary: String,
        },
        WriteContentType {
            start: usize,
            content_type: Vec<u8>,
        },
        WriteBody {
            body: Box<dyn ::std::io::Read + Send>,
        },
    }

    impl ::std::io::Read for RelatedMultiPartReader {
        fn read(&mut self, buf: &mut [u8]) -> ::std::io::Result<usize> {
            use RelatedMultiPartReaderState::*;
            let mut bytes_written: usize = 0;
            loop {
                let rem_buf = &mut buf[bytes_written..];
                match &mut self.state {
                    WriteBoundary { start, boundary } => {
                        let bytes_to_copy = std::cmp::min(boundary.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&boundary.as_bytes()[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == boundary.len() {
                            let next_part = match self.parts.next() {
                                None => break,
                                Some(part) => part,
                            };
                            self.next_body = Some(next_part.body);
                            self.state = WriteContentType {
                                start: 0,
                                content_type: format!(
                                    "Content-Type: {}\r\n\r\n",
                                    next_part.content_type
                                )
                                .into_bytes(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteContentType {
                        start,
                        content_type,
                    } => {
                        let bytes_to_copy =
                            std::cmp::min(content_type.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&content_type[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == content_type.len() {
                            self.state = WriteBody {
                                body: self.next_body.take().unwrap(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteBody { body } => {
                        let written = body.read(rem_buf)?;
                        bytes_written += written;
                        if written == 0 {
                            self.state = WriteBoundary {
                                start: 0,
                                boundary: format!("\r\n{}\r\n", &self.boundary),
                            };
                        } else {
                            break;
                        }
                    }
                }
            }
            Ok(bytes_written)
        }
    }

    fn boundary_marker(boundary: &str) -> String {
        let mut marker = String::with_capacity(boundary.len() + 2);
        marker.push_str("--");
        marker.push_str(boundary);
        marker
    }
}
// A serde helper module that can be used with the `with` attribute
// to deserialize any string to a FromStr type and serialize any
// Display type to a String. Google API's encode i64, u64 values as
// strings.
#[allow(dead_code)]
mod parsed_string {
    pub fn serialize<T, S>(
        value: &Option<T>,
        serializer: S,
    ) -> ::std::result::Result<S::Ok, S::Error>
    where
        T: ::std::fmt::Display,
        S: ::serde::Serializer,
    {
        use ::serde::Serialize;
        value.as_ref().map(|x| x.to_string()).serialize(serializer)
    }

    pub fn deserialize<'de, T, D>(deserializer: D) -> ::std::result::Result<Option<T>, D::Error>
    where
        T: ::std::str::FromStr,
        T::Err: ::std::fmt::Display,
        D: ::serde::de::Deserializer<'de>,
    {
        use ::serde::Deserialize;
        match Option::<String>::deserialize(deserializer)? {
            Some(x) => Ok(Some(x.parse().map_err(::serde::de::Error::custom)?)),
            None => Ok(None),
        }
    }
}
pub mod iter {
    pub trait IterableMethod {
        fn set_page_token(&mut self, value: String);
        fn execute<T>(&mut self) -> Result<T, crate::Error>
        where
            T: ::serde::de::DeserializeOwned;
    }

    pub struct PageIter<M, T> {
        pub method: M,
        pub finished: bool,
        pub _phantom: ::std::marker::PhantomData<T>,
    }

    impl<M, T> PageIter<M, T>
    where
        M: IterableMethod,
        T: ::serde::de::DeserializeOwned,
    {
        pub(crate) fn new(method: M) -> Self {
            PageIter {
                method,
                finished: false,
                _phantom: ::std::marker::PhantomData,
            }
        }
    }

    impl<M, T> Iterator for PageIter<M, T>
    where
        M: IterableMethod,
        T: ::serde::de::DeserializeOwned,
    {
        type Item = Result<T, crate::Error>;

        fn next(&mut self) -> Option<Result<T, crate::Error>> {
            if self.finished {
                return None;
            }
            let paginated_result: ::serde_json::Map<String, ::serde_json::Value> =
                match self.method.execute() {
                    Ok(r) => r,
                    Err(err) => return Some(Err(err)),
                };
            if let Some(next_page_token) = paginated_result
                .get("nextPageToken")
                .and_then(|t| t.as_str())
            {
                self.method.set_page_token(next_page_token.to_owned());
            } else {
                self.finished = true;
            }

            Some(
                match ::serde_json::from_value(::serde_json::Value::Object(paginated_result)) {
                    Ok(resp) => Ok(resp),
                    Err(err) => Err(err.into()),
                },
            )
        }
    }

    pub struct PageItemIter<M, T> {
        items_field: &'static str,
        page_iter: PageIter<M, ::serde_json::Map<String, ::serde_json::Value>>,
        items: ::std::vec::IntoIter<T>,
    }

    impl<M, T> PageItemIter<M, T>
    where
        M: IterableMethod,
        T: ::serde::de::DeserializeOwned,
    {
        pub(crate) fn new(method: M, items_field: &'static str) -> Self {
            PageItemIter {
                items_field,
                page_iter: PageIter::new(method),
                items: Vec::new().into_iter(),
            }
        }
    }

    impl<M, T> Iterator for PageItemIter<M, T>
    where
        M: IterableMethod,
        T: ::serde::de::DeserializeOwned,
    {
        type Item = Result<T, crate::Error>;

        fn next(&mut self) -> Option<Result<T, crate::Error>> {
            loop {
                if let Some(v) = self.items.next() {
                    return Some(Ok(v));
                }

                let next_page = self.page_iter.next();
                match next_page {
                    None => return None,
                    Some(Err(err)) => return Some(Err(err)),
                    Some(Ok(next_page)) => {
                        let mut next_page: ::serde_json::Map<String, ::serde_json::Value> =
                            next_page;
                        let items_array = match next_page.remove(self.items_field) {
                            Some(items) => items,
                            None => {
                                return Some(Err(crate::Error::Other(
                                    format!("no {} field found in iter response", self.items_field)
                                        .into(),
                                )))
                            }
                        };
                        let items_vec: Result<Vec<T>, _> = ::serde_json::from_value(items_array);
                        match items_vec {
                            Ok(items) => self.items = items.into_iter(),
                            Err(err) => return Some(Err(err.into())),
                        }
                    }
                }
            }
        }
    }
}
