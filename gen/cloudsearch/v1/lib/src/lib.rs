#![allow(rustdoc::bare_urls)]
#![doc = "# Resources and Methods\n* [debug](resources/debug/struct.DebugActions.html)\n  * [datasources](resources/debug/datasources/struct.DatasourcesActions.html)\n    * [items](resources/debug/datasources/items/struct.ItemsActions.html)\n      * [*checkAccess*](resources/debug/datasources/items/struct.CheckAccessRequestBuilder.html), [*searchByViewUrl*](resources/debug/datasources/items/struct.SearchByViewUrlRequestBuilder.html)\n      * [unmappedids](resources/debug/datasources/items/unmappedids/struct.UnmappedidsActions.html)\n        * [*list*](resources/debug/datasources/items/unmappedids/struct.ListRequestBuilder.html)\n  * [identitysources](resources/debug/identitysources/struct.IdentitysourcesActions.html)\n    * [items](resources/debug/identitysources/items/struct.ItemsActions.html)\n      * [*listForunmappedidentity*](resources/debug/identitysources/items/struct.ListForunmappedidentityRequestBuilder.html)\n    * [unmappedids](resources/debug/identitysources/unmappedids/struct.UnmappedidsActions.html)\n      * [*list*](resources/debug/identitysources/unmappedids/struct.ListRequestBuilder.html)\n* [indexing](resources/indexing/struct.IndexingActions.html)\n  * [datasources](resources/indexing/datasources/struct.DatasourcesActions.html)\n    * [*deleteSchema*](resources/indexing/datasources/struct.DeleteSchemaRequestBuilder.html), [*getSchema*](resources/indexing/datasources/struct.GetSchemaRequestBuilder.html), [*updateSchema*](resources/indexing/datasources/struct.UpdateSchemaRequestBuilder.html)\n    * [items](resources/indexing/datasources/items/struct.ItemsActions.html)\n      * [*delete*](resources/indexing/datasources/items/struct.DeleteRequestBuilder.html), [*deleteQueueItems*](resources/indexing/datasources/items/struct.DeleteQueueItemsRequestBuilder.html), [*get*](resources/indexing/datasources/items/struct.GetRequestBuilder.html), [*index*](resources/indexing/datasources/items/struct.IndexRequestBuilder.html), [*list*](resources/indexing/datasources/items/struct.ListRequestBuilder.html), [*poll*](resources/indexing/datasources/items/struct.PollRequestBuilder.html), [*push*](resources/indexing/datasources/items/struct.PushRequestBuilder.html), [*unreserve*](resources/indexing/datasources/items/struct.UnreserveRequestBuilder.html), [*upload*](resources/indexing/datasources/items/struct.UploadRequestBuilder.html)\n* [media](resources/media/struct.MediaActions.html)\n  * [*upload*](resources/media/struct.UploadRequestBuilder.html)\n* [operations](resources/operations/struct.OperationsActions.html)\n  * [*get*](resources/operations/struct.GetRequestBuilder.html)\n  * [lro](resources/operations/lro/struct.LroActions.html)\n    * [*list*](resources/operations/lro/struct.ListRequestBuilder.html)\n* [query](resources/query/struct.QueryActions.html)\n  * [*search*](resources/query/struct.SearchRequestBuilder.html), [*suggest*](resources/query/struct.SuggestRequestBuilder.html)\n  * [sources](resources/query/sources/struct.SourcesActions.html)\n    * [*list*](resources/query/sources/struct.ListRequestBuilder.html)\n* [settings](resources/settings/struct.SettingsActions.html)\n  * [*getCustomer*](resources/settings/struct.GetCustomerRequestBuilder.html), [*updateCustomer*](resources/settings/struct.UpdateCustomerRequestBuilder.html)\n  * [datasources](resources/settings/datasources/struct.DatasourcesActions.html)\n    * [*create*](resources/settings/datasources/struct.CreateRequestBuilder.html), [*delete*](resources/settings/datasources/struct.DeleteRequestBuilder.html), [*get*](resources/settings/datasources/struct.GetRequestBuilder.html), [*list*](resources/settings/datasources/struct.ListRequestBuilder.html), [*patch*](resources/settings/datasources/struct.PatchRequestBuilder.html), [*update*](resources/settings/datasources/struct.UpdateRequestBuilder.html)\n  * [searchapplications](resources/settings/searchapplications/struct.SearchapplicationsActions.html)\n    * [*create*](resources/settings/searchapplications/struct.CreateRequestBuilder.html), [*delete*](resources/settings/searchapplications/struct.DeleteRequestBuilder.html), [*get*](resources/settings/searchapplications/struct.GetRequestBuilder.html), [*list*](resources/settings/searchapplications/struct.ListRequestBuilder.html), [*patch*](resources/settings/searchapplications/struct.PatchRequestBuilder.html), [*reset*](resources/settings/searchapplications/struct.ResetRequestBuilder.html), [*update*](resources/settings/searchapplications/struct.UpdateRequestBuilder.html)\n* [stats](resources/stats/struct.StatsActions.html)\n  * [*getIndex*](resources/stats/struct.GetIndexRequestBuilder.html), [*getQuery*](resources/stats/struct.GetQueryRequestBuilder.html), [*getSearchapplication*](resources/stats/struct.GetSearchapplicationRequestBuilder.html), [*getSession*](resources/stats/struct.GetSessionRequestBuilder.html), [*getUser*](resources/stats/struct.GetUserRequestBuilder.html)\n  * [index](resources/stats/index/struct.IndexActions.html)\n    * [datasources](resources/stats/index/datasources/struct.DatasourcesActions.html)\n      * [*get*](resources/stats/index/datasources/struct.GetRequestBuilder.html)\n  * [query](resources/stats/query/struct.QueryActions.html)\n    * [searchapplications](resources/stats/query/searchapplications/struct.SearchapplicationsActions.html)\n      * [*get*](resources/stats/query/searchapplications/struct.GetRequestBuilder.html)\n  * [session](resources/stats/session/struct.SessionActions.html)\n    * [searchapplications](resources/stats/session/searchapplications/struct.SearchapplicationsActions.html)\n      * [*get*](resources/stats/session/searchapplications/struct.GetRequestBuilder.html)\n  * [user](resources/stats/user/struct.UserActions.html)\n    * [searchapplications](resources/stats/user/searchapplications/struct.SearchapplicationsActions.html)\n      * [*get*](resources/stats/user/searchapplications/struct.GetRequestBuilder.html)\n* [v_1](resources/v_1/struct.V1Actions.html)\n  * [*initializeCustomer*](resources/v_1/struct.InitializeCustomerRequestBuilder.html)\n"]
pub mod scopes {
    #[doc = "Index and serve your organization's data with Cloud Search\n\n`https://www.googleapis.com/auth/cloud_search`"]
    pub const CLOUD_SEARCH: &str = "https://www.googleapis.com/auth/cloud_search";
    #[doc = "Index and serve your organization's data with Cloud Search\n\n`https://www.googleapis.com/auth/cloud_search.debug`"]
    pub const CLOUD_SEARCH_DEBUG: &str = "https://www.googleapis.com/auth/cloud_search.debug";
    #[doc = "Index and serve your organization's data with Cloud Search\n\n`https://www.googleapis.com/auth/cloud_search.indexing`"]
    pub const CLOUD_SEARCH_INDEXING: &str = "https://www.googleapis.com/auth/cloud_search.indexing";
    #[doc = "Search your organization's data in the Cloud Search index\n\n`https://www.googleapis.com/auth/cloud_search.query`"]
    pub const CLOUD_SEARCH_QUERY: &str = "https://www.googleapis.com/auth/cloud_search.query";
    #[doc = "Index and serve your organization's data with Cloud Search\n\n`https://www.googleapis.com/auth/cloud_search.settings`"]
    pub const CLOUD_SEARCH_SETTINGS: &str = "https://www.googleapis.com/auth/cloud_search.settings";
    #[doc = "Index and serve your organization's data with Cloud Search\n\n`https://www.googleapis.com/auth/cloud_search.settings.indexing`"]
    pub const CLOUD_SEARCH_SETTINGS_INDEXING: &str =
        "https://www.googleapis.com/auth/cloud_search.settings.indexing";
    #[doc = "Index and serve your organization's data with Cloud Search\n\n`https://www.googleapis.com/auth/cloud_search.settings.query`"]
    pub const CLOUD_SEARCH_SETTINGS_QUERY: &str =
        "https://www.googleapis.com/auth/cloud_search.settings.query";
    #[doc = "Index and serve your organization's data with Cloud Search\n\n`https://www.googleapis.com/auth/cloud_search.stats`"]
    pub const CLOUD_SEARCH_STATS: &str = "https://www.googleapis.com/auth/cloud_search.stats";
    #[doc = "Index and serve your organization's data with Cloud Search\n\n`https://www.googleapis.com/auth/cloud_search.stats.indexing`"]
    pub const CLOUD_SEARCH_STATS_INDEXING: &str =
        "https://www.googleapis.com/auth/cloud_search.stats.indexing";
}
pub mod schemas {
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AbuseReportingConfig {
        #[doc = "Whether the current call may include video recordings in its abuse reports."]
        #[serde(
            rename = "recordingAllowed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recording_allowed: ::std::option::Option<bool>,
        #[doc = "Whether the current call may include user generated content (chat, polls, Q&A…) in its abuse reports."]
        #[serde(
            rename = "writtenUgcAllowed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub written_ugc_allowed: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for AbuseReportingConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AbuseReportingConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AckInfo {
        #[doc = "Output only. Number of meeting devices that have not acked yet."]
        #[serde(
            rename = "unackedDeviceCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub unacked_device_count: ::std::option::Option<i32>,
        #[doc = "Output only. IDs of meeting devices (at most ten are provided) that have not acked yet."]
        #[serde(
            rename = "unackedDeviceIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub unacked_device_ids: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for AckInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AckInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AclFixRequest {
        #[doc = "For Spaces messages: This field is ignored. For DMs messages: The list of email addresses that should be added to the Drive item’s ACL. In general, the list should not be empty when the boolean “should_fix” field is set; otherwise, the list should be empty. During transition - when clients do not specify this field but the “should_fix” is true, we follow the legacy behavior: share to all users in the DM regardless of emails. This behavior is being phased out."]
        #[serde(
            rename = "recipientEmails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recipient_emails: ::std::option::Option<Vec<String>>,
        #[serde(
            rename = "role",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub role: ::std::option::Option<crate::schemas::AclFixRequestRole>,
        #[doc = "Whether to attempt to fix the ACL by adding the room or DM members to the Drive file’s ACL."]
        #[serde(
            rename = "shouldFix",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub should_fix: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for AclFixRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AclFixRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AclFixRequestRole {
        Commenter,
        Reader,
        Unknown,
        Writer,
    }
    impl AclFixRequestRole {
        pub fn as_str(self) -> &'static str {
            match self {
                AclFixRequestRole::Commenter => "COMMENTER",
                AclFixRequestRole::Reader => "READER",
                AclFixRequestRole::Unknown => "UNKNOWN",
                AclFixRequestRole::Writer => "WRITER",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AclFixRequestRole {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AclFixRequestRole {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AclFixRequestRole, ()> {
            Ok(match s {
                "COMMENTER" => AclFixRequestRole::Commenter,
                "READER" => AclFixRequestRole::Reader,
                "UNKNOWN" => AclFixRequestRole::Unknown,
                "WRITER" => AclFixRequestRole::Writer,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AclFixRequestRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AclFixRequestRole {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AclFixRequestRole {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "COMMENTER" => AclFixRequestRole::Commenter,
                "READER" => AclFixRequestRole::Reader,
                "UNKNOWN" => AclFixRequestRole::Unknown,
                "WRITER" => AclFixRequestRole::Writer,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AclFixRequestRole {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AclFixRequestRole {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AclFixStatus {
        #[serde(
            rename = "fixability",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fixability: ::std::option::Option<crate::schemas::AclFixStatusFixability>,
        #[doc = "List of recipient email addresses for which access can be granted. This field contains the same email addresses from the GetMessagePreviewMetadata request if all recipients can be successfully added to the ACL as determined by Drive ACL Fixer. For now, the field is non-empty if and only if the “fixability” value is “CAN_FIX”."]
        #[serde(
            rename = "fixableEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fixable_email_address: ::std::option::Option<Vec<String>>,
        #[doc = "List of recipient email addresses for which an out-of-domain-sharing warning must be shown, stating that these email addresses are not in the Google Apps organization that the requested item belong to. Empty if all recipients are in the same Google Apps organization."]
        #[serde(
            rename = "outOfDomainWarningEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub out_of_domain_warning_email_address: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for AclFixStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AclFixStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AclFixStatusFixability {
        AclFixerError,
        AlreadyAccessible,
        CanFix,
        CannotFix,
        Unknown,
    }
    impl AclFixStatusFixability {
        pub fn as_str(self) -> &'static str {
            match self {
                AclFixStatusFixability::AclFixerError => "ACL_FIXER_ERROR",
                AclFixStatusFixability::AlreadyAccessible => "ALREADY_ACCESSIBLE",
                AclFixStatusFixability::CanFix => "CAN_FIX",
                AclFixStatusFixability::CannotFix => "CANNOT_FIX",
                AclFixStatusFixability::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AclFixStatusFixability {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AclFixStatusFixability {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AclFixStatusFixability, ()> {
            Ok(match s {
                "ACL_FIXER_ERROR" => AclFixStatusFixability::AclFixerError,
                "ALREADY_ACCESSIBLE" => AclFixStatusFixability::AlreadyAccessible,
                "CAN_FIX" => AclFixStatusFixability::CanFix,
                "CANNOT_FIX" => AclFixStatusFixability::CannotFix,
                "UNKNOWN" => AclFixStatusFixability::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AclFixStatusFixability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AclFixStatusFixability {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AclFixStatusFixability {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACL_FIXER_ERROR" => AclFixStatusFixability::AclFixerError,
                "ALREADY_ACCESSIBLE" => AclFixStatusFixability::AlreadyAccessible,
                "CAN_FIX" => AclFixStatusFixability::CanFix,
                "CANNOT_FIX" => AclFixStatusFixability::CannotFix,
                "UNKNOWN" => AclFixStatusFixability::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AclFixStatusFixability {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AclFixStatusFixability {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AclInfo {
        #[doc = "Number of groups which have at least read access to the document."]
        #[serde(
            rename = "groupsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub groups_count: ::std::option::Option<i32>,
        #[doc = "The scope to which the content was shared."]
        #[serde(
            rename = "scope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scope: ::std::option::Option<crate::schemas::AclInfoScope>,
        #[doc = "Number of users which have at least read access to the document."]
        #[serde(
            rename = "usersCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub users_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for AclInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AclInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AclInfoScope {
        #[doc = "Now it works only for google.com. Anybody at the same domain. Now it works only"]
        DasherDomain,
        #[doc = "Anybody at the same domain with the link."]
        DasherDomainWithLink,
        #[doc = "Explicit set of people and groups."]
        Limited,
        #[doc = "Anybody."]
        Public,
        #[doc = "for google.com. Anybody with the link."]
        PublicWithLink,
        #[doc = "Special tag to indicate TeamDrive scope."]
        TeamDrive,
    }
    impl AclInfoScope {
        pub fn as_str(self) -> &'static str {
            match self {
                AclInfoScope::DasherDomain => "DASHER_DOMAIN",
                AclInfoScope::DasherDomainWithLink => "DASHER_DOMAIN_WITH_LINK",
                AclInfoScope::Limited => "LIMITED",
                AclInfoScope::Public => "PUBLIC",
                AclInfoScope::PublicWithLink => "PUBLIC_WITH_LINK",
                AclInfoScope::TeamDrive => "TEAM_DRIVE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AclInfoScope {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AclInfoScope {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AclInfoScope, ()> {
            Ok(match s {
                "DASHER_DOMAIN" => AclInfoScope::DasherDomain,
                "DASHER_DOMAIN_WITH_LINK" => AclInfoScope::DasherDomainWithLink,
                "LIMITED" => AclInfoScope::Limited,
                "PUBLIC" => AclInfoScope::Public,
                "PUBLIC_WITH_LINK" => AclInfoScope::PublicWithLink,
                "TEAM_DRIVE" => AclInfoScope::TeamDrive,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AclInfoScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AclInfoScope {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AclInfoScope {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DASHER_DOMAIN" => AclInfoScope::DasherDomain,
                "DASHER_DOMAIN_WITH_LINK" => AclInfoScope::DasherDomainWithLink,
                "LIMITED" => AclInfoScope::Limited,
                "PUBLIC" => AclInfoScope::Public,
                "PUBLIC_WITH_LINK" => AclInfoScope::PublicWithLink,
                "TEAM_DRIVE" => AclInfoScope::TeamDrive,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AclInfoScope {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AclInfoScope {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ActionParameter {
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ActionParameter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActionParameter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AddonComposeUiActionMarkup {
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::AddonComposeUiActionMarkupType>,
    }
    impl ::google_field_selector::FieldSelector for AddonComposeUiActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AddonComposeUiActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AddonComposeUiActionMarkupType {
        #[doc = "Dismisses the add-on compose UI."]
        Dismiss,
        #[doc = "Default. When unspecified, no action is taken."]
        Unspecified,
    }
    impl AddonComposeUiActionMarkupType {
        pub fn as_str(self) -> &'static str {
            match self {
                AddonComposeUiActionMarkupType::Dismiss => "DISMISS",
                AddonComposeUiActionMarkupType::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AddonComposeUiActionMarkupType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AddonComposeUiActionMarkupType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AddonComposeUiActionMarkupType, ()> {
            Ok(match s {
                "DISMISS" => AddonComposeUiActionMarkupType::Dismiss,
                "UNSPECIFIED" => AddonComposeUiActionMarkupType::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AddonComposeUiActionMarkupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AddonComposeUiActionMarkupType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AddonComposeUiActionMarkupType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DISMISS" => AddonComposeUiActionMarkupType::Dismiss,
                "UNSPECIFIED" => AddonComposeUiActionMarkupType::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AddonComposeUiActionMarkupType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AddonComposeUiActionMarkupType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AffectedMembership {
        #[serde(
            rename = "affectedMember",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub affected_member: ::std::option::Option<crate::schemas::MemberId>,
        #[serde(
            rename = "priorMembershipRole",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub prior_membership_role:
            ::std::option::Option<crate::schemas::AffectedMembershipPriorMembershipRole>,
        #[serde(
            rename = "priorMembershipState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub prior_membership_state:
            ::std::option::Option<crate::schemas::AffectedMembershipPriorMembershipState>,
        #[serde(
            rename = "targetMembershipRole",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub target_membership_role:
            ::std::option::Option<crate::schemas::AffectedMembershipTargetMembershipRole>,
    }
    impl ::google_field_selector::FieldSelector for AffectedMembership {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AffectedMembership {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AffectedMembershipPriorMembershipRole {
        #[doc = "This role is used for two purposes. 1. A group is invited to a room, making it discoverable for its members. 2. A user was part of a room, but willingly left the room."]
        RoleInvitee,
        #[doc = "— Following roles are for joined members of a roster. — Default role for any joined user. Has basic capabilities within a room."]
        RoleMember,
        #[doc = "This role is used when a user is forcibly removed from a room by another user. They will no longer be able to search for the room, but their history will be retained."]
        RoleNone,
        #[doc = "Role assigned to room creators and explicitly promoted members. Has broad powers to manage the room."]
        RoleOwner,
        RoleUnknown,
    }
    impl AffectedMembershipPriorMembershipRole {
        pub fn as_str(self) -> &'static str {
            match self {
                AffectedMembershipPriorMembershipRole::RoleInvitee => "ROLE_INVITEE",
                AffectedMembershipPriorMembershipRole::RoleMember => "ROLE_MEMBER",
                AffectedMembershipPriorMembershipRole::RoleNone => "ROLE_NONE",
                AffectedMembershipPriorMembershipRole::RoleOwner => "ROLE_OWNER",
                AffectedMembershipPriorMembershipRole::RoleUnknown => "ROLE_UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AffectedMembershipPriorMembershipRole {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AffectedMembershipPriorMembershipRole {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AffectedMembershipPriorMembershipRole, ()> {
            Ok(match s {
                "ROLE_INVITEE" => AffectedMembershipPriorMembershipRole::RoleInvitee,
                "ROLE_MEMBER" => AffectedMembershipPriorMembershipRole::RoleMember,
                "ROLE_NONE" => AffectedMembershipPriorMembershipRole::RoleNone,
                "ROLE_OWNER" => AffectedMembershipPriorMembershipRole::RoleOwner,
                "ROLE_UNKNOWN" => AffectedMembershipPriorMembershipRole::RoleUnknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AffectedMembershipPriorMembershipRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AffectedMembershipPriorMembershipRole {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AffectedMembershipPriorMembershipRole {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ROLE_INVITEE" => AffectedMembershipPriorMembershipRole::RoleInvitee,
                "ROLE_MEMBER" => AffectedMembershipPriorMembershipRole::RoleMember,
                "ROLE_NONE" => AffectedMembershipPriorMembershipRole::RoleNone,
                "ROLE_OWNER" => AffectedMembershipPriorMembershipRole::RoleOwner,
                "ROLE_UNKNOWN" => AffectedMembershipPriorMembershipRole::RoleUnknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AffectedMembershipPriorMembershipRole {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AffectedMembershipPriorMembershipRole {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AffectedMembershipPriorMembershipState {
        #[doc = "This state should never be stored in Spanner. It is a state for responses to the clients to indicate that membership mutations have failed and the member is in its previous state."]
        MemberFailed,
        #[doc = "An invitation to the space has been sent"]
        MemberInvited,
        #[doc = "User has joined the space"]
        MemberJoined,
        #[doc = "User is not a member"]
        MemberNotAMember,
        #[doc = "Default state, do not use"]
        MemberUnknown,
    }
    impl AffectedMembershipPriorMembershipState {
        pub fn as_str(self) -> &'static str {
            match self {
                AffectedMembershipPriorMembershipState::MemberFailed => "MEMBER_FAILED",
                AffectedMembershipPriorMembershipState::MemberInvited => "MEMBER_INVITED",
                AffectedMembershipPriorMembershipState::MemberJoined => "MEMBER_JOINED",
                AffectedMembershipPriorMembershipState::MemberNotAMember => "MEMBER_NOT_A_MEMBER",
                AffectedMembershipPriorMembershipState::MemberUnknown => "MEMBER_UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AffectedMembershipPriorMembershipState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AffectedMembershipPriorMembershipState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AffectedMembershipPriorMembershipState, ()> {
            Ok(match s {
                "MEMBER_FAILED" => AffectedMembershipPriorMembershipState::MemberFailed,
                "MEMBER_INVITED" => AffectedMembershipPriorMembershipState::MemberInvited,
                "MEMBER_JOINED" => AffectedMembershipPriorMembershipState::MemberJoined,
                "MEMBER_NOT_A_MEMBER" => AffectedMembershipPriorMembershipState::MemberNotAMember,
                "MEMBER_UNKNOWN" => AffectedMembershipPriorMembershipState::MemberUnknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AffectedMembershipPriorMembershipState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AffectedMembershipPriorMembershipState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AffectedMembershipPriorMembershipState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MEMBER_FAILED" => AffectedMembershipPriorMembershipState::MemberFailed,
                "MEMBER_INVITED" => AffectedMembershipPriorMembershipState::MemberInvited,
                "MEMBER_JOINED" => AffectedMembershipPriorMembershipState::MemberJoined,
                "MEMBER_NOT_A_MEMBER" => AffectedMembershipPriorMembershipState::MemberNotAMember,
                "MEMBER_UNKNOWN" => AffectedMembershipPriorMembershipState::MemberUnknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AffectedMembershipPriorMembershipState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AffectedMembershipPriorMembershipState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AffectedMembershipTargetMembershipRole {
        #[doc = "This role is used for two purposes. 1. A group is invited to a room, making it discoverable for its members. 2. A user was part of a room, but willingly left the room."]
        RoleInvitee,
        #[doc = "— Following roles are for joined members of a roster. — Default role for any joined user. Has basic capabilities within a room."]
        RoleMember,
        #[doc = "This role is used when a user is forcibly removed from a room by another user. They will no longer be able to search for the room, but their history will be retained."]
        RoleNone,
        #[doc = "Role assigned to room creators and explicitly promoted members. Has broad powers to manage the room."]
        RoleOwner,
        RoleUnknown,
    }
    impl AffectedMembershipTargetMembershipRole {
        pub fn as_str(self) -> &'static str {
            match self {
                AffectedMembershipTargetMembershipRole::RoleInvitee => "ROLE_INVITEE",
                AffectedMembershipTargetMembershipRole::RoleMember => "ROLE_MEMBER",
                AffectedMembershipTargetMembershipRole::RoleNone => "ROLE_NONE",
                AffectedMembershipTargetMembershipRole::RoleOwner => "ROLE_OWNER",
                AffectedMembershipTargetMembershipRole::RoleUnknown => "ROLE_UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AffectedMembershipTargetMembershipRole {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AffectedMembershipTargetMembershipRole {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AffectedMembershipTargetMembershipRole, ()> {
            Ok(match s {
                "ROLE_INVITEE" => AffectedMembershipTargetMembershipRole::RoleInvitee,
                "ROLE_MEMBER" => AffectedMembershipTargetMembershipRole::RoleMember,
                "ROLE_NONE" => AffectedMembershipTargetMembershipRole::RoleNone,
                "ROLE_OWNER" => AffectedMembershipTargetMembershipRole::RoleOwner,
                "ROLE_UNKNOWN" => AffectedMembershipTargetMembershipRole::RoleUnknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AffectedMembershipTargetMembershipRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AffectedMembershipTargetMembershipRole {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AffectedMembershipTargetMembershipRole {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ROLE_INVITEE" => AffectedMembershipTargetMembershipRole::RoleInvitee,
                "ROLE_MEMBER" => AffectedMembershipTargetMembershipRole::RoleMember,
                "ROLE_NONE" => AffectedMembershipTargetMembershipRole::RoleNone,
                "ROLE_OWNER" => AffectedMembershipTargetMembershipRole::RoleOwner,
                "ROLE_UNKNOWN" => AffectedMembershipTargetMembershipRole::RoleUnknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AffectedMembershipTargetMembershipRole {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AffectedMembershipTargetMembershipRole {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AllAuthenticatedUsersProto {}
    impl ::google_field_selector::FieldSelector for AllAuthenticatedUsersProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AllAuthenticatedUsersProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Annotation {
        #[serde(
            rename = "babelPlaceholderMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub babel_placeholder_metadata:
            ::std::option::Option<crate::schemas::BabelPlaceholderMetadata>,
        #[doc = "LINT.ThenChange(//depot/google3/java/com/google/apps/dynamite/v1/backend/action/common/SystemMessageHelper.java)"]
        #[serde(
            rename = "cardCapabilityMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub card_capability_metadata: ::std::option::Option<crate::schemas::CardCapabilityMetadata>,
        #[doc = "Whether the annotation should be rendered as a chip. If this is missing or unspecified, fallback to should_not_render on the metadata."]
        #[serde(
            rename = "chipRenderType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub chip_render_type: ::std::option::Option<crate::schemas::AnnotationChipRenderType>,
        #[serde(
            rename = "consentedAppUnfurlMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub consented_app_unfurl_metadata:
            ::std::option::Option<crate::schemas::ConsentedAppUnfurlMetadata>,
        #[serde(
            rename = "customEmojiMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub custom_emoji_metadata: ::std::option::Option<crate::schemas::CustomEmojiMetadata>,
        #[serde(
            rename = "dataLossPreventionMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_loss_prevention_metadata:
            ::std::option::Option<crate::schemas::DataLossPreventionMetadata>,
        #[doc = "Chip annotations"]
        #[serde(
            rename = "driveMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_metadata: ::std::option::Option<crate::schemas::DriveMetadata>,
        #[serde(
            rename = "formatMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub format_metadata: ::std::option::Option<crate::schemas::FormatMetadata>,
        #[serde(
            rename = "groupRetentionSettingsUpdated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_retention_settings_updated:
            ::std::option::Option<crate::schemas::GroupRetentionSettingsUpdatedMetaData>,
        #[doc = "Metadata for 1P integrations like tasks, calendar. These are supported only through integration server as 1P integrations use the integration API (which in turn uses backend API with special permissions) to post messages. Clients should never set this. LINT.IfChange"]
        #[serde(
            rename = "gsuiteIntegrationMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gsuite_integration_metadata:
            ::std::option::Option<crate::schemas::GsuiteIntegrationMetadata>,
        #[serde(
            rename = "incomingWebhookChangedMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub incoming_webhook_changed_metadata:
            ::std::option::Option<crate::schemas::IncomingWebhookChangedMetadata>,
        #[doc = "LINT.ThenChange(//depot/google3/java/com/google/apps/dynamite/v1/backend/action/common/SystemMessageHelper.java)"]
        #[serde(
            rename = "integrationConfigUpdated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integration_config_updated:
            ::std::option::Option<crate::schemas::IntegrationConfigUpdatedMetadata>,
        #[doc = "Length of the text_body substring beginning from start_index the Annotation corresponds to."]
        #[serde(
            rename = "length",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub length: ::std::option::Option<i32>,
        #[doc = "A unique client-assigned ID for this annotation. This is helpful in matching the back-filled annotations to the original annotations on client side, without having to re-parse the message."]
        #[serde(
            rename = "localId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub local_id: ::std::option::Option<String>,
        #[doc = "Metadata for system messages. Clients should never set this. LINT.IfChange"]
        #[serde(
            rename = "membershipChanged",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub membership_changed: ::std::option::Option<crate::schemas::MembershipChangedMetadata>,
        #[doc = "Type of the Annotation."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::AnnotationType>,
        #[serde(
            rename = "readReceiptsSettingsMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub read_receipts_settings_metadata:
            ::std::option::Option<crate::schemas::ReadReceiptsSettingsUpdatedMetadata>,
        #[doc = "Metadata that defines all of the required features that must be rendered in the message. Clients can use this to see whether they support the entire message, or show a fallback chip otherwise. See go/message-quoting-client-to-server for details. LINT.ThenChange( //depot/google3/java/com/google/apps/dynamite/v1/allshared/parser/AnnotationSanitizer.java, //depot/google3/java/com/google/apps/dynamite/v1/backend/action/common/SystemMessageHelper.java, //depot/google3/java/com/google/caribou/eli/mediation/chat/AnnotationTranslator.java )"]
        #[serde(
            rename = "requiredMessageFeaturesMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub required_message_features_metadata:
            ::std::option::Option<crate::schemas::RequiredMessageFeaturesMetadata>,
        #[serde(
            rename = "roomUpdated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub room_updated: ::std::option::Option<crate::schemas::RoomUpdatedMetadata>,
        #[doc = "Whether or not the annotation is invalidated by the server. Example of situations for invalidation include: when the URL is malformed, or when Drive item ID is rejected by Drive Service."]
        #[serde(
            rename = "serverInvalidated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub server_invalidated: ::std::option::Option<bool>,
        #[serde(
            rename = "slashCommandMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub slash_command_metadata: ::std::option::Option<crate::schemas::SlashCommandMetadata>,
        #[doc = "Start index (0-indexed) of the Message text the Annotation corresponds to, inclusive."]
        #[serde(
            rename = "startIndex",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_index: ::std::option::Option<i32>,
        #[doc = "A unique server-assigned ID for this annotation. This is helpful in matching annotation objects when fetched from service."]
        #[serde(
            rename = "uniqueId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub unique_id: ::std::option::Option<String>,
        #[serde(
            rename = "uploadMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub upload_metadata: ::std::option::Option<crate::schemas::UploadMetadata>,
        #[serde(
            rename = "urlMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url_metadata: ::std::option::Option<crate::schemas::UrlMetadata>,
        #[doc = "Metadata that clients can set for annotations. LINT.IfChange In-text annotations"]
        #[serde(
            rename = "userMentionMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_mention_metadata: ::std::option::Option<crate::schemas::UserMentionMetadata>,
        #[serde(
            rename = "videoCallMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_call_metadata: ::std::option::Option<crate::schemas::VideoCallMetadata>,
        #[serde(
            rename = "youtubeMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub youtube_metadata: ::std::option::Option<crate::schemas::YoutubeMetadata>,
    }
    impl ::google_field_selector::FieldSelector for Annotation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Annotation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AnnotationChipRenderType {
        ChipRenderTypeUnspecified,
        #[doc = "Client should not render the annotation as a chip."]
        DoNotRender,
        #[doc = "Clients must render the annotation as a chip, and if they cannot render this many Annotations, show a fallback card."]
        Render,
        #[doc = "Client can render the annotation if it has room to render it."]
        RenderIfPossible,
    }
    impl AnnotationChipRenderType {
        pub fn as_str(self) -> &'static str {
            match self {
                AnnotationChipRenderType::ChipRenderTypeUnspecified => {
                    "CHIP_RENDER_TYPE_UNSPECIFIED"
                }
                AnnotationChipRenderType::DoNotRender => "DO_NOT_RENDER",
                AnnotationChipRenderType::Render => "RENDER",
                AnnotationChipRenderType::RenderIfPossible => "RENDER_IF_POSSIBLE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AnnotationChipRenderType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AnnotationChipRenderType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AnnotationChipRenderType, ()> {
            Ok(match s {
                "CHIP_RENDER_TYPE_UNSPECIFIED" => {
                    AnnotationChipRenderType::ChipRenderTypeUnspecified
                }
                "DO_NOT_RENDER" => AnnotationChipRenderType::DoNotRender,
                "RENDER" => AnnotationChipRenderType::Render,
                "RENDER_IF_POSSIBLE" => AnnotationChipRenderType::RenderIfPossible,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AnnotationChipRenderType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AnnotationChipRenderType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AnnotationChipRenderType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CHIP_RENDER_TYPE_UNSPECIFIED" => {
                    AnnotationChipRenderType::ChipRenderTypeUnspecified
                }
                "DO_NOT_RENDER" => AnnotationChipRenderType::DoNotRender,
                "RENDER" => AnnotationChipRenderType::Render,
                "RENDER_IF_POSSIBLE" => AnnotationChipRenderType::RenderIfPossible,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AnnotationChipRenderType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AnnotationChipRenderType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AnnotationType {
        BabelPlaceholder,
        #[doc = "Card capability for in-stream widgets."]
        CardCapability,
        ConsentedAppUnfurl,
        CustomEmoji,
        DataLossPrevention,
        DriveDoc,
        #[doc = "Any drive file"]
        DriveFile,
        DriveForm,
        DriveSheet,
        DriveSlide,
        #[doc = "UI should not be concerned with FORMAT_DATA"]
        FormatData,
        GroupRetentionSettingsUpdated,
        #[doc = "Generic annotation for gsuite integrations"]
        GsuiteIntegration,
        Image,
        IncomingWebhookChanged,
        IntegrationConfigUpdated,
        #[doc = "Message-level annotations. First message of an invite. Should not be set by clients."]
        Invitation,
        #[doc = "Annotation types for system messages. Clients should never set this."]
        MembershipChanged,
        Pdf,
        ReadReceiptsSettingsUpdated,
        #[doc = "Clients can use this to see whether they support the entire message, or show a fallback chip otherwise."]
        RequiredMessageFeaturesMetadata,
        RoomUpdated,
        SlashCommand,
        #[doc = "Default value for the enum. DO NOT USE."]
        TypeUnspecified,
        #[doc = "Blobstore uploads"]
        UploadMetadata,
        #[doc = "These can have overlaps, i.e. same message can have multiple of these. For example a Drive link to a PDF can have URL, DRIVE_FILE and PDF all set Links"]
        Url,
        UserMention,
        #[doc = "Any video, not just youtube, the url decides how to play"]
        Video,
        #[doc = "For Thor integration"]
        VideoCall,
    }
    impl AnnotationType {
        pub fn as_str(self) -> &'static str {
            match self {
                AnnotationType::BabelPlaceholder => "BABEL_PLACEHOLDER",
                AnnotationType::CardCapability => "CARD_CAPABILITY",
                AnnotationType::ConsentedAppUnfurl => "CONSENTED_APP_UNFURL",
                AnnotationType::CustomEmoji => "CUSTOM_EMOJI",
                AnnotationType::DataLossPrevention => "DATA_LOSS_PREVENTION",
                AnnotationType::DriveDoc => "DRIVE_DOC",
                AnnotationType::DriveFile => "DRIVE_FILE",
                AnnotationType::DriveForm => "DRIVE_FORM",
                AnnotationType::DriveSheet => "DRIVE_SHEET",
                AnnotationType::DriveSlide => "DRIVE_SLIDE",
                AnnotationType::FormatData => "FORMAT_DATA",
                AnnotationType::GroupRetentionSettingsUpdated => "GROUP_RETENTION_SETTINGS_UPDATED",
                AnnotationType::GsuiteIntegration => "GSUITE_INTEGRATION",
                AnnotationType::Image => "IMAGE",
                AnnotationType::IncomingWebhookChanged => "INCOMING_WEBHOOK_CHANGED",
                AnnotationType::IntegrationConfigUpdated => "INTEGRATION_CONFIG_UPDATED",
                AnnotationType::Invitation => "INVITATION",
                AnnotationType::MembershipChanged => "MEMBERSHIP_CHANGED",
                AnnotationType::Pdf => "PDF",
                AnnotationType::ReadReceiptsSettingsUpdated => "READ_RECEIPTS_SETTINGS_UPDATED",
                AnnotationType::RequiredMessageFeaturesMetadata => {
                    "REQUIRED_MESSAGE_FEATURES_METADATA"
                }
                AnnotationType::RoomUpdated => "ROOM_UPDATED",
                AnnotationType::SlashCommand => "SLASH_COMMAND",
                AnnotationType::TypeUnspecified => "TYPE_UNSPECIFIED",
                AnnotationType::UploadMetadata => "UPLOAD_METADATA",
                AnnotationType::Url => "URL",
                AnnotationType::UserMention => "USER_MENTION",
                AnnotationType::Video => "VIDEO",
                AnnotationType::VideoCall => "VIDEO_CALL",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AnnotationType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AnnotationType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AnnotationType, ()> {
            Ok(match s {
                "BABEL_PLACEHOLDER" => AnnotationType::BabelPlaceholder,
                "CARD_CAPABILITY" => AnnotationType::CardCapability,
                "CONSENTED_APP_UNFURL" => AnnotationType::ConsentedAppUnfurl,
                "CUSTOM_EMOJI" => AnnotationType::CustomEmoji,
                "DATA_LOSS_PREVENTION" => AnnotationType::DataLossPrevention,
                "DRIVE_DOC" => AnnotationType::DriveDoc,
                "DRIVE_FILE" => AnnotationType::DriveFile,
                "DRIVE_FORM" => AnnotationType::DriveForm,
                "DRIVE_SHEET" => AnnotationType::DriveSheet,
                "DRIVE_SLIDE" => AnnotationType::DriveSlide,
                "FORMAT_DATA" => AnnotationType::FormatData,
                "GROUP_RETENTION_SETTINGS_UPDATED" => AnnotationType::GroupRetentionSettingsUpdated,
                "GSUITE_INTEGRATION" => AnnotationType::GsuiteIntegration,
                "IMAGE" => AnnotationType::Image,
                "INCOMING_WEBHOOK_CHANGED" => AnnotationType::IncomingWebhookChanged,
                "INTEGRATION_CONFIG_UPDATED" => AnnotationType::IntegrationConfigUpdated,
                "INVITATION" => AnnotationType::Invitation,
                "MEMBERSHIP_CHANGED" => AnnotationType::MembershipChanged,
                "PDF" => AnnotationType::Pdf,
                "READ_RECEIPTS_SETTINGS_UPDATED" => AnnotationType::ReadReceiptsSettingsUpdated,
                "REQUIRED_MESSAGE_FEATURES_METADATA" => {
                    AnnotationType::RequiredMessageFeaturesMetadata
                }
                "ROOM_UPDATED" => AnnotationType::RoomUpdated,
                "SLASH_COMMAND" => AnnotationType::SlashCommand,
                "TYPE_UNSPECIFIED" => AnnotationType::TypeUnspecified,
                "UPLOAD_METADATA" => AnnotationType::UploadMetadata,
                "URL" => AnnotationType::Url,
                "USER_MENTION" => AnnotationType::UserMention,
                "VIDEO" => AnnotationType::Video,
                "VIDEO_CALL" => AnnotationType::VideoCall,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AnnotationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AnnotationType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AnnotationType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BABEL_PLACEHOLDER" => AnnotationType::BabelPlaceholder,
                "CARD_CAPABILITY" => AnnotationType::CardCapability,
                "CONSENTED_APP_UNFURL" => AnnotationType::ConsentedAppUnfurl,
                "CUSTOM_EMOJI" => AnnotationType::CustomEmoji,
                "DATA_LOSS_PREVENTION" => AnnotationType::DataLossPrevention,
                "DRIVE_DOC" => AnnotationType::DriveDoc,
                "DRIVE_FILE" => AnnotationType::DriveFile,
                "DRIVE_FORM" => AnnotationType::DriveForm,
                "DRIVE_SHEET" => AnnotationType::DriveSheet,
                "DRIVE_SLIDE" => AnnotationType::DriveSlide,
                "FORMAT_DATA" => AnnotationType::FormatData,
                "GROUP_RETENTION_SETTINGS_UPDATED" => AnnotationType::GroupRetentionSettingsUpdated,
                "GSUITE_INTEGRATION" => AnnotationType::GsuiteIntegration,
                "IMAGE" => AnnotationType::Image,
                "INCOMING_WEBHOOK_CHANGED" => AnnotationType::IncomingWebhookChanged,
                "INTEGRATION_CONFIG_UPDATED" => AnnotationType::IntegrationConfigUpdated,
                "INVITATION" => AnnotationType::Invitation,
                "MEMBERSHIP_CHANGED" => AnnotationType::MembershipChanged,
                "PDF" => AnnotationType::Pdf,
                "READ_RECEIPTS_SETTINGS_UPDATED" => AnnotationType::ReadReceiptsSettingsUpdated,
                "REQUIRED_MESSAGE_FEATURES_METADATA" => {
                    AnnotationType::RequiredMessageFeaturesMetadata
                }
                "ROOM_UPDATED" => AnnotationType::RoomUpdated,
                "SLASH_COMMAND" => AnnotationType::SlashCommand,
                "TYPE_UNSPECIFIED" => AnnotationType::TypeUnspecified,
                "UPLOAD_METADATA" => AnnotationType::UploadMetadata,
                "URL" => AnnotationType::Url,
                "USER_MENTION" => AnnotationType::UserMention,
                "VIDEO" => AnnotationType::Video,
                "VIDEO_CALL" => AnnotationType::VideoCall,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AnnotationType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AnnotationType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppId {
        #[doc = "Enum indicating the type of App this is."]
        #[serde(
            rename = "appType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app_type: ::std::option::Option<crate::schemas::AppIdAppType>,
        #[doc = "Enum indicating which 1P App this is when app_type is GSUITE_APP. Determined & set by the 1P API as a convenience for all users of this identifier(Eg. clients, chime, backend etc.) to map to 1P properties."]
        #[serde(
            rename = "gsuiteAppType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gsuite_app_type: ::std::option::Option<crate::schemas::AppIdGsuiteAppType>,
        #[doc = "Numeric identifier of the App. Set to Project number for 1/3P Apps. For Webhook, this is WebhookId. Determined & set by the 1P API from App credentials on the side channel."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for AppId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppIdAppType {
        #[doc = "3P APP eg. external Bots(Asana Bot), 1P Bots(Drive Bot)."]
        App,
        AppTypeUnspecified,
        #[doc = "1P APP eg. Tasks, Meet, Docs, Calendar.."]
        GsuiteApp,
        #[doc = "Asynchronous messages via an incoming webhook."]
        IncomingWebhook,
    }
    impl AppIdAppType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppIdAppType::App => "APP",
                AppIdAppType::AppTypeUnspecified => "APP_TYPE_UNSPECIFIED",
                AppIdAppType::GsuiteApp => "GSUITE_APP",
                AppIdAppType::IncomingWebhook => "INCOMING_WEBHOOK",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppIdAppType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppIdAppType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppIdAppType, ()> {
            Ok(match s {
                "APP" => AppIdAppType::App,
                "APP_TYPE_UNSPECIFIED" => AppIdAppType::AppTypeUnspecified,
                "GSUITE_APP" => AppIdAppType::GsuiteApp,
                "INCOMING_WEBHOOK" => AppIdAppType::IncomingWebhook,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppIdAppType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppIdAppType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppIdAppType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APP" => AppIdAppType::App,
                "APP_TYPE_UNSPECIFIED" => AppIdAppType::AppTypeUnspecified,
                "GSUITE_APP" => AppIdAppType::GsuiteApp,
                "INCOMING_WEBHOOK" => AppIdAppType::IncomingWebhook,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppIdAppType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppIdAppType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppIdGsuiteAppType {
        ActivityFeedApp,
        #[doc = "Powered by Bullseye"]
        AssistiveSuggestionApp,
        CalendarApp,
        ChatInMeetApp,
        ContactsApp,
        DocsApp,
        DriveApp,
        GsuiteAppTypeUnspecified,
        MeetApp,
        SheetsApp,
        SlidesApp,
        TasksApp,
    }
    impl AppIdGsuiteAppType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppIdGsuiteAppType::ActivityFeedApp => "ACTIVITY_FEED_APP",
                AppIdGsuiteAppType::AssistiveSuggestionApp => "ASSISTIVE_SUGGESTION_APP",
                AppIdGsuiteAppType::CalendarApp => "CALENDAR_APP",
                AppIdGsuiteAppType::ChatInMeetApp => "CHAT_IN_MEET_APP",
                AppIdGsuiteAppType::ContactsApp => "CONTACTS_APP",
                AppIdGsuiteAppType::DocsApp => "DOCS_APP",
                AppIdGsuiteAppType::DriveApp => "DRIVE_APP",
                AppIdGsuiteAppType::GsuiteAppTypeUnspecified => "GSUITE_APP_TYPE_UNSPECIFIED",
                AppIdGsuiteAppType::MeetApp => "MEET_APP",
                AppIdGsuiteAppType::SheetsApp => "SHEETS_APP",
                AppIdGsuiteAppType::SlidesApp => "SLIDES_APP",
                AppIdGsuiteAppType::TasksApp => "TASKS_APP",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppIdGsuiteAppType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppIdGsuiteAppType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppIdGsuiteAppType, ()> {
            Ok(match s {
                "ACTIVITY_FEED_APP" => AppIdGsuiteAppType::ActivityFeedApp,
                "ASSISTIVE_SUGGESTION_APP" => AppIdGsuiteAppType::AssistiveSuggestionApp,
                "CALENDAR_APP" => AppIdGsuiteAppType::CalendarApp,
                "CHAT_IN_MEET_APP" => AppIdGsuiteAppType::ChatInMeetApp,
                "CONTACTS_APP" => AppIdGsuiteAppType::ContactsApp,
                "DOCS_APP" => AppIdGsuiteAppType::DocsApp,
                "DRIVE_APP" => AppIdGsuiteAppType::DriveApp,
                "GSUITE_APP_TYPE_UNSPECIFIED" => AppIdGsuiteAppType::GsuiteAppTypeUnspecified,
                "MEET_APP" => AppIdGsuiteAppType::MeetApp,
                "SHEETS_APP" => AppIdGsuiteAppType::SheetsApp,
                "SLIDES_APP" => AppIdGsuiteAppType::SlidesApp,
                "TASKS_APP" => AppIdGsuiteAppType::TasksApp,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppIdGsuiteAppType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppIdGsuiteAppType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppIdGsuiteAppType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVITY_FEED_APP" => AppIdGsuiteAppType::ActivityFeedApp,
                "ASSISTIVE_SUGGESTION_APP" => AppIdGsuiteAppType::AssistiveSuggestionApp,
                "CALENDAR_APP" => AppIdGsuiteAppType::CalendarApp,
                "CHAT_IN_MEET_APP" => AppIdGsuiteAppType::ChatInMeetApp,
                "CONTACTS_APP" => AppIdGsuiteAppType::ContactsApp,
                "DOCS_APP" => AppIdGsuiteAppType::DocsApp,
                "DRIVE_APP" => AppIdGsuiteAppType::DriveApp,
                "GSUITE_APP_TYPE_UNSPECIFIED" => AppIdGsuiteAppType::GsuiteAppTypeUnspecified,
                "MEET_APP" => AppIdGsuiteAppType::MeetApp,
                "SHEETS_APP" => AppIdGsuiteAppType::SheetsApp,
                "SLIDES_APP" => AppIdGsuiteAppType::SlidesApp,
                "TASKS_APP" => AppIdGsuiteAppType::TasksApp,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppIdGsuiteAppType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppIdGsuiteAppType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedActivityFeedAnnotationData {
        #[doc = "Timestamp of when the Activity Feed message that contains this annotation was created. This is roughly when the activity happened, such as when a reaction happened, but will have at least some small delay, since the Activity Feed message is created asynchronously after. This timestamp should only be used for display when the activity create time is not available in the Chat UI, like the time of a reaction."]
        #[serde(
            rename = "activityFeedMessageCreateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub activity_feed_message_create_time: ::std::option::Option<String>,
        #[doc = "Unique id of the Activity Feed message used by clients to implement click-to-source. This is the same messageId as the top-level id field for the Activity Feed item."]
        #[serde(
            rename = "activityFeedMessageId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub activity_feed_message_id: ::std::option::Option<crate::schemas::MessageId>,
        #[serde(
            rename = "chatItem",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub chat_item: ::std::option::Option<crate::schemas::AppsDynamiteSharedChatItem>,
        #[doc = "Only populated on read path and should not be persisted in storage."]
        #[serde(
            rename = "sharedUserInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shared_user_info: ::std::option::Option<crate::schemas::UserInfo>,
        #[doc = "Use shared_user_info instead."]
        #[serde(
            rename = "userInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_info: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedActivityFeedAnnotationDataUserInfo,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedActivityFeedAnnotationData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedActivityFeedAnnotationData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedActivityFeedAnnotationDataUserInfo { # [doc = "Describes how updater_count_to_show should be used."] # [serde (rename = "updaterCountDisplayType" , default , skip_serializing_if = "std::option::Option::is_none")] pub updater_count_display_type : :: std :: option :: Option < crate :: schemas :: AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType > , # [doc = "The number of updaters for clients to show, currently set to the total number of updaters minus the one set in updater_to_show."] # [serde (rename = "updaterCountToShow" , default , skip_serializing_if = "std::option::Option::is_none")] pub updater_count_to_show : :: std :: option :: Option < i32 > , # [doc = "The updater for clients to show."] # [serde (rename = "updaterToShow" , default , skip_serializing_if = "std::option::Option::is_none")] pub updater_to_show : :: std :: option :: Option < crate :: schemas :: UserId > , }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedActivityFeedAnnotationDataUserInfo
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedActivityFeedAnnotationDataUserInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType {
        #[doc = "A precise updater count is known and the value set in updater_count_to_show should be used."]
        ExactCount,
        #[doc = "A precise updater count could not be calculated, but there is at least one. Any value set in updater_count_to_show should NOT be used."]
        NonzeroCount,
        UpdaterCountDisplayTypeUnspecified,
    }
    impl AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: ExactCount => "EXACT_COUNT" , AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: NonzeroCount => "NONZERO_COUNT" , AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: UpdaterCountDisplayTypeUnspecified => "UPDATER_COUNT_DISPLAY_TYPE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType,
            (),
        > {
            Ok (match s { "EXACT_COUNT" => AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: ExactCount , "NONZERO_COUNT" => AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: NonzeroCount , "UPDATER_COUNT_DISPLAY_TYPE_UNSPECIFIED" => AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: UpdaterCountDisplayTypeUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "EXACT_COUNT" => AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: ExactCount , "NONZERO_COUNT" => AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: NonzeroCount , "UPDATER_COUNT_DISPLAY_TYPE_UNSPECIFIED" => AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType :: UpdaterCountDisplayTypeUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedActivityFeedAnnotationDataUserInfoUpdaterCountDisplayType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAppProfile {
        #[doc = "Displayed user avatar emoji."]
        #[serde(
            rename = "avatarEmoji",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub avatar_emoji: ::std::option::Option<String>,
        #[doc = "Displayed user avatar url."]
        #[serde(
            rename = "avatarUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub avatar_url: ::std::option::Option<String>,
        #[doc = "Displayed user name."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedAppProfile {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedAppProfile {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAssistantAnnotationData {
        #[doc = "The suggestion to render in the card."]
        #[serde(
            rename = "suggestion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suggestion:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedAssistantSuggestion>,
        #[doc = "Set when the initial query was unfulfillable. Only an on-demand unfulfillable query will result in a response (not a proactive query). 1. On-demand: user explicitly invokes the bot 2. Proactive: bot makes proactive suggestion (when available) by listening to all user messages."]
        #[serde(
            rename = "unfulfillable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub unfulfillable:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedAssistantUnfulfillableRequest>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedAssistantAnnotationData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedAssistantAnnotationData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAssistantDebugContext {
        #[doc = "The query that triggered the resulting suggestion."]
        #[serde(
            rename = "query",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedAssistantDebugContext {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedAssistantDebugContext {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAssistantFeedbackContext {
        #[doc = "Specifies a list of feedback chips to show"]
        #[serde(
            rename = "feedbackChips",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feedback_chips: ::std::option::Option<
            Vec<crate::schemas::AppsDynamiteSharedAssistantFeedbackContextFeedbackChip>,
        >,
        #[doc = "Whether the thumbs feedback is provided"]
        #[serde(
            rename = "thumbsFeedback",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thumbs_feedback: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedAssistantFeedbackContext {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedAssistantFeedbackContext {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback {
        #[doc = "Thumbs down selected"]
        Down,
        #[doc = "Thumbs are not selected"]
        NoneSelected,
        #[doc = "Unspecified thumbs state"]
        ThumbsFeedbackUnspecified,
        #[doc = "Thumbs up selected"]
        Up,
    }
    impl AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: Down => "DOWN" , AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: NoneSelected => "NONE_SELECTED" , AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: ThumbsFeedbackUnspecified => "THUMBS_FEEDBACK_UNSPECIFIED" , AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: Up => "UP" , }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback, ()>
        {
            Ok (match s { "DOWN" => AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: Down , "NONE_SELECTED" => AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: NoneSelected , "THUMBS_FEEDBACK_UNSPECIFIED" => AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: ThumbsFeedbackUnspecified , "UP" => AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: Up , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DOWN" => AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: Down , "NONE_SELECTED" => AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: NoneSelected , "THUMBS_FEEDBACK_UNSPECIFIED" => AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: ThumbsFeedbackUnspecified , "UP" => AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback :: Up , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedAssistantFeedbackContextThumbsFeedback
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAssistantFeedbackContextFeedbackChip {
        #[doc = "What type of chip to display"]
        #[serde(
            rename = "feedbackChipType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feedback_chip_type: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType,
        >,
        #[doc = "Whether the chip has been selected"]
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType {
        #[doc = "The correct files were presented"]
        CorrectFile,
        #[doc = "The Assistant card triggered appropriately"]
        CorrectTrigger,
        #[doc = "The feature is disruptive"]
        Disruptive,
        #[doc = "Unspecified type of feedback chip"]
        FeedbackChipTypeUnspecified,
        #[doc = "Other reason"]
        Other,
        #[doc = "Incorrect files were presented"]
        WrongFile,
        #[doc = "Bad/noisy triggering"]
        WrongTrigger,
    }
    impl AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: CorrectFile => "CORRECT_FILE" , AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: CorrectTrigger => "CORRECT_TRIGGER" , AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: Disruptive => "DISRUPTIVE" , AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: FeedbackChipTypeUnspecified => "FEEDBACK_CHIP_TYPE_UNSPECIFIED" , AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: Other => "OTHER" , AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: WrongFile => "WRONG_FILE" , AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: WrongTrigger => "WRONG_TRIGGER" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType,
            (),
        > {
            Ok (match s { "CORRECT_FILE" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: CorrectFile , "CORRECT_TRIGGER" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: CorrectTrigger , "DISRUPTIVE" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: Disruptive , "FEEDBACK_CHIP_TYPE_UNSPECIFIED" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: FeedbackChipTypeUnspecified , "OTHER" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: Other , "WRONG_FILE" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: WrongFile , "WRONG_TRIGGER" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: WrongTrigger , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "CORRECT_FILE" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: CorrectFile , "CORRECT_TRIGGER" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: CorrectTrigger , "DISRUPTIVE" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: Disruptive , "FEEDBACK_CHIP_TYPE_UNSPECIFIED" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: FeedbackChipTypeUnspecified , "OTHER" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: Other , "WRONG_FILE" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: WrongFile , "WRONG_TRIGGER" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType :: WrongTrigger , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipFeedbackChipType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState {
        #[doc = "Unspecified selection state"]
        FeedbackChipStateUnspecified,
        #[doc = "Chip is selected"]
        Selected,
        #[doc = "Chip is not selected"]
        Unselected,
    }
    impl AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: FeedbackChipStateUnspecified => "FEEDBACK_CHIP_STATE_UNSPECIFIED" , AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: Selected => "SELECTED" , AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: Unselected => "UNSELECTED" , }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState, ()>
        {
            Ok (match s { "FEEDBACK_CHIP_STATE_UNSPECIFIED" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: FeedbackChipStateUnspecified , "SELECTED" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: Selected , "UNSELECTED" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: Unselected , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "FEEDBACK_CHIP_STATE_UNSPECIFIED" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: FeedbackChipStateUnspecified , "SELECTED" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: Selected , "UNSELECTED" => AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState :: Unselected , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedAssistantFeedbackContextFeedbackChipState
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAssistantSessionContext {
        #[doc = "Unique identifier populated by the contextual request handler for each vertical (Ex: File Suggestions, Smart Scheduling, etc.) that can be used to track sessions end-to-end. May span multiple users (sender-specific)."]
        #[serde(
            rename = "contextualSessionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contextual_session_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedAssistantSessionContext {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedAssistantSessionContext {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAssistantSuggestion {
        #[doc = "Info regarding suggestion debug information."]
        #[serde(
            rename = "debugContext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_context:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedAssistantDebugContext>,
        #[doc = "Data for rendering feedback."]
        #[serde(
            rename = "feedbackContext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feedback_context:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedAssistantFeedbackContext>,
        #[doc = "Suggestion type that suggests documents (docs, slides, sheets)."]
        #[serde(
            rename = "findDocumentSuggestion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub find_document_suggestion:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedFindDocumentSuggestion>,
        #[doc = "String representation of the suggestions provided."]
        #[serde(
            rename = "serializedSuggestions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub serialized_suggestions: ::std::option::Option<String>,
        #[doc = "Session context specific to the Assistant suggestion."]
        #[serde(
            rename = "sessionContext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_context:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedAssistantSessionContext>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedAssistantSuggestion {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedAssistantSuggestion {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAssistantUnfulfillableRequest {}
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedAssistantUnfulfillableRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedAssistantUnfulfillableRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedAvatarInfo {
        #[serde(
            rename = "emoji",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub emoji: ::std::option::Option<crate::schemas::AppsDynamiteSharedEmoji>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedAvatarInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedAvatarInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedBackendUploadMetadata {
        #[doc = "Blobstore path for the uploaded attachment"]
        #[serde(
            rename = "blobPath",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub blob_path: ::std::option::Option<String>,
        #[doc = "The original file name for the content, not the full path."]
        #[serde(
            rename = "contentName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_name: ::std::option::Option<String>,
        #[doc = "Scotty reported content size by default. http://google3/uploader/agent/scotty_agent.proto?l=101&rcl=140889785"]
        #[serde(
            rename = "contentSize",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub content_size: ::std::option::Option<i64>,
        #[doc = "Type is from Scotty’s best_guess by default: http://google3/uploader/agent/scotty_agent.proto?l=51&rcl=140889785"]
        #[serde(
            rename = "contentType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_type: ::std::option::Option<String>,
        #[doc = "The results of the Data Loss Prevention (DLP) scan of the attachment. DEPRECATED: use dlp_scan_summary instead."]
        #[serde(
            rename = "dlpScanOutcome",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dlp_scan_outcome: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome,
        >,
        #[doc = "Summary of a Data Loss Prevention (DLP) scan of the attachment. Attachments are evaluated in the backend when they are uploaded."]
        #[serde(
            rename = "dlpScanSummary",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dlp_scan_summary: ::std::option::Option<crate::schemas::DlpScanSummary>,
        #[doc = "GroupId to which this attachment is uploaded."]
        #[serde(
            rename = "groupId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_id: ::std::option::Option<crate::schemas::GroupId>,
        #[doc = "If the uploaded file is a video that has been transcoded on the client side Next tag: 18"]
        #[serde(
            rename = "isClientSideTranscodedVideo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_client_side_transcoded_video: ::std::option::Option<bool>,
        #[doc = "Original dimension of the content. Only set for image attachments."]
        #[serde(
            rename = "originalDimension",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub original_dimension: ::std::option::Option<crate::schemas::AppsDynamiteSharedDimension>,
        #[doc = "The message id of a quote reply referencing this attachment. When present, this attachment has been quoted in a reply message. Normally, the attachment is fetched through the message id in the blob_path, but in the case of a quote reply, the blob_path would contain the quoted message id. Thus this message id field is needed to fetch the quote reply message instead. This field is conditionally populated at read time for quotes and never persisted in storage. See go/message-quoting-attachments for more context."]
        #[serde(
            rename = "quoteReplyMessageId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub quote_reply_message_id: ::std::option::Option<crate::schemas::MessageId>,
        #[doc = "The SHA256 hash of the attachment bytes."]
        #[serde(
            rename = "sha256",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sha_256: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "User IP address at upload time. Ex. “123.1.2.3”. Used by Ares abuse scanning."]
        #[serde(
            rename = "uploadIp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub upload_ip: ::std::option::Option<String>,
        #[doc = "Timestamp of when user finished uploading the content."]
        #[serde(
            rename = "uploadTimestampUsec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub upload_timestamp_usec: ::std::option::Option<i64>,
        #[doc = "VideoID of the video attachments. This ID shall meets the Youtube ID format of 16 hex characters. For example, ‘4c14b8825af6059b’ is a valid ID."]
        #[serde(
            rename = "videoId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_id: ::std::option::Option<String>,
        #[doc = "Full Blobstore ID for the video thumbnail."]
        #[serde(
            rename = "videoThumbnailBlobId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_thumbnail_blob_id: ::std::option::Option<String>,
        #[doc = "Result for a virus scan."]
        #[serde(
            rename = "virusScanResult",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub virus_scan_result: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedBackendUploadMetadataVirusScanResult,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedBackendUploadMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedBackendUploadMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome {
        #[doc = "Rule fetch completed and evaluation were attempted, but all of the rules failed to be evaluated."]
        ScanFailureAllRulesFailed,
        #[doc = "Rule fetch and evaluation were attempted but an exception occurred."]
        ScanFailureException,
        #[doc = "An IllegalStateException is thrown when executing DLP on attachments. This could happen if the space row is missing."]
        ScanFailureIllegalStateForAttachments,
        #[doc = "Rule fetch was attempted but failed, so rule evaluation could not be performed."]
        ScanFailureRuleFetchFailed,
        #[doc = "Rule fetch and evaluation were attempted but the scanning timed out."]
        ScanFailureTimeout,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because Changeling returned an empty response while converting the attachment to text."]
        ScanRuleEvaluationSkippedChangelingEmptyResponse,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because Changeling returned permanent failure while converting the attachment to text."]
        ScanRuleEvaluationSkippedChangelingPermanentError,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because none of the rules are applicable to the given action params."]
        ScanRuleEvaluationSkippedNoApplicableRulesForActionParams,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because none of the rules are applicable to the given trigger."]
        ScanRuleEvaluationSkippedNoApplicableRulesForTrigger,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because no rules were found."]
        ScanRuleEvaluationSkippedNoRulesFound,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because file type is unsupported."]
        ScanRuleEvaluationSkippedUnsupportedFileType,
        #[doc = "Rule fetch and evaluation are skipped because the user sending message is consumer."]
        ScanSkippedConsumer,
        #[doc = "Rule fetch and evaluation is skipped because DLP is not enabled for the user."]
        ScanSkippedExperimentDisabled,
        #[doc = "Scanning was skipped because the message originated from Interop or Babel."]
        ScanSkippedMessageFromUnsupportedOrigin,
        #[doc = "Rule fetch and evaluation are skipped because there is no message to scan. Deprecated: this should not happen since there must be message or attachment for DLP scan."]
        ScanSkippedNoMessage,
        #[doc = "Rule fetch and evaluation are skipped because the user sending message is a non-human user (i.e. a bot)."]
        ScanSkippedNonHumanUser,
        #[doc = "Rule fetch and evaluation are skipped because the user has acknowledged the warning on the message that triggered the Warn violation and sent the message anyway."]
        ScanSkippedUserAcknowledgedWarning,
        #[doc = "Violation is detected and will be logged to BIP (no user-facing action performed)."]
        ScanSucceededAuditOnly,
        #[doc = "Violation is detected. The message/attachment will be blocked (or deleted if this happens in failure recovery), the user will be warned, and the violation will be logged to BIP."]
        ScanSucceededBlock,
        #[doc = "This means no violation is detected on the given message/attachment."]
        ScanSucceededNoViolation,
        #[doc = "Violation is detected. The user will be warned, and the violation will be logged to BIP."]
        ScanSucceededWarn,
        #[doc = "Rules were fetched but some evaluations failed. An audit-only violation was found in the rules that were successfully evaluated. The violation will be logged to BIP (no user-facing action performed)."]
        ScanSucceededWithFailuresAuditOnly,
        #[doc = "Rules were fetched but some evaluations failed. A blocking violation was found in the rules that were successfully evaluated. The message/attachment will be blocked, the user will be notified, and the violation will be logged to BIP. A blocking violation takes precedence over all other violation types."]
        ScanSucceededWithFailuresBlock,
        #[doc = "Rules were fetched but some evaluations failed. No violation was found in the rules that were successfully evaluated."]
        ScanSucceededWithFailuresNoViolation,
        #[doc = "Rules were fetched but some evaluations failed. A warn violation was found in the rules that were successfully evaluated. The user will be warned, and the violation will be logged to BIP."]
        ScanSucceededWithFailuresWarn,
        ScanUnknownOutcome,
    }
    impl AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureAllRulesFailed => "SCAN_FAILURE_ALL_RULES_FAILED" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureException => "SCAN_FAILURE_EXCEPTION" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureIllegalStateForAttachments => "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureRuleFetchFailed => "SCAN_FAILURE_RULE_FETCH_FAILED" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureTimeout => "SCAN_FAILURE_TIMEOUT" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedChangelingEmptyResponse => "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedChangelingPermanentError => "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForActionParams => "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForTrigger => "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoRulesFound => "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedUnsupportedFileType => "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedConsumer => "SCAN_SKIPPED_CONSUMER" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedExperimentDisabled => "SCAN_SKIPPED_EXPERIMENT_DISABLED" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedMessageFromUnsupportedOrigin => "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedNoMessage => "SCAN_SKIPPED_NO_MESSAGE" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedNonHumanUser => "SCAN_SKIPPED_NON_HUMAN_USER" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedUserAcknowledgedWarning => "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededAuditOnly => "SCAN_SUCCEEDED_AUDIT_ONLY" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededBlock => "SCAN_SUCCEEDED_BLOCK" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededNoViolation => "SCAN_SUCCEEDED_NO_VIOLATION" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWarn => "SCAN_SUCCEEDED_WARN" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresAuditOnly => "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresBlock => "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresNoViolation => "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresWarn => "SCAN_SUCCEEDED_WITH_FAILURES_WARN" , AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanUnknownOutcome => "SCAN_UNKNOWN_OUTCOME" , }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome, ()>
        {
            Ok (match s { "SCAN_FAILURE_ALL_RULES_FAILED" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureAllRulesFailed , "SCAN_FAILURE_EXCEPTION" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureException , "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureIllegalStateForAttachments , "SCAN_FAILURE_RULE_FETCH_FAILED" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureRuleFetchFailed , "SCAN_FAILURE_TIMEOUT" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureTimeout , "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedChangelingEmptyResponse , "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedChangelingPermanentError , "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForActionParams , "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForTrigger , "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoRulesFound , "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedUnsupportedFileType , "SCAN_SKIPPED_CONSUMER" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedConsumer , "SCAN_SKIPPED_EXPERIMENT_DISABLED" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedExperimentDisabled , "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedMessageFromUnsupportedOrigin , "SCAN_SKIPPED_NO_MESSAGE" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedNoMessage , "SCAN_SKIPPED_NON_HUMAN_USER" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedNonHumanUser , "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedUserAcknowledgedWarning , "SCAN_SUCCEEDED_AUDIT_ONLY" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededAuditOnly , "SCAN_SUCCEEDED_BLOCK" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededBlock , "SCAN_SUCCEEDED_NO_VIOLATION" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededNoViolation , "SCAN_SUCCEEDED_WARN" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWarn , "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresAuditOnly , "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresBlock , "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresNoViolation , "SCAN_SUCCEEDED_WITH_FAILURES_WARN" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresWarn , "SCAN_UNKNOWN_OUTCOME" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanUnknownOutcome , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "SCAN_FAILURE_ALL_RULES_FAILED" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureAllRulesFailed , "SCAN_FAILURE_EXCEPTION" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureException , "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureIllegalStateForAttachments , "SCAN_FAILURE_RULE_FETCH_FAILED" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureRuleFetchFailed , "SCAN_FAILURE_TIMEOUT" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanFailureTimeout , "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedChangelingEmptyResponse , "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedChangelingPermanentError , "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForActionParams , "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForTrigger , "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedNoRulesFound , "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanRuleEvaluationSkippedUnsupportedFileType , "SCAN_SKIPPED_CONSUMER" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedConsumer , "SCAN_SKIPPED_EXPERIMENT_DISABLED" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedExperimentDisabled , "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedMessageFromUnsupportedOrigin , "SCAN_SKIPPED_NO_MESSAGE" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedNoMessage , "SCAN_SKIPPED_NON_HUMAN_USER" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedNonHumanUser , "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSkippedUserAcknowledgedWarning , "SCAN_SUCCEEDED_AUDIT_ONLY" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededAuditOnly , "SCAN_SUCCEEDED_BLOCK" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededBlock , "SCAN_SUCCEEDED_NO_VIOLATION" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededNoViolation , "SCAN_SUCCEEDED_WARN" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWarn , "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresAuditOnly , "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresBlock , "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresNoViolation , "SCAN_SUCCEEDED_WITH_FAILURES_WARN" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanSucceededWithFailuresWarn , "SCAN_UNKNOWN_OUTCOME" => AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome :: ScanUnknownOutcome , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedBackendUploadMetadataDlpScanOutcome
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedBackendUploadMetadataVirusScanResult {
        Clean,
        Error,
        Infected,
        #[doc = "The document violates Google’s policy for executables and archives."]
        PolicyViolation,
        UnknownVirusScanResult,
    }
    impl AppsDynamiteSharedBackendUploadMetadataVirusScanResult {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Clean => "CLEAN",
                AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Error => "ERROR",
                AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Infected => "INFECTED",
                AppsDynamiteSharedBackendUploadMetadataVirusScanResult::PolicyViolation => {
                    "POLICY_VIOLATION"
                }
                AppsDynamiteSharedBackendUploadMetadataVirusScanResult::UnknownVirusScanResult => {
                    "UNKNOWN_VIRUS_SCAN_RESULT"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedBackendUploadMetadataVirusScanResult {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedBackendUploadMetadataVirusScanResult {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedBackendUploadMetadataVirusScanResult, ()>
        {
            Ok(match s {
                "CLEAN" => AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Clean,
                "ERROR" => AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Error,
                "INFECTED" => AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Infected,
                "POLICY_VIOLATION" => {
                    AppsDynamiteSharedBackendUploadMetadataVirusScanResult::PolicyViolation
                }
                "UNKNOWN_VIRUS_SCAN_RESULT" => {
                    AppsDynamiteSharedBackendUploadMetadataVirusScanResult::UnknownVirusScanResult
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedBackendUploadMetadataVirusScanResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedBackendUploadMetadataVirusScanResult {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedBackendUploadMetadataVirusScanResult {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CLEAN" => AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Clean,
                "ERROR" => AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Error,
                "INFECTED" => AppsDynamiteSharedBackendUploadMetadataVirusScanResult::Infected,
                "POLICY_VIOLATION" => {
                    AppsDynamiteSharedBackendUploadMetadataVirusScanResult::PolicyViolation
                }
                "UNKNOWN_VIRUS_SCAN_RESULT" => {
                    AppsDynamiteSharedBackendUploadMetadataVirusScanResult::UnknownVirusScanResult
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedBackendUploadMetadataVirusScanResult
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedBackendUploadMetadataVirusScanResult
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedCalendarEventAnnotationData {
        #[serde(
            rename = "calendarEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub calendar_event: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent,
        >,
        #[doc = "Notification about the creation of an event."]
        #[serde(
            rename = "eventCreation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_creation: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedCalendarEventAnnotationDataEventCreation,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedCalendarEventAnnotationData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedCalendarEventAnnotationData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent {
        #[doc = "The end time of the event."]
        #[serde(
            rename = "endTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub end_time: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime,
        >,
        #[doc = "ID of the event."]
        #[serde(
            rename = "eventId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_id: ::std::option::Option<String>,
        #[doc = "The start time of the event."]
        #[serde(
            rename = "startTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_time: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime,
        >,
        #[doc = "Title of the event (at the time the message was generated)."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime {
        #[doc = "All day event."]
        #[serde(
            rename = "allDay",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub all_day: ::std::option::Option<crate::schemas::Date>,
        #[doc = "Non all day event."]
        #[serde(
            rename = "timed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub timed: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedCalendarEventAnnotationDataEventCreation {}
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedCallAnnotationData {
        #[doc = "Timestamp when the call ended. Used to render the call ended system message."]
        #[serde(
            rename = "callEndedTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub call_ended_timestamp: ::std::option::Option<String>,
        #[doc = "Required. Call metadata required to create the call artifacts. For now, the metadata contains only the call id to identify the call. This field allows additional data (e.g. voice call type) to be added if needed in the future."]
        #[serde(
            rename = "callMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub call_metadata: ::std::option::Option<crate::schemas::AppsDynamiteSharedCallMetadata>,
        #[doc = "Required. Indicates the call status for the space. Used to determine the chip’s state."]
        #[serde(
            rename = "callStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub call_status:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedCallAnnotationDataCallStatus>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedCallAnnotationData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedCallAnnotationData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedCallAnnotationDataCallStatus {
        #[doc = "Indicates that the call has ended."]
        CallEnded,
        #[doc = "Indicates that the call is missed."]
        CallMissed,
        #[doc = "Indicates that the call has started."]
        CallStarted,
        #[doc = "Default value for the enum. DO NOT USE."]
        CallStatusUnspecified,
    }
    impl AppsDynamiteSharedCallAnnotationDataCallStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedCallAnnotationDataCallStatus::CallEnded => "CALL_ENDED",
                AppsDynamiteSharedCallAnnotationDataCallStatus::CallMissed => "CALL_MISSED",
                AppsDynamiteSharedCallAnnotationDataCallStatus::CallStarted => "CALL_STARTED",
                AppsDynamiteSharedCallAnnotationDataCallStatus::CallStatusUnspecified => {
                    "CALL_STATUS_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedCallAnnotationDataCallStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedCallAnnotationDataCallStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedCallAnnotationDataCallStatus, ()> {
            Ok(match s {
                "CALL_ENDED" => AppsDynamiteSharedCallAnnotationDataCallStatus::CallEnded,
                "CALL_MISSED" => AppsDynamiteSharedCallAnnotationDataCallStatus::CallMissed,
                "CALL_STARTED" => AppsDynamiteSharedCallAnnotationDataCallStatus::CallStarted,
                "CALL_STATUS_UNSPECIFIED" => {
                    AppsDynamiteSharedCallAnnotationDataCallStatus::CallStatusUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedCallAnnotationDataCallStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedCallAnnotationDataCallStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedCallAnnotationDataCallStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CALL_ENDED" => AppsDynamiteSharedCallAnnotationDataCallStatus::CallEnded,
                "CALL_MISSED" => AppsDynamiteSharedCallAnnotationDataCallStatus::CallMissed,
                "CALL_STARTED" => AppsDynamiteSharedCallAnnotationDataCallStatus::CallStarted,
                "CALL_STATUS_UNSPECIFIED" => {
                    AppsDynamiteSharedCallAnnotationDataCallStatus::CallStatusUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedCallAnnotationDataCallStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedCallAnnotationDataCallStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedCallMetadata {
        #[doc = "Metadata specific for the Meet call."]
        #[serde(
            rename = "meetMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meet_metadata: ::std::option::Option<crate::schemas::AppsDynamiteSharedMeetMetadata>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedCallMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedCallMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedCardClickSuggestion {
        #[doc = "Identify the button/action that created the suggestion. A simple example would be a card button within the stream, or the id which can identify a specific suggestion."]
        #[serde(
            rename = "actionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_id: ::std::option::Option<String>,
        #[doc = "The message_id for the message that was posted by the app/bot."]
        #[serde(
            rename = "suggestionMessageId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suggestion_message_id: ::std::option::Option<crate::schemas::MessageId>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedCardClickSuggestion {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedCardClickSuggestion {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedChatItem {
        #[doc = "Information needed to render the specific type of feed item."]
        #[serde(
            rename = "activityInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub activity_info:
            ::std::option::Option<Vec<crate::schemas::AppsDynamiteSharedChatItemActivityInfo>>,
        #[doc = "Only populated on read path and should not be persisted in storage."]
        #[serde(
            rename = "groupInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_info: ::std::option::Option<crate::schemas::AppsDynamiteSharedChatItemGroupInfo>,
        #[doc = "Additional information about the original chat message that isn’t captured in the top-level message proto."]
        #[serde(
            rename = "messageInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_info: ::std::option::Option<crate::schemas::AppsDynamiteSharedMessageInfo>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedChatItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedChatItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedChatItemActivityInfo {
        #[serde(
            rename = "feedItemNudge",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feed_item_nudge: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedChatItemActivityInfoFeedItemNudge,
        >,
        #[serde(
            rename = "feedItemReactions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feed_item_reactions: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedChatItemActivityInfoFeedItemReactions,
        >,
        #[serde(
            rename = "feedItemThreadReply",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feed_item_thread_reply: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply,
        >,
        #[serde(
            rename = "feedItemUserMention",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feed_item_user_mention: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedChatItemActivityInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedChatItemActivityInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedChatItemActivityInfoFeedItemNudge {
        #[doc = "Nudge type of the nudge feed item."]
        #[serde(
            rename = "nudgeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub nudge_type: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedChatItemActivityInfoFeedItemNudge
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedChatItemActivityInfoFeedItemNudge {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType {
        #[doc = "The message creator is nudged since the message may require a follow-up."]
        FollowUp,
        #[doc = "The message receiver is nudged since the message may require a reply."]
        Reply,
        Undefined,
    }
    impl AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::FollowUp => {
                    "FOLLOW_UP"
                }
                AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::Reply => "REPLY",
                AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::Undefined => {
                    "UNDEFINED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType, ()>
        {
            Ok(match s {
                "FOLLOW_UP" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::FollowUp
                }
                "REPLY" => AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::Reply,
                "UNDEFINED" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::Undefined
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FOLLOW_UP" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::FollowUp
                }
                "REPLY" => AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::Reply,
                "UNDEFINED" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType::Undefined
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedChatItemActivityInfoFeedItemNudgeNudgeType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedChatItemActivityInfoFeedItemReactions {}
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply {
        #[doc = "Reply type of the thread reply feed item. The field is not persisted in storage. It’s populated when constructing Activity Feed payload."]
        #[serde(
            rename = "replyType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reply_type: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType {
        #[doc = "The thread reply feed item is for a thread follower who’s not the root message poster."]
        Follower,
        #[doc = "The thread reply feed item is for the root message poster."]
        Root,
        Unspecified,
    }
    impl AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Follower => {
                    "FOLLOWER"
                }
                AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Root => "ROOT",
                AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Unspecified => {
                    "UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str>
        for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType,
            (),
        > {
            Ok(match s {
                "FOLLOWER" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Follower
                }
                "ROOT" => AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Root,
                "UNSPECIFIED" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Unspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FOLLOWER" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Follower
                }
                "ROOT" => AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Root,
                "UNSPECIFIED" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType::Unspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReplyReplyType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention {
        #[doc = "User mention type"]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType {
        #[doc = "Mentioned by @all."]
        All,
        #[doc = "Mentioned directly by name."]
        Direct,
        #[doc = "Mention type not specified."]
        TypeUnspecified,
    }
    impl AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::All => "ALL",
                AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::Direct => "DIRECT",
                AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::TypeUnspecified => {
                    "TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType, ()>
        {
            Ok(match s {
                "ALL" => AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::All,
                "DIRECT" => AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::Direct,
                "TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::TypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ALL" => AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::All,
                "DIRECT" => AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::Direct,
                "TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType::TypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedChatItemActivityInfoFeedItemUserMentionType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedChatItemGroupInfo {
        #[doc = "This is needed to determine what type of group the source message came from to support click-to-source."]
        #[serde(
            rename = "attributeCheckerGroupType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attribute_checker_group_type: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType,
        >,
        #[serde(
            rename = "groupName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_name: ::std::option::Option<String>,
        #[doc = "Timestamp of when the group containing the message has been read by the user."]
        #[serde(
            rename = "groupReadTimeUsec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub group_read_time_usec: ::std::option::Option<i64>,
        #[doc = "Indicates whether the group has inline replies enabled. If enabled, clients will render the space with inline replies."]
        #[serde(
            rename = "inlineThreadingEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub inline_threading_enabled: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedChatItemGroupInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedChatItemGroupInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType {
        #[doc = "Represents an Activity Feed space. These groups are modeled like flat rooms and contain items for users to catch up on important things. Each user should only have one group of this type. See go/activity-feed. Deprecated: The go/activity-feed project is cancelled and this should no longer be used. LINT.ThenChange(//depot/google3/logs/proto/apps_dynamite/dynamite_visual_element_entry.proto:LoggingGroupType,//depot/google3/java/com/google/apps/dynamite/v1/web/ui/group/groups.js:LoggingGroupType)"]
        ActivityFeed,
        #[doc = "LINT.IfChange"]
        AttributeCheckerGroupTypeUnspecified,
        #[doc = "A flat room that contains a single thread."]
        FlatRoom,
        #[doc = "A group DM that has multiple human users with immutable group membership. Deprecated. Use IMMUTABLE_MEMBERSHIP_HUMAN_DM instead."]
        ImmutableMembershipGroupDm,
        #[doc = "A DM with immutable group membership. It can be a 1:1 DM or a group DM with multiple human users."]
        ImmutableMembershipHumanDm,
        #[doc = "A 1:1 DM between a human user and a bot."]
        OneToOneBotDm,
        #[doc = "A 1:1 DM that has two human users. Deprecated. Use IMMUTABLE_MEMBERSHIP_HUMAN_DM instead."]
        OneToOneHumanDm,
        #[doc = "A post room. Topics in this room are organized in a post/reply style. See the design doc for more details: go/PostRoomsInDynamite. Deprecated. Post rooms are no longer supported."]
        PostRoom,
        #[doc = "A threaded room. Topics in this room are threaded, and users can reply to any topic."]
        ThreadedRoom,
    }
    impl AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ActivityFeed => "ACTIVITY_FEED" , AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: AttributeCheckerGroupTypeUnspecified => "ATTRIBUTE_CHECKER_GROUP_TYPE_UNSPECIFIED" , AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: FlatRoom => "FLAT_ROOM" , AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ImmutableMembershipGroupDm => "IMMUTABLE_MEMBERSHIP_GROUP_DM" , AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ImmutableMembershipHumanDm => "IMMUTABLE_MEMBERSHIP_HUMAN_DM" , AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: OneToOneBotDm => "ONE_TO_ONE_BOT_DM" , AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: OneToOneHumanDm => "ONE_TO_ONE_HUMAN_DM" , AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: PostRoom => "POST_ROOM" , AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ThreadedRoom => "THREADED_ROOM" , }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType, ()>
        {
            Ok (match s { "ACTIVITY_FEED" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ActivityFeed , "ATTRIBUTE_CHECKER_GROUP_TYPE_UNSPECIFIED" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: AttributeCheckerGroupTypeUnspecified , "FLAT_ROOM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: FlatRoom , "IMMUTABLE_MEMBERSHIP_GROUP_DM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ImmutableMembershipGroupDm , "IMMUTABLE_MEMBERSHIP_HUMAN_DM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ImmutableMembershipHumanDm , "ONE_TO_ONE_BOT_DM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: OneToOneBotDm , "ONE_TO_ONE_HUMAN_DM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: OneToOneHumanDm , "POST_ROOM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: PostRoom , "THREADED_ROOM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ThreadedRoom , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ACTIVITY_FEED" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ActivityFeed , "ATTRIBUTE_CHECKER_GROUP_TYPE_UNSPECIFIED" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: AttributeCheckerGroupTypeUnspecified , "FLAT_ROOM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: FlatRoom , "IMMUTABLE_MEMBERSHIP_GROUP_DM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ImmutableMembershipGroupDm , "IMMUTABLE_MEMBERSHIP_HUMAN_DM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ImmutableMembershipHumanDm , "ONE_TO_ONE_BOT_DM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: OneToOneBotDm , "ONE_TO_ONE_HUMAN_DM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: OneToOneHumanDm , "POST_ROOM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: PostRoom , "THREADED_ROOM" => AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType :: ThreadedRoom , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedChatItemGroupInfoAttributeCheckerGroupType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedContentReportType {
        #[doc = "Required. Google-defined system violation, covering the most common violations."]
        #[serde(
            rename = "systemViolation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub system_violation: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedContentReportTypeSystemViolation,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedContentReportType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedContentReportType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedContentReportTypeSystemViolation {
        #[doc = "“Confidential information”"]
        ConfidentialInformation,
        #[doc = "“Discrimination or harmful stereotypes against anyone, including protected groups”"]
        Discrimination,
        #[doc = "“Explicit content that’s graphic, violent, or otherwise inappropriate”"]
        ExplicitContent,
        #[doc = "Phishing, impersonation/misrepresentation, or deceiving other users into sharing information under false pretenses."]
        Fraud,
        #[doc = "“Harassment, offensive, or rude behavior”"]
        Harassment,
        #[doc = "Promoting, organizing, or engaging in illegal activities."]
        IllegalActivities,
        #[doc = "Malware, viruses, Trojan horses, corrupted files, destructive code, etc."]
        Malware,
        #[doc = "“Something else”"]
        Other,
        #[doc = "“Sensitive information”"]
        SensitiveInformation,
        #[doc = "“Spam”"]
        Spam,
        #[doc = "Default value if unset. Do not use directly. This value should not appear as a selectable violation during content reporting."]
        ViolationUnspecified,
    }
    impl AppsDynamiteSharedContentReportTypeSystemViolation {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedContentReportTypeSystemViolation::ConfidentialInformation => {
                    "CONFIDENTIAL_INFORMATION"
                }
                AppsDynamiteSharedContentReportTypeSystemViolation::Discrimination => {
                    "DISCRIMINATION"
                }
                AppsDynamiteSharedContentReportTypeSystemViolation::ExplicitContent => {
                    "EXPLICIT_CONTENT"
                }
                AppsDynamiteSharedContentReportTypeSystemViolation::Fraud => "FRAUD",
                AppsDynamiteSharedContentReportTypeSystemViolation::Harassment => "HARASSMENT",
                AppsDynamiteSharedContentReportTypeSystemViolation::IllegalActivities => {
                    "ILLEGAL_ACTIVITIES"
                }
                AppsDynamiteSharedContentReportTypeSystemViolation::Malware => "MALWARE",
                AppsDynamiteSharedContentReportTypeSystemViolation::Other => "OTHER",
                AppsDynamiteSharedContentReportTypeSystemViolation::SensitiveInformation => {
                    "SENSITIVE_INFORMATION"
                }
                AppsDynamiteSharedContentReportTypeSystemViolation::Spam => "SPAM",
                AppsDynamiteSharedContentReportTypeSystemViolation::ViolationUnspecified => {
                    "VIOLATION_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedContentReportTypeSystemViolation {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedContentReportTypeSystemViolation {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedContentReportTypeSystemViolation, ()> {
            Ok(match s {
                "CONFIDENTIAL_INFORMATION" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::ConfidentialInformation
                }
                "DISCRIMINATION" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::Discrimination
                }
                "EXPLICIT_CONTENT" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::ExplicitContent
                }
                "FRAUD" => AppsDynamiteSharedContentReportTypeSystemViolation::Fraud,
                "HARASSMENT" => AppsDynamiteSharedContentReportTypeSystemViolation::Harassment,
                "ILLEGAL_ACTIVITIES" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::IllegalActivities
                }
                "MALWARE" => AppsDynamiteSharedContentReportTypeSystemViolation::Malware,
                "OTHER" => AppsDynamiteSharedContentReportTypeSystemViolation::Other,
                "SENSITIVE_INFORMATION" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::SensitiveInformation
                }
                "SPAM" => AppsDynamiteSharedContentReportTypeSystemViolation::Spam,
                "VIOLATION_UNSPECIFIED" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::ViolationUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedContentReportTypeSystemViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedContentReportTypeSystemViolation {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedContentReportTypeSystemViolation {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CONFIDENTIAL_INFORMATION" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::ConfidentialInformation
                }
                "DISCRIMINATION" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::Discrimination
                }
                "EXPLICIT_CONTENT" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::ExplicitContent
                }
                "FRAUD" => AppsDynamiteSharedContentReportTypeSystemViolation::Fraud,
                "HARASSMENT" => AppsDynamiteSharedContentReportTypeSystemViolation::Harassment,
                "ILLEGAL_ACTIVITIES" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::IllegalActivities
                }
                "MALWARE" => AppsDynamiteSharedContentReportTypeSystemViolation::Malware,
                "OTHER" => AppsDynamiteSharedContentReportTypeSystemViolation::Other,
                "SENSITIVE_INFORMATION" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::SensitiveInformation
                }
                "SPAM" => AppsDynamiteSharedContentReportTypeSystemViolation::Spam,
                "VIOLATION_UNSPECIFIED" => {
                    AppsDynamiteSharedContentReportTypeSystemViolation::ViolationUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedContentReportTypeSystemViolation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedContentReportTypeSystemViolation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedCustomEmoji {
        #[doc = "ID for the underlying image data in Blobstore. This field should *only* be present in Spanner or within the server, but should not be exposed in public APIs."]
        #[serde(
            rename = "blobId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub blob_id: ::std::option::Option<String>,
        #[doc = "Content type of the file used to upload the emoji. Used for takeout. Written to Spanner when the emoji is created."]
        #[serde(
            rename = "contentType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_type: ::std::option::Option<String>,
        #[doc = "Time when the Emoji was created, in microseconds. This field may be present in Spanner, within the server, or in public APIs."]
        #[serde(
            rename = "createTimeMicros",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub create_time_micros: ::std::option::Option<i64>,
        #[doc = "This field should *never* be persisted to Spanner."]
        #[serde(
            rename = "creatorUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub creator_user_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Time when the emoji was deleted, in microseconds. This field may be present in Spanner, within the server, or in public APIs. Only present if the emoji has been deleted."]
        #[serde(
            rename = "deleteTimeMicros",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub delete_time_micros: ::std::option::Option<i64>,
        #[doc = "Output only. A short-lived URL clients can use for directly accessing a custom emoji image. This field is intended for API consumption, and should *never* be persisted to Spanner."]
        #[serde(
            rename = "ephemeralUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ephemeral_url: ::std::option::Option<String>,
        #[doc = "This field should *never* be persisted to Spanner."]
        #[serde(
            rename = "ownerCustomerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub owner_customer_id: ::std::option::Option<crate::schemas::CustomerId>,
        #[doc = "Opaque token that clients use to construct the URL for accessing the custom emoji’s image data. This field is intended for API consumption, and should *never* be persisted to Spanner."]
        #[serde(
            rename = "readToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub read_token: ::std::option::Option<String>,
        #[doc = "User-provided, human-readable ID for the custom emoji. Users are expected to observe this field in the UI instead of the UUID. This shortcode should be unique within an organization, but has no global uniqueness guarantees, unlike the UUID. This field should *never* be persisted to Spanner."]
        #[serde(
            rename = "shortcode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shortcode: ::std::option::Option<String>,
        #[doc = "Snapshot of the current state of the emoji, which may differ from the source-of-truth in the CustomEmojis table. This field should *never* be persisted to Spanner."]
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state: ::std::option::Option<crate::schemas::AppsDynamiteSharedCustomEmojiState>,
        #[serde(
            rename = "updateTimeMicros",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub update_time_micros: ::std::option::Option<i64>,
        #[doc = "Unique key for a custom emoji resource. Required. This field is *always* populated."]
        #[serde(
            rename = "uuid",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub uuid: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedCustomEmoji {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedCustomEmoji {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedCustomEmojiState {
        #[doc = "Emoji is removed everywhere and is not available to end-users."]
        EmojiDeleted,
        #[doc = "Emoji is visible and available to be used, subject to access control requirements."]
        EmojiEnabled,
        #[doc = "Emoji is hidden from pickers, so new usages are not allowed, but is not removed from existing embeddings."]
        EmojiHidden,
        EmojiStateUnspecified,
        #[doc = "Emoji can no longer be used (e.g. due to a shortcode conflict), but is not removed from existing embeddings."]
        EmojiSystemDisabled,
    }
    impl AppsDynamiteSharedCustomEmojiState {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedCustomEmojiState::EmojiDeleted => "EMOJI_DELETED",
                AppsDynamiteSharedCustomEmojiState::EmojiEnabled => "EMOJI_ENABLED",
                AppsDynamiteSharedCustomEmojiState::EmojiHidden => "EMOJI_HIDDEN",
                AppsDynamiteSharedCustomEmojiState::EmojiStateUnspecified => {
                    "EMOJI_STATE_UNSPECIFIED"
                }
                AppsDynamiteSharedCustomEmojiState::EmojiSystemDisabled => "EMOJI_SYSTEM_DISABLED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedCustomEmojiState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedCustomEmojiState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteSharedCustomEmojiState, ()> {
            Ok(match s {
                "EMOJI_DELETED" => AppsDynamiteSharedCustomEmojiState::EmojiDeleted,
                "EMOJI_ENABLED" => AppsDynamiteSharedCustomEmojiState::EmojiEnabled,
                "EMOJI_HIDDEN" => AppsDynamiteSharedCustomEmojiState::EmojiHidden,
                "EMOJI_STATE_UNSPECIFIED" => {
                    AppsDynamiteSharedCustomEmojiState::EmojiStateUnspecified
                }
                "EMOJI_SYSTEM_DISABLED" => AppsDynamiteSharedCustomEmojiState::EmojiSystemDisabled,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedCustomEmojiState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedCustomEmojiState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedCustomEmojiState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EMOJI_DELETED" => AppsDynamiteSharedCustomEmojiState::EmojiDeleted,
                "EMOJI_ENABLED" => AppsDynamiteSharedCustomEmojiState::EmojiEnabled,
                "EMOJI_HIDDEN" => AppsDynamiteSharedCustomEmojiState::EmojiHidden,
                "EMOJI_STATE_UNSPECIFIED" => {
                    AppsDynamiteSharedCustomEmojiState::EmojiStateUnspecified
                }
                "EMOJI_SYSTEM_DISABLED" => AppsDynamiteSharedCustomEmojiState::EmojiSystemDisabled,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedCustomEmojiState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedCustomEmojiState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedDimension {
        #[serde(
            rename = "height",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub height: ::std::option::Option<i32>,
        #[serde(
            rename = "width",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub width: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedDimension {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedDimension {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedDlpMetricsMetadata {
        #[doc = "\\[required\\] Describes the DLP status of message send and attachment upload events."]
        #[serde(
            rename = "dlpStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dlp_status:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedDlpMetricsMetadataDlpStatus>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedDlpMetricsMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedDlpMetricsMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        #[doc = "Rule fetch and evaluation are skipped because DLP experiment is not enabled."]
        DlpDisabled,
        #[doc = "Rule fetch and evaluation are skipped because there is no rule to be fetched (e.g. message is sent from a consumer, or there is no message.)"]
        DlpEnabledNoRuleFetch,
        #[doc = "Rule fetch and evaluation were performed and completed successfully."]
        DlpEnabledRulesFetchedAndEvaluated,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because none of the rules are applicable."]
        DlpEnabledRulesFetchedNoApplicableRules,
        #[doc = "Rule fetch happened, but rule evalution is skipped because the fetch returned no rules."]
        DlpEnabledRulesFetchedNoRules,
        #[doc = "Generic DLP failure. This case covers any other errors/exceptions in the Chat backend that caused the DLP scan to fail."]
        DlpEnabledScanFailed,
        #[doc = "DLP scan was attempted but timed out."]
        DlpEnabledScanTimeout,
        DlpStatusUnknown,
    }
    impl AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpDisabled => "DLP_DISABLED" , AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledNoRuleFetch => "DLP_ENABLED_NO_RULE_FETCH" , AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedAndEvaluated => "DLP_ENABLED_RULES_FETCHED_AND_EVALUATED" , AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedNoApplicableRules => "DLP_ENABLED_RULES_FETCHED_NO_APPLICABLE_RULES" , AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedNoRules => "DLP_ENABLED_RULES_FETCHED_NO_RULES" , AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledScanFailed => "DLP_ENABLED_SCAN_FAILED" , AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledScanTimeout => "DLP_ENABLED_SCAN_TIMEOUT" , AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpStatusUnknown => "DLP_STATUS_UNKNOWN" , }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedDlpMetricsMetadataDlpStatus, ()> {
            Ok (match s { "DLP_DISABLED" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpDisabled , "DLP_ENABLED_NO_RULE_FETCH" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledNoRuleFetch , "DLP_ENABLED_RULES_FETCHED_AND_EVALUATED" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedAndEvaluated , "DLP_ENABLED_RULES_FETCHED_NO_APPLICABLE_RULES" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedNoApplicableRules , "DLP_ENABLED_RULES_FETCHED_NO_RULES" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedNoRules , "DLP_ENABLED_SCAN_FAILED" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledScanFailed , "DLP_ENABLED_SCAN_TIMEOUT" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledScanTimeout , "DLP_STATUS_UNKNOWN" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpStatusUnknown , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DLP_DISABLED" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpDisabled , "DLP_ENABLED_NO_RULE_FETCH" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledNoRuleFetch , "DLP_ENABLED_RULES_FETCHED_AND_EVALUATED" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedAndEvaluated , "DLP_ENABLED_RULES_FETCHED_NO_APPLICABLE_RULES" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedNoApplicableRules , "DLP_ENABLED_RULES_FETCHED_NO_RULES" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledRulesFetchedNoRules , "DLP_ENABLED_SCAN_FAILED" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledScanFailed , "DLP_ENABLED_SCAN_TIMEOUT" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpEnabledScanTimeout , "DLP_STATUS_UNKNOWN" => AppsDynamiteSharedDlpMetricsMetadataDlpStatus :: DlpStatusUnknown , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedDlpMetricsMetadataDlpStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedDocument {
        #[doc = "Unique file ID."]
        #[serde(
            rename = "fileId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub file_id: ::std::option::Option<String>,
        #[doc = "Justification to explain why this document is being suggested."]
        #[serde(
            rename = "justification",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub justification: ::std::option::Option<crate::schemas::AppsDynamiteSharedJustification>,
        #[doc = "Time the document was last modified."]
        #[serde(
            rename = "lastModifiedTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_modified_time: ::std::option::Option<String>,
        #[doc = "Used to determine which icon to render (e.g. docs, slides, sheets)"]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Title of the document."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
        #[doc = "URL of the document."]
        #[serde(
            rename = "url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedDocument {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedDocument {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedEmoji {
        #[doc = "A custom emoji."]
        #[serde(
            rename = "customEmoji",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub custom_emoji: ::std::option::Option<crate::schemas::AppsDynamiteSharedCustomEmoji>,
        #[doc = "A basic emoji represented by a unicode string."]
        #[serde(
            rename = "unicode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub unicode: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedEmoji {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedEmoji {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedFindDocumentSuggestion {
        #[doc = "List of documents to render as suggestions."]
        #[serde(
            rename = "documentSuggestions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub document_suggestions:
            ::std::option::Option<Vec<crate::schemas::AppsDynamiteSharedDocument>>,
        #[doc = "Whether to show the action buttons in the card for the suggestions."]
        #[serde(
            rename = "showActionButtons",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub show_action_buttons: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedFindDocumentSuggestion {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedFindDocumentSuggestion {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedGroupDetails {
        #[doc = "A simple text that describes the purpose of a single Group, the general theme of the topics to be posted and/or the denominator of the Group participants."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "A simple text describing the rules and expectations from members when participating in conversation."]
        #[serde(
            rename = "guidelines",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub guidelines: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedGroupDetails {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedGroupDetails {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedGroupVisibility {
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state: ::std::option::Option<crate::schemas::AppsDynamiteSharedGroupVisibilityState>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedGroupVisibility {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedGroupVisibility {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedGroupVisibilityState {
        #[doc = "Explicitly invited users may join the room."]
        Private,
        #[doc = "Anyone in the domain may join the room."]
        Public,
        #[doc = "Do not use."]
        Unknown,
    }
    impl AppsDynamiteSharedGroupVisibilityState {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedGroupVisibilityState::Private => "PRIVATE",
                AppsDynamiteSharedGroupVisibilityState::Public => "PUBLIC",
                AppsDynamiteSharedGroupVisibilityState::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedGroupVisibilityState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedGroupVisibilityState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteSharedGroupVisibilityState, ()> {
            Ok(match s {
                "PRIVATE" => AppsDynamiteSharedGroupVisibilityState::Private,
                "PUBLIC" => AppsDynamiteSharedGroupVisibilityState::Public,
                "UNKNOWN" => AppsDynamiteSharedGroupVisibilityState::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedGroupVisibilityState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedGroupVisibilityState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedGroupVisibilityState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "PRIVATE" => AppsDynamiteSharedGroupVisibilityState::Private,
                "PUBLIC" => AppsDynamiteSharedGroupVisibilityState::Public,
                "UNKNOWN" => AppsDynamiteSharedGroupVisibilityState::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedGroupVisibilityState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedGroupVisibilityState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedJustification {
        #[doc = "Time the action took place."]
        #[serde(
            rename = "actionTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_time: ::std::option::Option<String>,
        #[doc = "Type of action performed on the document."]
        #[serde(
            rename = "actionType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_type:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedJustificationActionType>,
        #[doc = "Owner of the document."]
        #[serde(
            rename = "documentOwner",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub document_owner:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedJustificationPerson>,
        #[doc = "Words or phrases from the user’s query that describes the document content. (Ex: Users query is “Can you share the document about Bullseye?” the extracted topic would be “Bullseye”)."]
        #[serde(
            rename = "topics",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub topics: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedJustification {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedJustification {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedJustificationActionType {
        #[doc = "Unspecified action."]
        ActionTypeUnspecified,
        #[doc = "Resolved comment on document."]
        CommentResolved,
        #[doc = "Commented on document."]
        Commented,
        #[doc = "Created document."]
        Created,
        #[doc = "Edited document."]
        Edited,
        #[doc = "Presented document."]
        Presented,
        #[doc = "Sent document over chat/email."]
        Sent,
        #[doc = "Shared document."]
        Shared,
        #[doc = "Viewed document."]
        Viewed,
    }
    impl AppsDynamiteSharedJustificationActionType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedJustificationActionType::ActionTypeUnspecified => {
                    "ACTION_TYPE_UNSPECIFIED"
                }
                AppsDynamiteSharedJustificationActionType::CommentResolved => "COMMENT_RESOLVED",
                AppsDynamiteSharedJustificationActionType::Commented => "COMMENTED",
                AppsDynamiteSharedJustificationActionType::Created => "CREATED",
                AppsDynamiteSharedJustificationActionType::Edited => "EDITED",
                AppsDynamiteSharedJustificationActionType::Presented => "PRESENTED",
                AppsDynamiteSharedJustificationActionType::Sent => "SENT",
                AppsDynamiteSharedJustificationActionType::Shared => "SHARED",
                AppsDynamiteSharedJustificationActionType::Viewed => "VIEWED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedJustificationActionType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedJustificationActionType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedJustificationActionType, ()> {
            Ok(match s {
                "ACTION_TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedJustificationActionType::ActionTypeUnspecified
                }
                "COMMENT_RESOLVED" => AppsDynamiteSharedJustificationActionType::CommentResolved,
                "COMMENTED" => AppsDynamiteSharedJustificationActionType::Commented,
                "CREATED" => AppsDynamiteSharedJustificationActionType::Created,
                "EDITED" => AppsDynamiteSharedJustificationActionType::Edited,
                "PRESENTED" => AppsDynamiteSharedJustificationActionType::Presented,
                "SENT" => AppsDynamiteSharedJustificationActionType::Sent,
                "SHARED" => AppsDynamiteSharedJustificationActionType::Shared,
                "VIEWED" => AppsDynamiteSharedJustificationActionType::Viewed,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedJustificationActionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedJustificationActionType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedJustificationActionType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTION_TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedJustificationActionType::ActionTypeUnspecified
                }
                "COMMENT_RESOLVED" => AppsDynamiteSharedJustificationActionType::CommentResolved,
                "COMMENTED" => AppsDynamiteSharedJustificationActionType::Commented,
                "CREATED" => AppsDynamiteSharedJustificationActionType::Created,
                "EDITED" => AppsDynamiteSharedJustificationActionType::Edited,
                "PRESENTED" => AppsDynamiteSharedJustificationActionType::Presented,
                "SENT" => AppsDynamiteSharedJustificationActionType::Sent,
                "SHARED" => AppsDynamiteSharedJustificationActionType::Shared,
                "VIEWED" => AppsDynamiteSharedJustificationActionType::Viewed,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedJustificationActionType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedJustificationActionType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedJustificationPerson {
        #[doc = "Whether the person is the recipient of the suggestions."]
        #[serde(
            rename = "isRecipient",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_recipient: ::std::option::Option<bool>,
        #[doc = "Obfuscated user ID."]
        #[serde(
            rename = "user",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user: ::std::option::Option<crate::schemas::UserId>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedJustificationPerson {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedJustificationPerson {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedMeetMetadata {
        #[doc = "Required. A globally unique code (e.g. “cxv-zbgj-wzw”) that points to a meeting space. Note: Meeting codes may be regenerated, which will cause old meeting codes to become invalid."]
        #[serde(
            rename = "meetingCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_code: ::std::option::Option<String>,
        #[doc = "Required. A URL, in the format “https://meet.google.com/\\*” (e.g. https://meet.google.com/cxv-zbgj-wzw), to identify and access the meeting space."]
        #[serde(
            rename = "meetingUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedMeetMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedMeetMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedMessageInfo {
        #[doc = "Id of the source chat message. This is kept here because the top-level message ID to refers the AF message ID."]
        #[serde(
            rename = "messageId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_id: ::std::option::Option<crate::schemas::MessageId>,
        #[doc = "The type of the source chat message."]
        #[serde(
            rename = "messageType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_type:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedMessageInfoMessageType>,
        #[doc = "Timestamp of when the topic containing the message has been read by the user. This is populated if the message references an inline reply, in which case the space may be marked as read but the topic still has unread messages."]
        #[serde(
            rename = "topicReadTimeUsec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub topic_read_time_usec: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedMessageInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedMessageInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedMessageInfoMessageType {
        #[doc = "The source chat message is a threaded reply to another message."]
        InlineReply,
        #[doc = "Default value where type is not specified."]
        MessageTypeUnspecified,
    }
    impl AppsDynamiteSharedMessageInfoMessageType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedMessageInfoMessageType::InlineReply => "INLINE_REPLY",
                AppsDynamiteSharedMessageInfoMessageType::MessageTypeUnspecified => {
                    "MESSAGE_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedMessageInfoMessageType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedMessageInfoMessageType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedMessageInfoMessageType, ()> {
            Ok(match s {
                "INLINE_REPLY" => AppsDynamiteSharedMessageInfoMessageType::InlineReply,
                "MESSAGE_TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedMessageInfoMessageType::MessageTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedMessageInfoMessageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedMessageInfoMessageType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedMessageInfoMessageType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "INLINE_REPLY" => AppsDynamiteSharedMessageInfoMessageType::InlineReply,
                "MESSAGE_TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedMessageInfoMessageType::MessageTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedMessageInfoMessageType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedMessageInfoMessageType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedMessageIntegrationPayload {
        #[doc = "Pantheon project number used to identify the calling app."]
        #[serde(
            rename = "projectNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub project_number: ::std::option::Option<i64>,
        #[doc = "An enum indicating which 1P application’s payload this is. This field is required to add 1P payload."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedMessageIntegrationPayloadType>,
        #[serde(
            rename = "tasksMessageIntegrationPayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tasks_message_integration_payload:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedTasksMessageIntegrationPayload>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedMessageIntegrationPayload {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedMessageIntegrationPayload {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedMessageIntegrationPayloadType {
        PayloadTypeUnspecified,
        Tasks,
    }
    impl AppsDynamiteSharedMessageIntegrationPayloadType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedMessageIntegrationPayloadType::PayloadTypeUnspecified => {
                    "PAYLOAD_TYPE_UNSPECIFIED"
                }
                AppsDynamiteSharedMessageIntegrationPayloadType::Tasks => "TASKS",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedMessageIntegrationPayloadType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedMessageIntegrationPayloadType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedMessageIntegrationPayloadType, ()> {
            Ok(match s {
                "PAYLOAD_TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedMessageIntegrationPayloadType::PayloadTypeUnspecified
                }
                "TASKS" => AppsDynamiteSharedMessageIntegrationPayloadType::Tasks,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedMessageIntegrationPayloadType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedMessageIntegrationPayloadType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedMessageIntegrationPayloadType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "PAYLOAD_TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedMessageIntegrationPayloadType::PayloadTypeUnspecified
                }
                "TASKS" => AppsDynamiteSharedMessageIntegrationPayloadType::Tasks,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedMessageIntegrationPayloadType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedMessageIntegrationPayloadType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedOrganizationInfo {
        #[serde(
            rename = "consumerInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub consumer_info:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedOrganizationInfoConsumerInfo>,
        #[serde(
            rename = "customerInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub customer_info:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedOrganizationInfoCustomerInfo>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedOrganizationInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedOrganizationInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedOrganizationInfoConsumerInfo {}
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedOrganizationInfoConsumerInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedOrganizationInfoConsumerInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedOrganizationInfoCustomerInfo {
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<crate::schemas::CustomerId>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedOrganizationInfoCustomerInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedOrganizationInfoCustomerInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedOriginAppSuggestion {
        #[serde(
            rename = "appId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app_id: ::std::option::Option<crate::schemas::AppId>,
        #[serde(
            rename = "cardClickSuggestion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub card_click_suggestion:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedCardClickSuggestion>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedOriginAppSuggestion {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedOriginAppSuggestion {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedPhoneNumber {
        #[doc = "The phone number type, e.g., work, mobile, etc."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<String>,
        #[doc = "The actual phone number."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedPhoneNumber {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedPhoneNumber {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedReaction {
        #[doc = "The total number of users who have reacted."]
        #[serde(
            rename = "count",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub count: ::std::option::Option<i32>,
        #[doc = "When the first emoji of this type was added."]
        #[serde(
            rename = "createTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub create_timestamp: ::std::option::Option<i64>,
        #[doc = "Whether the current user reacted using this emoji. Note: Unlike most properties of messages, this is different per-user."]
        #[serde(
            rename = "currentUserParticipated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub current_user_participated: ::std::option::Option<bool>,
        #[serde(
            rename = "emoji",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub emoji: ::std::option::Option<crate::schemas::AppsDynamiteSharedEmoji>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedReaction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedReaction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedRetentionSettings {
        #[doc = "The timestamp after which the message/topic should be removed, in microseconds since the epoch, when state == EPHEMERAL_ONE_DAY. The value should not be set in other cases."]
        #[serde(
            rename = "expiryTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub expiry_timestamp: ::std::option::Option<i64>,
        #[doc = "The retention state."]
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state: ::std::option::Option<crate::schemas::AppsDynamiteSharedRetentionSettingsState>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedRetentionSettings {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedRetentionSettings {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedRetentionSettingsState {
        #[doc = "The message/topic should be kept with a 24-hour TTL."]
        EphemeralOneDay,
        #[doc = "The message/topic should be kept permanently."]
        Permanent,
        UnknownRetentionState,
    }
    impl AppsDynamiteSharedRetentionSettingsState {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedRetentionSettingsState::EphemeralOneDay => "EPHEMERAL_ONE_DAY",
                AppsDynamiteSharedRetentionSettingsState::Permanent => "PERMANENT",
                AppsDynamiteSharedRetentionSettingsState::UnknownRetentionState => {
                    "UNKNOWN_RETENTION_STATE"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedRetentionSettingsState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedRetentionSettingsState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedRetentionSettingsState, ()> {
            Ok(match s {
                "EPHEMERAL_ONE_DAY" => AppsDynamiteSharedRetentionSettingsState::EphemeralOneDay,
                "PERMANENT" => AppsDynamiteSharedRetentionSettingsState::Permanent,
                "UNKNOWN_RETENTION_STATE" => {
                    AppsDynamiteSharedRetentionSettingsState::UnknownRetentionState
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedRetentionSettingsState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedRetentionSettingsState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedRetentionSettingsState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EPHEMERAL_ONE_DAY" => AppsDynamiteSharedRetentionSettingsState::EphemeralOneDay,
                "PERMANENT" => AppsDynamiteSharedRetentionSettingsState::Permanent,
                "UNKNOWN_RETENTION_STATE" => {
                    AppsDynamiteSharedRetentionSettingsState::UnknownRetentionState
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedRetentionSettingsState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedRetentionSettingsState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedSegmentedMembershipCount {
        #[serde(
            rename = "memberType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub member_type: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedSegmentedMembershipCountMemberType,
        >,
        #[doc = "count of members with given type and state"]
        #[serde(
            rename = "membershipCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub membership_count: ::std::option::Option<i32>,
        #[serde(
            rename = "membershipState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub membership_state: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedSegmentedMembershipCountMembershipState,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedSegmentedMembershipCount {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedSegmentedMembershipCount {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedSegmentedMembershipCountMemberType {
        #[doc = "member is a human user"]
        HumanUser,
        #[doc = "default value"]
        MemberTypeUnspecified,
        #[doc = "member is a roster"]
        RosterMember,
    }
    impl AppsDynamiteSharedSegmentedMembershipCountMemberType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedSegmentedMembershipCountMemberType::HumanUser => "HUMAN_USER",
                AppsDynamiteSharedSegmentedMembershipCountMemberType::MemberTypeUnspecified => {
                    "MEMBER_TYPE_UNSPECIFIED"
                }
                AppsDynamiteSharedSegmentedMembershipCountMemberType::RosterMember => {
                    "ROSTER_MEMBER"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedSegmentedMembershipCountMemberType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedSegmentedMembershipCountMemberType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedSegmentedMembershipCountMemberType, ()>
        {
            Ok(match s {
                "HUMAN_USER" => AppsDynamiteSharedSegmentedMembershipCountMemberType::HumanUser,
                "MEMBER_TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedSegmentedMembershipCountMemberType::MemberTypeUnspecified
                }
                "ROSTER_MEMBER" => {
                    AppsDynamiteSharedSegmentedMembershipCountMemberType::RosterMember
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedSegmentedMembershipCountMemberType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedSegmentedMembershipCountMemberType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedSegmentedMembershipCountMemberType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "HUMAN_USER" => AppsDynamiteSharedSegmentedMembershipCountMemberType::HumanUser,
                "MEMBER_TYPE_UNSPECIFIED" => {
                    AppsDynamiteSharedSegmentedMembershipCountMemberType::MemberTypeUnspecified
                }
                "ROSTER_MEMBER" => {
                    AppsDynamiteSharedSegmentedMembershipCountMemberType::RosterMember
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedSegmentedMembershipCountMemberType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedSegmentedMembershipCountMemberType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedSegmentedMembershipCountMembershipState {
        #[doc = "This state should never be stored in Spanner. It is a state for responses to the clients to indicate that membership mutations have failed and the member is in its previous state."]
        MemberFailed,
        #[doc = "An invitation to the space has been sent"]
        MemberInvited,
        #[doc = "User has joined the space"]
        MemberJoined,
        #[doc = "User is not a member"]
        MemberNotAMember,
        #[doc = "Default state, do not use"]
        MemberUnknown,
    }
    impl AppsDynamiteSharedSegmentedMembershipCountMembershipState {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberFailed => {
                    "MEMBER_FAILED"
                }
                AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberInvited => {
                    "MEMBER_INVITED"
                }
                AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberJoined => {
                    "MEMBER_JOINED"
                }
                AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberNotAMember => {
                    "MEMBER_NOT_A_MEMBER"
                }
                AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberUnknown => {
                    "MEMBER_UNKNOWN"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedSegmentedMembershipCountMembershipState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedSegmentedMembershipCountMembershipState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedSegmentedMembershipCountMembershipState, ()>
        {
            Ok(match s {
                "MEMBER_FAILED" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberFailed
                }
                "MEMBER_INVITED" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberInvited
                }
                "MEMBER_JOINED" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberJoined
                }
                "MEMBER_NOT_A_MEMBER" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberNotAMember
                }
                "MEMBER_UNKNOWN" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberUnknown
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedSegmentedMembershipCountMembershipState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedSegmentedMembershipCountMembershipState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedSegmentedMembershipCountMembershipState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MEMBER_FAILED" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberFailed
                }
                "MEMBER_INVITED" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberInvited
                }
                "MEMBER_JOINED" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberJoined
                }
                "MEMBER_NOT_A_MEMBER" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberNotAMember
                }
                "MEMBER_UNKNOWN" => {
                    AppsDynamiteSharedSegmentedMembershipCountMembershipState::MemberUnknown
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedSegmentedMembershipCountMembershipState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedSegmentedMembershipCountMembershipState
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedSegmentedMembershipCounts {
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value:
            ::std::option::Option<Vec<crate::schemas::AppsDynamiteSharedSegmentedMembershipCount>>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedSegmentedMembershipCounts {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedSegmentedMembershipCounts {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedSpaceInfo {
        #[serde(
            rename = "avatarInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub avatar_info: ::std::option::Option<crate::schemas::AppsDynamiteSharedAvatarInfo>,
        #[serde(
            rename = "avatarUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub avatar_url: ::std::option::Option<String>,
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[serde(
            rename = "groupId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_id: ::std::option::Option<crate::schemas::GroupId>,
        #[doc = "The email address of the user that invited the calling user to the room, if available. This field will only be populated for direct invites, it will be empty if the user was indirectly invited to the group."]
        #[serde(
            rename = "inviterEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub inviter_email: ::std::option::Option<String>,
        #[doc = "Whether this is a space that enables guest access"]
        #[serde(
            rename = "isExternal",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_external: ::std::option::Option<bool>,
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "numMembers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_members: ::std::option::Option<i32>,
        #[doc = "searching user’s membership state in this space"]
        #[serde(
            rename = "userMembershipState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_membership_state:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedSpaceInfoUserMembershipState>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedSpaceInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedSpaceInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedSpaceInfoUserMembershipState {
        #[doc = "This state should never be stored in Spanner. It is a state for responses to the clients to indicate that membership mutations have failed and the member is in its previous state."]
        MemberFailed,
        #[doc = "An invitation to the space has been sent"]
        MemberInvited,
        #[doc = "User has joined the space"]
        MemberJoined,
        #[doc = "User is not a member"]
        MemberNotAMember,
        #[doc = "Default state, do not use"]
        MemberUnknown,
    }
    impl AppsDynamiteSharedSpaceInfoUserMembershipState {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedSpaceInfoUserMembershipState::MemberFailed => "MEMBER_FAILED",
                AppsDynamiteSharedSpaceInfoUserMembershipState::MemberInvited => "MEMBER_INVITED",
                AppsDynamiteSharedSpaceInfoUserMembershipState::MemberJoined => "MEMBER_JOINED",
                AppsDynamiteSharedSpaceInfoUserMembershipState::MemberNotAMember => {
                    "MEMBER_NOT_A_MEMBER"
                }
                AppsDynamiteSharedSpaceInfoUserMembershipState::MemberUnknown => "MEMBER_UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedSpaceInfoUserMembershipState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedSpaceInfoUserMembershipState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteSharedSpaceInfoUserMembershipState, ()> {
            Ok(match s {
                "MEMBER_FAILED" => AppsDynamiteSharedSpaceInfoUserMembershipState::MemberFailed,
                "MEMBER_INVITED" => AppsDynamiteSharedSpaceInfoUserMembershipState::MemberInvited,
                "MEMBER_JOINED" => AppsDynamiteSharedSpaceInfoUserMembershipState::MemberJoined,
                "MEMBER_NOT_A_MEMBER" => {
                    AppsDynamiteSharedSpaceInfoUserMembershipState::MemberNotAMember
                }
                "MEMBER_UNKNOWN" => AppsDynamiteSharedSpaceInfoUserMembershipState::MemberUnknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedSpaceInfoUserMembershipState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedSpaceInfoUserMembershipState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedSpaceInfoUserMembershipState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MEMBER_FAILED" => AppsDynamiteSharedSpaceInfoUserMembershipState::MemberFailed,
                "MEMBER_INVITED" => AppsDynamiteSharedSpaceInfoUserMembershipState::MemberInvited,
                "MEMBER_JOINED" => AppsDynamiteSharedSpaceInfoUserMembershipState::MemberJoined,
                "MEMBER_NOT_A_MEMBER" => {
                    AppsDynamiteSharedSpaceInfoUserMembershipState::MemberNotAMember
                }
                "MEMBER_UNKNOWN" => AppsDynamiteSharedSpaceInfoUserMembershipState::MemberUnknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedSpaceInfoUserMembershipState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedSpaceInfoUserMembershipState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedTasksAnnotationData {
        #[serde(
            rename = "assigneeChange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub assignee_change: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedTasksAnnotationDataAssigneeChange,
        >,
        #[serde(
            rename = "completionChange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub completion_change: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedTasksAnnotationDataCompletionChange,
        >,
        #[serde(
            rename = "creation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub creation:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedTasksAnnotationDataCreation>,
        #[serde(
            rename = "deletionChange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deletion_change: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedTasksAnnotationDataDeletionChange,
        >,
        #[doc = "ID of task. Will be used to create deep links to Tasks."]
        #[serde(
            rename = "taskId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_id: ::std::option::Option<String>,
        #[doc = "Task properties after the update has been applied."]
        #[serde(
            rename = "taskProperties",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_properties: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedTasksAnnotationDataTaskProperties,
        >,
        #[serde(
            rename = "userDefinedMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_defined_message: ::std::option::Option<
            crate::schemas::AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedTasksAnnotationData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedTasksAnnotationData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedTasksAnnotationDataAssigneeChange {
        #[doc = "Obfuscated user ID of previous assignee. Not set if the task was originally not assigned."]
        #[serde(
            rename = "oldAssignee",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub old_assignee: ::std::option::Option<crate::schemas::UserId>,
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedTasksAnnotationDataAssigneeChange
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedTasksAnnotationDataAssigneeChange {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedTasksAnnotationDataCompletionChange {}
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedTasksAnnotationDataCompletionChange
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedTasksAnnotationDataCompletionChange
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedTasksAnnotationDataCreation {}
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedTasksAnnotationDataCreation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedTasksAnnotationDataCreation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedTasksAnnotationDataDeletionChange {}
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedTasksAnnotationDataDeletionChange
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedTasksAnnotationDataDeletionChange {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedTasksAnnotationDataTaskProperties {
        #[doc = "Obfuscated user ID of new assignee. Not set if the task doesn’t have an assignee."]
        #[serde(
            rename = "assignee",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub assignee: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Whether the task is marked as completed."]
        #[serde(
            rename = "completed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub completed: ::std::option::Option<bool>,
        #[doc = "Whether the task is marked as deleted."]
        #[serde(
            rename = "deleted",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deleted: ::std::option::Option<bool>,
        #[doc = "The description of the task. If Task original description’s length is greater than 1024, then Task BE sends the truncated description to Dynamite Integration Server."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Set if the task has a date but no time. Source of truth in Tasks BE: http://shortn/\\_wyT7eB4Ixv"]
        #[serde(
            rename = "startDate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "Set if the task has both a date and a time. Source of truth in Tasks BE: http://shortn/\\_u6cr0F5ttE"]
        #[serde(
            rename = "startTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_time: ::std::option::Option<String>,
        #[doc = "The title of the task."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedTasksAnnotationDataTaskProperties
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedTasksAnnotationDataTaskProperties {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage {}
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedTasksMessageIntegrationPayload {}
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedTasksMessageIntegrationPayload {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedTasksMessageIntegrationPayload {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedUserBlockRelationship {
        #[serde(
            rename = "hasBlockedRequester",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub has_blocked_requester: ::std::option::Option<bool>,
        #[serde(
            rename = "isBlockedByRequester",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_blocked_by_requester: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedUserBlockRelationship {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedUserBlockRelationship {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteSharedVideoReference {
        #[doc = "Available transcode format. Value is defined in video/storage/proto/content_header.proto"]
        #[serde(
            rename = "format",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub format: ::std::option::Option<Vec<i32>>,
        #[doc = "Transcode status"]
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status: ::std::option::Option<crate::schemas::AppsDynamiteSharedVideoReferenceStatus>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedVideoReference {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedVideoReference {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteSharedVideoReferenceStatus {
        Error,
        GoLiveSuccess,
        NotApplicable,
        Success,
        ThumbnailSuccess,
        UnknownStatus,
    }
    impl AppsDynamiteSharedVideoReferenceStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteSharedVideoReferenceStatus::Error => "ERROR",
                AppsDynamiteSharedVideoReferenceStatus::GoLiveSuccess => "GO_LIVE_SUCCESS",
                AppsDynamiteSharedVideoReferenceStatus::NotApplicable => "NOT_APPLICABLE",
                AppsDynamiteSharedVideoReferenceStatus::Success => "SUCCESS",
                AppsDynamiteSharedVideoReferenceStatus::ThumbnailSuccess => "THUMBNAIL_SUCCESS",
                AppsDynamiteSharedVideoReferenceStatus::UnknownStatus => "UNKNOWN_STATUS",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteSharedVideoReferenceStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteSharedVideoReferenceStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteSharedVideoReferenceStatus, ()> {
            Ok(match s {
                "ERROR" => AppsDynamiteSharedVideoReferenceStatus::Error,
                "GO_LIVE_SUCCESS" => AppsDynamiteSharedVideoReferenceStatus::GoLiveSuccess,
                "NOT_APPLICABLE" => AppsDynamiteSharedVideoReferenceStatus::NotApplicable,
                "SUCCESS" => AppsDynamiteSharedVideoReferenceStatus::Success,
                "THUMBNAIL_SUCCESS" => AppsDynamiteSharedVideoReferenceStatus::ThumbnailSuccess,
                "UNKNOWN_STATUS" => AppsDynamiteSharedVideoReferenceStatus::UnknownStatus,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteSharedVideoReferenceStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteSharedVideoReferenceStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteSharedVideoReferenceStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ERROR" => AppsDynamiteSharedVideoReferenceStatus::Error,
                "GO_LIVE_SUCCESS" => AppsDynamiteSharedVideoReferenceStatus::GoLiveSuccess,
                "NOT_APPLICABLE" => AppsDynamiteSharedVideoReferenceStatus::NotApplicable,
                "SUCCESS" => AppsDynamiteSharedVideoReferenceStatus::Success,
                "THUMBNAIL_SUCCESS" => AppsDynamiteSharedVideoReferenceStatus::ThumbnailSuccess,
                "UNKNOWN_STATUS" => AppsDynamiteSharedVideoReferenceStatus::UnknownStatus,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteSharedVideoReferenceStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteSharedVideoReferenceStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageAction {
        #[doc = "Apps Script function to invoke when the containing element is clicked/activated."]
        #[serde(
            rename = "function",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function: ::std::option::Option<String>,
        #[serde(
            rename = "interaction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub interaction:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageActionInteraction>,
        #[serde(
            rename = "loadIndicator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub load_indicator:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageActionLoadIndicator>,
        #[doc = "List of action parameters."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters:
            ::std::option::Option<Vec<crate::schemas::AppsDynamiteStorageActionActionParameter>>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageActionInteraction {
        #[doc = "Default value if interaction is not specified."]
        InteractionUnspecified,
        #[doc = "A dialog opens by clicking the button."]
        OpenDialog,
    }
    impl AppsDynamiteStorageActionInteraction {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageActionInteraction::InteractionUnspecified => {
                    "INTERACTION_UNSPECIFIED"
                }
                AppsDynamiteStorageActionInteraction::OpenDialog => "OPEN_DIALOG",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageActionInteraction {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageActionInteraction {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageActionInteraction, ()> {
            Ok(match s {
                "INTERACTION_UNSPECIFIED" => {
                    AppsDynamiteStorageActionInteraction::InteractionUnspecified
                }
                "OPEN_DIALOG" => AppsDynamiteStorageActionInteraction::OpenDialog,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageActionInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageActionInteraction {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageActionInteraction {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "INTERACTION_UNSPECIFIED" => {
                    AppsDynamiteStorageActionInteraction::InteractionUnspecified
                }
                "OPEN_DIALOG" => AppsDynamiteStorageActionInteraction::OpenDialog,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageActionInteraction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageActionInteraction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageActionLoadIndicator {
        #[doc = "Nothing is displayed."]
        None,
        #[doc = "Displays a spinner to indicate that content is loading."]
        Spinner,
    }
    impl AppsDynamiteStorageActionLoadIndicator {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageActionLoadIndicator::None => "NONE",
                AppsDynamiteStorageActionLoadIndicator::Spinner => "SPINNER",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageActionLoadIndicator {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageActionLoadIndicator {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageActionLoadIndicator, ()> {
            Ok(match s {
                "NONE" => AppsDynamiteStorageActionLoadIndicator::None,
                "SPINNER" => AppsDynamiteStorageActionLoadIndicator::Spinner,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageActionLoadIndicator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageActionLoadIndicator {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageActionLoadIndicator {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NONE" => AppsDynamiteStorageActionLoadIndicator::None,
                "SPINNER" => AppsDynamiteStorageActionLoadIndicator::Spinner,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageActionLoadIndicator {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageActionLoadIndicator {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageActionActionParameter {
        #[doc = "The name of the parameter for the action script."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "The value of the parameter."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageActionActionParameter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageActionActionParameter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageBorderStyle {
        #[doc = "The corner radius for the border."]
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub corner_radius: ::std::option::Option<i32>,
        #[doc = "The border type."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::AppsDynamiteStorageBorderStyleType>,
        #[doc = "The colors to use when the type is `BORDER_TYPE_STROKE`."]
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stroke_color: ::std::option::Option<crate::schemas::Color>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageBorderStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageBorderStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageBorderStyleType {
        #[doc = "No value specified."]
        BorderTypeUnspecified,
        #[doc = "No border."]
        NoBorder,
        #[doc = "Outline."]
        Stroke,
    }
    impl AppsDynamiteStorageBorderStyleType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageBorderStyleType::BorderTypeUnspecified => {
                    "BORDER_TYPE_UNSPECIFIED"
                }
                AppsDynamiteStorageBorderStyleType::NoBorder => "NO_BORDER",
                AppsDynamiteStorageBorderStyleType::Stroke => "STROKE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageBorderStyleType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageBorderStyleType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageBorderStyleType, ()> {
            Ok(match s {
                "BORDER_TYPE_UNSPECIFIED" => {
                    AppsDynamiteStorageBorderStyleType::BorderTypeUnspecified
                }
                "NO_BORDER" => AppsDynamiteStorageBorderStyleType::NoBorder,
                "STROKE" => AppsDynamiteStorageBorderStyleType::Stroke,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageBorderStyleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageBorderStyleType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageBorderStyleType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BORDER_TYPE_UNSPECIFIED" => {
                    AppsDynamiteStorageBorderStyleType::BorderTypeUnspecified
                }
                "NO_BORDER" => AppsDynamiteStorageBorderStyleType::NoBorder,
                "STROKE" => AppsDynamiteStorageBorderStyleType::Stroke,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageBorderStyleType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageBorderStyleType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageButton {
        #[doc = "The alternative text used for accessibility. Has no effect when an icon is set; use `icon.alt_text` instead."]
        #[serde(
            rename = "altText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alt_text: ::std::option::Option<String>,
        #[doc = "If set, the button is filled with a solid background."]
        #[serde(
            rename = "color",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub color: ::std::option::Option<crate::schemas::Color>,
        #[doc = "If true, the button is displayed in a disabled state and doesn’t respond to user actions."]
        #[serde(
            rename = "disabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disabled: ::std::option::Option<bool>,
        #[doc = "The icon image."]
        #[serde(
            rename = "icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon: ::std::option::Option<crate::schemas::AppsDynamiteStorageIcon>,
        #[doc = "The action to perform when the button is clicked."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::AppsDynamiteStorageOnClick>,
        #[doc = "The text of the button."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageButton {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageButton {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageButtonList {
        #[serde(
            rename = "buttons",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub buttons: ::std::option::Option<Vec<crate::schemas::AppsDynamiteStorageButton>>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageButtonList {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageButtonList {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageCard {
        #[doc = "The actions of this card. They are added to a card’s generated toolbar menu. For example, the following JSON constructs a card action menu with Settings and Send Feedback options: `\"card_actions\": [ { \"actionLabel\": \"Setting\", \"onClick\": { \"action\": { \"functionName\": \"goToView\", \"parameters\": [ { \"key\": \"viewType\", \"value\": \"SETTING\" } ], \"loadIndicator\": \"LoadIndicator.SPINNER\" } } }, { \"actionLabel\": \"Send Feedback\", \"onClick\": { \"openLink\": { \"url\": \"https://example.com/feedback\" } } } ]`"]
        #[serde(
            rename = "cardActions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub card_actions:
            ::std::option::Option<Vec<crate::schemas::AppsDynamiteStorageCardCardAction>>,
        #[doc = "The header of the card. A header usually contains a title and an image."]
        #[serde(
            rename = "header",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub header: ::std::option::Option<crate::schemas::AppsDynamiteStorageCardCardHeader>,
        #[doc = "Name of the card, which is used as a identifier for the card in card navigation."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Sections are separated by a line divider."]
        #[serde(
            rename = "sections",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sections: ::std::option::Option<Vec<crate::schemas::AppsDynamiteStorageCardSection>>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageCard {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageCard {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageCardCardAction {
        #[doc = "The label that displays as the action menu item."]
        #[serde(
            rename = "actionLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_label: ::std::option::Option<String>,
        #[doc = "The onclick action for this action item."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::AppsDynamiteStorageOnClick>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageCardCardAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageCardCardAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageCardCardHeader {
        #[doc = "The alternative text of this image which is used for accessibility."]
        #[serde(
            rename = "imageAltText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_alt_text: ::std::option::Option<String>,
        #[doc = "The image’s type."]
        #[serde(
            rename = "imageType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_type:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageCardCardHeaderImageType>,
        #[doc = "The URL of the image in the card header."]
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
        #[doc = "The subtitle of the card header."]
        #[serde(
            rename = "subtitle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub subtitle: ::std::option::Option<String>,
        #[doc = "The title of the card header. The title must be specified. The header has a fixed height: if both a title and subtitle are specified, each takes up one line. If only the title is specified, it takes up both lines."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageCardCardHeader {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageCardCardHeader {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageCardCardHeaderImageType {
        #[doc = "Applies a circular mask to the image."]
        Circle,
        #[doc = "Applies no cropping to the image."]
        Square,
    }
    impl AppsDynamiteStorageCardCardHeaderImageType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageCardCardHeaderImageType::Circle => "CIRCLE",
                AppsDynamiteStorageCardCardHeaderImageType::Square => "SQUARE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageCardCardHeaderImageType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageCardCardHeaderImageType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteStorageCardCardHeaderImageType, ()> {
            Ok(match s {
                "CIRCLE" => AppsDynamiteStorageCardCardHeaderImageType::Circle,
                "SQUARE" => AppsDynamiteStorageCardCardHeaderImageType::Square,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageCardCardHeaderImageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageCardCardHeaderImageType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageCardCardHeaderImageType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CIRCLE" => AppsDynamiteStorageCardCardHeaderImageType::Circle,
                "SQUARE" => AppsDynamiteStorageCardCardHeaderImageType::Square,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageCardCardHeaderImageType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageCardCardHeaderImageType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageCardSection {
        #[doc = "Indicates whether this section is collapsible. If a section is collapsible, the description must be given."]
        #[serde(
            rename = "collapsible",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub collapsible: ::std::option::Option<bool>,
        #[doc = "The header of the section. Formatted text is supported."]
        #[serde(
            rename = "header",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub header: ::std::option::Option<String>,
        #[doc = "The number of uncollapsible widgets. For example, when a section contains five widgets and the `numUncollapsibleWidget` is set to `2`, the first two widgets are always shown and the last three are collapsed as default. The `numUncollapsibleWidget` is taken into account only when collapsible is set to `true`."]
        #[serde(
            rename = "uncollapsibleWidgetsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub uncollapsible_widgets_count: ::std::option::Option<i32>,
        #[doc = "A section must contain at least 1 widget."]
        #[serde(
            rename = "widgets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub widgets: ::std::option::Option<Vec<crate::schemas::AppsDynamiteStorageWidget>>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageCardSection {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageCardSection {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageColumns {
        #[doc = "Each card supports up to 2 columns."]
        #[serde(
            rename = "columnItems",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub column_items:
            ::std::option::Option<Vec<crate::schemas::AppsDynamiteStorageColumnsColumn>>,
        #[doc = "Controls how the column resizes based on screen width."]
        #[serde(
            rename = "wrapStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wrap_style: ::std::option::Option<crate::schemas::AppsDynamiteStorageColumnsWrapStyle>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageColumns {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageColumns {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageColumnsWrapStyle {
        #[doc = "Column widgets don’t wrap."]
        Nowrap,
        #[doc = "Column Widgets wrap."]
        Wrap,
        #[doc = "Unspecified."]
        WrapStyleUnspecified,
    }
    impl AppsDynamiteStorageColumnsWrapStyle {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageColumnsWrapStyle::Nowrap => "NOWRAP",
                AppsDynamiteStorageColumnsWrapStyle::Wrap => "WRAP",
                AppsDynamiteStorageColumnsWrapStyle::WrapStyleUnspecified => {
                    "WRAP_STYLE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageColumnsWrapStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageColumnsWrapStyle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageColumnsWrapStyle, ()> {
            Ok(match s {
                "NOWRAP" => AppsDynamiteStorageColumnsWrapStyle::Nowrap,
                "WRAP" => AppsDynamiteStorageColumnsWrapStyle::Wrap,
                "WRAP_STYLE_UNSPECIFIED" => {
                    AppsDynamiteStorageColumnsWrapStyle::WrapStyleUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageColumnsWrapStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageColumnsWrapStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageColumnsWrapStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NOWRAP" => AppsDynamiteStorageColumnsWrapStyle::Nowrap,
                "WRAP" => AppsDynamiteStorageColumnsWrapStyle::Wrap,
                "WRAP_STYLE_UNSPECIFIED" => {
                    AppsDynamiteStorageColumnsWrapStyle::WrapStyleUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageColumnsWrapStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageColumnsWrapStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageColumnsColumn {
        #[doc = "The horizontal alignment of the column."]
        #[serde(
            rename = "horizontalAlignment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub horizontal_alignment: ::std::option::Option<
            crate::schemas::AppsDynamiteStorageColumnsColumnHorizontalAlignment,
        >,
        #[doc = "Specifies how the column content is sized horizontally."]
        #[serde(
            rename = "horizontalSizeStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub horizontal_size_style: ::std::option::Option<
            crate::schemas::AppsDynamiteStorageColumnsColumnHorizontalSizeStyle,
        >,
        #[doc = "The vertical alignment of the column."]
        #[serde(
            rename = "verticalAlignment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vertical_alignment: ::std::option::Option<
            crate::schemas::AppsDynamiteStorageColumnsColumnVerticalAlignment,
        >,
        #[doc = "LINT.ThenChange(//depot/google3/google/apps/card/v1/card.proto) Array of widgets included in the column."]
        #[serde(
            rename = "widgets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub widgets:
            ::std::option::Option<Vec<crate::schemas::AppsDynamiteStorageColumnsColumnWidgets>>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageColumnsColumn {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageColumnsColumn {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageColumnsColumnHorizontalAlignment {
        #[doc = "Alignment to the center position."]
        Center,
        #[doc = "Alignment to the end position."]
        End,
        #[doc = "Unspecified alignment."]
        HorizontalAlignmentUnspecified,
        #[doc = "Alignment to the start position."]
        Start,
    }
    impl AppsDynamiteStorageColumnsColumnHorizontalAlignment {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteStorageColumnsColumnHorizontalAlignment :: Center => "CENTER" , AppsDynamiteStorageColumnsColumnHorizontalAlignment :: End => "END" , AppsDynamiteStorageColumnsColumnHorizontalAlignment :: HorizontalAlignmentUnspecified => "HORIZONTAL_ALIGNMENT_UNSPECIFIED" , AppsDynamiteStorageColumnsColumnHorizontalAlignment :: Start => "START" , }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageColumnsColumnHorizontalAlignment {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageColumnsColumnHorizontalAlignment {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteStorageColumnsColumnHorizontalAlignment, ()>
        {
            Ok (match s { "CENTER" => AppsDynamiteStorageColumnsColumnHorizontalAlignment :: Center , "END" => AppsDynamiteStorageColumnsColumnHorizontalAlignment :: End , "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => AppsDynamiteStorageColumnsColumnHorizontalAlignment :: HorizontalAlignmentUnspecified , "START" => AppsDynamiteStorageColumnsColumnHorizontalAlignment :: Start , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageColumnsColumnHorizontalAlignment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageColumnsColumnHorizontalAlignment {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageColumnsColumnHorizontalAlignment {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "CENTER" => AppsDynamiteStorageColumnsColumnHorizontalAlignment :: Center , "END" => AppsDynamiteStorageColumnsColumnHorizontalAlignment :: End , "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => AppsDynamiteStorageColumnsColumnHorizontalAlignment :: HorizontalAlignmentUnspecified , "START" => AppsDynamiteStorageColumnsColumnHorizontalAlignment :: Start , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteStorageColumnsColumnHorizontalAlignment
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageColumnsColumnHorizontalAlignment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageColumnsColumnHorizontalSizeStyle {
        #[doc = "Fills up the available horizontal width. Default value if unspecified."]
        FillAvailableSpace,
        #[doc = "Fills up the minimum horizontal width."]
        FillMinimumSpace,
        #[doc = "Unspecified."]
        HorizontalSizeStyleUnspecified,
    }
    impl AppsDynamiteStorageColumnsColumnHorizontalSizeStyle {
        pub fn as_str(self) -> &'static str {
            match self { AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: FillAvailableSpace => "FILL_AVAILABLE_SPACE" , AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: FillMinimumSpace => "FILL_MINIMUM_SPACE" , AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: HorizontalSizeStyleUnspecified => "HORIZONTAL_SIZE_STYLE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageColumnsColumnHorizontalSizeStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageColumnsColumnHorizontalSizeStyle {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteStorageColumnsColumnHorizontalSizeStyle, ()>
        {
            Ok (match s { "FILL_AVAILABLE_SPACE" => AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: FillAvailableSpace , "FILL_MINIMUM_SPACE" => AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: FillMinimumSpace , "HORIZONTAL_SIZE_STYLE_UNSPECIFIED" => AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: HorizontalSizeStyleUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageColumnsColumnHorizontalSizeStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageColumnsColumnHorizontalSizeStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageColumnsColumnHorizontalSizeStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "FILL_AVAILABLE_SPACE" => AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: FillAvailableSpace , "FILL_MINIMUM_SPACE" => AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: FillMinimumSpace , "HORIZONTAL_SIZE_STYLE_UNSPECIFIED" => AppsDynamiteStorageColumnsColumnHorizontalSizeStyle :: HorizontalSizeStyleUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteStorageColumnsColumnHorizontalSizeStyle
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageColumnsColumnHorizontalSizeStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageColumnsColumnVerticalAlignment {
        #[doc = "Aligns the widget at the bottom of the column."]
        Bottom,
        #[doc = "Aligns the widget in the center of the column. Default value if unspecified."]
        Center,
        #[doc = "Aligns the widget at the top of the column."]
        Top,
        #[doc = "Unspecified."]
        VerticalAlignmentUnspecified,
    }
    impl AppsDynamiteStorageColumnsColumnVerticalAlignment {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageColumnsColumnVerticalAlignment::Bottom => "BOTTOM",
                AppsDynamiteStorageColumnsColumnVerticalAlignment::Center => "CENTER",
                AppsDynamiteStorageColumnsColumnVerticalAlignment::Top => "TOP",
                AppsDynamiteStorageColumnsColumnVerticalAlignment::VerticalAlignmentUnspecified => {
                    "VERTICAL_ALIGNMENT_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageColumnsColumnVerticalAlignment {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageColumnsColumnVerticalAlignment {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteStorageColumnsColumnVerticalAlignment, ()> {
            Ok(match s {
                "BOTTOM" => AppsDynamiteStorageColumnsColumnVerticalAlignment::Bottom,
                "CENTER" => AppsDynamiteStorageColumnsColumnVerticalAlignment::Center,
                "TOP" => AppsDynamiteStorageColumnsColumnVerticalAlignment::Top,
                "VERTICAL_ALIGNMENT_UNSPECIFIED" => {
                    AppsDynamiteStorageColumnsColumnVerticalAlignment::VerticalAlignmentUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageColumnsColumnVerticalAlignment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageColumnsColumnVerticalAlignment {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageColumnsColumnVerticalAlignment {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOTTOM" => AppsDynamiteStorageColumnsColumnVerticalAlignment::Bottom,
                "CENTER" => AppsDynamiteStorageColumnsColumnVerticalAlignment::Center,
                "TOP" => AppsDynamiteStorageColumnsColumnVerticalAlignment::Top,
                "VERTICAL_ALIGNMENT_UNSPECIFIED" => {
                    AppsDynamiteStorageColumnsColumnVerticalAlignment::VerticalAlignmentUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageColumnsColumnVerticalAlignment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageColumnsColumnVerticalAlignment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageColumnsColumnWidgets {
        #[doc = "ButtonList widget."]
        #[serde(
            rename = "buttonList",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub button_list: ::std::option::Option<crate::schemas::AppsDynamiteStorageButtonList>,
        #[doc = "DateTimePicker widget."]
        #[serde(
            rename = "dateTimePicker",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date_time_picker:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageDateTimePicker>,
        #[doc = "DecoratedText widget."]
        #[serde(
            rename = "decoratedText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub decorated_text: ::std::option::Option<crate::schemas::AppsDynamiteStorageDecoratedText>,
        #[doc = "Image widget."]
        #[serde(
            rename = "image",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image: ::std::option::Option<crate::schemas::AppsDynamiteStorageImage>,
        #[doc = "SelectionInput widget."]
        #[serde(
            rename = "selectionInput",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub selection_input:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageSelectionInput>,
        #[doc = "TextInput widget."]
        #[serde(
            rename = "textInput",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_input: ::std::option::Option<crate::schemas::AppsDynamiteStorageTextInput>,
        #[doc = "Text paragraph widget."]
        #[serde(
            rename = "textParagraph",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_paragraph: ::std::option::Option<crate::schemas::AppsDynamiteStorageTextParagraph>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageColumnsColumnWidgets {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageColumnsColumnWidgets {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageDateTimePicker {
        #[doc = "The label for the field that displays to the user."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "The name of the text input that’s used in formInput, and uniquely identifies this input."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Triggered when the user clicks Save or Clear from the date/time picker dialog. This is only triggered if the value changed as a result of the Save/Clear operation."]
        #[serde(
            rename = "onChangeAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change_action: ::std::option::Option<crate::schemas::AppsDynamiteStorageAction>,
        #[doc = "The type of the date/time picker."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::AppsDynamiteStorageDateTimePickerType>,
        #[doc = "The number representing the time zone offset from UTC, in minutes. If set, the `value_ms_epoch` is displayed in the specified time zone. If not set, it uses the user’s time zone setting on the client side."]
        #[serde(
            rename = "timezoneOffsetDate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub timezone_offset_date: ::std::option::Option<i32>,
        #[doc = "The value to display as the default value before user input or previous user input. It is represented in milliseconds (Epoch time). For `DATE_AND_TIME` type, the full epoch value is used. For `DATE_ONLY` type, only date of the epoch time is used. For `TIME_ONLY` type, only time of the epoch time is used. For example, you can set epoch time to `3 * 60 * 60 * 1000` to represent 3am."]
        #[serde(
            rename = "valueMsEpoch",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub value_ms_epoch: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageDateTimePicker {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageDateTimePicker {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageDateTimePickerType {
        #[doc = "The user can select a date and time."]
        DateAndTime,
        #[doc = "The user can only select a date."]
        DateOnly,
        #[doc = "The user can only select a time."]
        TimeOnly,
    }
    impl AppsDynamiteStorageDateTimePickerType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageDateTimePickerType::DateAndTime => "DATE_AND_TIME",
                AppsDynamiteStorageDateTimePickerType::DateOnly => "DATE_ONLY",
                AppsDynamiteStorageDateTimePickerType::TimeOnly => "TIME_ONLY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageDateTimePickerType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageDateTimePickerType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageDateTimePickerType, ()> {
            Ok(match s {
                "DATE_AND_TIME" => AppsDynamiteStorageDateTimePickerType::DateAndTime,
                "DATE_ONLY" => AppsDynamiteStorageDateTimePickerType::DateOnly,
                "TIME_ONLY" => AppsDynamiteStorageDateTimePickerType::TimeOnly,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageDateTimePickerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageDateTimePickerType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageDateTimePickerType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DATE_AND_TIME" => AppsDynamiteStorageDateTimePickerType::DateAndTime,
                "DATE_ONLY" => AppsDynamiteStorageDateTimePickerType::DateOnly,
                "TIME_ONLY" => AppsDynamiteStorageDateTimePickerType::TimeOnly,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageDateTimePickerType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageDateTimePickerType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageDecoratedText {
        #[doc = "The formatted text label that shows below the main text."]
        #[serde(
            rename = "bottomLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bottom_label: ::std::option::Option<String>,
        #[doc = "A button that can be clicked to trigger an action."]
        #[serde(
            rename = "button",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub button: ::std::option::Option<crate::schemas::AppsDynamiteStorageButton>,
        #[doc = "An icon displayed after the text."]
        #[serde(
            rename = "endIcon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub end_icon: ::std::option::Option<crate::schemas::AppsDynamiteStorageIcon>,
        #[doc = "Deprecated in favor of start_icon."]
        #[serde(
            rename = "icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon: ::std::option::Option<crate::schemas::AppsDynamiteStorageIcon>,
        #[doc = "Only the top and bottom label and content region are clickable."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::AppsDynamiteStorageOnClick>,
        #[doc = "The icon displayed in front of the text."]
        #[serde(
            rename = "startIcon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_icon: ::std::option::Option<crate::schemas::AppsDynamiteStorageIcon>,
        #[doc = "A switch widget can be clicked to change its state or trigger an action."]
        #[serde(
            rename = "switchControl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub switch_control:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageDecoratedTextSwitchControl>,
        #[doc = "Required. The main widget formatted text. See Text formatting for details."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "The formatted text label that shows above the main text."]
        #[serde(
            rename = "topLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub top_label: ::std::option::Option<String>,
        #[doc = "The wrap text setting. If `true`, the text is wrapped and displayed in multiline. Otherwise, the text is truncated."]
        #[serde(
            rename = "wrapText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wrap_text: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageDecoratedText {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageDecoratedText {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageDecoratedTextSwitchControl {
        #[doc = "The control type, either switch or checkbox."]
        #[serde(
            rename = "controlType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub control_type: ::std::option::Option<
            crate::schemas::AppsDynamiteStorageDecoratedTextSwitchControlControlType,
        >,
        #[doc = "The name of the switch widget that’s used in formInput."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The action when the switch state is changed."]
        #[serde(
            rename = "onChangeAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change_action: ::std::option::Option<crate::schemas::AppsDynamiteStorageAction>,
        #[doc = "If the switch is selected."]
        #[serde(
            rename = "selected",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub selected: ::std::option::Option<bool>,
        #[doc = "The value is what is passed back in the callback."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageDecoratedTextSwitchControl {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageDecoratedTextSwitchControl {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageDecoratedTextSwitchControlControlType {
        CheckBox,
        #[doc = "Deprecated in favor of `CHECK_BOX`."]
        Checkbox,
        Switch,
    }
    impl AppsDynamiteStorageDecoratedTextSwitchControlControlType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageDecoratedTextSwitchControlControlType::CheckBox => "CHECK_BOX",
                AppsDynamiteStorageDecoratedTextSwitchControlControlType::Checkbox => "CHECKBOX",
                AppsDynamiteStorageDecoratedTextSwitchControlControlType::Switch => "SWITCH",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageDecoratedTextSwitchControlControlType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageDecoratedTextSwitchControlControlType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteStorageDecoratedTextSwitchControlControlType, ()>
        {
            Ok(match s {
                "CHECK_BOX" => AppsDynamiteStorageDecoratedTextSwitchControlControlType::CheckBox,
                "CHECKBOX" => AppsDynamiteStorageDecoratedTextSwitchControlControlType::Checkbox,
                "SWITCH" => AppsDynamiteStorageDecoratedTextSwitchControlControlType::Switch,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageDecoratedTextSwitchControlControlType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageDecoratedTextSwitchControlControlType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageDecoratedTextSwitchControlControlType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CHECK_BOX" => AppsDynamiteStorageDecoratedTextSwitchControlControlType::CheckBox,
                "CHECKBOX" => AppsDynamiteStorageDecoratedTextSwitchControlControlType::Checkbox,
                "SWITCH" => AppsDynamiteStorageDecoratedTextSwitchControlControlType::Switch,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsDynamiteStorageDecoratedTextSwitchControlControlType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsDynamiteStorageDecoratedTextSwitchControlControlType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageDivider {}
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageDivider {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageDivider {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageGrid {
        #[doc = "The border style to apply to each grid item."]
        #[serde(
            rename = "borderStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub border_style: ::std::option::Option<crate::schemas::AppsDynamiteStorageBorderStyle>,
        #[doc = "The number of columns to display in the grid. A default value is used if this field isn’t specified, and that default value is different depending on where the grid is shown (dialog versus companion)."]
        #[serde(
            rename = "columnCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub column_count: ::std::option::Option<i32>,
        #[doc = "The items to display in the grid."]
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<Vec<crate::schemas::AppsDynamiteStorageGridGridItem>>,
        #[doc = "This callback is reused by each individual grid item, but with the item’s identifier and index in the items list added to the callback’s parameters."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::AppsDynamiteStorageOnClick>,
        #[doc = "The text that displays in the grid header."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageGrid {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageGrid {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageGridGridItem {
        #[doc = "A user-specified identifier for this grid item. This identifier is returned in the parent Grid’s onClick callback parameters."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
        #[doc = "The image that displays in the grid item."]
        #[serde(
            rename = "image",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image: ::std::option::Option<crate::schemas::AppsDynamiteStorageImageComponent>,
        #[doc = "The layout to use for the grid item."]
        #[serde(
            rename = "layout",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub layout: ::std::option::Option<crate::schemas::AppsDynamiteStorageGridGridItemLayout>,
        #[doc = "The grid item’s subtitle."]
        #[serde(
            rename = "subtitle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub subtitle: ::std::option::Option<String>,
        #[doc = "The horizontal alignment of the grid item’s text."]
        #[serde(
            rename = "textAlignment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_alignment:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageGridGridItemTextAlignment>,
        #[doc = "The grid item’s title."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageGridGridItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageGridGridItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageGridGridItemLayout {
        #[doc = "No layout specified."]
        GridItemLayoutUnspecified,
        #[doc = "The title and subtitle are shown above the grid item’s image."]
        TextAbove,
        #[doc = "The title and subtitle are shown below the grid item’s image."]
        TextBelow,
    }
    impl AppsDynamiteStorageGridGridItemLayout {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageGridGridItemLayout::GridItemLayoutUnspecified => {
                    "GRID_ITEM_LAYOUT_UNSPECIFIED"
                }
                AppsDynamiteStorageGridGridItemLayout::TextAbove => "TEXT_ABOVE",
                AppsDynamiteStorageGridGridItemLayout::TextBelow => "TEXT_BELOW",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageGridGridItemLayout {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageGridGridItemLayout {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageGridGridItemLayout, ()> {
            Ok(match s {
                "GRID_ITEM_LAYOUT_UNSPECIFIED" => {
                    AppsDynamiteStorageGridGridItemLayout::GridItemLayoutUnspecified
                }
                "TEXT_ABOVE" => AppsDynamiteStorageGridGridItemLayout::TextAbove,
                "TEXT_BELOW" => AppsDynamiteStorageGridGridItemLayout::TextBelow,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageGridGridItemLayout {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageGridGridItemLayout {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageGridGridItemLayout {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "GRID_ITEM_LAYOUT_UNSPECIFIED" => {
                    AppsDynamiteStorageGridGridItemLayout::GridItemLayoutUnspecified
                }
                "TEXT_ABOVE" => AppsDynamiteStorageGridGridItemLayout::TextAbove,
                "TEXT_BELOW" => AppsDynamiteStorageGridGridItemLayout::TextBelow,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageGridGridItemLayout {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageGridGridItemLayout {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageGridGridItemTextAlignment {
        #[doc = "Alignment to the center position."]
        Center,
        #[doc = "Alignment to the end position."]
        End,
        #[doc = "Unspecified alignment."]
        HorizontalAlignmentUnspecified,
        #[doc = "Alignment to the start position."]
        Start,
    }
    impl AppsDynamiteStorageGridGridItemTextAlignment {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageGridGridItemTextAlignment::Center => "CENTER",
                AppsDynamiteStorageGridGridItemTextAlignment::End => "END",
                AppsDynamiteStorageGridGridItemTextAlignment::HorizontalAlignmentUnspecified => {
                    "HORIZONTAL_ALIGNMENT_UNSPECIFIED"
                }
                AppsDynamiteStorageGridGridItemTextAlignment::Start => "START",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageGridGridItemTextAlignment {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageGridGridItemTextAlignment {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteStorageGridGridItemTextAlignment, ()> {
            Ok(match s {
                "CENTER" => AppsDynamiteStorageGridGridItemTextAlignment::Center,
                "END" => AppsDynamiteStorageGridGridItemTextAlignment::End,
                "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                    AppsDynamiteStorageGridGridItemTextAlignment::HorizontalAlignmentUnspecified
                }
                "START" => AppsDynamiteStorageGridGridItemTextAlignment::Start,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageGridGridItemTextAlignment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageGridGridItemTextAlignment {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageGridGridItemTextAlignment {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CENTER" => AppsDynamiteStorageGridGridItemTextAlignment::Center,
                "END" => AppsDynamiteStorageGridGridItemTextAlignment::End,
                "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                    AppsDynamiteStorageGridGridItemTextAlignment::HorizontalAlignmentUnspecified
                }
                "START" => AppsDynamiteStorageGridGridItemTextAlignment::Start,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageGridGridItemTextAlignment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageGridGridItemTextAlignment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageIcon {
        #[doc = "The description of the icon, used for accessibility. The default value is provided if you don’t specify one."]
        #[serde(
            rename = "altText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alt_text: ::std::option::Option<String>,
        #[doc = "The icon specified by a URL."]
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[doc = "The crop style applied to the image. In some cases, applying a `CIRCLE` crop causes the image to be drawn larger than a standard icon."]
        #[serde(
            rename = "imageType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_type: ::std::option::Option<crate::schemas::AppsDynamiteStorageIconImageType>,
        #[doc = "The icon specified by the string name of a list of known icons"]
        #[serde(
            rename = "knownIcon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub known_icon: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageIcon {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageIcon {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageIconImageType {
        #[doc = "Applies a circular mask to the image."]
        Circle,
        #[doc = "Applies no cropping to the image."]
        Square,
    }
    impl AppsDynamiteStorageIconImageType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageIconImageType::Circle => "CIRCLE",
                AppsDynamiteStorageIconImageType::Square => "SQUARE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageIconImageType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageIconImageType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageIconImageType, ()> {
            Ok(match s {
                "CIRCLE" => AppsDynamiteStorageIconImageType::Circle,
                "SQUARE" => AppsDynamiteStorageIconImageType::Square,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageIconImageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageIconImageType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageIconImageType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CIRCLE" => AppsDynamiteStorageIconImageType::Circle,
                "SQUARE" => AppsDynamiteStorageIconImageType::Square,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageIconImageType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageIconImageType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageImage {
        #[doc = "The alternative text of this image, used for accessibility."]
        #[serde(
            rename = "altText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alt_text: ::std::option::Option<String>,
        #[doc = "An image URL."]
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::AppsDynamiteStorageOnClick>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageImage {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageImage {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageImageComponent {
        #[doc = "The accessibility label for the image."]
        #[serde(
            rename = "altText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alt_text: ::std::option::Option<String>,
        #[doc = "The border style to apply to the image."]
        #[serde(
            rename = "borderStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub border_style: ::std::option::Option<crate::schemas::AppsDynamiteStorageBorderStyle>,
        #[doc = "The crop style to apply to the image."]
        #[serde(
            rename = "cropStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub crop_style: ::std::option::Option<crate::schemas::AppsDynamiteStorageImageCropStyle>,
        #[doc = "The image URL."]
        #[serde(
            rename = "imageUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageImageComponent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageImageComponent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageImageCropStyle {
        #[doc = "The aspect ratio to use if the crop type is `RECTANGLE_CUSTOM`."]
        #[serde(
            rename = "aspectRatio",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub aspect_ratio: ::std::option::Option<f64>,
        #[doc = "The crop type."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::AppsDynamiteStorageImageCropStyleType>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageImageCropStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageImageCropStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageImageCropStyleType {
        #[doc = "Applies a circular crop."]
        Circle,
        #[doc = "No value specified."]
        ImageCropTypeUnspecified,
        #[doc = "Applies a rectangular crop with a 4:3 aspect ratio."]
        Rectangle43,
        #[doc = "Applies a rectangular crop with a custom aspect ratio."]
        RectangleCustom,
        #[doc = "Applies a square crop."]
        Square,
    }
    impl AppsDynamiteStorageImageCropStyleType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageImageCropStyleType::Circle => "CIRCLE",
                AppsDynamiteStorageImageCropStyleType::ImageCropTypeUnspecified => {
                    "IMAGE_CROP_TYPE_UNSPECIFIED"
                }
                AppsDynamiteStorageImageCropStyleType::Rectangle43 => "RECTANGLE_4_3",
                AppsDynamiteStorageImageCropStyleType::RectangleCustom => "RECTANGLE_CUSTOM",
                AppsDynamiteStorageImageCropStyleType::Square => "SQUARE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageImageCropStyleType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageImageCropStyleType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageImageCropStyleType, ()> {
            Ok(match s {
                "CIRCLE" => AppsDynamiteStorageImageCropStyleType::Circle,
                "IMAGE_CROP_TYPE_UNSPECIFIED" => {
                    AppsDynamiteStorageImageCropStyleType::ImageCropTypeUnspecified
                }
                "RECTANGLE_4_3" => AppsDynamiteStorageImageCropStyleType::Rectangle43,
                "RECTANGLE_CUSTOM" => AppsDynamiteStorageImageCropStyleType::RectangleCustom,
                "SQUARE" => AppsDynamiteStorageImageCropStyleType::Square,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageImageCropStyleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageImageCropStyleType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageImageCropStyleType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CIRCLE" => AppsDynamiteStorageImageCropStyleType::Circle,
                "IMAGE_CROP_TYPE_UNSPECIFIED" => {
                    AppsDynamiteStorageImageCropStyleType::ImageCropTypeUnspecified
                }
                "RECTANGLE_4_3" => AppsDynamiteStorageImageCropStyleType::Rectangle43,
                "RECTANGLE_CUSTOM" => AppsDynamiteStorageImageCropStyleType::RectangleCustom,
                "SQUARE" => AppsDynamiteStorageImageCropStyleType::Square,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageImageCropStyleType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageImageCropStyleType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageOnClick {
        #[doc = "If specified, an action is triggered by this onClick."]
        #[serde(
            rename = "action",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action: ::std::option::Option<crate::schemas::AppsDynamiteStorageAction>,
        #[doc = "Triggers host app action on click directly without invoking form actions. This is currently not available to end-users and is used internal only."]
        #[serde(
            rename = "hostAppAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub host_app_action: ::std::option::Option<crate::schemas::HostAppActionMarkup>,
        #[doc = "An add-on triggers this action when the action needs to open a link. This differs from the open_link above in that this needs to talk to server to get the link. Thus some preparation work is required for web client to do before the open link action response comes back."]
        #[serde(
            rename = "openDynamicLinkAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub open_dynamic_link_action:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageAction>,
        #[doc = "If specified, this onClick triggers an open link action."]
        #[serde(
            rename = "openLink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub open_link: ::std::option::Option<crate::schemas::AppsDynamiteStorageOpenLink>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageOnClick {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageOnClick {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageOpenLink {
        #[doc = "Represents the platform specific uri/intent to open on each client. For example: A companion_url will open in a companion window on the web. An iOS URL and android intent will open in the corresponding hosting apps. If these platform specific URLs can’t be handled correctly, i.e. if the companion isn’t supported on web and the hosting apps aren’t available on the mobile platforms then the `uri` will open in a new browser window on all the platforms."]
        #[serde(
            rename = "appUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app_uri: ::std::option::Option<crate::schemas::AppsDynamiteStorageOpenLinkAppUri>,
        #[serde(
            rename = "onClose",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_close: ::std::option::Option<crate::schemas::AppsDynamiteStorageOpenLinkOnClose>,
        #[serde(
            rename = "openAs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub open_as: ::std::option::Option<crate::schemas::AppsDynamiteStorageOpenLinkOpenAs>,
        #[doc = "The URL to open."]
        #[serde(
            rename = "url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageOpenLink {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageOpenLink {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageOpenLinkOnClose {
        #[doc = "Doesn’t reload the card after the child window closes. Reloads the card after the child window closes. If used in conjunction with [OpenAs.OVERLAY](/workspace/add-ons/reference/rpc/google.apps.card.v1#openas), the child window acts as a modal dialog and the main card is blocked until the child window closes."]
        Nothing,
        Reload,
    }
    impl AppsDynamiteStorageOpenLinkOnClose {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageOpenLinkOnClose::Nothing => "NOTHING",
                AppsDynamiteStorageOpenLinkOnClose::Reload => "RELOAD",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageOpenLinkOnClose {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageOpenLinkOnClose {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageOpenLinkOnClose, ()> {
            Ok(match s {
                "NOTHING" => AppsDynamiteStorageOpenLinkOnClose::Nothing,
                "RELOAD" => AppsDynamiteStorageOpenLinkOnClose::Reload,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageOpenLinkOnClose {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageOpenLinkOnClose {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageOpenLinkOnClose {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NOTHING" => AppsDynamiteStorageOpenLinkOnClose::Nothing,
                "RELOAD" => AppsDynamiteStorageOpenLinkOnClose::Reload,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageOpenLinkOnClose {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageOpenLinkOnClose {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageOpenLinkOpenAs {
        #[doc = "The link opens as a full size window (if that’s the frame used by the client."]
        FullSize,
        #[doc = "The link opens as an overlay, such as a pop-up."]
        Overlay,
    }
    impl AppsDynamiteStorageOpenLinkOpenAs {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageOpenLinkOpenAs::FullSize => "FULL_SIZE",
                AppsDynamiteStorageOpenLinkOpenAs::Overlay => "OVERLAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageOpenLinkOpenAs {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageOpenLinkOpenAs {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageOpenLinkOpenAs, ()> {
            Ok(match s {
                "FULL_SIZE" => AppsDynamiteStorageOpenLinkOpenAs::FullSize,
                "OVERLAY" => AppsDynamiteStorageOpenLinkOpenAs::Overlay,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageOpenLinkOpenAs {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageOpenLinkOpenAs {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageOpenLinkOpenAs {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FULL_SIZE" => AppsDynamiteStorageOpenLinkOpenAs::FullSize,
                "OVERLAY" => AppsDynamiteStorageOpenLinkOpenAs::Overlay,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageOpenLinkOpenAs {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageOpenLinkOpenAs {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageOpenLinkAppUri {
        #[doc = "An intent object to be opened in the corresponding android hosting app."]
        #[serde(
            rename = "androidIntent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub android_intent:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageOpenLinkAppUriIntent>,
        #[doc = "A companion uri string to be opened in the chat companion window. on the web."]
        #[serde(
            rename = "companionUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub companion_uri: ::std::option::Option<String>,
        #[doc = "A uri string to be opened in the corresponding iOS hosting app."]
        #[serde(
            rename = "iosUri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ios_uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageOpenLinkAppUri {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageOpenLinkAppUri {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageOpenLinkAppUriIntent {
        #[doc = "A list of extra data for the android intent. For example, for a calendar event edit intent, the event title information can be passed as extra data."]
        #[serde(
            rename = "extraData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub extra_data: ::std::option::Option<
            Vec<crate::schemas::AppsDynamiteStorageOpenLinkAppUriIntentExtraData>,
        >,
        #[doc = "An android intent action string for the {@link android.content.Intent} object. For example: for the view intent action type, a valid value will be android.content.Intent.ACTION_VIEW."]
        #[serde(
            rename = "intentAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub intent_action: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageOpenLinkAppUriIntent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageOpenLinkAppUriIntent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageOpenLinkAppUriIntentExtraData {
        #[doc = "A key for the intent extra data."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "Value for the given extra data key."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageOpenLinkAppUriIntentExtraData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageOpenLinkAppUriIntentExtraData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageSelectionInput {
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<
            Vec<crate::schemas::AppsDynamiteStorageSelectionInputSelectionItem>,
        >,
        #[doc = "The label displayed ahead of the switch control."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "The name of the text input which is used in formInput."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "If specified, the form is submitted when the selection changes. If not specified, you must specify a separate button."]
        #[serde(
            rename = "onChangeAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change_action: ::std::option::Option<crate::schemas::AppsDynamiteStorageAction>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::AppsDynamiteStorageSelectionInputType>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageSelectionInput {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageSelectionInput {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageSelectionInputType {
        #[doc = "The selection type is a checkbox."]
        CheckBox,
        #[doc = "The selection type is a dropdown."]
        Dropdown,
        #[doc = "The selection type is a radio button."]
        RadioButton,
        #[doc = "The selection type is a switch."]
        Switch,
    }
    impl AppsDynamiteStorageSelectionInputType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageSelectionInputType::CheckBox => "CHECK_BOX",
                AppsDynamiteStorageSelectionInputType::Dropdown => "DROPDOWN",
                AppsDynamiteStorageSelectionInputType::RadioButton => "RADIO_BUTTON",
                AppsDynamiteStorageSelectionInputType::Switch => "SWITCH",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageSelectionInputType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageSelectionInputType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageSelectionInputType, ()> {
            Ok(match s {
                "CHECK_BOX" => AppsDynamiteStorageSelectionInputType::CheckBox,
                "DROPDOWN" => AppsDynamiteStorageSelectionInputType::Dropdown,
                "RADIO_BUTTON" => AppsDynamiteStorageSelectionInputType::RadioButton,
                "SWITCH" => AppsDynamiteStorageSelectionInputType::Switch,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageSelectionInputType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageSelectionInputType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageSelectionInputType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CHECK_BOX" => AppsDynamiteStorageSelectionInputType::CheckBox,
                "DROPDOWN" => AppsDynamiteStorageSelectionInputType::Dropdown,
                "RADIO_BUTTON" => AppsDynamiteStorageSelectionInputType::RadioButton,
                "SWITCH" => AppsDynamiteStorageSelectionInputType::Switch,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageSelectionInputType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageSelectionInputType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageSelectionInputSelectionItem {
        #[doc = "If more than one item is selected for `RADIO_BUTTON` and `DROPDOWN`, the first selected item is treated as selected and the ones after are ignored."]
        #[serde(
            rename = "selected",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub selected: ::std::option::Option<bool>,
        #[doc = "The text to be displayed."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "The value associated with this item. The client should use this as a form input value."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageSelectionInputSelectionItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageSelectionInputSelectionItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageSuggestions {
        #[doc = "A list of suggestions items which will be used in are used in autocomplete."]
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<
            Vec<crate::schemas::AppsDynamiteStorageSuggestionsSuggestionItem>,
        >,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageSuggestions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageSuggestions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageSuggestionsSuggestionItem {
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageSuggestionsSuggestionItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageSuggestionsSuggestionItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageTextInput {
        #[doc = "The refresh function that returns suggestions based on the user’s input text. If the callback is not specified, autocomplete is done in client side based on the initial suggestion items."]
        #[serde(
            rename = "autoCompleteAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auto_complete_action: ::std::option::Option<crate::schemas::AppsDynamiteStorageAction>,
        #[doc = "The hint text."]
        #[serde(
            rename = "hintText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hint_text: ::std::option::Option<String>,
        #[doc = "The initial suggestions made before any user input."]
        #[serde(
            rename = "initialSuggestions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initial_suggestions:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageSuggestions>,
        #[doc = "At least one of label and hintText must be specified."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "The name of the text input which is used in formInput."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The onChange action, for example, invoke a function."]
        #[serde(
            rename = "onChangeAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change_action: ::std::option::Option<crate::schemas::AppsDynamiteStorageAction>,
        #[doc = "The style of the text, for example, a single line or multiple lines."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::AppsDynamiteStorageTextInputType>,
        #[doc = "The default value when there is no input from the user."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageTextInput {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageTextInput {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageTextInputType {
        #[doc = "The text is put into multiple lines."]
        MultipleLine,
        #[doc = "The text is put into a single line."]
        SingleLine,
    }
    impl AppsDynamiteStorageTextInputType {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageTextInputType::MultipleLine => "MULTIPLE_LINE",
                AppsDynamiteStorageTextInputType::SingleLine => "SINGLE_LINE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageTextInputType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageTextInputType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<AppsDynamiteStorageTextInputType, ()> {
            Ok(match s {
                "MULTIPLE_LINE" => AppsDynamiteStorageTextInputType::MultipleLine,
                "SINGLE_LINE" => AppsDynamiteStorageTextInputType::SingleLine,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageTextInputType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageTextInputType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageTextInputType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MULTIPLE_LINE" => AppsDynamiteStorageTextInputType::MultipleLine,
                "SINGLE_LINE" => AppsDynamiteStorageTextInputType::SingleLine,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageTextInputType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageTextInputType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteStorageTextParagraph {
        #[doc = "The text that’s shown in the widget."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageTextParagraph {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageTextParagraph {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct AppsDynamiteStorageWidget {
        #[doc = "A list of buttons. For example, the following JSON creates two buttons. The first is a filled text button and the second is an image button that opens a link: `\"buttonList\": { \"buttons\": [ \"button\": { \"text\": \"Edit\", \"Color\": { \"Red\": 255 \"Green\": 255 \"Blue\": 255 } \"disabled\": true }, \"button\": { \"icon\": { \"knownIcon\": \"INVITE\" \"altText\": \"check calendar\" }, \"onClick\": { \"openLink\": { \"url\": \"https://example.com/calendar\" } } }, ] }`"]
        #[serde(
            rename = "buttonList",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub button_list: ::std::option::Option<crate::schemas::AppsDynamiteStorageButtonList>,
        #[doc = "Displays a single row of columns with widgets stacked vertically in each column. For example, the following JSON creates a 2 column widget each containing a single item. `\"columns\": { \"wrapStyle\": \"WRAP\", \"columnItems\": [ { \"horizontalSizeStyle\": \"FILL_AVAILABLE_SPACE\", \"horizontalAlignment\": \"CENTER\", \"verticalAlignment\" : \"CENTER\", \"widgets\": [ { \"textParagraph\": { \"text\": \"First column text paragraph\", } } ] }, { \"horizontalSizeStyle\": \"FILL_AVAILABLE_SPACE\", \"horizontalAlignment\": \"CENTER\", \"verticalAlignment\" : \"CENTER\", \"widgets\": [ { \"textParagraph\": { \"text\": \"Second column text paragraph\", } } ] }, ] } }`"]
        #[serde(
            rename = "columns",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub columns: ::std::option::Option<crate::schemas::AppsDynamiteStorageColumns>,
        #[doc = "Displays a selection/input widget for date/time. For example, the following JSON creates a date/time picker for an appointment time: `\"date_time_picker\": { \"name\": \"appointment_time\", \"label\": \"Book your appointment at:\", \"type\": \"DateTimePickerType.DATE_AND_TIME\", \"valueMsEpoch\": \"796435200000\" }`"]
        #[serde(
            rename = "dateTimePicker",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date_time_picker:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageDateTimePicker>,
        #[doc = "Displays a decorated text item in this widget. For example, the following JSON creates a decorated text widget showing email address: `\"decoratedText\": { \"icon\": { \"knownIcon\": \"EMAIL\" }, \"topLabel\": \"Email Address\", \"content\": \"heba.salam@example.com\", \"bottomLabel\": \"This is a new Email address!\", \"switchWidget\": { \"name\": \"has_send_welcome_email_to_heba_salam\", \"selected\": false, \"controlType\": \"ControlType.CHECKBOX\" } }`"]
        #[serde(
            rename = "decoratedText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub decorated_text: ::std::option::Option<crate::schemas::AppsDynamiteStorageDecoratedText>,
        #[doc = "Displays a divider. For example, the following JSON creates a divider: `\"divider\": { }`"]
        #[serde(
            rename = "divider",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub divider: ::std::option::Option<crate::schemas::AppsDynamiteStorageDivider>,
        #[doc = "Displays a grid with a collection of items. For example, the following JSON creates a 2 column grid with a single item: `\"grid\": { \"title\": \"A fine collection of items\", \"numColumns\": 2, \"borderStyle\": { \"type\": \"STROKE\", \"cornerRadius\": 4.0 }, \"items\": [ \"image\": { \"imageUri\": \"https://www.example.com/image.png\", \"cropStyle\": { \"type\": \"SQUARE\" }, \"borderStyle\": { \"type\": \"STROKE\" } }, \"title\": \"An item\", \"textAlignment\": \"CENTER\" ], \"onClick\": { \"openLink\": { \"url\":\"https://www.example.com\" } } }`"]
        #[serde(
            rename = "grid",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub grid: ::std::option::Option<crate::schemas::AppsDynamiteStorageGrid>,
        #[doc = "The horizontal alignment of this widget."]
        #[serde(
            rename = "horizontalAlignment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub horizontal_alignment:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageWidgetHorizontalAlignment>,
        #[doc = "Displays an image in this widget. For example, the following JSON creates an image with alternative text: `\"image\": { \"imageUrl\": \"https://example.com/heba_salam.png\" \"altText\": \"Avatar for Heba Salam\" }`"]
        #[serde(
            rename = "image",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image: ::std::option::Option<crate::schemas::AppsDynamiteStorageImage>,
        #[doc = "Displays a switch control in this widget. For example, the following JSON creates a dropdown selection for size: `\"switchControl\": { \"name\": \"size\", \"label\": \"Size\" \"type\": \"SelectionType.DROPDOWN\", \"items\": [ { \"text\": \"S\", \"value\": \"small\", \"selected\": false }, { \"text\": \"M\", \"value\": \"medium\", \"selected\": true }, { \"text\": \"L\", \"value\": \"large\", \"selected\": false }, { \"text\": \"XL\", \"value\": \"extra_large\", \"selected\": false } ] }`"]
        #[serde(
            rename = "selectionInput",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub selection_input:
            ::std::option::Option<crate::schemas::AppsDynamiteStorageSelectionInput>,
        #[doc = "Displays a text input in this widget. For example, the following JSON creates a text input for mail address: `\"textInput\": { \"name\": \"mailing_address\", \"label\": \"Mailing Address\" }` As another example, the following JSON creates a text input for programming language with static suggestions: `\"textInput\": { \"name\": \"preferred_programing_language\", \"label\": \"Preferred Language\", \"initialSuggestions\": { \"items\": [ { \"text\": \"C++\" }, { \"text\": \"Java\" }, { \"text\": \"JavaScript\" }, { \"text\": \"Python\" } ] } }`"]
        #[serde(
            rename = "textInput",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_input: ::std::option::Option<crate::schemas::AppsDynamiteStorageTextInput>,
        #[doc = "Displays a text paragraph in this widget. For example, the following JSON creates a bolded text: `\"textParagraph\": { \"text\": \" *bold text*\" }`"]
        #[serde(
            rename = "textParagraph",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_paragraph: ::std::option::Option<crate::schemas::AppsDynamiteStorageTextParagraph>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageWidget {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageWidget {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsDynamiteStorageWidgetHorizontalAlignment {
        #[doc = "Alignment to the center position."]
        Center,
        #[doc = "Alignment to the end position."]
        End,
        #[doc = "Unspecified alignment."]
        HorizontalAlignmentUnspecified,
        #[doc = "Alignment to the start position."]
        Start,
    }
    impl AppsDynamiteStorageWidgetHorizontalAlignment {
        pub fn as_str(self) -> &'static str {
            match self {
                AppsDynamiteStorageWidgetHorizontalAlignment::Center => "CENTER",
                AppsDynamiteStorageWidgetHorizontalAlignment::End => "END",
                AppsDynamiteStorageWidgetHorizontalAlignment::HorizontalAlignmentUnspecified => {
                    "HORIZONTAL_ALIGNMENT_UNSPECIFIED"
                }
                AppsDynamiteStorageWidgetHorizontalAlignment::Start => "START",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AppsDynamiteStorageWidgetHorizontalAlignment {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AppsDynamiteStorageWidgetHorizontalAlignment {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AppsDynamiteStorageWidgetHorizontalAlignment, ()> {
            Ok(match s {
                "CENTER" => AppsDynamiteStorageWidgetHorizontalAlignment::Center,
                "END" => AppsDynamiteStorageWidgetHorizontalAlignment::End,
                "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                    AppsDynamiteStorageWidgetHorizontalAlignment::HorizontalAlignmentUnspecified
                }
                "START" => AppsDynamiteStorageWidgetHorizontalAlignment::Start,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AppsDynamiteStorageWidgetHorizontalAlignment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AppsDynamiteStorageWidgetHorizontalAlignment {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AppsDynamiteStorageWidgetHorizontalAlignment {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CENTER" => AppsDynamiteStorageWidgetHorizontalAlignment::Center,
                "END" => AppsDynamiteStorageWidgetHorizontalAlignment::End,
                "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                    AppsDynamiteStorageWidgetHorizontalAlignment::HorizontalAlignmentUnspecified
                }
                "START" => AppsDynamiteStorageWidgetHorizontalAlignment::Start,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteStorageWidgetHorizontalAlignment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteStorageWidgetHorizontalAlignment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteV1ApiCompatV1Action {
        #[doc = "Confirmation dialog config."]
        #[serde(
            rename = "confirm",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub confirm: ::std::option::Option<crate::schemas::AppsDynamiteV1ApiCompatV1ActionConfirm>,
        #[doc = "Unique identifier for this action."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Action type - currently only “button”."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<String>,
        #[doc = "Button style (“default”, “primary”, or “danger”)."]
        #[serde(
            rename = "style",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub style: ::std::option::Option<String>,
        #[doc = "User-facing label for the action."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "Payload for this action. Will be sent to the action handler along with name."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteV1ApiCompatV1Action {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteV1ApiCompatV1Action {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteV1ApiCompatV1ActionConfirm {
        #[doc = "“Cancel” button label."]
        #[serde(
            rename = "dismiss_text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dismiss_text: ::std::option::Option<String>,
        #[doc = "“OK” button label."]
        #[serde(
            rename = "ok_text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ok_text: ::std::option::Option<String>,
        #[doc = "Confirmation dialog body text."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "Confirmation dialog title."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteV1ApiCompatV1ActionConfirm {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteV1ApiCompatV1ActionConfirm {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteV1ApiCompatV1Attachment {
        #[doc = "Array of actions (currently only buttons)."]
        #[serde(
            rename = "actions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub actions: ::std::option::Option<Vec<crate::schemas::AppsDynamiteV1ApiCompatV1Action>>,
        #[doc = "Undocumented - used in interactive button examples. The only valid value appears to be “default”."]
        #[serde(
            rename = "attachment_type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment_type: ::std::option::Option<String>,
        #[doc = "Avatar URL for the user."]
        #[serde(
            rename = "author_icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub author_icon: ::std::option::Option<String>,
        #[doc = "URL that the user name should link to."]
        #[serde(
            rename = "author_link",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub author_link: ::std::option::Option<String>,
        #[doc = "User name to display as the author of the message."]
        #[serde(
            rename = "author_name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub author_name: ::std::option::Option<String>,
        #[doc = "Unique identifier for the collection of buttons within this attachment. Will be sent back to the action handler URL when a button is clicked."]
        #[serde(
            rename = "callback_id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub callback_id: ::std::option::Option<String>,
        #[doc = "A color “bar” to display to the left of the attachment."]
        #[serde(
            rename = "color",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub color: ::std::option::Option<String>,
        #[doc = "Fallback plain-text string for clients that don’t support attachments."]
        #[serde(
            rename = "fallback",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fallback: ::std::option::Option<String>,
        #[doc = "Columns of text inside the attachment body."]
        #[serde(
            rename = "fields",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fields: ::std::option::Option<Vec<crate::schemas::AppsDynamiteV1ApiCompatV1Field>>,
        #[doc = "A string displayed at the bottom of the attachment."]
        #[serde(
            rename = "footer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub footer: ::std::option::Option<String>,
        #[doc = "Avatar URL displayed to the left of the footer."]
        #[serde(
            rename = "footer_icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub footer_icon: ::std::option::Option<String>,
        #[doc = "URL of an image to display in an image chip."]
        #[serde(
            rename = "image_url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
        #[doc = "List of fields to apply formatting to."]
        #[serde(
            rename = "mrkdwn_in",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mrkdwn_in: ::std::option::Option<Vec<String>>,
        #[doc = "A string to show above the attachment."]
        #[serde(
            rename = "pretext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pretext: ::std::option::Option<String>,
        #[doc = "Main text."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "URL of a thumbnail image to display to the right of the attachment body."]
        #[serde(
            rename = "thumb_url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thumb_url: ::std::option::Option<String>,
        #[doc = "Title string of this attachment."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
        #[doc = "URL that the title string should link to."]
        #[serde(
            rename = "title_link",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title_link: ::std::option::Option<String>,
        #[doc = "UNIX timestamp of the attachment."]
        #[serde(
            rename = "ts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ts: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteV1ApiCompatV1Attachment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteV1ApiCompatV1Attachment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsDynamiteV1ApiCompatV1Field {
        #[doc = "Whether the field can be shown side-by-side with another field."]
        #[serde(
            rename = "short",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub short: ::std::option::Option<bool>,
        #[doc = "The heading text, shown in bold."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
        #[doc = "The text value of the field."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AppsDynamiteV1ApiCompatV1Field {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AppsDynamiteV1ApiCompatV1Field {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup { # [serde (rename = "addonAttachments" , default , skip_serializing_if = "std::option::Option::is_none")] pub addon_attachments : :: std :: option :: Option < Vec < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment > > , }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment {
        #[doc = "Link to the resource’s icon."]
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[doc = "MIME type of the content in resource_url."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[serde(
            rename = "resourceUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resource_url: ::std::option::Option<String>,
        #[doc = "Title of the attachment."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup { # [doc = "Unique identifier for this conference data. Maximum 512 characters long."] # [serde (rename = "conferenceId" , default , skip_serializing_if = "std::option::Option::is_none")] pub conference_id : :: std :: option :: Option < String > , # [doc = "An identifier of the conferencing solution. Must match a value from the deployment’s `calendar.conferenceSolution.id` field."] # [serde (rename = "conferenceSolutionId" , default , skip_serializing_if = "std::option::Option::is_none")] pub conference_solution_id : :: std :: option :: Option < String > , # [doc = "Entry points to the conference. Maximum 300 entry points are allowed."] # [serde (rename = "entryPoints" , default , skip_serializing_if = "std::option::Option::is_none")] pub entry_points : :: std :: option :: Option < Vec < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup > > , # [doc = "If set, it means an error occurred during conference creation."] # [serde (rename = "error" , default , skip_serializing_if = "std::option::Option::is_none")] pub error : :: std :: option :: Option < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError > , # [doc = "Additional notes (such as instructions from the administrator, legal notices) to display to the user. Can contain HTML. Max length 2048 characters."] # [serde (rename = "note" , default , skip_serializing_if = "std::option::Option::is_none")] pub note : :: std :: option :: Option < String > , # [doc = "Additional add-on parameters. Maximum 300 parameters are allowed."] # [serde (rename = "parameters" , default , skip_serializing_if = "std::option::Option::is_none")] pub parameters : :: std :: option :: Option < Vec < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter > > , }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup { # [doc = "An access code for accessing the conference. Maximum 128 characters long."] # [serde (rename = "accessCode" , default , skip_serializing_if = "std::option::Option::is_none")] pub access_code : :: std :: option :: Option < String > , # [doc = "Features of the entry point, such as being toll or toll-free. One entry point can have multiple features."] # [serde (rename = "features" , default , skip_serializing_if = "std::option::Option::is_none")] pub features : :: std :: option :: Option < Vec < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems > > , # [doc = "The label of the entry point to display to the user. Maximum 512 characters long."] # [serde (rename = "label" , default , skip_serializing_if = "std::option::Option::is_none")] pub label : :: std :: option :: Option < String > , # [doc = "A meeting code for accessing the conference. Maximum 128 characters long."] # [serde (rename = "meetingCode" , default , skip_serializing_if = "std::option::Option::is_none")] pub meeting_code : :: std :: option :: Option < String > , # [doc = "A passcode for accessing the conference. Maximum 128 characters long."] # [serde (rename = "passcode" , default , skip_serializing_if = "std::option::Option::is_none")] pub passcode : :: std :: option :: Option < String > , # [doc = "A password for accessing the conference. Maximum 128 characters long."] # [serde (rename = "password" , default , skip_serializing_if = "std::option::Option::is_none")] pub password : :: std :: option :: Option < String > , # [doc = "A PIN for accessing the conference. Maximum 128 characters long."] # [serde (rename = "pin" , default , skip_serializing_if = "std::option::Option::is_none")] pub pin : :: std :: option :: Option < String > , # [doc = "The type of the entry point. Required."] # [serde (rename = "type" , default , skip_serializing_if = "std::option::Option::is_none")] pub r#type : :: std :: option :: Option < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType > , # [doc = "The CLDR/ISO 3166 region code for the country associated with this entry point. Applicable only to `Type.PHONE`."] # [serde (rename = "regionCode" , default , skip_serializing_if = "std::option::Option::is_none")] pub region_code : :: std :: option :: Option < String > , # [doc = "A URI for joining the conference. Supports tel: and http(s): and should be at most 1300 characters long. Required."] # [serde (rename = "uri" , default , skip_serializing_if = "std::option::Option::is_none")] pub uri : :: std :: option :: Option < String > , }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems
    {
        #[doc = "Applies to `PHONE` entry point. A call to a toll number is charged to the calling party. A number can’t be toll and toll-free at the same time."]
        Toll,
        #[doc = "Applies to `PHONE` entry point. For the calling party, a call to a toll-free number is free of charge. A number can’t be toll and toll-free at the same time."]
        TollFree,
        #[doc = "Unknown feature."]
        UnknownFeature,
    }
    impl AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems { pub fn as_str (self) -> & 'static str { match self { AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: Toll => "TOLL" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: TollFree => "TOLL_FREE" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: UnknownFeature => "UNKNOWN_FEATURE" , } } }
    impl :: std :: convert :: AsRef < str > for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems { fn as_ref (& self) -> & str { self . as_str () } }
    impl :: std :: str :: FromStr for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems { type Err = () ; fn from_str (s : & str) -> :: std :: result :: Result < AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems , () > { Ok (match s { "TOLL" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: Toll , "TOLL_FREE" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: TollFree , "UNKNOWN_FEATURE" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: UnknownFeature , _ => return Err (()) , }) } }
    impl :: std :: fmt :: Display for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_str (self . as_str ()) } }
    impl :: serde :: Serialize for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems { fn serialize < S > (& self , serializer : S) -> :: std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: ser :: Serializer { serializer . serialize_str (self . as_str ()) } }
    impl < 'de > :: serde :: Deserialize < 'de > for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems { fn deserialize < D > (deserializer : D) -> :: std :: result :: Result < Self , D :: Error > where D : :: serde :: de :: Deserializer < 'de > , { let value : & 'de str = < & str > :: deserialize (deserializer) ? ; Ok (match value { "TOLL" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: Toll , "TOLL_FREE" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: TollFree , "UNKNOWN_FEATURE" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems :: UnknownFeature , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , }) } }
    impl :: google_field_selector :: FieldSelector for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems { fn fields () -> Vec < :: google_field_selector :: Field > { Vec :: new () } }
    impl :: google_field_selector :: ToFieldType for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupFeaturesItems { fn field_type () -> :: google_field_selector :: FieldType { :: google_field_selector :: FieldType :: Leaf } }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType {
        #[doc = "Used to provide a link to further conference joining information."]
        More,
        #[doc = "A phone conference."]
        Phone,
        #[doc = "A conference using [Session Initiation Protocol](https://en.wikipedia.org/wiki/Session_Initiation_Protocol)"]
        Sip,
        #[doc = "Unknown conference type."]
        Unknown,
        #[doc = "A video conference."]
        Video,
    }
    impl AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType {
        pub fn as_str(self) -> &'static str {
            match self { AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: More => "MORE" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Phone => "PHONE" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Sip => "SIP" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Unknown => "UNKNOWN" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Video => "VIDEO" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType,
            (),
        > {
            Ok (match s { "MORE" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: More , "PHONE" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Phone , "SIP" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Sip , "UNKNOWN" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Unknown , "VIDEO" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Video , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "MORE" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: More , "PHONE" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Phone , "SIP" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Sip , "UNKNOWN" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Unknown , "VIDEO" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType :: Video , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkupType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError { # [doc = "If the error type is `AUTHENTICATION`, the add-on can provide a URL allowing users to log in. Maximum 1300 characters long."] # [serde (rename = "authenticationUrl" , default , skip_serializing_if = "std::option::Option::is_none")] pub authentication_url : :: std :: option :: Option < String > , # [doc = "The type of error. Required."] # [serde (rename = "type" , default , skip_serializing_if = "std::option::Option::is_none")] pub r#type : :: std :: option :: Option < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType > , }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType {
        #[doc = "An authentication error."]
        Authentication,
        #[doc = "The user isn’t allowed to use the selected conference solution (but might be allowed to use other solutions offered by the add-on)."]
        ConferenceSolutionForbidden,
        #[doc = "A permanent error."]
        Permanent,
        #[doc = "The user isn’t allowed to perform some action in the third-party conferencing system."]
        PermissionDenied,
        #[doc = "A temporary error."]
        Temporary,
        #[doc = "Unknown error."]
        Unknown,
    }
    impl AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType {
        pub fn as_str(self) -> &'static str {
            match self { AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Authentication => "AUTHENTICATION" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: ConferenceSolutionForbidden => "CONFERENCE_SOLUTION_FORBIDDEN" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Permanent => "PERMANENT" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: PermissionDenied => "PERMISSION_DENIED" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Temporary => "TEMPORARY" , AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Unknown => "UNKNOWN" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType,
            (),
        > {
            Ok (match s { "AUTHENTICATION" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Authentication , "CONFERENCE_SOLUTION_FORBIDDEN" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: ConferenceSolutionForbidden , "PERMANENT" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Permanent , "PERMISSION_DENIED" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: PermissionDenied , "TEMPORARY" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Temporary , "UNKNOWN" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Unknown , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "AUTHENTICATION" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Authentication , "CONFERENCE_SOLUTION_FORBIDDEN" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: ConferenceSolutionForbidden , "PERMANENT" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Permanent , "PERMISSION_DENIED" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: PermissionDenied , "TEMPORARY" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Temporary , "UNKNOWN" => AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType :: Unknown , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupErrorType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter {
        #[doc = "The key of the parameter. Maximum 50 characters long. Required."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "The value of the parameter. Maximum 1024 characters long. Required."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup {
        #[doc = "A list of attendees to add to the Google Calendar event."]
        #[serde(
            rename = "addAttendeeEmails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub add_attendee_emails: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup {
        #[doc = "The conference data to add to the Google Calendar event."]
        #[serde(
            rename = "conferenceData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub conference_data: ::std::option::Option<
            crate::schemas::AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct Attachment {
        #[doc = "Revised version of Gmail AddOn attachment approved by API design review."]
        #[serde(
            rename = "addOnData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub add_on_data: ::std::option::Option<crate::schemas::GoogleChatV1ContextualAddOnMarkup>,
        #[doc = "The userId for the bot/app that created this data, to be used for attribution of attachments when the attachment was not created by the message sender."]
        #[serde(
            rename = "appId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "To identify an attachment within repeated in a message"]
        #[serde(
            rename = "attachmentId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment_id: ::std::option::Option<String>,
        #[doc = "Card AddOn attachment with the possibility for specifying editable widgets."]
        #[serde(
            rename = "cardAddOnData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub card_add_on_data: ::std::option::Option<crate::schemas::AppsDynamiteStorageCard>,
        #[doc = "Deprecated version of Gmail AddOn attachment."]
        #[serde(
            rename = "deprecatedAddOnData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deprecated_add_on_data: ::std::option::Option<crate::schemas::ContextualAddOnMarkup>,
        #[doc = "Slack attachment."]
        #[serde(
            rename = "slackData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub slack_data: ::std::option::Option<crate::schemas::AppsDynamiteV1ApiCompatV1Attachment>,
        #[doc = "The height of image url as fetched by fife. This field is asynchronously filled."]
        #[serde(
            rename = "slackDataImageUrlHeight",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub slack_data_image_url_height: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for Attachment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Attachment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Attribute {
        #[doc = "The name of the attribute. Required - If a write is attempted with an empty string, the server will return an error."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<crate::schemas::CaribouAttributeValue>,
    }
    impl ::google_field_selector::FieldSelector for Attribute {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Attribute {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AttributeRemoved {
        #[serde(
            rename = "attributeId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attribute_id: ::std::option::Option<String>,
        #[serde(
            rename = "messageKeys",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_keys: ::std::option::Option<Vec<crate::schemas::MultiKey>>,
    }
    impl ::google_field_selector::FieldSelector for AttributeRemoved {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AttributeRemoved {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AttributeSet {
        #[serde(
            rename = "attributeId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attribute_id: ::std::option::Option<String>,
        #[doc = "The serialized attribute_value as persisted in the storage layer. The application is responsible for deserializing it to an Attribute.Value if appropriate."]
        #[serde(
            rename = "attributeValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attribute_value: ::std::option::Option<::google_api_bytes::Bytes>,
        #[serde(
            rename = "messageKeys",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_keys: ::std::option::Option<Vec<crate::schemas::MultiKey>>,
    }
    impl ::google_field_selector::FieldSelector for AttributeSet {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AttributeSet {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Attributes {
        #[serde(
            rename = "attribute",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attribute: ::std::option::Option<Vec<crate::schemas::Attribute>>,
    }
    impl ::google_field_selector::FieldSelector for Attributes {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Attributes {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AuditLoggingSettings {
        #[doc = "Indicates whether audit logging is on/off for admin activity read APIs i.e. Get/List DataSources, Get/List SearchApplications etc."]
        #[serde(
            rename = "logAdminReadActions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_admin_read_actions: ::std::option::Option<bool>,
        #[doc = "Indicates whether audit logging is on/off for data access read APIs i.e. ListItems, GetItem etc."]
        #[serde(
            rename = "logDataReadActions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_data_read_actions: ::std::option::Option<bool>,
        #[doc = "Indicates whether audit logging is on/off for data access write APIs i.e. IndexItem etc."]
        #[serde(
            rename = "logDataWriteActions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_data_write_actions: ::std::option::Option<bool>,
        #[doc = "The resource name of the GCP Project to store audit logs. Cloud audit logging will be enabled after project_name has been updated through CustomerService. Format: projects/{project_id}"]
        #[serde(
            rename = "project",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub project: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AuditLoggingSettings {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AuditLoggingSettings {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AuthorizedItemId {
        #[doc = "Serialized ID of the Drive resource"]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
        #[doc = "Resource key of the Drive item. This field should be unset if, depending on the context, the item does not have a resource key, or if none was specified. This must never be logged."]
        #[serde(
            rename = "resourceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resource_key: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AuthorizedItemId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AuthorizedItemId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AutoComplete {
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<Vec<crate::schemas::AutoCompleteItem>>,
    }
    impl ::google_field_selector::FieldSelector for AutoComplete {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AutoComplete {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AutoCompleteItem {
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for AutoCompleteItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AutoCompleteItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BabelMessageProps {
        #[doc = "Babel clients locally generate this ID to dedupe against the async fanout."]
        #[serde(
            rename = "clientGeneratedId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub client_generated_id: ::std::option::Option<i64>,
        #[doc = "Stores additional Babel-specific properties (such as event metadata)."]
        #[serde(
            rename = "contentExtension",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_extension: ::std::option::Option<crate::schemas::ChatContentExtension>,
        #[doc = "Stores the delivery source of messages (such as phone number for SMS)."]
        #[serde(
            rename = "deliveryMedium",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub delivery_medium: ::std::option::Option<crate::schemas::DeliveryMedium>,
        #[doc = "Primary identifier used by Hangouts Classic for its events (messages)."]
        #[serde(
            rename = "eventId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_id: ::std::option::Option<String>,
        #[doc = "Stores message segments (text content) and attachments (media URLs)."]
        #[serde(
            rename = "messageContent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_content: ::std::option::Option<crate::schemas::ChatConserverMessageContent>,
        #[doc = "Whether or not these message properties were backfilled by go/dinnertrain."]
        #[serde(
            rename = "wasUpdatedByBackfill",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub was_updated_by_backfill: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for BabelMessageProps {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BabelMessageProps {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BabelPlaceholderMetadata {
        #[serde(
            rename = "deleteMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub delete_metadata: ::std::option::Option<crate::schemas::DeleteMetadata>,
        #[serde(
            rename = "editMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub edit_metadata: ::std::option::Option<crate::schemas::EditMetadata>,
        #[serde(
            rename = "hangoutVideoMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hangout_video_metadata:
            ::std::option::Option<crate::schemas::HangoutVideoEventMetadata>,
    }
    impl ::google_field_selector::FieldSelector for BabelPlaceholderMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BabelPlaceholderMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BooleanOperatorOptions {
        #[doc = "Indicates the operator name required in the query in order to isolate the boolean property. For example, if operatorName is *closed* and the property’s name is *isClosed*, then queries like *closed:<value>* show results only where the value of the property named *isClosed* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for BooleanOperatorOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BooleanOperatorOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BooleanPropertyOptions {
        #[doc = "If set, describes how the boolean should be used as a search operator."]
        #[serde(
            rename = "operatorOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_options: ::std::option::Option<crate::schemas::BooleanOperatorOptions>,
    }
    impl ::google_field_selector::FieldSelector for BooleanPropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BooleanPropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BorderStyle {
        #[doc = "The corner radius for the border."]
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub corner_radius: ::std::option::Option<i32>,
        #[doc = "The border type."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::BorderStyleType>,
        #[doc = "The colors to use when the type is STROKE."]
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stroke_color: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for BorderStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BorderStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BorderStyleType {
        #[doc = "No value specified."]
        BorderTypeNotSet,
        #[doc = "No border."]
        NoBorder,
        #[doc = "Outline."]
        Stroke,
    }
    impl BorderStyleType {
        pub fn as_str(self) -> &'static str {
            match self {
                BorderStyleType::BorderTypeNotSet => "BORDER_TYPE_NOT_SET",
                BorderStyleType::NoBorder => "NO_BORDER",
                BorderStyleType::Stroke => "STROKE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BorderStyleType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BorderStyleType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BorderStyleType, ()> {
            Ok(match s {
                "BORDER_TYPE_NOT_SET" => BorderStyleType::BorderTypeNotSet,
                "NO_BORDER" => BorderStyleType::NoBorder,
                "STROKE" => BorderStyleType::Stroke,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BorderStyleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BorderStyleType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BorderStyleType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BORDER_TYPE_NOT_SET" => BorderStyleType::BorderTypeNotSet,
                "NO_BORDER" => BorderStyleType::NoBorder,
                "STROKE" => BorderStyleType::Stroke,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BorderStyleType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BorderStyleType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BotInfo {
        #[serde(
            rename = "appAllowlistStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app_allowlist_status: ::std::option::Option<crate::schemas::BotInfoAppAllowlistStatus>,
        #[doc = "Identifier of the application associated with the bot."]
        #[serde(
            rename = "appId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app_id: ::std::option::Option<crate::schemas::AppId>,
        #[doc = "URL for the avatar picture of the User in dynamite. This field should be populated if the request is FetchBotCategories/ListBotCatalogEntries"]
        #[serde(
            rename = "botAvatarUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bot_avatar_url: ::std::option::Option<String>,
        #[doc = "Non-unique, user-defined display name of the Bot. This field should be populated if the request is FetchBotCategories/ListBotCatalogEntries."]
        #[serde(
            rename = "botName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bot_name: ::std::option::Option<String>,
        #[doc = "Short description for the bot."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Name of bot developer."]
        #[serde(
            rename = "developerName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub developer_name: ::std::option::Option<String>,
        #[doc = "URL for the banner image in GSuite Market Place. The banner will be 220x140."]
        #[serde(
            rename = "marketPlaceBannerUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub market_place_banner_url: ::std::option::Option<String>,
        #[doc = "Indicates whether bot is enabled/disabled."]
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status: ::std::option::Option<crate::schemas::BotInfoStatus>,
        #[doc = "If the app supports a home screen."]
        #[serde(
            rename = "supportHomeScreen",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub support_home_screen: ::std::option::Option<bool>,
        #[doc = "Urls with additional information related to the bot. This field should always be set even if all the fields within it are empty, so that it is convenient for clients to work with this field in javascript."]
        #[serde(
            rename = "supportUrls",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub support_urls: ::std::option::Option<crate::schemas::SupportUrls>,
        #[doc = "The supported uses are limited according to the user that made the request. If the user does not have permission to use the bot, the list will be empty. This could occur for non whitelisted bots in the catalog."]
        #[serde(
            rename = "supportedUses",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub supported_uses: ::std::option::Option<Vec<crate::schemas::BotInfoSupportedUsesItems>>,
    }
    impl ::google_field_selector::FieldSelector for BotInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BotInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BotInfoAppAllowlistStatus {
        #[doc = "For both ALL_APPS_DISABLED_BY_ADMIN and APP_NOT_ALLOWLISTED_BY_ADMIN, the app should still be visible in the catalog, but usage of the app will be disabled. Indicates that all apps have been disabled by the dasher admin."]
        AllAppsDisabledByAdmin,
        Allowed,
        #[doc = "Indicates that the customer is using allowlisting, but that the bot is not allowlisted."]
        AppNotAllowlistedByAdmin,
        UnspecifiedStatus,
    }
    impl BotInfoAppAllowlistStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                BotInfoAppAllowlistStatus::AllAppsDisabledByAdmin => "ALL_APPS_DISABLED_BY_ADMIN",
                BotInfoAppAllowlistStatus::Allowed => "ALLOWED",
                BotInfoAppAllowlistStatus::AppNotAllowlistedByAdmin => {
                    "APP_NOT_ALLOWLISTED_BY_ADMIN"
                }
                BotInfoAppAllowlistStatus::UnspecifiedStatus => "UNSPECIFIED_STATUS",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BotInfoAppAllowlistStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BotInfoAppAllowlistStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BotInfoAppAllowlistStatus, ()> {
            Ok(match s {
                "ALL_APPS_DISABLED_BY_ADMIN" => BotInfoAppAllowlistStatus::AllAppsDisabledByAdmin,
                "ALLOWED" => BotInfoAppAllowlistStatus::Allowed,
                "APP_NOT_ALLOWLISTED_BY_ADMIN" => {
                    BotInfoAppAllowlistStatus::AppNotAllowlistedByAdmin
                }
                "UNSPECIFIED_STATUS" => BotInfoAppAllowlistStatus::UnspecifiedStatus,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BotInfoAppAllowlistStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BotInfoAppAllowlistStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BotInfoAppAllowlistStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ALL_APPS_DISABLED_BY_ADMIN" => BotInfoAppAllowlistStatus::AllAppsDisabledByAdmin,
                "ALLOWED" => BotInfoAppAllowlistStatus::Allowed,
                "APP_NOT_ALLOWLISTED_BY_ADMIN" => {
                    BotInfoAppAllowlistStatus::AppNotAllowlistedByAdmin
                }
                "UNSPECIFIED_STATUS" => BotInfoAppAllowlistStatus::UnspecifiedStatus,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BotInfoAppAllowlistStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BotInfoAppAllowlistStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BotInfoStatus {
        #[doc = "Bot has been disabled by the bot developer. No one can @mention or interact with the bot."]
        DisabledByDeveloper,
        Enabled,
        UnknownStatus,
    }
    impl BotInfoStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                BotInfoStatus::DisabledByDeveloper => "DISABLED_BY_DEVELOPER",
                BotInfoStatus::Enabled => "ENABLED",
                BotInfoStatus::UnknownStatus => "UNKNOWN_STATUS",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BotInfoStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BotInfoStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BotInfoStatus, ()> {
            Ok(match s {
                "DISABLED_BY_DEVELOPER" => BotInfoStatus::DisabledByDeveloper,
                "ENABLED" => BotInfoStatus::Enabled,
                "UNKNOWN_STATUS" => BotInfoStatus::UnknownStatus,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BotInfoStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BotInfoStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BotInfoStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DISABLED_BY_DEVELOPER" => BotInfoStatus::DisabledByDeveloper,
                "ENABLED" => BotInfoStatus::Enabled,
                "UNKNOWN_STATUS" => BotInfoStatus::UnknownStatus,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BotInfoStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BotInfoStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BotInfoSupportedUsesItems {
        CanAddToDm,
        CanAddToHumanDm,
        CanAddToRoom,
        Unknown,
    }
    impl BotInfoSupportedUsesItems {
        pub fn as_str(self) -> &'static str {
            match self {
                BotInfoSupportedUsesItems::CanAddToDm => "CAN_ADD_TO_DM",
                BotInfoSupportedUsesItems::CanAddToHumanDm => "CAN_ADD_TO_HUMAN_DM",
                BotInfoSupportedUsesItems::CanAddToRoom => "CAN_ADD_TO_ROOM",
                BotInfoSupportedUsesItems::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BotInfoSupportedUsesItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BotInfoSupportedUsesItems {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BotInfoSupportedUsesItems, ()> {
            Ok(match s {
                "CAN_ADD_TO_DM" => BotInfoSupportedUsesItems::CanAddToDm,
                "CAN_ADD_TO_HUMAN_DM" => BotInfoSupportedUsesItems::CanAddToHumanDm,
                "CAN_ADD_TO_ROOM" => BotInfoSupportedUsesItems::CanAddToRoom,
                "UNKNOWN" => BotInfoSupportedUsesItems::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BotInfoSupportedUsesItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BotInfoSupportedUsesItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BotInfoSupportedUsesItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CAN_ADD_TO_DM" => BotInfoSupportedUsesItems::CanAddToDm,
                "CAN_ADD_TO_HUMAN_DM" => BotInfoSupportedUsesItems::CanAddToHumanDm,
                "CAN_ADD_TO_ROOM" => BotInfoSupportedUsesItems::CanAddToRoom,
                "UNKNOWN" => BotInfoSupportedUsesItems::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BotInfoSupportedUsesItems {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BotInfoSupportedUsesItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BotResponse {
        #[serde(
            rename = "botId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bot_id: ::std::option::Option<crate::schemas::UserId>,
        #[serde(
            rename = "requiredAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub required_action: ::std::option::Option<crate::schemas::BotResponseRequiredAction>,
        #[serde(
            rename = "responseType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub response_type: ::std::option::Option<crate::schemas::BotResponseResponseType>,
        #[doc = "URL for setting up bot."]
        #[serde(
            rename = "setupUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub setup_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for BotResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BotResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BotResponseRequiredAction {
        #[doc = "Bot requires authentication."]
        Authentication,
        #[doc = "Bot requires configuration."]
        Configuration,
        UnknownSetupType,
    }
    impl BotResponseRequiredAction {
        pub fn as_str(self) -> &'static str {
            match self {
                BotResponseRequiredAction::Authentication => "AUTHENTICATION",
                BotResponseRequiredAction::Configuration => "CONFIGURATION",
                BotResponseRequiredAction::UnknownSetupType => "UNKNOWN_SETUP_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BotResponseRequiredAction {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BotResponseRequiredAction {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BotResponseRequiredAction, ()> {
            Ok(match s {
                "AUTHENTICATION" => BotResponseRequiredAction::Authentication,
                "CONFIGURATION" => BotResponseRequiredAction::Configuration,
                "UNKNOWN_SETUP_TYPE" => BotResponseRequiredAction::UnknownSetupType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BotResponseRequiredAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BotResponseRequiredAction {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BotResponseRequiredAction {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AUTHENTICATION" => BotResponseRequiredAction::Authentication,
                "CONFIGURATION" => BotResponseRequiredAction::Configuration,
                "UNKNOWN_SETUP_TYPE" => BotResponseRequiredAction::UnknownSetupType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BotResponseRequiredAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BotResponseRequiredAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BotResponseResponseType {
        #[doc = "A suggestion to promote an app."]
        AppSuggestion,
        #[doc = "Bot fails to respond because it is disabled by domain admin"]
        DisabledByAdmin,
        #[doc = "Bot fails to respond because it is disabled by the bot’s developer"]
        DisabledByDeveloper,
        #[doc = "Bot fails to respond because of deadline_exceeded or failing to parse bot message."]
        Error,
        #[doc = "Message to bot should be permanently private."]
        Private,
        #[doc = "Bot requires auth or config"]
        SetupRequired,
        UnknownResponseType,
    }
    impl BotResponseResponseType {
        pub fn as_str(self) -> &'static str {
            match self {
                BotResponseResponseType::AppSuggestion => "APP_SUGGESTION",
                BotResponseResponseType::DisabledByAdmin => "DISABLED_BY_ADMIN",
                BotResponseResponseType::DisabledByDeveloper => "DISABLED_BY_DEVELOPER",
                BotResponseResponseType::Error => "ERROR",
                BotResponseResponseType::Private => "PRIVATE",
                BotResponseResponseType::SetupRequired => "SETUP_REQUIRED",
                BotResponseResponseType::UnknownResponseType => "UNKNOWN_RESPONSE_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BotResponseResponseType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BotResponseResponseType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BotResponseResponseType, ()> {
            Ok(match s {
                "APP_SUGGESTION" => BotResponseResponseType::AppSuggestion,
                "DISABLED_BY_ADMIN" => BotResponseResponseType::DisabledByAdmin,
                "DISABLED_BY_DEVELOPER" => BotResponseResponseType::DisabledByDeveloper,
                "ERROR" => BotResponseResponseType::Error,
                "PRIVATE" => BotResponseResponseType::Private,
                "SETUP_REQUIRED" => BotResponseResponseType::SetupRequired,
                "UNKNOWN_RESPONSE_TYPE" => BotResponseResponseType::UnknownResponseType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BotResponseResponseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BotResponseResponseType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BotResponseResponseType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APP_SUGGESTION" => BotResponseResponseType::AppSuggestion,
                "DISABLED_BY_ADMIN" => BotResponseResponseType::DisabledByAdmin,
                "DISABLED_BY_DEVELOPER" => BotResponseResponseType::DisabledByDeveloper,
                "ERROR" => BotResponseResponseType::Error,
                "PRIVATE" => BotResponseResponseType::Private,
                "SETUP_REQUIRED" => BotResponseResponseType::SetupRequired,
                "UNKNOWN_RESPONSE_TYPE" => BotResponseResponseType::UnknownResponseType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BotResponseResponseType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BotResponseResponseType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BroadcastAccess {
        #[doc = "The policy that controls the broadcast’s viewer access."]
        #[serde(
            rename = "accessPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_policy: ::std::option::Option<crate::schemas::BroadcastAccessAccessPolicy>,
        #[doc = "A URL that can be used to access the broadcast of the meeting. This field will be empty if broadcast is not enabled. It will be populated by the backend. Clients cannot modify the value."]
        #[serde(
            rename = "viewUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub view_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for BroadcastAccess {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BroadcastAccess {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BroadcastAccessAccessPolicy {
        #[doc = "Used only when broadcast is not enabled, or an unknown enum value is used."]
        BroadcastingAccessPolicyUnspecified,
        #[doc = "Only authenticated Google accounts belonging to the same organization as the meeting organizer can access the broadcast."]
        Organization,
        #[doc = "Anyone with the broadcast view URL can access the broadcast."]
        Public,
    }
    impl BroadcastAccessAccessPolicy {
        pub fn as_str(self) -> &'static str {
            match self {
                BroadcastAccessAccessPolicy::BroadcastingAccessPolicyUnspecified => {
                    "BROADCASTING_ACCESS_POLICY_UNSPECIFIED"
                }
                BroadcastAccessAccessPolicy::Organization => "ORGANIZATION",
                BroadcastAccessAccessPolicy::Public => "PUBLIC",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BroadcastAccessAccessPolicy {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BroadcastAccessAccessPolicy {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BroadcastAccessAccessPolicy, ()> {
            Ok(match s {
                "BROADCASTING_ACCESS_POLICY_UNSPECIFIED" => {
                    BroadcastAccessAccessPolicy::BroadcastingAccessPolicyUnspecified
                }
                "ORGANIZATION" => BroadcastAccessAccessPolicy::Organization,
                "PUBLIC" => BroadcastAccessAccessPolicy::Public,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BroadcastAccessAccessPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BroadcastAccessAccessPolicy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BroadcastAccessAccessPolicy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BROADCASTING_ACCESS_POLICY_UNSPECIFIED" => {
                    BroadcastAccessAccessPolicy::BroadcastingAccessPolicyUnspecified
                }
                "ORGANIZATION" => BroadcastAccessAccessPolicy::Organization,
                "PUBLIC" => BroadcastAccessAccessPolicy::Public,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BroadcastAccessAccessPolicy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BroadcastAccessAccessPolicy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BroadcastSessionInfo {
        #[doc = "A unique server-generated ID for the broadcast session."]
        #[serde(
            rename = "broadcastSessionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub broadcast_session_id: ::std::option::Option<String>,
        #[doc = "Output only. Current broadcast session’s statistics."]
        #[serde(
            rename = "broadcastStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub broadcast_stats: ::std::option::Option<crate::schemas::BroadcastStats>,
        #[doc = "Input only. Deprecated field, should not be used."]
        #[serde(
            rename = "ingestionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ingestion_id: ::std::option::Option<String>,
        #[doc = "Broadcast session’s state information."]
        #[serde(
            rename = "sessionStateInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_state_info: ::std::option::Option<crate::schemas::SessionStateInfo>,
    }
    impl ::google_field_selector::FieldSelector for BroadcastSessionInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BroadcastSessionInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BroadcastStats {
        #[doc = "Estimated concurrent viewer count."]
        #[serde(
            rename = "estimatedViewerCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub estimated_viewer_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for BroadcastStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BroadcastStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Button {
        #[serde(
            rename = "imageButton",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_button: ::std::option::Option<crate::schemas::ImageButton>,
        #[serde(
            rename = "textButton",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_button: ::std::option::Option<crate::schemas::TextButton>,
    }
    impl ::google_field_selector::FieldSelector for Button {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Button {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CalendarClientActionMarkup { # [doc = "An action that adds attachments to the Google Calendar event."] # [serde (rename = "addAttachmentsActionMarkup" , default , skip_serializing_if = "std::option::Option::is_none")] pub add_attachments_action_markup : :: std :: option :: Option < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup > , # [doc = "An action that adds attendees to the Google Calendar event."] # [serde (rename = "editAttendeesActionMarkup" , default , skip_serializing_if = "std::option::Option::is_none")] pub edit_attendees_action_markup : :: std :: option :: Option < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup > , # [doc = "An action that adds conference data to the Google Calendar event."] # [serde (rename = "editConferenceDataActionMarkup" , default , skip_serializing_if = "std::option::Option::is_none")] pub edit_conference_data_action_markup : :: std :: option :: Option < crate :: schemas :: AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup > , }
    impl ::google_field_selector::FieldSelector for CalendarClientActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CalendarClientActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CallInfo {
        #[doc = "Abuse reporting configuration for the ongoing conference."]
        #[serde(
            rename = "abuseReportingConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub abuse_reporting_config: ::std::option::Option<crate::schemas::AbuseReportingConfig>,
        #[doc = "Output only. Display name of the owner of artifacts generated in this conference. The expected use of this in clients is to present info like “This recording will be sent to John Doe’s Drive”. This field can be empty if preferred display name determination fails for any reason."]
        #[serde(
            rename = "artifactOwner",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub artifact_owner: ::std::option::Option<crate::schemas::UserDisplayInfo>,
        #[doc = "Output only. Documents attached to an ongoing conference."]
        #[serde(
            rename = "attachedDocuments",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attached_documents: ::std::option::Option<Vec<crate::schemas::DocumentInfo>>,
        #[doc = "List of available access types of the conference."]
        #[serde(
            rename = "availableAccessTypes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub available_access_types:
            ::std::option::Option<Vec<crate::schemas::CallInfoAvailableAccessTypesItems>>,
        #[doc = "Output only. The set of reactions that clients are allowed to send and can expect to receive. Note that a device in the conference should have the MAY_SEND_REACTIONS privilege to be able to send reactions."]
        #[serde(
            rename = "availableReactions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub available_reactions: ::std::option::Option<Vec<crate::schemas::ReactionInfo>>,
        #[doc = "Information about active broadcast session in the ongoing conference."]
        #[serde(
            rename = "broadcastSessionInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub broadcast_session_info: ::std::option::Option<crate::schemas::BroadcastSessionInfo>,
        #[doc = "Output only. The calendar event ID of a Google Calendar event that the meeting space is associated with. If the meeting space is not associated with an event in Google Calendar, this field is empty. For recurring events, it refers to the recurring instance associated with the current call, as determined by the server."]
        #[serde(
            rename = "calendarEventId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub calendar_event_id: ::std::option::Option<String>,
        #[doc = "The current co-activity session, or unset if there is none in progress. A co-activity session can be initiated by devices in JOINED state . Initiator of the co-activity is expected to populate this field to start the session. Once clients detect that the co-activity has finished, any JOINED device can clear this field to end the co-activity session. In the case of switching activities, the initiator of the new activity merely needs to override this with the new co-activity data, and all connected clients are expected to handle the transition gracefully."]
        #[serde(
            rename = "coActivity",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub co_activity: ::std::option::Option<crate::schemas::CoActivity>,
        #[doc = "The current collaboration session, or unset if no collaboration is in progress."]
        #[serde(
            rename = "collaboration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub collaboration: ::std::option::Option<crate::schemas::Collaboration>,
        #[doc = "CSE information for the ongoing conference."]
        #[serde(
            rename = "cseInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cse_info: ::std::option::Option<crate::schemas::CseInfo>,
        #[doc = "Output only. The maximum number of devices that may be in the joined state simultaneously in this conference. This can be used by clients to guess whether it will be possible to join, but the only way to know is to try to join. It can also be used to inform users about the limit that is in effect. This limit is normally set when the conference is created and not changed during the lifetime of the conference. But there are some cases where it may change, so clients should be aware that the information may be stale."]
        #[serde(
            rename = "maxJoinedDevices",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_joined_devices: ::std::option::Option<i32>,
        #[doc = "Output only. The name or description of the organization or domain that the organizer belongs to. The expected use of this in clients is to present messages like “John Doe (outside of Google.com) is trying to join this call”, where “Google.com” is the organization name. The field will be empty if the organization name could not be determined, possibly because of a backend error."]
        #[serde(
            rename = "organizationName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub organization_name: ::std::option::Option<String>,
        #[doc = "Paygate information to clients."]
        #[serde(
            rename = "paygateInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub paygate_info: ::std::option::Option<crate::schemas::PaygateInfo>,
        #[doc = "The current presenter in the call, or unset if there is no current presenter. Clients can set this to change the presenter."]
        #[serde(
            rename = "presenter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub presenter: ::std::option::Option<crate::schemas::Presenter>,
        #[doc = "Deprecated, use RecordingSessionInfo instead. Info about recording for this conference. This will always be set in server responses, with a valid recording status. This is superseded by streaming_sessions field, which contains the same information about this recording as well as additional information about other application type at the same time. This will be deprecated and removed at some point."]
        #[serde(
            rename = "recordingInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recording_info: ::std::option::Option<crate::schemas::RecordingInfo>,
        #[doc = "Information about active recording session in the ongoing conference."]
        #[serde(
            rename = "recordingSessionInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recording_session_info: ::std::option::Option<crate::schemas::RecordingSessionInfo>,
        #[doc = "Settings of the ongoing conference."]
        #[serde(
            rename = "settings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub settings: ::std::option::Option<crate::schemas::CallSettings>,
        #[doc = "Output only. Info about streaming sessions (recording or broadcast) for this conference. This should contain all active sessions. Currently, it’s guaranteed to have at most one recording and at most one broadcast (at most two sessions in total). For each application type (recording or broadcast), latest inactive session is included if there’s no active one."]
        #[serde(
            rename = "streamingSessions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub streaming_sessions: ::std::option::Option<Vec<crate::schemas::StreamingSessionInfo>>,
        #[doc = "Information about active transcription session in the ongoing conference."]
        #[serde(
            rename = "transcriptionSessionInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transcription_session_info:
            ::std::option::Option<crate::schemas::TranscriptionSessionInfo>,
        #[doc = "The number of devices viewing the conference - MeetingDevices that are in VIEWER role and JOINED state in the conference."]
        #[serde(
            rename = "viewerCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub viewer_count: ::std::option::Option<i32>,
        #[doc = "Information about active YouTube broadcast sessions in the ongoing conference."]
        #[serde(
            rename = "youTubeBroadcastSessionInfos",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub you_tube_broadcast_session_infos:
            ::std::option::Option<Vec<crate::schemas::YouTubeBroadcastSessionInfo>>,
    }
    impl ::google_field_selector::FieldSelector for CallInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CallInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum CallInfoAvailableAccessTypesItems {
        #[doc = "Anyone with meeting join information (url, phone access…) can join, no knocking required. (Subject to organization policies)"]
        AccessTypeOpen,
        #[doc = "Only participants invited by a host can automatically join, everyone else must knock and be admitted. (Subject to organization policies) Participants cannot dial out from the meeting. And only hosts can accept knocks."]
        AccessTypeRestricted,
        #[doc = "Members of the Host’s organization, invited external users, and dial-in users can join without knocking, everyone else must knock. (Subject to organization policies)"]
        AccessTypeTrusted,
        #[doc = "Default value. This value is unused."]
        AccessTypeUnspecified,
    }
    impl CallInfoAvailableAccessTypesItems {
        pub fn as_str(self) -> &'static str {
            match self {
                CallInfoAvailableAccessTypesItems::AccessTypeOpen => "ACCESS_TYPE_OPEN",
                CallInfoAvailableAccessTypesItems::AccessTypeRestricted => "ACCESS_TYPE_RESTRICTED",
                CallInfoAvailableAccessTypesItems::AccessTypeTrusted => "ACCESS_TYPE_TRUSTED",
                CallInfoAvailableAccessTypesItems::AccessTypeUnspecified => {
                    "ACCESS_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for CallInfoAvailableAccessTypesItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for CallInfoAvailableAccessTypesItems {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<CallInfoAvailableAccessTypesItems, ()> {
            Ok(match s {
                "ACCESS_TYPE_OPEN" => CallInfoAvailableAccessTypesItems::AccessTypeOpen,
                "ACCESS_TYPE_RESTRICTED" => CallInfoAvailableAccessTypesItems::AccessTypeRestricted,
                "ACCESS_TYPE_TRUSTED" => CallInfoAvailableAccessTypesItems::AccessTypeTrusted,
                "ACCESS_TYPE_UNSPECIFIED" => {
                    CallInfoAvailableAccessTypesItems::AccessTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for CallInfoAvailableAccessTypesItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for CallInfoAvailableAccessTypesItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CallInfoAvailableAccessTypesItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACCESS_TYPE_OPEN" => CallInfoAvailableAccessTypesItems::AccessTypeOpen,
                "ACCESS_TYPE_RESTRICTED" => CallInfoAvailableAccessTypesItems::AccessTypeRestricted,
                "ACCESS_TYPE_TRUSTED" => CallInfoAvailableAccessTypesItems::AccessTypeTrusted,
                "ACCESS_TYPE_UNSPECIFIED" => {
                    CallInfoAvailableAccessTypesItems::AccessTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for CallInfoAvailableAccessTypesItems {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CallInfoAvailableAccessTypesItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CallSettings {
        #[doc = "Indicates whether the access lock is currently on or off."]
        #[serde(
            rename = "accessLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_lock: ::std::option::Option<bool>,
        #[doc = "The current access type of the conference."]
        #[serde(
            rename = "accessType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_type: ::std::option::Option<crate::schemas::CallSettingsAccessType>,
        #[doc = "Whether users can join this conference before a host (Host or Cohost)."]
        #[serde(
            rename = "allowJoiningBeforeHost",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub allow_joining_before_host: ::std::option::Option<bool>,
        #[doc = "Indicates whether the attendance report is currently enabled or disabled."]
        #[serde(
            rename = "attendanceReportEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attendance_report_enabled: ::std::option::Option<bool>,
        #[doc = "Indicates whether the audio lock is currently on or off."]
        #[serde(
            rename = "audioLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub audio_lock: ::std::option::Option<bool>,
        #[doc = "Indicates whether the chat lock is currently on or off."]
        #[serde(
            rename = "chatLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub chat_lock: ::std::option::Option<bool>,
        #[doc = "Whether Client-side Encryption is enabled for this conference."]
        #[serde(
            rename = "cseEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cse_enabled: ::std::option::Option<bool>,
        #[doc = "Indicates whether moderation is currently on or off."]
        #[serde(
            rename = "moderationEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub moderation_enabled: ::std::option::Option<bool>,
        #[doc = "Indicates whether the present lock is currently on or off."]
        #[serde(
            rename = "presentLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub present_lock: ::std::option::Option<bool>,
        #[doc = "Indicates whether the reactions lock is currently on or off."]
        #[serde(
            rename = "reactionsLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reactions_lock: ::std::option::Option<bool>,
        #[doc = "Indicates whether the video lock is currently on or off."]
        #[serde(
            rename = "videoLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_lock: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for CallSettings {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CallSettings {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum CallSettingsAccessType {
        #[doc = "Anyone with meeting join information (url, phone access…) can join, no knocking required. (Subject to organization policies)"]
        AccessTypeOpen,
        #[doc = "Only participants invited by a host can automatically join, everyone else must knock and be admitted. (Subject to organization policies) Participants cannot dial out from the meeting. And only hosts can accept knocks."]
        AccessTypeRestricted,
        #[doc = "Members of the Host’s organization, invited external users, and dial-in users can join without knocking, everyone else must knock. (Subject to organization policies)"]
        AccessTypeTrusted,
        #[doc = "Default value. This value is unused."]
        AccessTypeUnspecified,
    }
    impl CallSettingsAccessType {
        pub fn as_str(self) -> &'static str {
            match self {
                CallSettingsAccessType::AccessTypeOpen => "ACCESS_TYPE_OPEN",
                CallSettingsAccessType::AccessTypeRestricted => "ACCESS_TYPE_RESTRICTED",
                CallSettingsAccessType::AccessTypeTrusted => "ACCESS_TYPE_TRUSTED",
                CallSettingsAccessType::AccessTypeUnspecified => "ACCESS_TYPE_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for CallSettingsAccessType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for CallSettingsAccessType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<CallSettingsAccessType, ()> {
            Ok(match s {
                "ACCESS_TYPE_OPEN" => CallSettingsAccessType::AccessTypeOpen,
                "ACCESS_TYPE_RESTRICTED" => CallSettingsAccessType::AccessTypeRestricted,
                "ACCESS_TYPE_TRUSTED" => CallSettingsAccessType::AccessTypeTrusted,
                "ACCESS_TYPE_UNSPECIFIED" => CallSettingsAccessType::AccessTypeUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for CallSettingsAccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for CallSettingsAccessType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CallSettingsAccessType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACCESS_TYPE_OPEN" => CallSettingsAccessType::AccessTypeOpen,
                "ACCESS_TYPE_RESTRICTED" => CallSettingsAccessType::AccessTypeRestricted,
                "ACCESS_TYPE_TRUSTED" => CallSettingsAccessType::AccessTypeTrusted,
                "ACCESS_TYPE_UNSPECIFIED" => CallSettingsAccessType::AccessTypeUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for CallSettingsAccessType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CallSettingsAccessType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CapTokenHolderProto {
        #[doc = "The hash of the corresponding capability token. The value is defined to be identical to the one in acl.proto’s CapTokenMetadata: 10-byte prefix of HMAC-SHA1 of the token. The HMAC key is the following fixed (non-secret) 512-bit value: 79b1c8f4 82baf523 b8a9ab4a e960f438 c45be041 11f1f222 e8a3f64d aeb05e3d c3576acc ec649194 aede422c 4e48e0d1 ff21234a a6ed6b49 a7fa592e efd7bba3"]
        #[serde(
            rename = "tokenHmacSha1Prefix",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_hmac_sha_1_prefix: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector for CapTokenHolderProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CapTokenHolderProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Card {
        #[serde(
            rename = "cardActions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub card_actions: ::std::option::Option<Vec<crate::schemas::CardAction>>,
        #[serde(
            rename = "displayStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_style: ::std::option::Option<crate::schemas::CardDisplayStyle>,
        #[serde(
            rename = "fixedFooter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fixed_footer: ::std::option::Option<crate::schemas::FixedFooter>,
        #[serde(
            rename = "header",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub header: ::std::option::Option<crate::schemas::CardHeader>,
        #[doc = "Name of the card used in CardNavigation.pop_to_card_name."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "When displaying contextual content, the peek card header acts as a placeholder so that the user can navigate forward between the homepage cards and the contextual cards."]
        #[serde(
            rename = "peekCardHeader",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub peek_card_header: ::std::option::Option<crate::schemas::CardHeader>,
        #[serde(
            rename = "sections",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sections: ::std::option::Option<Vec<crate::schemas::Section>>,
    }
    impl ::google_field_selector::FieldSelector for Card {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Card {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum CardDisplayStyle {
        DisplayStyleUnspecified,
        Peek,
        Replace,
    }
    impl CardDisplayStyle {
        pub fn as_str(self) -> &'static str {
            match self {
                CardDisplayStyle::DisplayStyleUnspecified => "DISPLAY_STYLE_UNSPECIFIED",
                CardDisplayStyle::Peek => "PEEK",
                CardDisplayStyle::Replace => "REPLACE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for CardDisplayStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for CardDisplayStyle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<CardDisplayStyle, ()> {
            Ok(match s {
                "DISPLAY_STYLE_UNSPECIFIED" => CardDisplayStyle::DisplayStyleUnspecified,
                "PEEK" => CardDisplayStyle::Peek,
                "REPLACE" => CardDisplayStyle::Replace,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for CardDisplayStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for CardDisplayStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CardDisplayStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DISPLAY_STYLE_UNSPECIFIED" => CardDisplayStyle::DisplayStyleUnspecified,
                "PEEK" => CardDisplayStyle::Peek,
                "REPLACE" => CardDisplayStyle::Replace,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for CardDisplayStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CardDisplayStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CardAction {
        #[doc = "The label used to be displayed in the action menu item."]
        #[serde(
            rename = "actionLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_label: ::std::option::Option<String>,
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::OnClick>,
    }
    impl ::google_field_selector::FieldSelector for CardAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CardAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CardCapabilityMetadata {
        #[doc = "NEXT TAG : 2"]
        #[serde(
            rename = "requiredCapabilities",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub required_capabilities: ::std::option::Option<
            Vec<crate::schemas::CardCapabilityMetadataRequiredCapabilitiesItems>,
        >,
    }
    impl ::google_field_selector::FieldSelector for CardCapabilityMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CardCapabilityMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum CardCapabilityMetadataRequiredCapabilitiesItems {
        #[doc = "NEXT TAG : 2"]
        SupportsBaseCards,
        Unknown,
    }
    impl CardCapabilityMetadataRequiredCapabilitiesItems {
        pub fn as_str(self) -> &'static str {
            match self {
                CardCapabilityMetadataRequiredCapabilitiesItems::SupportsBaseCards => {
                    "SUPPORTS_BASE_CARDS"
                }
                CardCapabilityMetadataRequiredCapabilitiesItems::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for CardCapabilityMetadataRequiredCapabilitiesItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for CardCapabilityMetadataRequiredCapabilitiesItems {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<CardCapabilityMetadataRequiredCapabilitiesItems, ()> {
            Ok(match s {
                "SUPPORTS_BASE_CARDS" => {
                    CardCapabilityMetadataRequiredCapabilitiesItems::SupportsBaseCards
                }
                "UNKNOWN" => CardCapabilityMetadataRequiredCapabilitiesItems::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for CardCapabilityMetadataRequiredCapabilitiesItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for CardCapabilityMetadataRequiredCapabilitiesItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CardCapabilityMetadataRequiredCapabilitiesItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "SUPPORTS_BASE_CARDS" => {
                    CardCapabilityMetadataRequiredCapabilitiesItems::SupportsBaseCards
                }
                "UNKNOWN" => CardCapabilityMetadataRequiredCapabilitiesItems::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for CardCapabilityMetadataRequiredCapabilitiesItems {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CardCapabilityMetadataRequiredCapabilitiesItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CardHeader {
        #[doc = "The alternative text of this image which will be used for accessibility."]
        #[serde(
            rename = "imageAltText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_alt_text: ::std::option::Option<String>,
        #[serde(
            rename = "imageStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_style: ::std::option::Option<crate::schemas::CardHeaderImageStyle>,
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
        #[serde(
            rename = "subtitle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub subtitle: ::std::option::Option<String>,
        #[doc = "The title must be specified. The header has a fixed height: if both a title and subtitle is specified, each will take up 1 line. If only the title is specified, it will take up both lines. The header is rendered in collapsed and detailed view."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for CardHeader {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CardHeader {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum CardHeaderImageStyle {
        #[doc = "Applies a circular crop."]
        Circle,
        #[doc = "No value specified."]
        CropTypeNotSet,
        #[doc = "Applies a rectangular crop with a 4:3 aspect ratio."]
        Rectangle43,
        #[doc = "Applies a rectangular crop with a custom aspect ratio."]
        RectangleCustom,
        #[doc = "Applies a square crop."]
        Square,
    }
    impl CardHeaderImageStyle {
        pub fn as_str(self) -> &'static str {
            match self {
                CardHeaderImageStyle::Circle => "CIRCLE",
                CardHeaderImageStyle::CropTypeNotSet => "CROP_TYPE_NOT_SET",
                CardHeaderImageStyle::Rectangle43 => "RECTANGLE_4_3",
                CardHeaderImageStyle::RectangleCustom => "RECTANGLE_CUSTOM",
                CardHeaderImageStyle::Square => "SQUARE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for CardHeaderImageStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for CardHeaderImageStyle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<CardHeaderImageStyle, ()> {
            Ok(match s {
                "CIRCLE" => CardHeaderImageStyle::Circle,
                "CROP_TYPE_NOT_SET" => CardHeaderImageStyle::CropTypeNotSet,
                "RECTANGLE_4_3" => CardHeaderImageStyle::Rectangle43,
                "RECTANGLE_CUSTOM" => CardHeaderImageStyle::RectangleCustom,
                "SQUARE" => CardHeaderImageStyle::Square,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for CardHeaderImageStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for CardHeaderImageStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CardHeaderImageStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CIRCLE" => CardHeaderImageStyle::Circle,
                "CROP_TYPE_NOT_SET" => CardHeaderImageStyle::CropTypeNotSet,
                "RECTANGLE_4_3" => CardHeaderImageStyle::Rectangle43,
                "RECTANGLE_CUSTOM" => CardHeaderImageStyle::RectangleCustom,
                "SQUARE" => CardHeaderImageStyle::Square,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for CardHeaderImageStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CardHeaderImageStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CaribouAttributeValue {
        #[doc = "Tags 1 through 15 are reserved for the most commonly used fields."]
        #[serde(
            rename = "booleanValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_value: ::std::option::Option<bool>,
        #[serde(
            rename = "intValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_value: ::std::option::Option<i32>,
        #[serde(
            rename = "longValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub long_value: ::std::option::Option<i64>,
        #[doc = "Generally, applications should avoid storing raw bytes and instead store structured data as protocol buffer extensions. This both reduces the amount of ad-hoc attribute parsing code as well as eliminates an intermediate copy of the data when deserializing the value. The rawByteValue field is mainly provided for compatibility with attributes stored before the introduction of the Attribute.Value."]
        #[serde(
            rename = "rawByteValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub raw_byte_value: ::std::option::Option<::google_api_bytes::Bytes>,
        #[serde(
            rename = "stringValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for CaribouAttributeValue {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CaribouAttributeValue {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatClientActionMarkup {}
    impl ::google_field_selector::FieldSelector for ChatClientActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ChatClientActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverDynamitePlaceholderMetadata {
        #[serde(
            rename = "attachmentMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment_metadata: ::std::option::Option<
            crate::schemas::ChatConserverDynamitePlaceholderMetadataAttachmentMetadata,
        >,
        #[serde(
            rename = "botMessageMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bot_message_metadata: ::std::option::Option<
            crate::schemas::ChatConserverDynamitePlaceholderMetadataBotMessageMetadata,
        >,
        #[serde(
            rename = "calendarEventMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub calendar_event_metadata: ::std::option::Option<
            crate::schemas::ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata,
        >,
        #[serde(
            rename = "deleteMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub delete_metadata: ::std::option::Option<
            crate::schemas::ChatConserverDynamitePlaceholderMetadataDeleteMetadata,
        >,
        #[serde(
            rename = "editMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub edit_metadata: ::std::option::Option<
            crate::schemas::ChatConserverDynamitePlaceholderMetadataEditMetadata,
        >,
        #[doc = "The space URL embedded in the localized string."]
        #[serde(
            rename = "spaceUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub space_url: ::std::option::Option<String>,
        #[serde(
            rename = "tasksMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tasks_metadata: ::std::option::Option<
            crate::schemas::ChatConserverDynamitePlaceholderMetadataTasksMetadata,
        >,
        #[serde(
            rename = "videoCallMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_call_metadata: ::std::option::Option<
            crate::schemas::ChatConserverDynamitePlaceholderMetadataVideoCallMetadata,
        >,
    }
    impl ::google_field_selector::FieldSelector for ChatConserverDynamitePlaceholderMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ChatConserverDynamitePlaceholderMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverDynamitePlaceholderMetadataAttachmentMetadata {
        #[serde(
            rename = "filename",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filename: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverDynamitePlaceholderMetadataBotMessageMetadata {}
    impl ::google_field_selector::FieldSelector
        for ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata {}
    impl ::google_field_selector::FieldSelector
        for ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverDynamitePlaceholderMetadataDeleteMetadata {}
    impl ::google_field_selector::FieldSelector
        for ChatConserverDynamitePlaceholderMetadataDeleteMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for ChatConserverDynamitePlaceholderMetadataDeleteMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverDynamitePlaceholderMetadataEditMetadata {}
    impl ::google_field_selector::FieldSelector
        for ChatConserverDynamitePlaceholderMetadataEditMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ChatConserverDynamitePlaceholderMetadataEditMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverDynamitePlaceholderMetadataTasksMetadata {}
    impl ::google_field_selector::FieldSelector
        for ChatConserverDynamitePlaceholderMetadataTasksMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for ChatConserverDynamitePlaceholderMetadataTasksMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverDynamitePlaceholderMetadataVideoCallMetadata {
        #[serde(
            rename = "meetingUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatConserverMessageContent {
        #[doc = "Items attached to this message, such as photos. This should *NOT* be set by clients. It will be automatically set from media uploaded along with this request and using the information provided in existing_media."]
        #[serde(
            rename = "attachment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment:
            ::std::option::Option<Vec<crate::schemas::SocialCommonAttachmentAttachment>>,
        #[doc = "The text part of the message content. Segments are concatenated together to yield the full message. A message can have zero or more segments."]
        #[serde(
            rename = "segment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub segment: ::std::option::Option<Vec<crate::schemas::Segment>>,
    }
    impl ::google_field_selector::FieldSelector for ChatConserverMessageContent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ChatConserverMessageContent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatContentExtension {
        #[doc = "Annotations to decorate this event."]
        #[serde(
            rename = "annotation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation: ::std::option::Option<Vec<crate::schemas::EventAnnotation>>,
        #[doc = "This metadata informs how the placeholder string will be localized dynamically in Hangouts. See go/localization-of-system-messages. This is only used as part of REGULAR_CHAT_MESSAGE events."]
        #[serde(
            rename = "dynamitePlaceholderMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dynamite_placeholder_metadata:
            ::std::option::Option<crate::schemas::ChatConserverDynamitePlaceholderMetadata>,
        #[doc = "Is this event OnTR or OffTR? Since some events can be ON_THE_RECORD and have an expiration_timestamp (for example enterprise retention users) we need to store the otr status."]
        #[serde(
            rename = "eventOtrStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_otr_status:
            ::std::option::Option<crate::schemas::ChatContentExtensionEventOtrStatus>,
        #[doc = "Group-link sharing toggle event."]
        #[serde(
            rename = "groupLinkSharingModificationEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_link_sharing_modification_event:
            ::std::option::Option<crate::schemas::GroupLinkSharingModificationEvent>,
        #[doc = "Audio/video Hangout event."]
        #[serde(
            rename = "hangoutEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hangout_event: ::std::option::Option<crate::schemas::HangoutEvent>,
        #[doc = "Invite accepted events. Note: this is only used ephemerally to sync to Gmail. No actual cent is stored in Papyrus."]
        #[serde(
            rename = "inviteAcceptedEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub invite_accepted_event: ::std::option::Option<crate::schemas::InviteAcceptedEvent>,
        #[doc = "Join/leave events."]
        #[serde(
            rename = "membershipChangeEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub membership_change_event: ::std::option::Option<crate::schemas::MembershipChangeEvent>,
        #[doc = "Metadata for off-the-record message."]
        #[serde(
            rename = "otrChatMessageEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub otr_chat_message_event: ::std::option::Option<crate::schemas::OtrChatMessageEvent>,
        #[serde(
            rename = "otrModificationEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub otr_modification_event: ::std::option::Option<crate::schemas::OtrModificationEvent>,
        #[serde(
            rename = "renameEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rename_event: ::std::option::Option<crate::schemas::RenameEvent>,
    }
    impl ::google_field_selector::FieldSelector for ChatContentExtension {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ChatContentExtension {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ChatContentExtensionEventOtrStatus {
        #[doc = "The conversation is completely off the record."]
        OffTheRecord,
        #[doc = "The conversation is completely on the record."]
        OnTheRecord,
    }
    impl ChatContentExtensionEventOtrStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                ChatContentExtensionEventOtrStatus::OffTheRecord => "OFF_THE_RECORD",
                ChatContentExtensionEventOtrStatus::OnTheRecord => "ON_THE_RECORD",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ChatContentExtensionEventOtrStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ChatContentExtensionEventOtrStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ChatContentExtensionEventOtrStatus, ()> {
            Ok(match s {
                "OFF_THE_RECORD" => ChatContentExtensionEventOtrStatus::OffTheRecord,
                "ON_THE_RECORD" => ChatContentExtensionEventOtrStatus::OnTheRecord,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ChatContentExtensionEventOtrStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ChatContentExtensionEventOtrStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ChatContentExtensionEventOtrStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "OFF_THE_RECORD" => ChatContentExtensionEventOtrStatus::OffTheRecord,
                "ON_THE_RECORD" => ChatContentExtensionEventOtrStatus::OnTheRecord,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ChatContentExtensionEventOtrStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ChatContentExtensionEventOtrStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChatProto {
        #[doc = "Chat IDs consist of alphanumeric characters and colons. Currently required."]
        #[serde(
            rename = "chatId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub chat_id: ::std::option::Option<String>,
        #[doc = "The type of Chat members to consider, e.g. “all members” vs. “invitee” These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See chat.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with chat. Currently required."]
        #[serde(
            rename = "memberType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub member_type: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for ChatProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ChatProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CheckAccessResponse {
        #[doc = "Returns true if principal has access. Returns false otherwise."]
        #[serde(
            rename = "hasAccess",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub has_access: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for CheckAccessResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CheckAccessResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CircleProto {
        #[doc = "Circle ID is unique only relative to the owner’s Gaia ID. Currently required."]
        #[serde(
            rename = "circleId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub circle_id: ::std::option::Option<i64>,
        #[doc = "The owner of the circle. Currently required."]
        #[serde(
            rename = "ownerGaiaId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub owner_gaia_id: ::std::option::Option<i64>,
        #[doc = "If present, then tests for membership in this circle must use data known to be at least as fresh as the given (FBS-assigned) timestamp. See http://go/fbs-consistent-read-after-important-write Before using this, be sure that any service checking authorization against this circle supports checking consistency timestamps. For example, as of 12/2011, Keystore only supports this for the Moonshine configuration, and in others authorization checks will fail if the timestamp is present."]
        #[serde(
            rename = "requiredConsistencyTimestampUsec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub required_consistency_timestamp_usec: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for CircleProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CircleProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ClientContext {
        #[doc = "The client operation to which this history record belongs. The notion of a client operation is provided to keep track of client operations which might span multiple transactions in the lower level."]
        #[serde(
            rename = "clientOperationId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_operation_id: ::std::option::Option<String>,
        #[doc = "E.g. “pinto”, “imap”, “bigtop”, “upload”"]
        #[serde(
            rename = "clientType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_type: ::std::option::Option<String>,
        #[doc = "Contains information about the session which created this history record. This will be empty if the history record was generated by an internal request."]
        #[serde(
            rename = "sessionContext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_context: ::std::option::Option<crate::schemas::SessionContext>,
        #[doc = "Textual representation of the user’s IP address, if available."]
        #[serde(
            rename = "userIp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_ip: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ClientContext {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ClientContext {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CloudPrincipalProto {
        #[doc = "Format: “{identity-pool}:{subject}#” Details: go/cloud-principal-identifiers"]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for CloudPrincipalProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CloudPrincipalProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ClusterInfo {
        #[doc = "IDs of the highest priority clusters to which the thread belongs to. If this field is not present, the thread does not belong to any cluster and would be shown in the inbox, unclustered."]
        #[serde(
            rename = "clusterId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cluster_id: ::std::option::Option<Vec<String>>,
        #[doc = "If the thread belongs to a grouped cluster and all of those clusters are throttled, then this field is set to true."]
        #[serde(
            rename = "throttled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub throttled: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for ClusterInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ClusterInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CoActivity {
        #[doc = "The title of the activity in this co-activity session. For example, this might be the title of the video being co-watched, or the name of the round of a game being co-played."]
        #[serde(
            rename = "activityTitle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub activity_title: ::std::option::Option<String>,
        #[doc = "Identifies the app handling this co-activity."]
        #[serde(
            rename = "coActivityApp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub co_activity_app: ::std::option::Option<crate::schemas::CoActivityCoActivityApp>,
    }
    impl ::google_field_selector::FieldSelector for CoActivity {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CoActivity {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum CoActivityCoActivityApp {
        #[doc = "GQueues task manager."]
        CoActivityAppGqueues,
        #[doc = "HeadsUp game."]
        CoActivityAppHeadsup,
        #[doc = "Kahoot! educational software."]
        CoActivityAppKahoot,
        #[doc = "Samsung Notes"]
        CoActivityAppSamsungNotes,
        #[doc = "Spotify music."]
        CoActivityAppSpotify,
        #[doc = "Uno game."]
        CoActivityAppUno,
        #[doc = "Should never be used."]
        CoActivityAppUnspecified,
        #[doc = "Main YouTube app, for watching videos."]
        CoActivityAppYouTubeMain,
        #[doc = "YouTube Music"]
        CoActivityAppYouTubeMusic,
    }
    impl CoActivityCoActivityApp {
        pub fn as_str(self) -> &'static str {
            match self {
                CoActivityCoActivityApp::CoActivityAppGqueues => "CO_ACTIVITY_APP_GQUEUES",
                CoActivityCoActivityApp::CoActivityAppHeadsup => "CO_ACTIVITY_APP_HEADSUP",
                CoActivityCoActivityApp::CoActivityAppKahoot => "CO_ACTIVITY_APP_KAHOOT",
                CoActivityCoActivityApp::CoActivityAppSamsungNotes => {
                    "CO_ACTIVITY_APP_SAMSUNG_NOTES"
                }
                CoActivityCoActivityApp::CoActivityAppSpotify => "CO_ACTIVITY_APP_SPOTIFY",
                CoActivityCoActivityApp::CoActivityAppUno => "CO_ACTIVITY_APP_UNO",
                CoActivityCoActivityApp::CoActivityAppUnspecified => "CO_ACTIVITY_APP_UNSPECIFIED",
                CoActivityCoActivityApp::CoActivityAppYouTubeMain => {
                    "CO_ACTIVITY_APP_YOU_TUBE_MAIN"
                }
                CoActivityCoActivityApp::CoActivityAppYouTubeMusic => {
                    "CO_ACTIVITY_APP_YOU_TUBE_MUSIC"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for CoActivityCoActivityApp {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for CoActivityCoActivityApp {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<CoActivityCoActivityApp, ()> {
            Ok(match s {
                "CO_ACTIVITY_APP_GQUEUES" => CoActivityCoActivityApp::CoActivityAppGqueues,
                "CO_ACTIVITY_APP_HEADSUP" => CoActivityCoActivityApp::CoActivityAppHeadsup,
                "CO_ACTIVITY_APP_KAHOOT" => CoActivityCoActivityApp::CoActivityAppKahoot,
                "CO_ACTIVITY_APP_SAMSUNG_NOTES" => {
                    CoActivityCoActivityApp::CoActivityAppSamsungNotes
                }
                "CO_ACTIVITY_APP_SPOTIFY" => CoActivityCoActivityApp::CoActivityAppSpotify,
                "CO_ACTIVITY_APP_UNO" => CoActivityCoActivityApp::CoActivityAppUno,
                "CO_ACTIVITY_APP_UNSPECIFIED" => CoActivityCoActivityApp::CoActivityAppUnspecified,
                "CO_ACTIVITY_APP_YOU_TUBE_MAIN" => {
                    CoActivityCoActivityApp::CoActivityAppYouTubeMain
                }
                "CO_ACTIVITY_APP_YOU_TUBE_MUSIC" => {
                    CoActivityCoActivityApp::CoActivityAppYouTubeMusic
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for CoActivityCoActivityApp {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for CoActivityCoActivityApp {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CoActivityCoActivityApp {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CO_ACTIVITY_APP_GQUEUES" => CoActivityCoActivityApp::CoActivityAppGqueues,
                "CO_ACTIVITY_APP_HEADSUP" => CoActivityCoActivityApp::CoActivityAppHeadsup,
                "CO_ACTIVITY_APP_KAHOOT" => CoActivityCoActivityApp::CoActivityAppKahoot,
                "CO_ACTIVITY_APP_SAMSUNG_NOTES" => {
                    CoActivityCoActivityApp::CoActivityAppSamsungNotes
                }
                "CO_ACTIVITY_APP_SPOTIFY" => CoActivityCoActivityApp::CoActivityAppSpotify,
                "CO_ACTIVITY_APP_UNO" => CoActivityCoActivityApp::CoActivityAppUno,
                "CO_ACTIVITY_APP_UNSPECIFIED" => CoActivityCoActivityApp::CoActivityAppUnspecified,
                "CO_ACTIVITY_APP_YOU_TUBE_MAIN" => {
                    CoActivityCoActivityApp::CoActivityAppYouTubeMain
                }
                "CO_ACTIVITY_APP_YOU_TUBE_MUSIC" => {
                    CoActivityCoActivityApp::CoActivityAppYouTubeMusic
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for CoActivityCoActivityApp {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CoActivityCoActivityApp {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Collaboration {
        #[doc = "The attachment being collaborated on."]
        #[serde(
            rename = "attachmentId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment_id: ::std::option::Option<String>,
        #[doc = "Display info of the user who initiated the collaboration session."]
        #[serde(
            rename = "initiator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator: ::std::option::Option<crate::schemas::UserDisplayInfo>,
        #[doc = "The uri of the artifact being collaborated on."]
        #[serde(
            rename = "uri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Collaboration {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Collaboration {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Color {
        #[doc = "The fraction of this color that should be applied to the pixel. That is, the final pixel color is defined by the equation: `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)` This means that a value of 1.0 corresponds to a solid color, whereas a value of 0.0 corresponds to a completely transparent color. This uses a wrapper message rather than a simple float scalar so that it is possible to distinguish between a default value and the value being unset. If omitted, this color object is rendered as a solid color (as if the alpha value had been explicitly given a value of 1.0)."]
        #[serde(
            rename = "alpha",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alpha: ::std::option::Option<f32>,
        #[doc = "The amount of blue in the color as a value in the interval \\[0, 1\\]."]
        #[serde(
            rename = "blue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub blue: ::std::option::Option<f32>,
        #[doc = "The amount of green in the color as a value in the interval \\[0, 1\\]."]
        #[serde(
            rename = "green",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub green: ::std::option::Option<f32>,
        #[doc = "The amount of red in the color as a value in the interval \\[0, 1\\]."]
        #[serde(
            rename = "red",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub red: ::std::option::Option<f32>,
    }
    impl ::google_field_selector::FieldSelector for Color {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Color {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CommunalLabelTag {
        #[doc = "Gaia ID of the user who added the tag, if any. Not present for any tags automatically created by server-side processing."]
        #[serde(
            rename = "creatorUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub creator_user_id: ::std::option::Option<i64>,
        #[doc = "A string ID representing the label. Possible ID values are documented at go/chat-labels-howto:ids. Example: “^\\*t_p” for “Pinned”."]
        #[serde(
            rename = "labelId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for CommunalLabelTag {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CommunalLabelTag {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct CompositeFilter {
        #[doc = "The logic operator of the sub filter."]
        #[serde(
            rename = "logicOperator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub logic_operator: ::std::option::Option<crate::schemas::CompositeFilterLogicOperator>,
        #[doc = "Sub filters."]
        #[serde(
            rename = "subFilters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sub_filters: ::std::option::Option<Vec<crate::schemas::Filter>>,
    }
    impl ::google_field_selector::FieldSelector for CompositeFilter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CompositeFilter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum CompositeFilterLogicOperator {
        #[doc = "Logical operators, which can only be applied to sub filters."]
        And,
        #[doc = "NOT can only be applied on a single sub filter."]
        Not,
        Or,
    }
    impl CompositeFilterLogicOperator {
        pub fn as_str(self) -> &'static str {
            match self {
                CompositeFilterLogicOperator::And => "AND",
                CompositeFilterLogicOperator::Not => "NOT",
                CompositeFilterLogicOperator::Or => "OR",
            }
        }
    }
    impl ::std::convert::AsRef<str> for CompositeFilterLogicOperator {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for CompositeFilterLogicOperator {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<CompositeFilterLogicOperator, ()> {
            Ok(match s {
                "AND" => CompositeFilterLogicOperator::And,
                "NOT" => CompositeFilterLogicOperator::Not,
                "OR" => CompositeFilterLogicOperator::Or,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for CompositeFilterLogicOperator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for CompositeFilterLogicOperator {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CompositeFilterLogicOperator {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AND" => CompositeFilterLogicOperator::And,
                "NOT" => CompositeFilterLogicOperator::Not,
                "OR" => CompositeFilterLogicOperator::Or,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for CompositeFilterLogicOperator {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CompositeFilterLogicOperator {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ConsentedAppUnfurlMetadata {
        #[doc = "Client specified AppId, which will not be sanitized and is untrusted."]
        #[serde(
            rename = "clientSpecifiedAppId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_specified_app_id: ::std::option::Option<crate::schemas::UserId>,
    }
    impl ::google_field_selector::FieldSelector for ConsentedAppUnfurlMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ConsentedAppUnfurlMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ContactGroupProto {
        #[doc = "Group ID is unique only relative to the owner’s Gaia ID."]
        #[serde(
            rename = "groupId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub group_id: ::std::option::Option<i64>,
        #[serde(
            rename = "ownerGaiaId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub owner_gaia_id: ::std::option::Option<i64>,
        #[doc = "If present, then tests for membership in this ContactGroup must use data known to be at least as fresh as the given (FBS-assigned) timestamp. See http://go/fbs-consistent-read-after-important-write Before using this, be sure that any service checking authorization against this group supports checking consistency timestamps. For example, as of 12/2011, Keystore only supports this for the Moonshine configuration, and in others authorization checks will fail if the timestamp is present."]
        #[serde(
            rename = "requiredConsistencyTimestampUsec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub required_consistency_timestamp_usec: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for ContactGroupProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ContactGroupProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ContentReport {
        #[doc = "The time at which the report is generated. Always populated when it is in a response."]
        #[serde(
            rename = "reportCreateTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub report_create_timestamp: ::std::option::Option<String>,
        #[doc = "Additional user-provided justification on the report. Optional."]
        #[serde(
            rename = "reportJustification",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub report_justification: ::std::option::Option<crate::schemas::ContentReportJustification>,
        #[doc = "Type of the report. Always populated when it is in a response."]
        #[serde(
            rename = "reportType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub report_type: ::std::option::Option<crate::schemas::AppsDynamiteSharedContentReportType>,
        #[doc = "User ID of the reporter. Always populated when it is in a response."]
        #[serde(
            rename = "reporterUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reporter_user_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Create timestamp of the revisions of the message when it’s reported. Always populated when it is in a response."]
        #[serde(
            rename = "revisionCreateTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub revision_create_timestamp: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ContentReport {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ContentReport {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ContentReportJustification {
        #[doc = "Optional. User-generated free-text justification for the content report."]
        #[serde(
            rename = "userJustification",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_justification: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ContentReportJustification {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ContentReportJustification {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ContentReportSummary {
        #[doc = "Total number of reports attached to this (revision of) message."]
        #[serde(
            rename = "numberReports",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub number_reports: ::std::option::Option<i32>,
        #[doc = "Totoal number of reports attached to all revisions of this message (i.e. since creation). Set only when the request asks for it."]
        #[serde(
            rename = "numberReportsAllRevisions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub number_reports_all_revisions: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for ContentReportSummary {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ContentReportSummary {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ContextAttribute {
        #[doc = "The name of the attribute. It should not be empty. The maximum length is 32 characters. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The name will be normalized (lower-cased) before being matched."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Text values of the attribute. The maximum number of elements is 10. The maximum length of an element in the array is 32 characters. The value will be normalized (lower-cased) before being matched."]
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for ContextAttribute {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ContextAttribute {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ContextualAddOnMarkup {
        #[doc = "A card must contain a header and at least 1 section."]
        #[serde(
            rename = "cards",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cards: ::std::option::Option<Vec<crate::schemas::Card>>,
        #[doc = "Deprecated."]
        #[serde(
            rename = "toolbar",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub toolbar: ::std::option::Option<crate::schemas::Toolbar>,
    }
    impl ::google_field_selector::FieldSelector for ContextualAddOnMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ContextualAddOnMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CseInfo {
        #[doc = "CSE domain name claimed by the meeting owner’s company. This field is expected to be used for display purposes only, i.e., “Extra encryption added by $cse_domain”. It can differ from the `cse_domain` as defined elsewhere on the User, in the case of cross-domain meetings."]
        #[serde(
            rename = "cseDomain",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cse_domain: ::std::option::Option<String>,
        #[doc = "The wrapped CSE key used by this conference."]
        #[serde(
            rename = "wrappedKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wrapped_key: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector for CseInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CseInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CustomEmojiMetadata {
        #[serde(
            rename = "customEmoji",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub custom_emoji: ::std::option::Option<crate::schemas::AppsDynamiteSharedCustomEmoji>,
    }
    impl ::google_field_selector::FieldSelector for CustomEmojiMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomEmojiMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct CustomFunctionReturnValueMarkup {
        #[doc = "The error message to show to the user if something went wrong."]
        #[serde(
            rename = "errorMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_message: ::std::option::Option<String>,
        #[doc = "The value that resulted from running the custom function."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<::serde_json::Value>,
    }
    impl ::google_field_selector::FieldSelector for CustomFunctionReturnValueMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomFunctionReturnValueMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CustomerId {
        #[serde(
            rename = "customerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub customer_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for CustomerId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomerId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CustomerIndexStats {
        #[doc = "The date for which statistics were calculated."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "Number of items aggregrated by status code."]
        #[serde(
            rename = "itemCountByStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item_count_by_status: ::std::option::Option<Vec<crate::schemas::ItemCountByStatus>>,
    }
    impl ::google_field_selector::FieldSelector for CustomerIndexStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomerIndexStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CustomerQueryStats {
        #[doc = "The date for which query stats were calculated. Stats calculated on the next day close to midnight are returned."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[serde(
            rename = "queryCountByStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query_count_by_status: ::std::option::Option<Vec<crate::schemas::QueryCountByStatus>>,
    }
    impl ::google_field_selector::FieldSelector for CustomerQueryStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomerQueryStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CustomerSearchApplicationStats {
        #[doc = "The count of search applications for the date."]
        #[serde(
            rename = "count",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub count: ::std::option::Option<i64>,
        #[doc = "The date for which search application stats were calculated."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
    }
    impl ::google_field_selector::FieldSelector for CustomerSearchApplicationStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomerSearchApplicationStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CustomerSessionStats {
        #[doc = "The date for which session stats were calculated. Stats are calculated on the following day, close to midnight PST, and then returned."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "The count of search sessions on the day"]
        #[serde(
            rename = "searchSessionsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub search_sessions_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for CustomerSessionStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomerSessionStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CustomerSettings {
        #[doc = "Audit Logging settings for the customer. If update_mask is empty then this field will be updated based on UpdateCustomerSettings request."]
        #[serde(
            rename = "auditLoggingSettings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub audit_logging_settings: ::std::option::Option<crate::schemas::AuditLoggingSettings>,
        #[doc = "VPC SC settings for the customer. If update_mask is empty then this field will be updated based on UpdateCustomerSettings request."]
        #[serde(
            rename = "vpcSettings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vpc_settings: ::std::option::Option<crate::schemas::Vpcsettings>,
    }
    impl ::google_field_selector::FieldSelector for CustomerSettings {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomerSettings {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CustomerUserStats {
        #[doc = "The date for which session stats were calculated. Stats calculated on the next day close to midnight are returned."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "The count of unique active users in the past one day"]
        #[serde(
            rename = "oneDayActiveUsersCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub one_day_active_users_count: ::std::option::Option<i64>,
        #[doc = "The count of unique active users in the past seven days"]
        #[serde(
            rename = "sevenDaysActiveUsersCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub seven_days_active_users_count: ::std::option::Option<i64>,
        #[doc = "The count of unique active users in the past thirty days"]
        #[serde(
            rename = "thirtyDaysActiveUsersCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub thirty_days_active_users_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for CustomerUserStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CustomerUserStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DataLossPreventionMetadata {
        #[doc = "The DLP scan summary that should only be set after the message is scanned in the Chat backend."]
        #[serde(
            rename = "dlpScanSummary",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dlp_scan_summary: ::std::option::Option<crate::schemas::DlpScanSummary>,
        #[doc = "Flag set by client on message resend to bypass WARN violation."]
        #[serde(
            rename = "warnAcknowledged",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub warn_acknowledged: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for DataLossPreventionMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DataLossPreventionMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DataSource {
        #[doc = "If true, sets the datasource to read-only mode. In read-only mode, the Indexing API rejects any requests to index or delete items in this source. Enabling read-only mode does not stop the processing of previously accepted data."]
        #[serde(
            rename = "disableModifications",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disable_modifications: ::std::option::Option<bool>,
        #[doc = "Disable serving any search or assist results."]
        #[serde(
            rename = "disableServing",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disable_serving: ::std::option::Option<bool>,
        #[doc = "Required. Display name of the datasource The maximum length is 300 characters."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "List of service accounts that have indexing access."]
        #[serde(
            rename = "indexingServiceAccounts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub indexing_service_accounts: ::std::option::Option<Vec<String>>,
        #[doc = "This field restricts visibility to items at the datasource level. Items within the datasource are restricted to the union of users and groups included in this field. Note that, this does not ensure access to a specific item, as users need to have ACL permissions on the contained items. This ensures a high level access on the entire datasource, and that the individual items are not shared outside this visibility."]
        #[serde(
            rename = "itemsVisibility",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items_visibility: ::std::option::Option<Vec<crate::schemas::GsuitePrincipal>>,
        #[doc = "The name of the datasource resource. Format: datasources/{source_id}. The name is ignored when creating a datasource."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "IDs of the Long Running Operations (LROs) currently running for this schema."]
        #[serde(
            rename = "operationIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operation_ids: ::std::option::Option<Vec<String>>,
        #[doc = "Can a user request to get thumbnail URI for Items indexed in this data source."]
        #[serde(
            rename = "returnThumbnailUrls",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub return_thumbnail_urls: ::std::option::Option<bool>,
        #[doc = "A short name or alias for the source. This value will be used to match the ‘source’ operator. For example, if the short name is *<value>* then queries like *source:<value>* will only return results for this source. The value must be unique across all datasources. The value must only contain alphanumeric characters (a-zA-Z0-9). The value cannot start with ‘google’ and cannot be one of the following: mail, gmail, docs, drive, groups, sites, calendar, hangouts, gplus, keep, people, teams. Its maximum length is 32 characters."]
        #[serde(
            rename = "shortName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub short_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for DataSource {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DataSource {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DataSourceIndexStats {
        #[doc = "The date for which index stats were calculated. If the date of request is not the current date then stats calculated on the next day are returned. Stats are calculated close to mid night in this case. If date of request is current date, then real time stats are returned."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "Number of items aggregrated by status code."]
        #[serde(
            rename = "itemCountByStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item_count_by_status: ::std::option::Option<Vec<crate::schemas::ItemCountByStatus>>,
    }
    impl ::google_field_selector::FieldSelector for DataSourceIndexStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DataSourceIndexStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct DataSourceRestriction {
        #[doc = "Filter options restricting the results. If multiple filters are present, they are grouped by object type before joining. Filters with the same object type are joined conjunctively, then the resulting expressions are joined disjunctively. The maximum number of elements is 20. NOTE: Suggest API supports only few filters at the moment: “objecttype”, “type” and “mimetype”. For now, schema specific filters cannot be used to filter suggestions."]
        #[serde(
            rename = "filterOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter_options: ::std::option::Option<Vec<crate::schemas::FilterOptions>>,
        #[doc = "The source of restriction."]
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source: ::std::option::Option<crate::schemas::Source>,
    }
    impl ::google_field_selector::FieldSelector for DataSourceRestriction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DataSourceRestriction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Date {
        #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
        #[serde(
            rename = "day",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub day: ::std::option::Option<i32>,
        #[doc = "Month of date. Must be from 1 to 12."]
        #[serde(
            rename = "month",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub month: ::std::option::Option<i32>,
        #[doc = "Year of date. Must be from 1 to 9999."]
        #[serde(
            rename = "year",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub year: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for Date {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Date {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DateOperatorOptions {
        #[doc = "Indicates the operator name required in the query in order to isolate the date property using the greater-than operator. For example, if greaterThanOperatorName is *closedafter* and the property’s name is *closeDate*, then queries like *closedafter:<value>* show results only where the value of the property named *closeDate* is later than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "greaterThanOperatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub greater_than_operator_name: ::std::option::Option<String>,
        #[doc = "Indicates the operator name required in the query in order to isolate the date property using the less-than operator. For example, if lessThanOperatorName is *closedbefore* and the property’s name is *closeDate*, then queries like *closedbefore:<value>* show results only where the value of the property named *closeDate* is earlier than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "lessThanOperatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub less_than_operator_name: ::std::option::Option<String>,
        #[doc = "Indicates the actual string required in the query in order to isolate the date property. For example, suppose an issue tracking schema object has a property named *closeDate* that specifies an operator with an operatorName of *closedon*. For searches on that data, queries like *closedon:<value>* show results only where the value of the *closeDate* property matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the indexed datasource. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for DateOperatorOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DateOperatorOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DatePropertyOptions {
        #[doc = "If set, describes how the date should be used as a search operator."]
        #[serde(
            rename = "operatorOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_options: ::std::option::Option<crate::schemas::DateOperatorOptions>,
    }
    impl ::google_field_selector::FieldSelector for DatePropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DatePropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DateTimePicker {
        #[doc = "The label for the field, which is displayed to the user."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "The name of the text field which is used in FormInput, and uniquely identifies this input."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Triggered when the user clicks on the Save, or Clear button from the date / time picker dialog. Will only be triggered if the value changed as a result of the Save / Clear operation."]
        #[serde(
            rename = "onChange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change: ::std::option::Option<crate::schemas::FormAction>,
        #[doc = "The type of the DateTimePicker."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::DateTimePickerType>,
        #[doc = "The number representing the time-zone offset from UTC, in minutes. If set, the value_ms_epoch will be displayed in the specified time zone. If not set, it will use the user’s timezone setting in client side."]
        #[serde(
            rename = "timezoneOffsetDate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub timezone_offset_date: ::std::option::Option<i32>,
        #[doc = "The value to display which can be the default value before user input or previous user input. It is represented in milliseconds (Epoch time). - For DATE_AND_TIME type, the full epoch value is used. - For DATE_ONLY type, only date of the epoch time is used. - For TIME_ONLY type, only time of the epoch time is used. For example, you can set epoch time to 3 * 60 * 60 * 1000 to represent 3am."]
        #[serde(
            rename = "valueMsEpoch",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub value_ms_epoch: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for DateTimePicker {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DateTimePicker {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DateTimePickerType {
        DateAndTime,
        DateOnly,
        TimeOnly,
        UnspecifiedType,
    }
    impl DateTimePickerType {
        pub fn as_str(self) -> &'static str {
            match self {
                DateTimePickerType::DateAndTime => "DATE_AND_TIME",
                DateTimePickerType::DateOnly => "DATE_ONLY",
                DateTimePickerType::TimeOnly => "TIME_ONLY",
                DateTimePickerType::UnspecifiedType => "UNSPECIFIED_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for DateTimePickerType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DateTimePickerType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DateTimePickerType, ()> {
            Ok(match s {
                "DATE_AND_TIME" => DateTimePickerType::DateAndTime,
                "DATE_ONLY" => DateTimePickerType::DateOnly,
                "TIME_ONLY" => DateTimePickerType::TimeOnly,
                "UNSPECIFIED_TYPE" => DateTimePickerType::UnspecifiedType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for DateTimePickerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DateTimePickerType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DateTimePickerType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DATE_AND_TIME" => DateTimePickerType::DateAndTime,
                "DATE_ONLY" => DateTimePickerType::DateOnly,
                "TIME_ONLY" => DateTimePickerType::TimeOnly,
                "UNSPECIFIED_TYPE" => DateTimePickerType::UnspecifiedType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for DateTimePickerType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DateTimePickerType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DateValues {
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<crate::schemas::Date>>,
    }
    impl ::google_field_selector::FieldSelector for DateValues {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DateValues {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DebugOptions {
        #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
        #[serde(
            rename = "enableDebugging",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enable_debugging: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for DebugOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DebugOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DeepLinkData {
        #[doc = "Application ID (or project ID) from Google API Console."]
        #[serde(
            rename = "appId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub app_id: ::std::option::Option<i64>,
        #[doc = "The data for a Google API Console client is entered by a developer during client registration and is stored in PackagingService."]
        #[serde(
            rename = "client",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client: ::std::option::Option<Vec<crate::schemas::PackagingServiceClient>>,
        #[doc = "The ID for non-URL content. Embeds may either have no analogous web presence or prefer a native mobile experience if supported. In the case of no web presence, instead of setting the “url” field of an embed, such developers will set this field and other content fields, e.g. thumbnail, title, description. If set, this field is used to construct the deep-link URI. Note that the native experience is preferred over the web link and the web link is used as a fallback."]
        #[serde(
            rename = "deepLinkId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deep_link_id: ::std::option::Option<String>,
        #[doc = "Analogous web presence. Used as desktop fallback or when no native link data is present."]
        #[serde(
            rename = "url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for DeepLinkData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DeepLinkData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DeleteMetadata {}
    impl ::google_field_selector::FieldSelector for DeleteMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DeleteMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DeleteQueueItemsRequest {
        #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
        #[serde(
            rename = "connectorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connector_name: ::std::option::Option<String>,
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[doc = "The name of a queue to delete items from."]
        #[serde(
            rename = "queue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub queue: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for DeleteQueueItemsRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DeleteQueueItemsRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DeliveryMedium {
        #[doc = "Describes the medium the cent was sent/received. For example, if I receive an SMS via GV, the medium_type will be GV."]
        #[serde(
            rename = "mediumType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub medium_type: ::std::option::Option<crate::schemas::DeliveryMediumMediumType>,
        #[doc = "In the case of multiple GV/native numbers, this defines the exact number to send from. It is used to differentiate mediums that have the same type, but different addresses (e.g. two android phones)."]
        #[serde(
            rename = "selfPhone",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub self_phone: ::std::option::Option<crate::schemas::VoicePhoneNumber>,
    }
    impl ::google_field_selector::FieldSelector for DeliveryMedium {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DeliveryMedium {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DeliveryMediumMediumType {
        BabelMedium,
        GoogleVoiceMedium,
        LocalSmsMedium,
        UnknownMedium,
    }
    impl DeliveryMediumMediumType {
        pub fn as_str(self) -> &'static str {
            match self {
                DeliveryMediumMediumType::BabelMedium => "BABEL_MEDIUM",
                DeliveryMediumMediumType::GoogleVoiceMedium => "GOOGLE_VOICE_MEDIUM",
                DeliveryMediumMediumType::LocalSmsMedium => "LOCAL_SMS_MEDIUM",
                DeliveryMediumMediumType::UnknownMedium => "UNKNOWN_MEDIUM",
            }
        }
    }
    impl ::std::convert::AsRef<str> for DeliveryMediumMediumType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DeliveryMediumMediumType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DeliveryMediumMediumType, ()> {
            Ok(match s {
                "BABEL_MEDIUM" => DeliveryMediumMediumType::BabelMedium,
                "GOOGLE_VOICE_MEDIUM" => DeliveryMediumMediumType::GoogleVoiceMedium,
                "LOCAL_SMS_MEDIUM" => DeliveryMediumMediumType::LocalSmsMedium,
                "UNKNOWN_MEDIUM" => DeliveryMediumMediumType::UnknownMedium,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for DeliveryMediumMediumType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DeliveryMediumMediumType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeliveryMediumMediumType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BABEL_MEDIUM" => DeliveryMediumMediumType::BabelMedium,
                "GOOGLE_VOICE_MEDIUM" => DeliveryMediumMediumType::GoogleVoiceMedium,
                "LOCAL_SMS_MEDIUM" => DeliveryMediumMediumType::LocalSmsMedium,
                "UNKNOWN_MEDIUM" => DeliveryMediumMediumType::UnknownMedium,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for DeliveryMediumMediumType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DeliveryMediumMediumType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DisplayedProperty {
        #[doc = "The name of the top-level property as defined in a property definition for the object. If the name is not a defined property in the schema, an error is given when attempting to update the schema."]
        #[serde(
            rename = "propertyName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub property_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for DisplayedProperty {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DisplayedProperty {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Divider {}
    impl ::google_field_selector::FieldSelector for Divider {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Divider {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DlpScanSummary {
        #[doc = "The scan ID of the corresponding {@link DlpViolationScanRecord} in the {@link EphemeralDlpScans} Spanner table. This can be used to fetch additional details about the scan, e.g. for audit logging."]
        #[serde(
            rename = "scanId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scan_id: ::std::option::Option<String>,
        #[doc = "Indicates that was no attempt to scan a message or attachment because it was not applicable in the given context (e.g. atomic mutuate). If this is true, scan_outcome should not be set. This flag is used to identify messages that DLP did not attempt to scan for monitoring scan coverage. Contents that DLP attempted to scan but skipped can be identified by DlpScanOutcome.SCAN_SKIPPED\\_\\* reasons."]
        #[serde(
            rename = "scanNotApplicableForContext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scan_not_applicable_for_context: ::std::option::Option<bool>,
        #[doc = "The outcome of a DLP Scan. If this is set, scan_not_applicable_for_context should not be true."]
        #[serde(
            rename = "scanOutcome",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scan_outcome: ::std::option::Option<crate::schemas::DlpScanSummaryScanOutcome>,
    }
    impl ::google_field_selector::FieldSelector for DlpScanSummary {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DlpScanSummary {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DlpScanSummaryScanOutcome {
        #[doc = "Rule fetch completed and evaluation were attempted, but all of the rules failed to be evaluated."]
        ScanFailureAllRulesFailed,
        #[doc = "Rule fetch and evaluation were attempted but an exception occurred."]
        ScanFailureException,
        #[doc = "An IllegalStateException is thrown when executing DLP on attachments. This could happen if the space row is missing."]
        ScanFailureIllegalStateForAttachments,
        #[doc = "Rule fetch was attempted but failed, so rule evaluation could not be performed."]
        ScanFailureRuleFetchFailed,
        #[doc = "Rule fetch and evaluation were attempted but the scanning timed out."]
        ScanFailureTimeout,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because Changeling returned an empty response while converting the attachment to text."]
        ScanRuleEvaluationSkippedChangelingEmptyResponse,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because Changeling returned permanent failure while converting the attachment to text."]
        ScanRuleEvaluationSkippedChangelingPermanentError,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because none of the rules are applicable to the given action params."]
        ScanRuleEvaluationSkippedNoApplicableRulesForActionParams,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because none of the rules are applicable to the given trigger."]
        ScanRuleEvaluationSkippedNoApplicableRulesForTrigger,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because no rules were found."]
        ScanRuleEvaluationSkippedNoRulesFound,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because file type is unsupported."]
        ScanRuleEvaluationSkippedUnsupportedFileType,
        #[doc = "Rule fetch and evaluation are skipped because the user sending message is consumer."]
        ScanSkippedConsumer,
        #[doc = "Rule fetch and evaluation is skipped because DLP is not enabled for the user."]
        ScanSkippedExperimentDisabled,
        #[doc = "Scanning was skipped because the message originated from Interop or Babel."]
        ScanSkippedMessageFromUnsupportedOrigin,
        #[doc = "Rule fetch and evaluation are skipped because there is no message to scan. Deprecated: this should not happen since there must be message or attachment for DLP scan."]
        ScanSkippedNoMessage,
        #[doc = "Rule fetch and evaluation are skipped because the user sending message is a non-human user (i.e. a bot)."]
        ScanSkippedNonHumanUser,
        #[doc = "Rule fetch and evaluation are skipped because the user has acknowledged the warning on the message that triggered the Warn violation and sent the message anyway."]
        ScanSkippedUserAcknowledgedWarning,
        #[doc = "Violation is detected and will be logged to BIP (no user-facing action performed)."]
        ScanSucceededAuditOnly,
        #[doc = "Violation is detected. The message/attachment will be blocked (or deleted if this happens in failure recovery), the user will be warned, and the violation will be logged to BIP."]
        ScanSucceededBlock,
        #[doc = "This means no violation is detected on the given message/attachment."]
        ScanSucceededNoViolation,
        #[doc = "Violation is detected. The user will be warned, and the violation will be logged to BIP."]
        ScanSucceededWarn,
        #[doc = "Rules were fetched but some evaluations failed. An audit-only violation was found in the rules that were successfully evaluated. The violation will be logged to BIP (no user-facing action performed)."]
        ScanSucceededWithFailuresAuditOnly,
        #[doc = "Rules were fetched but some evaluations failed. A blocking violation was found in the rules that were successfully evaluated. The message/attachment will be blocked, the user will be notified, and the violation will be logged to BIP. A blocking violation takes precedence over all other violation types."]
        ScanSucceededWithFailuresBlock,
        #[doc = "Rules were fetched but some evaluations failed. No violation was found in the rules that were successfully evaluated."]
        ScanSucceededWithFailuresNoViolation,
        #[doc = "Rules were fetched but some evaluations failed. A warn violation was found in the rules that were successfully evaluated. The user will be warned, and the violation will be logged to BIP."]
        ScanSucceededWithFailuresWarn,
        ScanUnknownOutcome,
    }
    impl DlpScanSummaryScanOutcome {
        pub fn as_str(self) -> &'static str {
            match self { DlpScanSummaryScanOutcome :: ScanFailureAllRulesFailed => "SCAN_FAILURE_ALL_RULES_FAILED" , DlpScanSummaryScanOutcome :: ScanFailureException => "SCAN_FAILURE_EXCEPTION" , DlpScanSummaryScanOutcome :: ScanFailureIllegalStateForAttachments => "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" , DlpScanSummaryScanOutcome :: ScanFailureRuleFetchFailed => "SCAN_FAILURE_RULE_FETCH_FAILED" , DlpScanSummaryScanOutcome :: ScanFailureTimeout => "SCAN_FAILURE_TIMEOUT" , DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedChangelingEmptyResponse => "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" , DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedChangelingPermanentError => "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" , DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForActionParams => "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" , DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForTrigger => "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" , DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoRulesFound => "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" , DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedUnsupportedFileType => "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" , DlpScanSummaryScanOutcome :: ScanSkippedConsumer => "SCAN_SKIPPED_CONSUMER" , DlpScanSummaryScanOutcome :: ScanSkippedExperimentDisabled => "SCAN_SKIPPED_EXPERIMENT_DISABLED" , DlpScanSummaryScanOutcome :: ScanSkippedMessageFromUnsupportedOrigin => "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" , DlpScanSummaryScanOutcome :: ScanSkippedNoMessage => "SCAN_SKIPPED_NO_MESSAGE" , DlpScanSummaryScanOutcome :: ScanSkippedNonHumanUser => "SCAN_SKIPPED_NON_HUMAN_USER" , DlpScanSummaryScanOutcome :: ScanSkippedUserAcknowledgedWarning => "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" , DlpScanSummaryScanOutcome :: ScanSucceededAuditOnly => "SCAN_SUCCEEDED_AUDIT_ONLY" , DlpScanSummaryScanOutcome :: ScanSucceededBlock => "SCAN_SUCCEEDED_BLOCK" , DlpScanSummaryScanOutcome :: ScanSucceededNoViolation => "SCAN_SUCCEEDED_NO_VIOLATION" , DlpScanSummaryScanOutcome :: ScanSucceededWarn => "SCAN_SUCCEEDED_WARN" , DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresAuditOnly => "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" , DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresBlock => "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" , DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresNoViolation => "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" , DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresWarn => "SCAN_SUCCEEDED_WITH_FAILURES_WARN" , DlpScanSummaryScanOutcome :: ScanUnknownOutcome => "SCAN_UNKNOWN_OUTCOME" , }
        }
    }
    impl ::std::convert::AsRef<str> for DlpScanSummaryScanOutcome {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DlpScanSummaryScanOutcome {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DlpScanSummaryScanOutcome, ()> {
            Ok (match s { "SCAN_FAILURE_ALL_RULES_FAILED" => DlpScanSummaryScanOutcome :: ScanFailureAllRulesFailed , "SCAN_FAILURE_EXCEPTION" => DlpScanSummaryScanOutcome :: ScanFailureException , "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" => DlpScanSummaryScanOutcome :: ScanFailureIllegalStateForAttachments , "SCAN_FAILURE_RULE_FETCH_FAILED" => DlpScanSummaryScanOutcome :: ScanFailureRuleFetchFailed , "SCAN_FAILURE_TIMEOUT" => DlpScanSummaryScanOutcome :: ScanFailureTimeout , "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedChangelingEmptyResponse , "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedChangelingPermanentError , "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForActionParams , "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForTrigger , "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoRulesFound , "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedUnsupportedFileType , "SCAN_SKIPPED_CONSUMER" => DlpScanSummaryScanOutcome :: ScanSkippedConsumer , "SCAN_SKIPPED_EXPERIMENT_DISABLED" => DlpScanSummaryScanOutcome :: ScanSkippedExperimentDisabled , "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" => DlpScanSummaryScanOutcome :: ScanSkippedMessageFromUnsupportedOrigin , "SCAN_SKIPPED_NO_MESSAGE" => DlpScanSummaryScanOutcome :: ScanSkippedNoMessage , "SCAN_SKIPPED_NON_HUMAN_USER" => DlpScanSummaryScanOutcome :: ScanSkippedNonHumanUser , "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" => DlpScanSummaryScanOutcome :: ScanSkippedUserAcknowledgedWarning , "SCAN_SUCCEEDED_AUDIT_ONLY" => DlpScanSummaryScanOutcome :: ScanSucceededAuditOnly , "SCAN_SUCCEEDED_BLOCK" => DlpScanSummaryScanOutcome :: ScanSucceededBlock , "SCAN_SUCCEEDED_NO_VIOLATION" => DlpScanSummaryScanOutcome :: ScanSucceededNoViolation , "SCAN_SUCCEEDED_WARN" => DlpScanSummaryScanOutcome :: ScanSucceededWarn , "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" => DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresAuditOnly , "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" => DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresBlock , "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" => DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresNoViolation , "SCAN_SUCCEEDED_WITH_FAILURES_WARN" => DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresWarn , "SCAN_UNKNOWN_OUTCOME" => DlpScanSummaryScanOutcome :: ScanUnknownOutcome , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for DlpScanSummaryScanOutcome {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DlpScanSummaryScanOutcome {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DlpScanSummaryScanOutcome {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "SCAN_FAILURE_ALL_RULES_FAILED" => DlpScanSummaryScanOutcome :: ScanFailureAllRulesFailed , "SCAN_FAILURE_EXCEPTION" => DlpScanSummaryScanOutcome :: ScanFailureException , "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" => DlpScanSummaryScanOutcome :: ScanFailureIllegalStateForAttachments , "SCAN_FAILURE_RULE_FETCH_FAILED" => DlpScanSummaryScanOutcome :: ScanFailureRuleFetchFailed , "SCAN_FAILURE_TIMEOUT" => DlpScanSummaryScanOutcome :: ScanFailureTimeout , "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedChangelingEmptyResponse , "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedChangelingPermanentError , "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForActionParams , "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForTrigger , "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedNoRulesFound , "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" => DlpScanSummaryScanOutcome :: ScanRuleEvaluationSkippedUnsupportedFileType , "SCAN_SKIPPED_CONSUMER" => DlpScanSummaryScanOutcome :: ScanSkippedConsumer , "SCAN_SKIPPED_EXPERIMENT_DISABLED" => DlpScanSummaryScanOutcome :: ScanSkippedExperimentDisabled , "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" => DlpScanSummaryScanOutcome :: ScanSkippedMessageFromUnsupportedOrigin , "SCAN_SKIPPED_NO_MESSAGE" => DlpScanSummaryScanOutcome :: ScanSkippedNoMessage , "SCAN_SKIPPED_NON_HUMAN_USER" => DlpScanSummaryScanOutcome :: ScanSkippedNonHumanUser , "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" => DlpScanSummaryScanOutcome :: ScanSkippedUserAcknowledgedWarning , "SCAN_SUCCEEDED_AUDIT_ONLY" => DlpScanSummaryScanOutcome :: ScanSucceededAuditOnly , "SCAN_SUCCEEDED_BLOCK" => DlpScanSummaryScanOutcome :: ScanSucceededBlock , "SCAN_SUCCEEDED_NO_VIOLATION" => DlpScanSummaryScanOutcome :: ScanSucceededNoViolation , "SCAN_SUCCEEDED_WARN" => DlpScanSummaryScanOutcome :: ScanSucceededWarn , "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" => DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresAuditOnly , "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" => DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresBlock , "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" => DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresNoViolation , "SCAN_SUCCEEDED_WITH_FAILURES_WARN" => DlpScanSummaryScanOutcome :: ScanSucceededWithFailuresWarn , "SCAN_UNKNOWN_OUTCOME" => DlpScanSummaryScanOutcome :: ScanUnknownOutcome , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector for DlpScanSummaryScanOutcome {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DlpScanSummaryScanOutcome {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DmId {
        #[doc = "Unique server assigned Id, per Direct Message Space."]
        #[serde(
            rename = "dmId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dm_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for DmId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DmId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DocumentInfo {
        #[doc = "A whiteboard document."]
        #[serde(
            rename = "whiteboardInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub whiteboard_info: ::std::option::Option<crate::schemas::WhiteboardInfo>,
    }
    impl ::google_field_selector::FieldSelector for DocumentInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DocumentInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DoubleOperatorOptions {
        #[doc = "Indicates the operator name required in the query in order to use the double property in sorting or as a facet. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for DoubleOperatorOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DoubleOperatorOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DoublePropertyOptions {
        #[doc = "If set, describes how the double should be used as a search operator."]
        #[serde(
            rename = "operatorOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_options: ::std::option::Option<crate::schemas::DoubleOperatorOptions>,
    }
    impl ::google_field_selector::FieldSelector for DoublePropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DoublePropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct DoubleValues {
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<f64>>,
    }
    impl ::google_field_selector::FieldSelector for DoubleValues {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DoubleValues {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveClientActionMarkup {
        #[serde(
            rename = "requestFileScope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_file_scope: ::std::option::Option<crate::schemas::RequestFileScope>,
    }
    impl ::google_field_selector::FieldSelector for DriveClientActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveClientActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveFollowUpRestrict {
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::DriveFollowUpRestrictType>,
    }
    impl ::google_field_selector::FieldSelector for DriveFollowUpRestrict {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveFollowUpRestrict {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DriveFollowUpRestrictType {
        FollowupActionItems,
        FollowupSuggestions,
        Unspecified,
    }
    impl DriveFollowUpRestrictType {
        pub fn as_str(self) -> &'static str {
            match self {
                DriveFollowUpRestrictType::FollowupActionItems => "FOLLOWUP_ACTION_ITEMS",
                DriveFollowUpRestrictType::FollowupSuggestions => "FOLLOWUP_SUGGESTIONS",
                DriveFollowUpRestrictType::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for DriveFollowUpRestrictType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DriveFollowUpRestrictType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DriveFollowUpRestrictType, ()> {
            Ok(match s {
                "FOLLOWUP_ACTION_ITEMS" => DriveFollowUpRestrictType::FollowupActionItems,
                "FOLLOWUP_SUGGESTIONS" => DriveFollowUpRestrictType::FollowupSuggestions,
                "UNSPECIFIED" => DriveFollowUpRestrictType::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for DriveFollowUpRestrictType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DriveFollowUpRestrictType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DriveFollowUpRestrictType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FOLLOWUP_ACTION_ITEMS" => DriveFollowUpRestrictType::FollowupActionItems,
                "FOLLOWUP_SUGGESTIONS" => DriveFollowUpRestrictType::FollowupSuggestions,
                "UNSPECIFIED" => DriveFollowUpRestrictType::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for DriveFollowUpRestrictType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveFollowUpRestrictType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveLocationRestrict {
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::DriveLocationRestrictType>,
    }
    impl ::google_field_selector::FieldSelector for DriveLocationRestrict {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveLocationRestrict {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DriveLocationRestrictType {
        Starred,
        Trashed,
        Unspecified,
    }
    impl DriveLocationRestrictType {
        pub fn as_str(self) -> &'static str {
            match self {
                DriveLocationRestrictType::Starred => "STARRED",
                DriveLocationRestrictType::Trashed => "TRASHED",
                DriveLocationRestrictType::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for DriveLocationRestrictType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DriveLocationRestrictType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DriveLocationRestrictType, ()> {
            Ok(match s {
                "STARRED" => DriveLocationRestrictType::Starred,
                "TRASHED" => DriveLocationRestrictType::Trashed,
                "UNSPECIFIED" => DriveLocationRestrictType::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for DriveLocationRestrictType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DriveLocationRestrictType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DriveLocationRestrictType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "STARRED" => DriveLocationRestrictType::Starred,
                "TRASHED" => DriveLocationRestrictType::Trashed,
                "UNSPECIFIED" => DriveLocationRestrictType::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for DriveLocationRestrictType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveLocationRestrictType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveMetadata {
        #[serde(
            rename = "aclFixRequest",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub acl_fix_request: ::std::option::Option<crate::schemas::AclFixRequest>,
        #[serde(
            rename = "aclFixStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub acl_fix_status: ::std::option::Option<crate::schemas::AclFixStatus>,
        #[doc = "Can the current user edit this resource"]
        #[serde(
            rename = "canEdit",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub can_edit: ::std::option::Option<bool>,
        #[doc = "Can the current user share this resource"]
        #[serde(
            rename = "canShare",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub can_share: ::std::option::Option<bool>,
        #[doc = "Can the current user view this resource"]
        #[serde(
            rename = "canView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub can_view: ::std::option::Option<bool>,
        #[doc = "DriveAction for organizing this file in Drive. If the user does not have access to the Drive file, the value will be DriveAction.DRIVE_ACTION_UNSPECIFIED. This field is only set when part of a FileResult in a ListFilesResponse."]
        #[serde(
            rename = "driveAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_action: ::std::option::Option<crate::schemas::DriveMetadataDriveAction>,
        #[serde(
            rename = "driveState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_state: ::std::option::Option<crate::schemas::DriveMetadataDriveState>,
        #[doc = "Output only. Trusted Resource URL for drive file embedding."]
        #[serde(
            rename = "embedUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub embed_url: ::std::option::Option<crate::schemas::TrustedResourceUrlProto>,
        #[doc = "Indicates whether the Drive link contains an encrypted doc ID. If true, Dynamite should not attempt to query the doc ID in Drive Service. See go/docid-encryption for details."]
        #[serde(
            rename = "encryptedDocId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub encrypted_doc_id: ::std::option::Option<bool>,
        #[doc = "This is deprecated and unneeded. TODO (b/182479059): Remove this."]
        #[serde(
            rename = "encryptedResourceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub encrypted_resource_key: ::std::option::Option<String>,
        #[doc = "External mimetype of the Drive Resource (Useful for creating Drive URL) See: http://b/35219462"]
        #[serde(
            rename = "externalMimetype",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub external_mimetype: ::std::option::Option<String>,
        #[doc = "Drive resource ID of the artifact."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
        #[doc = "Deprecated. Whether the setting to restrict downloads is enabled for this file. This was previously used to determine whether to hide the download and print buttons in the UI, but is no longer used by clients, because Projector now independently queries Drive to ensure that we have the most up-to-date value."]
        #[serde(
            rename = "isDownloadRestricted",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_download_restricted: ::std::option::Option<bool>,
        #[doc = "If the current user is the Drive file’s owner. The field is currently only set for Annotations for the ListFiles action (as opposed to fetching Topics/Messages with Drive annotations)."]
        #[serde(
            rename = "isOwner",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_owner: ::std::option::Option<bool>,
        #[doc = "Only present if this DriveMetadata is converted from an UploadMetadata."]
        #[serde(
            rename = "legacyUploadMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub legacy_upload_metadata: ::std::option::Option<crate::schemas::LegacyUploadMetadata>,
        #[doc = "Mimetype of the Drive Resource"]
        #[serde(
            rename = "mimetype",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mimetype: ::std::option::Option<String>,
        #[doc = "The display name of the organization owning the Drive item."]
        #[serde(
            rename = "organizationDisplayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub organization_display_name: ::std::option::Option<String>,
        #[doc = "Shortcut ID of this drive file in the shared drive, which is associated with a named room this file was shared in. Shortcuts will not be created for DMs or unnamed rooms. This is populated after the DriveMetadata is migrated to shared drive. go/chat-shared-drive-uploads."]
        #[serde(
            rename = "shortcutAuthorizedItemId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shortcut_authorized_item_id: ::std::option::Option<crate::schemas::AuthorizedItemId>,
        #[doc = "If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip."]
        #[serde(
            rename = "shouldNotRender",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub should_not_render: ::std::option::Option<bool>,
        #[doc = "Thumbnail image of the Drive Resource"]
        #[serde(
            rename = "thumbnailHeight",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thumbnail_height: ::std::option::Option<i32>,
        #[doc = "Thumbnail image of the Drive Resource"]
        #[serde(
            rename = "thumbnailUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thumbnail_url: ::std::option::Option<String>,
        #[doc = "Thumbnail image of the Drive Resource"]
        #[serde(
            rename = "thumbnailWidth",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thumbnail_width: ::std::option::Option<i32>,
        #[doc = "Title of the Drive Resource"]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
        #[doc = "Url string fragment that generally indicates the specific location in the linked file. Example: #header=h.123abc456. If the fragment is not present this will not be present and therefore default to an empty string. The “\\#” will not be included."]
        #[serde(
            rename = "urlFragment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url_fragment: ::std::option::Option<String>,
        #[doc = "This is considered SPII and should not be logged."]
        #[serde(
            rename = "wrappedResourceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wrapped_resource_key: ::std::option::Option<crate::schemas::WrappedResourceKey>,
    }
    impl ::google_field_selector::FieldSelector for DriveMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DriveMetadataDriveAction {
        #[doc = "Show “Add another shortcut” button, for Drive files the user has already created a shortcut to."]
        AddAnotherShortcut,
        #[doc = "Show “Add shortcut” button, for adding a shortcut to a Drive file the user does not have permission to move."]
        AddShortcut,
        #[doc = "Show “Add to Drive” button, for adding file that doesn’t exist in Drive to Drive. Note that deleted Drive files that still exist (i.e. in your Trash) will still be ORGANIZE (this is consistent with Gmail Drive attachments)."]
        AddToDrive,
        #[doc = "No organize action should be shown."]
        DriveActionUnspecified,
        #[doc = "Show “Move” button, for organizing a Drive file the user has permission to move."]
        Organize,
    }
    impl DriveMetadataDriveAction {
        pub fn as_str(self) -> &'static str {
            match self {
                DriveMetadataDriveAction::AddAnotherShortcut => "ADD_ANOTHER_SHORTCUT",
                DriveMetadataDriveAction::AddShortcut => "ADD_SHORTCUT",
                DriveMetadataDriveAction::AddToDrive => "ADD_TO_DRIVE",
                DriveMetadataDriveAction::DriveActionUnspecified => "DRIVE_ACTION_UNSPECIFIED",
                DriveMetadataDriveAction::Organize => "ORGANIZE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for DriveMetadataDriveAction {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DriveMetadataDriveAction {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DriveMetadataDriveAction, ()> {
            Ok(match s {
                "ADD_ANOTHER_SHORTCUT" => DriveMetadataDriveAction::AddAnotherShortcut,
                "ADD_SHORTCUT" => DriveMetadataDriveAction::AddShortcut,
                "ADD_TO_DRIVE" => DriveMetadataDriveAction::AddToDrive,
                "DRIVE_ACTION_UNSPECIFIED" => DriveMetadataDriveAction::DriveActionUnspecified,
                "ORGANIZE" => DriveMetadataDriveAction::Organize,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for DriveMetadataDriveAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DriveMetadataDriveAction {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DriveMetadataDriveAction {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADD_ANOTHER_SHORTCUT" => DriveMetadataDriveAction::AddAnotherShortcut,
                "ADD_SHORTCUT" => DriveMetadataDriveAction::AddShortcut,
                "ADD_TO_DRIVE" => DriveMetadataDriveAction::AddToDrive,
                "DRIVE_ACTION_UNSPECIFIED" => DriveMetadataDriveAction::DriveActionUnspecified,
                "ORGANIZE" => DriveMetadataDriveAction::Organize,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for DriveMetadataDriveAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveMetadataDriveAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DriveMetadataDriveState {
        #[doc = "Default value"]
        DriveStateUnspecified,
        #[doc = "File in My Drive"]
        InMyDrive,
        #[doc = "File in Team Drive"]
        InTeamDrive,
        #[doc = "File not in drive"]
        NotInDrive,
        #[doc = "File in someone else’s Drive, but is shared with the current user"]
        SharedInDrive,
    }
    impl DriveMetadataDriveState {
        pub fn as_str(self) -> &'static str {
            match self {
                DriveMetadataDriveState::DriveStateUnspecified => "DRIVE_STATE_UNSPECIFIED",
                DriveMetadataDriveState::InMyDrive => "IN_MY_DRIVE",
                DriveMetadataDriveState::InTeamDrive => "IN_TEAM_DRIVE",
                DriveMetadataDriveState::NotInDrive => "NOT_IN_DRIVE",
                DriveMetadataDriveState::SharedInDrive => "SHARED_IN_DRIVE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for DriveMetadataDriveState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DriveMetadataDriveState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DriveMetadataDriveState, ()> {
            Ok(match s {
                "DRIVE_STATE_UNSPECIFIED" => DriveMetadataDriveState::DriveStateUnspecified,
                "IN_MY_DRIVE" => DriveMetadataDriveState::InMyDrive,
                "IN_TEAM_DRIVE" => DriveMetadataDriveState::InTeamDrive,
                "NOT_IN_DRIVE" => DriveMetadataDriveState::NotInDrive,
                "SHARED_IN_DRIVE" => DriveMetadataDriveState::SharedInDrive,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for DriveMetadataDriveState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DriveMetadataDriveState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DriveMetadataDriveState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DRIVE_STATE_UNSPECIFIED" => DriveMetadataDriveState::DriveStateUnspecified,
                "IN_MY_DRIVE" => DriveMetadataDriveState::InMyDrive,
                "IN_TEAM_DRIVE" => DriveMetadataDriveState::InTeamDrive,
                "NOT_IN_DRIVE" => DriveMetadataDriveState::NotInDrive,
                "SHARED_IN_DRIVE" => DriveMetadataDriveState::SharedInDrive,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for DriveMetadataDriveState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveMetadataDriveState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveMimeTypeRestrict {
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::DriveMimeTypeRestrictType>,
    }
    impl ::google_field_selector::FieldSelector for DriveMimeTypeRestrict {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveMimeTypeRestrict {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DriveMimeTypeRestrictType {
        Archive,
        Audio,
        Document,
        Drawing,
        Folder,
        Form,
        Image,
        Map,
        Pdf,
        Presentation,
        Script,
        Site,
        Spreadsheet,
        Unspecified,
        Video,
    }
    impl DriveMimeTypeRestrictType {
        pub fn as_str(self) -> &'static str {
            match self {
                DriveMimeTypeRestrictType::Archive => "ARCHIVE",
                DriveMimeTypeRestrictType::Audio => "AUDIO",
                DriveMimeTypeRestrictType::Document => "DOCUMENT",
                DriveMimeTypeRestrictType::Drawing => "DRAWING",
                DriveMimeTypeRestrictType::Folder => "FOLDER",
                DriveMimeTypeRestrictType::Form => "FORM",
                DriveMimeTypeRestrictType::Image => "IMAGE",
                DriveMimeTypeRestrictType::Map => "MAP",
                DriveMimeTypeRestrictType::Pdf => "PDF",
                DriveMimeTypeRestrictType::Presentation => "PRESENTATION",
                DriveMimeTypeRestrictType::Script => "SCRIPT",
                DriveMimeTypeRestrictType::Site => "SITE",
                DriveMimeTypeRestrictType::Spreadsheet => "SPREADSHEET",
                DriveMimeTypeRestrictType::Unspecified => "UNSPECIFIED",
                DriveMimeTypeRestrictType::Video => "VIDEO",
            }
        }
    }
    impl ::std::convert::AsRef<str> for DriveMimeTypeRestrictType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DriveMimeTypeRestrictType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DriveMimeTypeRestrictType, ()> {
            Ok(match s {
                "ARCHIVE" => DriveMimeTypeRestrictType::Archive,
                "AUDIO" => DriveMimeTypeRestrictType::Audio,
                "DOCUMENT" => DriveMimeTypeRestrictType::Document,
                "DRAWING" => DriveMimeTypeRestrictType::Drawing,
                "FOLDER" => DriveMimeTypeRestrictType::Folder,
                "FORM" => DriveMimeTypeRestrictType::Form,
                "IMAGE" => DriveMimeTypeRestrictType::Image,
                "MAP" => DriveMimeTypeRestrictType::Map,
                "PDF" => DriveMimeTypeRestrictType::Pdf,
                "PRESENTATION" => DriveMimeTypeRestrictType::Presentation,
                "SCRIPT" => DriveMimeTypeRestrictType::Script,
                "SITE" => DriveMimeTypeRestrictType::Site,
                "SPREADSHEET" => DriveMimeTypeRestrictType::Spreadsheet,
                "UNSPECIFIED" => DriveMimeTypeRestrictType::Unspecified,
                "VIDEO" => DriveMimeTypeRestrictType::Video,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for DriveMimeTypeRestrictType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DriveMimeTypeRestrictType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DriveMimeTypeRestrictType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ARCHIVE" => DriveMimeTypeRestrictType::Archive,
                "AUDIO" => DriveMimeTypeRestrictType::Audio,
                "DOCUMENT" => DriveMimeTypeRestrictType::Document,
                "DRAWING" => DriveMimeTypeRestrictType::Drawing,
                "FOLDER" => DriveMimeTypeRestrictType::Folder,
                "FORM" => DriveMimeTypeRestrictType::Form,
                "IMAGE" => DriveMimeTypeRestrictType::Image,
                "MAP" => DriveMimeTypeRestrictType::Map,
                "PDF" => DriveMimeTypeRestrictType::Pdf,
                "PRESENTATION" => DriveMimeTypeRestrictType::Presentation,
                "SCRIPT" => DriveMimeTypeRestrictType::Script,
                "SITE" => DriveMimeTypeRestrictType::Site,
                "SPREADSHEET" => DriveMimeTypeRestrictType::Spreadsheet,
                "UNSPECIFIED" => DriveMimeTypeRestrictType::Unspecified,
                "VIDEO" => DriveMimeTypeRestrictType::Video,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for DriveMimeTypeRestrictType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveMimeTypeRestrictType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveTimeSpanRestrict {
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::DriveTimeSpanRestrictType>,
    }
    impl ::google_field_selector::FieldSelector for DriveTimeSpanRestrict {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveTimeSpanRestrict {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum DriveTimeSpanRestrictType {
        #[doc = "Not Enabled"]
        Last30Days,
        Last7Days,
        #[doc = "Not Enabled"]
        Last90Days,
        Today,
        Unspecified,
        Yesterday,
    }
    impl DriveTimeSpanRestrictType {
        pub fn as_str(self) -> &'static str {
            match self {
                DriveTimeSpanRestrictType::Last30Days => "LAST_30_DAYS",
                DriveTimeSpanRestrictType::Last7Days => "LAST_7_DAYS",
                DriveTimeSpanRestrictType::Last90Days => "LAST_90_DAYS",
                DriveTimeSpanRestrictType::Today => "TODAY",
                DriveTimeSpanRestrictType::Unspecified => "UNSPECIFIED",
                DriveTimeSpanRestrictType::Yesterday => "YESTERDAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for DriveTimeSpanRestrictType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for DriveTimeSpanRestrictType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<DriveTimeSpanRestrictType, ()> {
            Ok(match s {
                "LAST_30_DAYS" => DriveTimeSpanRestrictType::Last30Days,
                "LAST_7_DAYS" => DriveTimeSpanRestrictType::Last7Days,
                "LAST_90_DAYS" => DriveTimeSpanRestrictType::Last90Days,
                "TODAY" => DriveTimeSpanRestrictType::Today,
                "UNSPECIFIED" => DriveTimeSpanRestrictType::Unspecified,
                "YESTERDAY" => DriveTimeSpanRestrictType::Yesterday,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for DriveTimeSpanRestrictType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for DriveTimeSpanRestrictType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DriveTimeSpanRestrictType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "LAST_30_DAYS" => DriveTimeSpanRestrictType::Last30Days,
                "LAST_7_DAYS" => DriveTimeSpanRestrictType::Last7Days,
                "LAST_90_DAYS" => DriveTimeSpanRestrictType::Last90Days,
                "TODAY" => DriveTimeSpanRestrictType::Today,
                "UNSPECIFIED" => DriveTimeSpanRestrictType::Unspecified,
                "YESTERDAY" => DriveTimeSpanRestrictType::Yesterday,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for DriveTimeSpanRestrictType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DriveTimeSpanRestrictType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct DynamiteMessagesScoringInfo {
        #[serde(
            rename = "finalScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub final_score: ::std::option::Option<f64>,
        #[serde(
            rename = "freshnessScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub freshness_score: ::std::option::Option<f64>,
        #[serde(
            rename = "joinedSpaceAffinityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub joined_space_affinity_score: ::std::option::Option<f64>,
        #[serde(
            rename = "messageAgeInDays",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_age_in_days: ::std::option::Option<f64>,
        #[serde(
            rename = "messageSenderAffinityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_sender_affinity_score: ::std::option::Option<f64>,
        #[serde(
            rename = "topicalityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub topicality_score: ::std::option::Option<f64>,
        #[serde(
            rename = "unjoinedSpaceAffinityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub unjoined_space_affinity_score: ::std::option::Option<f64>,
    }
    impl ::google_field_selector::FieldSelector for DynamiteMessagesScoringInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DynamiteMessagesScoringInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct DynamiteSpacesScoringInfo {
        #[serde(
            rename = "affinityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub affinity_score: ::std::option::Option<f64>,
        #[serde(
            rename = "commonContactCountAffinityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_contact_count_affinity_score: ::std::option::Option<f64>,
        #[serde(
            rename = "contactsIntersectionCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contacts_intersection_count: ::std::option::Option<f64>,
        #[serde(
            rename = "finalScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub final_score: ::std::option::Option<f64>,
        #[serde(
            rename = "freshnessScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub freshness_score: ::std::option::Option<f64>,
        #[serde(
            rename = "joinedSpacesAffinityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub joined_spaces_affinity_score: ::std::option::Option<f64>,
        #[serde(
            rename = "lastMessagePostedTimestampSecs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_message_posted_timestamp_secs: ::std::option::Option<i64>,
        #[serde(
            rename = "lastReadTimestampSecs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_read_timestamp_secs: ::std::option::Option<i64>,
        #[serde(
            rename = "memberMetadataCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub member_metadata_count: ::std::option::Option<f64>,
        #[serde(
            rename = "messageScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_score: ::std::option::Option<f64>,
        #[serde(
            rename = "numAucContacts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub num_auc_contacts: ::std::option::Option<i64>,
        #[serde(
            rename = "smallContactListAffinityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub small_contact_list_affinity_score: ::std::option::Option<f64>,
        #[serde(
            rename = "smallUnjoinedSpacesAffinityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub small_unjoined_spaces_affinity_score: ::std::option::Option<f64>,
        #[serde(
            rename = "spaceAgeInDays",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub space_age_in_days: ::std::option::Option<f64>,
        #[serde(
            rename = "spaceCreationTimestampSecs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub space_creation_timestamp_secs: ::std::option::Option<i64>,
        #[serde(
            rename = "topicalityScore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub topicality_score: ::std::option::Option<f64>,
    }
    impl ::google_field_selector::FieldSelector for DynamiteSpacesScoringInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for DynamiteSpacesScoringInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EditMetadata {}
    impl ::google_field_selector::FieldSelector for EditMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EditMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EditorClientActionMarkup {
        #[serde(
            rename = "requestFileScopeForActiveDocument",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_file_scope_for_active_document:
            ::std::option::Option<crate::schemas::RequestFileScopeForActiveDocument>,
    }
    impl ::google_field_selector::FieldSelector for EditorClientActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EditorClientActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EmailAddress {
        #[doc = "If the value of type is custom, this property contains the custom type string."]
        #[serde(
            rename = "customType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub custom_type: ::std::option::Option<String>,
        #[doc = "The email address."]
        #[serde(
            rename = "emailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email_address: ::std::option::Option<String>,
        #[doc = "The URL to send email."]
        #[serde(
            rename = "emailUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email_url: ::std::option::Option<String>,
        #[doc = "Indicates if this is the user’s primary email. Only one entry can be marked as primary."]
        #[serde(
            rename = "primary",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub primary: ::std::option::Option<bool>,
        #[doc = "The type of the email account. Acceptable values are: “custom”, “home”, “other”, “work”."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EmailAddress {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EmailAddress {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EmailOwnerProto {
        #[serde(
            rename = "email",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EmailOwnerProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EmailOwnerProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EmbedClientItem {
        #[doc = "The canonical ID of the embed. If absent, the canonical ID is equal to the ID; if present, then the canonical ID represents an “equivalence class” of embeds which really refer to the same object. (For example, the URLs http://www.foo.com/ and http://foo.com/ refer to the same object) This field may be updated periodically by background processes."]
        #[serde(
            rename = "canonicalId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub canonical_id: ::std::option::Option<String>,
        #[doc = "Deep-linking data to take the user to the right place in a mobile app. This is only used for preview and attribution. Links that are specific to a given embed type should live on that specific embed’s proto by using Link. See http://goto.google.com/mariana-design."]
        #[serde(
            rename = "deepLinkData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deep_link_data: ::std::option::Option<crate::schemas::DeepLinkData>,
        #[doc = "The ID of the embed. This corresponds to the schema.org ID, as represented in the ItemScope.id field."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
        #[doc = "The provenance of the embed, populated when the embed originated from a web fetch. The provenance captures information about the web page the embed had originated, like the URL that was retrieved and the retrieved URL’s canonical form. This is useful in the case where the URL shared by the URL redirects (e.g., in the case of a shortened URL)."]
        #[serde(
            rename = "provenance",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub provenance: ::std::option::Option<crate::schemas::Provenance>,
        #[doc = "The first value in `type` determines which extension field will be set. When creating an EmbedClientItem, you only need to set the first (primary) type in this field. When the server receives the item, it will populate the full type list using the parent annotations in the ItemType enum."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<Vec<crate::schemas::EmbedClientItemTypeItems>>,
        #[doc = "The ID used to identify the embed during rendering. This field will match ID, if set, otherwise it will be the ID of the parent activity. This field is only populated on the server for client use and is not persisted to storage."]
        #[serde(
            rename = "renderId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub render_id: ::std::option::Option<String>,
        #[doc = "Signature of the embed, used for verification."]
        #[serde(
            rename = "signature",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub signature: ::std::option::Option<String>,
        #[doc = "Transient generic data that will not be saved on the server."]
        #[serde(
            rename = "transientData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transient_data: ::std::option::Option<crate::schemas::TransientData>,
    }
    impl ::google_field_selector::FieldSelector for EmbedClientItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EmbedClientItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EmbedClientItemTypeItems {
        AboutPage,
        AccountingService,
        #[doc = "Embeds V2 types"]
        ActionV2,
        AddActionV2,
        #[doc = "PLACE subtypes"]
        AdministrativeArea,
        AdultEntertainment,
        AggregateRating,
        AggregateRatingV2,
        Airport,
        AmusementPark,
        AnimalShelter,
        ApartmentComplex,
        AppInvite,
        Aquarium,
        ArtGallery,
        #[doc = "CREATIVE_WORK subtypes"]
        Article,
        ArticleV2,
        AssessActionV2,
        Attorney,
        AudioObject,
        AudioObjectV2,
        AutoBodyShop,
        AutoDealer,
        AutoPartsStore,
        AutoRental,
        AutoRepair,
        AutoWash,
        AutomatedTeller,
        AutomotiveBusiness,
        Bakery,
        BankOrCreditUnion,
        BarOrPub,
        BasicInteractionV2,
        Beach,
        BeautySalon,
        BedAndBreakfast,
        BikeStore,
        Blog,
        BlogPosting,
        BlogPostingV2,
        BlogV2,
        BodyOfWater,
        Book,
        BookFormatType,
        BookStore,
        BookV2,
        BowlingAlley,
        Brewery,
        BuddhistTemple,
        BusStation,
        BusStop,
        #[doc = "EVENT subtypes"]
        BusinessEvent,
        BuyActionV2,
        CafeOrCoffeeShop,
        Campground,
        Canal,
        #[doc = "Single frame for http://goto/carousel."]
        CarouselFrame,
        Casino,
        CatholicChurch,
        Cemetery,
        #[doc = "The action of checking in, as opposed to a “check-in”."]
        CheckInActionV2,
        Checkin,
        CheckinV2,
        CheckoutPage,
        ChildCare,
        ChildrensEvent,
        Church,
        City,
        CityHall,
        CivicStructure,
        ClothingStore,
        CollectionPage,
        CollegeOrUniversity,
        CollexionV2,
        ComedyClub,
        ComedyEvent,
        Comment,
        #[doc = "The act of commenting, which might result in a comment."]
        CommentActionV2,
        CommentV2,
        CommunicateActionV2,
        ComputerStore,
        ConsumeActionV2,
        ContactPage,
        ContactPoint,
        Continent,
        ConvenienceStore,
        #[doc = "ORGANIZATION subtypes"]
        Corporation,
        Country,
        Courthouse,
        CreateActionV2,
        CreativeWork,
        CreativeWorkV2,
        Crematorium,
        DanceEvent,
        #[doc = "An http://schema.org/Date unstructured ISO-8859 timestamp string."]
        Date,
        DaySpa,
        DefenceEstablishment,
        Dentist,
        DepartmentStore,
        DeprecatedTourObject,
        DeprecatedTourObjectV2,
        DiscoverActionV2,
        Distance,
        DocumentObject,
        DocumentObjectV2,
        DrawingObject,
        DrawingObjectV2,
        #[doc = "Embed representing a collection of multiple Drive objects."]
        DriveObjectCollection,
        DriveObjectV2,
        DryCleaningOrLaundry,
        Duration,
        #[doc = "Deprecated in favor of DYNAMITE_MESSAGE_METADATA"]
        DynamiteAttachmentMetadata,
        #[doc = "Used for Dynamite message metadata in Hangouts"]
        DynamiteMessageMetadata,
        EducationEvent,
        EducationalOrganization,
        Electrician,
        ElectronicsStore,
        ElementarySchool,
        Embassy,
        EmergencyService,
        Emotishare,
        EmotishareV2,
        EmploymentAgengy,
        Energy,
        EntertainmentBusiness,
        EntryPointV2,
        #[doc = "Intangibles, primarily used as sub-objects of other types"]
        Enumeration,
        Event,
        EventTimeV2,
        EventV2,
        EventVenue,
        ExampleObject,
        ExerciseGym,
        FastFoodRestaurant,
        Festival,
        FileObject,
        FileObjectV2,
        FinancialQuote,
        FinancialQuoteV2,
        FinancialService,
        FindActionV2,
        FireStation,
        Florist,
        FoodEstablishment,
        FoodEvent,
        FormObject,
        FormObjectV2,
        FurnitureStore,
        GardenStore,
        GasStation,
        GatedResidenceCommunity,
        GeneralContractor,
        GeoCoordinates,
        GeoCoordinatesV2,
        GeoShape,
        GolfCourse,
        #[doc = "Data visualizations. See http://code.google.com/apis/chart/index.html"]
        GoogleChart,
        GoogleOfferV2,
        #[doc = "An embed used to create a single photo in photo service. This type is never stored but is used to create a GOOGLE_USER_PHOTO_V2 or PLUS_PHOTO_V2 embed."]
        GooglePhotoRecipe,
        #[doc = "A photo album in photo service owned by a Google account user. This is distinct from PlusPhotoAlbum as it isn’t tied to GPlus, but is instead intended to be a general photo album tied to a google user."]
        GoogleUserPhotoAlbum,
        #[doc = "A photo stored in photo service owned by a Google account user. This is distinct from PlusPhoto as it isn’t tied to GPlus, but is instead intended to be a more general photo tied to a google user."]
        GoogleUserPhotoV2,
        GovernmentBuilding,
        GovernmentOffice,
        GovernmentOrganization,
        GroceryStore,
        HairSalon,
        #[doc = "No declared proto. Used only as a base type for now."]
        Hangout,
        HangoutBroadcast,
        HangoutChatMessage,
        HangoutConsumer,
        HangoutQuote,
        HangoutV2,
        HardwareStore,
        HealthAndBeautyBusiness,
        HealthClub,
        HighSchool,
        HinduTemple,
        HoaPlusEventV2,
        HobbyShop,
        HomeAndConstructionBusiness,
        HomeGoodsStore,
        Hospital,
        Hostel,
        Hotel,
        HousePainter,
        HvacBusiness,
        IceCreamShop,
        ImageGallery,
        ImageObject,
        ImageObjectV2,
        InsuranceAgency,
        Intangible,
        InteractActionV2,
        InteractionV2,
        InternetCafe,
        ItemAvailability,
        ItemList,
        ItemPage,
        JewelryStore,
        JobPosting,
        LakeBodyOfWater,
        Landform,
        LandmarksOrHistoricalBuildings,
        Language,
        LegislativeBuilding,
        Library,
        LiquorStore,
        ListenActionV2,
        LiteraryEvent,
        LocalBusiness,
        LocalBusinessV2,
        LocalPlusPhotoAlbum,
        LocalPlusPhotoAlbumV2,
        Locksmith,
        LodgingBusiness,
        Magazine,
        MagazineV2,
        Map,
        Mass,
        MediaObject,
        MediaObjectV2,
        MedicalClinic,
        MedicalOrganization,
        MensClothingStore,
        MiddleSchool,
        MobileApplication,
        MobileApplicationV2,
        MobilePhoneStore,
        Mosque,
        Motel,
        MotorcycleDealer,
        MotorcycleRepair,
        Mountain,
        Movie,
        MovieRentalStore,
        MovieTheater,
        MovieV2,
        MovingCompany,
        Museum,
        MusicAlbum,
        MusicAlbumV2,
        MusicEvent,
        MusicGroup,
        MusicGroupV2,
        MusicPlaylist,
        MusicPlaylistV2,
        MusicRecording,
        MusicRecordingV2,
        MusicStore,
        MusicVenue,
        MusicVideoObject,
        NailSalon,
        NewsArticle,
        NewsArticleV2,
        #[doc = "https://schema.org/NewsMediaOrganization"]
        NewsMediaOrganization,
        NightClub,
        Notary,
        NutritionInformation,
        OceanBodyOfWater,
        Offer,
        OfferItemCondition,
        OfferV2,
        OfficeEquipmentStore,
        Optician,
        Organization,
        OrganizationV2,
        OrganizeActionV2,
        OutletStore,
        Painting,
        Park,
        ParkingFacility,
        PawnShop,
        PerformingArtsTheater,
        PerformingGroup,
        Person,
        PersonV2,
        PetStore,
        Pharmacy,
        Photograph,
        Physician,
        Place,
        PlaceOfWorship,
        PlaceReview,
        PlaceReviewV2,
        PlaceV2,
        PlanActionV2,
        PlayMusicAlbum,
        PlayMusicAlbumV2,
        PlayMusicTrack,
        PlayMusicTrackV2,
        PlayObjectV2,
        Playground,
        Plumber,
        PlusAudioV2,
        #[doc = "EVENT extensions"]
        PlusEvent,
        PlusEventV2,
        PlusMediaCollectionV2,
        PlusMediaObjectV2,
        PlusPage,
        PlusPageV2,
        PlusPhoto,
        PlusPhotoAlbum,
        PlusPhotoAlbumV2,
        PlusPhotoCollectionV2,
        PlusPhotoV2,
        PlusPhotosAddedToCollection,
        PlusPhotosAddedToCollectionV2,
        #[doc = "A Google+ post."]
        PlusPost,
        PlusPostV2,
        PlusReshareV2,
        PlusSoftwareApplicationV2,
        PoliceStation,
        PollOptionV2,
        PollV2,
        Pond,
        PostOffice,
        PostalAddress,
        PostalAddressV2,
        Preschool,
        #[doc = "CREATIVE_WORK extensions"]
        PresentationObject,
        PresentationObjectV2,
        Product,
        ProductReview,
        ProductReviewV2,
        ProfessionalService,
        ProfilePage,
        PublicSwimmingPool,
        Quantity,
        RVPark,
        RadioStation,
        Rating,
        RatingV2,
        ReactActionV2,
        RealEstateAgent,
        Recipe,
        #[doc = "A collection of people that have been recommended to a user."]
        RecommendedPeople,
        RecyclingCenter,
        Reservation,
        ReservationV2,
        ReserveActionV2,
        Reservoir,
        Residence,
        Restaurant,
        Review,
        ReviewActionV2,
        ReviewV2,
        RiverBodyOfWater,
        RoofingContractor,
        SaleEvent,
        ScholarlyArticle,
        School,
        Sculpture,
        SeaBodyOfWater,
        SearchResultsPage,
        SelfStorage,
        ShoeStore,
        ShoppingCenter,
        SingleFamilyResidence,
        SiteNavigationElement,
        SkiResort,
        SocialEvent,
        SoftwareApplication,
        SoftwareApplicationV2,
        SportingGoodsStore,
        SportsActivityLocation,
        SportsClub,
        SportsEvent,
        SpreadsheetObject,
        SpreadsheetObjectV2,
        #[doc = "NOTE(melchang): These correspond to http://schema.org/WebPage/Community and http://schema.org/WebPage/CommunityInvite. See b/7653610 for why these are “SQUARE” and not “COMMUNITY”."]
        Square,
        SquareInvite,
        SquareInviteV2,
        SquareV2,
        StadiumOrArena,
        State,
        StickerV2,
        Store,
        #[doc = "Boswell story (see goto/boswell)"]
        StoryV2,
        StructuredValue,
        SubwayStation,
        Synagogue,
        Table,
        TattooParlor,
        TaxiStand,
        TelevisionStation,
        TennisComplex,
        TheaterEvent,
        #[doc = "Embeds V1 types"]
        Thing,
        ThingV2,
        TireShop,
        TouristAttraction,
        TouristInformationCenter,
        ToyStore,
        TradeActionV2,
        TrainStation,
        TravelAgency,
        TravelEvent,
        TvEpisode,
        TvEpisodeV2,
        TvSeason,
        TvSeries,
        TvSeriesV2,
        #[doc = "Largely deprecated, effectively an error condition and should not be in storage."]
        Unknown,
        UpdateActionV2,
        #[doc = "NOTE(jpanzer): This is a badly designed hierarchy and we should avoid depending on Event properties inside UserInteractions as much as possible IMHO."]
        UserInteraction,
        UserPlusOnes,
        VeterinaryCare,
        VideoGallery,
        VideoGalleryV2,
        VideoObject,
        VideoObjectV2,
        ViewActionV2,
        VisualArtsEvent,
        Volcano,
        WantActionV2,
        Waterfall,
        WebApplication,
        WebPage,
        WebPageElement,
        WebPageV2,
        WholesaleStore,
        Winery,
        WpAdBlock,
        WpFooter,
        WpHeader,
        WpSidebar,
        WriteActionV2,
        YoutubeChannelV2,
        Zoo,
    }
    impl EmbedClientItemTypeItems {
        pub fn as_str(self) -> &'static str {
            match self {
                EmbedClientItemTypeItems::AboutPage => "ABOUT_PAGE",
                EmbedClientItemTypeItems::AccountingService => "ACCOUNTING_SERVICE",
                EmbedClientItemTypeItems::ActionV2 => "ACTION_V2",
                EmbedClientItemTypeItems::AddActionV2 => "ADD_ACTION_V2",
                EmbedClientItemTypeItems::AdministrativeArea => "ADMINISTRATIVE_AREA",
                EmbedClientItemTypeItems::AdultEntertainment => "ADULT_ENTERTAINMENT",
                EmbedClientItemTypeItems::AggregateRating => "AGGREGATE_RATING",
                EmbedClientItemTypeItems::AggregateRatingV2 => "AGGREGATE_RATING_V2",
                EmbedClientItemTypeItems::Airport => "AIRPORT",
                EmbedClientItemTypeItems::AmusementPark => "AMUSEMENT_PARK",
                EmbedClientItemTypeItems::AnimalShelter => "ANIMAL_SHELTER",
                EmbedClientItemTypeItems::ApartmentComplex => "APARTMENT_COMPLEX",
                EmbedClientItemTypeItems::AppInvite => "APP_INVITE",
                EmbedClientItemTypeItems::Aquarium => "AQUARIUM",
                EmbedClientItemTypeItems::ArtGallery => "ART_GALLERY",
                EmbedClientItemTypeItems::Article => "ARTICLE",
                EmbedClientItemTypeItems::ArticleV2 => "ARTICLE_V2",
                EmbedClientItemTypeItems::AssessActionV2 => "ASSESS_ACTION_V2",
                EmbedClientItemTypeItems::Attorney => "ATTORNEY",
                EmbedClientItemTypeItems::AudioObject => "AUDIO_OBJECT",
                EmbedClientItemTypeItems::AudioObjectV2 => "AUDIO_OBJECT_V2",
                EmbedClientItemTypeItems::AutoBodyShop => "AUTO_BODY_SHOP",
                EmbedClientItemTypeItems::AutoDealer => "AUTO_DEALER",
                EmbedClientItemTypeItems::AutoPartsStore => "AUTO_PARTS_STORE",
                EmbedClientItemTypeItems::AutoRental => "AUTO_RENTAL",
                EmbedClientItemTypeItems::AutoRepair => "AUTO_REPAIR",
                EmbedClientItemTypeItems::AutoWash => "AUTO_WASH",
                EmbedClientItemTypeItems::AutomatedTeller => "AUTOMATED_TELLER",
                EmbedClientItemTypeItems::AutomotiveBusiness => "AUTOMOTIVE_BUSINESS",
                EmbedClientItemTypeItems::Bakery => "BAKERY",
                EmbedClientItemTypeItems::BankOrCreditUnion => "BANK_OR_CREDIT_UNION",
                EmbedClientItemTypeItems::BarOrPub => "BAR_OR_PUB",
                EmbedClientItemTypeItems::BasicInteractionV2 => "BASIC_INTERACTION_V2",
                EmbedClientItemTypeItems::Beach => "BEACH",
                EmbedClientItemTypeItems::BeautySalon => "BEAUTY_SALON",
                EmbedClientItemTypeItems::BedAndBreakfast => "BED_AND_BREAKFAST",
                EmbedClientItemTypeItems::BikeStore => "BIKE_STORE",
                EmbedClientItemTypeItems::Blog => "BLOG",
                EmbedClientItemTypeItems::BlogPosting => "BLOG_POSTING",
                EmbedClientItemTypeItems::BlogPostingV2 => "BLOG_POSTING_V2",
                EmbedClientItemTypeItems::BlogV2 => "BLOG_V2",
                EmbedClientItemTypeItems::BodyOfWater => "BODY_OF_WATER",
                EmbedClientItemTypeItems::Book => "BOOK",
                EmbedClientItemTypeItems::BookFormatType => "BOOK_FORMAT_TYPE",
                EmbedClientItemTypeItems::BookStore => "BOOK_STORE",
                EmbedClientItemTypeItems::BookV2 => "BOOK_V2",
                EmbedClientItemTypeItems::BowlingAlley => "BOWLING_ALLEY",
                EmbedClientItemTypeItems::Brewery => "BREWERY",
                EmbedClientItemTypeItems::BuddhistTemple => "BUDDHIST_TEMPLE",
                EmbedClientItemTypeItems::BusStation => "BUS_STATION",
                EmbedClientItemTypeItems::BusStop => "BUS_STOP",
                EmbedClientItemTypeItems::BusinessEvent => "BUSINESS_EVENT",
                EmbedClientItemTypeItems::BuyActionV2 => "BUY_ACTION_V2",
                EmbedClientItemTypeItems::CafeOrCoffeeShop => "CAFE_OR_COFFEE_SHOP",
                EmbedClientItemTypeItems::Campground => "CAMPGROUND",
                EmbedClientItemTypeItems::Canal => "CANAL",
                EmbedClientItemTypeItems::CarouselFrame => "CAROUSEL_FRAME",
                EmbedClientItemTypeItems::Casino => "CASINO",
                EmbedClientItemTypeItems::CatholicChurch => "CATHOLIC_CHURCH",
                EmbedClientItemTypeItems::Cemetery => "CEMETERY",
                EmbedClientItemTypeItems::CheckInActionV2 => "CHECK_IN_ACTION_V2",
                EmbedClientItemTypeItems::Checkin => "CHECKIN",
                EmbedClientItemTypeItems::CheckinV2 => "CHECKIN_V2",
                EmbedClientItemTypeItems::CheckoutPage => "CHECKOUT_PAGE",
                EmbedClientItemTypeItems::ChildCare => "CHILD_CARE",
                EmbedClientItemTypeItems::ChildrensEvent => "CHILDRENS_EVENT",
                EmbedClientItemTypeItems::Church => "CHURCH",
                EmbedClientItemTypeItems::City => "CITY",
                EmbedClientItemTypeItems::CityHall => "CITY_HALL",
                EmbedClientItemTypeItems::CivicStructure => "CIVIC_STRUCTURE",
                EmbedClientItemTypeItems::ClothingStore => "CLOTHING_STORE",
                EmbedClientItemTypeItems::CollectionPage => "COLLECTION_PAGE",
                EmbedClientItemTypeItems::CollegeOrUniversity => "COLLEGE_OR_UNIVERSITY",
                EmbedClientItemTypeItems::CollexionV2 => "COLLEXION_V2",
                EmbedClientItemTypeItems::ComedyClub => "COMEDY_CLUB",
                EmbedClientItemTypeItems::ComedyEvent => "COMEDY_EVENT",
                EmbedClientItemTypeItems::Comment => "COMMENT",
                EmbedClientItemTypeItems::CommentActionV2 => "COMMENT_ACTION_V2",
                EmbedClientItemTypeItems::CommentV2 => "COMMENT_V2",
                EmbedClientItemTypeItems::CommunicateActionV2 => "COMMUNICATE_ACTION_V2",
                EmbedClientItemTypeItems::ComputerStore => "COMPUTER_STORE",
                EmbedClientItemTypeItems::ConsumeActionV2 => "CONSUME_ACTION_V2",
                EmbedClientItemTypeItems::ContactPage => "CONTACT_PAGE",
                EmbedClientItemTypeItems::ContactPoint => "CONTACT_POINT",
                EmbedClientItemTypeItems::Continent => "CONTINENT",
                EmbedClientItemTypeItems::ConvenienceStore => "CONVENIENCE_STORE",
                EmbedClientItemTypeItems::Corporation => "CORPORATION",
                EmbedClientItemTypeItems::Country => "COUNTRY",
                EmbedClientItemTypeItems::Courthouse => "COURTHOUSE",
                EmbedClientItemTypeItems::CreateActionV2 => "CREATE_ACTION_V2",
                EmbedClientItemTypeItems::CreativeWork => "CREATIVE_WORK",
                EmbedClientItemTypeItems::CreativeWorkV2 => "CREATIVE_WORK_V2",
                EmbedClientItemTypeItems::Crematorium => "CREMATORIUM",
                EmbedClientItemTypeItems::DanceEvent => "DANCE_EVENT",
                EmbedClientItemTypeItems::Date => "DATE",
                EmbedClientItemTypeItems::DaySpa => "DAY_SPA",
                EmbedClientItemTypeItems::DefenceEstablishment => "DEFENCE_ESTABLISHMENT",
                EmbedClientItemTypeItems::Dentist => "DENTIST",
                EmbedClientItemTypeItems::DepartmentStore => "DEPARTMENT_STORE",
                EmbedClientItemTypeItems::DeprecatedTourObject => "DEPRECATED_TOUR_OBJECT",
                EmbedClientItemTypeItems::DeprecatedTourObjectV2 => "DEPRECATED_TOUR_OBJECT_V2",
                EmbedClientItemTypeItems::DiscoverActionV2 => "DISCOVER_ACTION_V2",
                EmbedClientItemTypeItems::Distance => "DISTANCE",
                EmbedClientItemTypeItems::DocumentObject => "DOCUMENT_OBJECT",
                EmbedClientItemTypeItems::DocumentObjectV2 => "DOCUMENT_OBJECT_V2",
                EmbedClientItemTypeItems::DrawingObject => "DRAWING_OBJECT",
                EmbedClientItemTypeItems::DrawingObjectV2 => "DRAWING_OBJECT_V2",
                EmbedClientItemTypeItems::DriveObjectCollection => "DRIVE_OBJECT_COLLECTION",
                EmbedClientItemTypeItems::DriveObjectV2 => "DRIVE_OBJECT_V2",
                EmbedClientItemTypeItems::DryCleaningOrLaundry => "DRY_CLEANING_OR_LAUNDRY",
                EmbedClientItemTypeItems::Duration => "DURATION",
                EmbedClientItemTypeItems::DynamiteAttachmentMetadata => {
                    "DYNAMITE_ATTACHMENT_METADATA"
                }
                EmbedClientItemTypeItems::DynamiteMessageMetadata => "DYNAMITE_MESSAGE_METADATA",
                EmbedClientItemTypeItems::EducationEvent => "EDUCATION_EVENT",
                EmbedClientItemTypeItems::EducationalOrganization => "EDUCATIONAL_ORGANIZATION",
                EmbedClientItemTypeItems::Electrician => "ELECTRICIAN",
                EmbedClientItemTypeItems::ElectronicsStore => "ELECTRONICS_STORE",
                EmbedClientItemTypeItems::ElementarySchool => "ELEMENTARY_SCHOOL",
                EmbedClientItemTypeItems::Embassy => "EMBASSY",
                EmbedClientItemTypeItems::EmergencyService => "EMERGENCY_SERVICE",
                EmbedClientItemTypeItems::Emotishare => "EMOTISHARE",
                EmbedClientItemTypeItems::EmotishareV2 => "EMOTISHARE_V2",
                EmbedClientItemTypeItems::EmploymentAgengy => "EMPLOYMENT_AGENGY",
                EmbedClientItemTypeItems::Energy => "ENERGY",
                EmbedClientItemTypeItems::EntertainmentBusiness => "ENTERTAINMENT_BUSINESS",
                EmbedClientItemTypeItems::EntryPointV2 => "ENTRY_POINT_V2",
                EmbedClientItemTypeItems::Enumeration => "ENUMERATION",
                EmbedClientItemTypeItems::Event => "EVENT",
                EmbedClientItemTypeItems::EventTimeV2 => "EVENT_TIME_V2",
                EmbedClientItemTypeItems::EventV2 => "EVENT_V2",
                EmbedClientItemTypeItems::EventVenue => "EVENT_VENUE",
                EmbedClientItemTypeItems::ExampleObject => "EXAMPLE_OBJECT",
                EmbedClientItemTypeItems::ExerciseGym => "EXERCISE_GYM",
                EmbedClientItemTypeItems::FastFoodRestaurant => "FAST_FOOD_RESTAURANT",
                EmbedClientItemTypeItems::Festival => "FESTIVAL",
                EmbedClientItemTypeItems::FileObject => "FILE_OBJECT",
                EmbedClientItemTypeItems::FileObjectV2 => "FILE_OBJECT_V2",
                EmbedClientItemTypeItems::FinancialQuote => "FINANCIAL_QUOTE",
                EmbedClientItemTypeItems::FinancialQuoteV2 => "FINANCIAL_QUOTE_V2",
                EmbedClientItemTypeItems::FinancialService => "FINANCIAL_SERVICE",
                EmbedClientItemTypeItems::FindActionV2 => "FIND_ACTION_V2",
                EmbedClientItemTypeItems::FireStation => "FIRE_STATION",
                EmbedClientItemTypeItems::Florist => "FLORIST",
                EmbedClientItemTypeItems::FoodEstablishment => "FOOD_ESTABLISHMENT",
                EmbedClientItemTypeItems::FoodEvent => "FOOD_EVENT",
                EmbedClientItemTypeItems::FormObject => "FORM_OBJECT",
                EmbedClientItemTypeItems::FormObjectV2 => "FORM_OBJECT_V2",
                EmbedClientItemTypeItems::FurnitureStore => "FURNITURE_STORE",
                EmbedClientItemTypeItems::GardenStore => "GARDEN_STORE",
                EmbedClientItemTypeItems::GasStation => "GAS_STATION",
                EmbedClientItemTypeItems::GatedResidenceCommunity => "GATED_RESIDENCE_COMMUNITY",
                EmbedClientItemTypeItems::GeneralContractor => "GENERAL_CONTRACTOR",
                EmbedClientItemTypeItems::GeoCoordinates => "GEO_COORDINATES",
                EmbedClientItemTypeItems::GeoCoordinatesV2 => "GEO_COORDINATES_V2",
                EmbedClientItemTypeItems::GeoShape => "GEO_SHAPE",
                EmbedClientItemTypeItems::GolfCourse => "GOLF_COURSE",
                EmbedClientItemTypeItems::GoogleChart => "GOOGLE_CHART",
                EmbedClientItemTypeItems::GoogleOfferV2 => "GOOGLE_OFFER_V2",
                EmbedClientItemTypeItems::GooglePhotoRecipe => "GOOGLE_PHOTO_RECIPE",
                EmbedClientItemTypeItems::GoogleUserPhotoAlbum => "GOOGLE_USER_PHOTO_ALBUM",
                EmbedClientItemTypeItems::GoogleUserPhotoV2 => "GOOGLE_USER_PHOTO_V2",
                EmbedClientItemTypeItems::GovernmentBuilding => "GOVERNMENT_BUILDING",
                EmbedClientItemTypeItems::GovernmentOffice => "GOVERNMENT_OFFICE",
                EmbedClientItemTypeItems::GovernmentOrganization => "GOVERNMENT_ORGANIZATION",
                EmbedClientItemTypeItems::GroceryStore => "GROCERY_STORE",
                EmbedClientItemTypeItems::HairSalon => "HAIR_SALON",
                EmbedClientItemTypeItems::Hangout => "HANGOUT",
                EmbedClientItemTypeItems::HangoutBroadcast => "HANGOUT_BROADCAST",
                EmbedClientItemTypeItems::HangoutChatMessage => "HANGOUT_CHAT_MESSAGE",
                EmbedClientItemTypeItems::HangoutConsumer => "HANGOUT_CONSUMER",
                EmbedClientItemTypeItems::HangoutQuote => "HANGOUT_QUOTE",
                EmbedClientItemTypeItems::HangoutV2 => "HANGOUT_V2",
                EmbedClientItemTypeItems::HardwareStore => "HARDWARE_STORE",
                EmbedClientItemTypeItems::HealthAndBeautyBusiness => "HEALTH_AND_BEAUTY_BUSINESS",
                EmbedClientItemTypeItems::HealthClub => "HEALTH_CLUB",
                EmbedClientItemTypeItems::HighSchool => "HIGH_SCHOOL",
                EmbedClientItemTypeItems::HinduTemple => "HINDU_TEMPLE",
                EmbedClientItemTypeItems::HoaPlusEventV2 => "HOA_PLUS_EVENT_V2",
                EmbedClientItemTypeItems::HobbyShop => "HOBBY_SHOP",
                EmbedClientItemTypeItems::HomeAndConstructionBusiness => {
                    "HOME_AND_CONSTRUCTION_BUSINESS"
                }
                EmbedClientItemTypeItems::HomeGoodsStore => "HOME_GOODS_STORE",
                EmbedClientItemTypeItems::Hospital => "HOSPITAL",
                EmbedClientItemTypeItems::Hostel => "HOSTEL",
                EmbedClientItemTypeItems::Hotel => "HOTEL",
                EmbedClientItemTypeItems::HousePainter => "HOUSE_PAINTER",
                EmbedClientItemTypeItems::HvacBusiness => "HVAC_BUSINESS",
                EmbedClientItemTypeItems::IceCreamShop => "ICE_CREAM_SHOP",
                EmbedClientItemTypeItems::ImageGallery => "IMAGE_GALLERY",
                EmbedClientItemTypeItems::ImageObject => "IMAGE_OBJECT",
                EmbedClientItemTypeItems::ImageObjectV2 => "IMAGE_OBJECT_V2",
                EmbedClientItemTypeItems::InsuranceAgency => "INSURANCE_AGENCY",
                EmbedClientItemTypeItems::Intangible => "INTANGIBLE",
                EmbedClientItemTypeItems::InteractActionV2 => "INTERACT_ACTION_V2",
                EmbedClientItemTypeItems::InteractionV2 => "INTERACTION_V2",
                EmbedClientItemTypeItems::InternetCafe => "INTERNET_CAFE",
                EmbedClientItemTypeItems::ItemAvailability => "ITEM_AVAILABILITY",
                EmbedClientItemTypeItems::ItemList => "ITEM_LIST",
                EmbedClientItemTypeItems::ItemPage => "ITEM_PAGE",
                EmbedClientItemTypeItems::JewelryStore => "JEWELRY_STORE",
                EmbedClientItemTypeItems::JobPosting => "JOB_POSTING",
                EmbedClientItemTypeItems::LakeBodyOfWater => "LAKE_BODY_OF_WATER",
                EmbedClientItemTypeItems::Landform => "LANDFORM",
                EmbedClientItemTypeItems::LandmarksOrHistoricalBuildings => {
                    "LANDMARKS_OR_HISTORICAL_BUILDINGS"
                }
                EmbedClientItemTypeItems::Language => "LANGUAGE",
                EmbedClientItemTypeItems::LegislativeBuilding => "LEGISLATIVE_BUILDING",
                EmbedClientItemTypeItems::Library => "LIBRARY",
                EmbedClientItemTypeItems::LiquorStore => "LIQUOR_STORE",
                EmbedClientItemTypeItems::ListenActionV2 => "LISTEN_ACTION_V2",
                EmbedClientItemTypeItems::LiteraryEvent => "LITERARY_EVENT",
                EmbedClientItemTypeItems::LocalBusiness => "LOCAL_BUSINESS",
                EmbedClientItemTypeItems::LocalBusinessV2 => "LOCAL_BUSINESS_V2",
                EmbedClientItemTypeItems::LocalPlusPhotoAlbum => "LOCAL_PLUS_PHOTO_ALBUM",
                EmbedClientItemTypeItems::LocalPlusPhotoAlbumV2 => "LOCAL_PLUS_PHOTO_ALBUM_V2",
                EmbedClientItemTypeItems::Locksmith => "LOCKSMITH",
                EmbedClientItemTypeItems::LodgingBusiness => "LODGING_BUSINESS",
                EmbedClientItemTypeItems::Magazine => "MAGAZINE",
                EmbedClientItemTypeItems::MagazineV2 => "MAGAZINE_V2",
                EmbedClientItemTypeItems::Map => "MAP",
                EmbedClientItemTypeItems::Mass => "MASS",
                EmbedClientItemTypeItems::MediaObject => "MEDIA_OBJECT",
                EmbedClientItemTypeItems::MediaObjectV2 => "MEDIA_OBJECT_V2",
                EmbedClientItemTypeItems::MedicalClinic => "MEDICAL_CLINIC",
                EmbedClientItemTypeItems::MedicalOrganization => "MEDICAL_ORGANIZATION",
                EmbedClientItemTypeItems::MensClothingStore => "MENS_CLOTHING_STORE",
                EmbedClientItemTypeItems::MiddleSchool => "MIDDLE_SCHOOL",
                EmbedClientItemTypeItems::MobileApplication => "MOBILE_APPLICATION",
                EmbedClientItemTypeItems::MobileApplicationV2 => "MOBILE_APPLICATION_V2",
                EmbedClientItemTypeItems::MobilePhoneStore => "MOBILE_PHONE_STORE",
                EmbedClientItemTypeItems::Mosque => "MOSQUE",
                EmbedClientItemTypeItems::Motel => "MOTEL",
                EmbedClientItemTypeItems::MotorcycleDealer => "MOTORCYCLE_DEALER",
                EmbedClientItemTypeItems::MotorcycleRepair => "MOTORCYCLE_REPAIR",
                EmbedClientItemTypeItems::Mountain => "MOUNTAIN",
                EmbedClientItemTypeItems::Movie => "MOVIE",
                EmbedClientItemTypeItems::MovieRentalStore => "MOVIE_RENTAL_STORE",
                EmbedClientItemTypeItems::MovieTheater => "MOVIE_THEATER",
                EmbedClientItemTypeItems::MovieV2 => "MOVIE_V2",
                EmbedClientItemTypeItems::MovingCompany => "MOVING_COMPANY",
                EmbedClientItemTypeItems::Museum => "MUSEUM",
                EmbedClientItemTypeItems::MusicAlbum => "MUSIC_ALBUM",
                EmbedClientItemTypeItems::MusicAlbumV2 => "MUSIC_ALBUM_V2",
                EmbedClientItemTypeItems::MusicEvent => "MUSIC_EVENT",
                EmbedClientItemTypeItems::MusicGroup => "MUSIC_GROUP",
                EmbedClientItemTypeItems::MusicGroupV2 => "MUSIC_GROUP_V2",
                EmbedClientItemTypeItems::MusicPlaylist => "MUSIC_PLAYLIST",
                EmbedClientItemTypeItems::MusicPlaylistV2 => "MUSIC_PLAYLIST_V2",
                EmbedClientItemTypeItems::MusicRecording => "MUSIC_RECORDING",
                EmbedClientItemTypeItems::MusicRecordingV2 => "MUSIC_RECORDING_V2",
                EmbedClientItemTypeItems::MusicStore => "MUSIC_STORE",
                EmbedClientItemTypeItems::MusicVenue => "MUSIC_VENUE",
                EmbedClientItemTypeItems::MusicVideoObject => "MUSIC_VIDEO_OBJECT",
                EmbedClientItemTypeItems::NailSalon => "NAIL_SALON",
                EmbedClientItemTypeItems::NewsArticle => "NEWS_ARTICLE",
                EmbedClientItemTypeItems::NewsArticleV2 => "NEWS_ARTICLE_V2",
                EmbedClientItemTypeItems::NewsMediaOrganization => "NEWS_MEDIA_ORGANIZATION",
                EmbedClientItemTypeItems::NightClub => "NIGHT_CLUB",
                EmbedClientItemTypeItems::Notary => "NOTARY",
                EmbedClientItemTypeItems::NutritionInformation => "NUTRITION_INFORMATION",
                EmbedClientItemTypeItems::OceanBodyOfWater => "OCEAN_BODY_OF_WATER",
                EmbedClientItemTypeItems::Offer => "OFFER",
                EmbedClientItemTypeItems::OfferItemCondition => "OFFER_ITEM_CONDITION",
                EmbedClientItemTypeItems::OfferV2 => "OFFER_V2",
                EmbedClientItemTypeItems::OfficeEquipmentStore => "OFFICE_EQUIPMENT_STORE",
                EmbedClientItemTypeItems::Optician => "OPTICIAN",
                EmbedClientItemTypeItems::Organization => "ORGANIZATION",
                EmbedClientItemTypeItems::OrganizationV2 => "ORGANIZATION_V2",
                EmbedClientItemTypeItems::OrganizeActionV2 => "ORGANIZE_ACTION_V2",
                EmbedClientItemTypeItems::OutletStore => "OUTLET_STORE",
                EmbedClientItemTypeItems::Painting => "PAINTING",
                EmbedClientItemTypeItems::Park => "PARK",
                EmbedClientItemTypeItems::ParkingFacility => "PARKING_FACILITY",
                EmbedClientItemTypeItems::PawnShop => "PAWN_SHOP",
                EmbedClientItemTypeItems::PerformingArtsTheater => "PERFORMING_ARTS_THEATER",
                EmbedClientItemTypeItems::PerformingGroup => "PERFORMING_GROUP",
                EmbedClientItemTypeItems::Person => "PERSON",
                EmbedClientItemTypeItems::PersonV2 => "PERSON_V2",
                EmbedClientItemTypeItems::PetStore => "PET_STORE",
                EmbedClientItemTypeItems::Pharmacy => "PHARMACY",
                EmbedClientItemTypeItems::Photograph => "PHOTOGRAPH",
                EmbedClientItemTypeItems::Physician => "PHYSICIAN",
                EmbedClientItemTypeItems::Place => "PLACE",
                EmbedClientItemTypeItems::PlaceOfWorship => "PLACE_OF_WORSHIP",
                EmbedClientItemTypeItems::PlaceReview => "PLACE_REVIEW",
                EmbedClientItemTypeItems::PlaceReviewV2 => "PLACE_REVIEW_V2",
                EmbedClientItemTypeItems::PlaceV2 => "PLACE_V2",
                EmbedClientItemTypeItems::PlanActionV2 => "PLAN_ACTION_V2",
                EmbedClientItemTypeItems::PlayMusicAlbum => "PLAY_MUSIC_ALBUM",
                EmbedClientItemTypeItems::PlayMusicAlbumV2 => "PLAY_MUSIC_ALBUM_V2",
                EmbedClientItemTypeItems::PlayMusicTrack => "PLAY_MUSIC_TRACK",
                EmbedClientItemTypeItems::PlayMusicTrackV2 => "PLAY_MUSIC_TRACK_V2",
                EmbedClientItemTypeItems::PlayObjectV2 => "PLAY_OBJECT_V2",
                EmbedClientItemTypeItems::Playground => "PLAYGROUND",
                EmbedClientItemTypeItems::Plumber => "PLUMBER",
                EmbedClientItemTypeItems::PlusAudioV2 => "PLUS_AUDIO_V2",
                EmbedClientItemTypeItems::PlusEvent => "PLUS_EVENT",
                EmbedClientItemTypeItems::PlusEventV2 => "PLUS_EVENT_V2",
                EmbedClientItemTypeItems::PlusMediaCollectionV2 => "PLUS_MEDIA_COLLECTION_V2",
                EmbedClientItemTypeItems::PlusMediaObjectV2 => "PLUS_MEDIA_OBJECT_V2",
                EmbedClientItemTypeItems::PlusPage => "PLUS_PAGE",
                EmbedClientItemTypeItems::PlusPageV2 => "PLUS_PAGE_V2",
                EmbedClientItemTypeItems::PlusPhoto => "PLUS_PHOTO",
                EmbedClientItemTypeItems::PlusPhotoAlbum => "PLUS_PHOTO_ALBUM",
                EmbedClientItemTypeItems::PlusPhotoAlbumV2 => "PLUS_PHOTO_ALBUM_V2",
                EmbedClientItemTypeItems::PlusPhotoCollectionV2 => "PLUS_PHOTO_COLLECTION_V2",
                EmbedClientItemTypeItems::PlusPhotoV2 => "PLUS_PHOTO_V2",
                EmbedClientItemTypeItems::PlusPhotosAddedToCollection => {
                    "PLUS_PHOTOS_ADDED_TO_COLLECTION"
                }
                EmbedClientItemTypeItems::PlusPhotosAddedToCollectionV2 => {
                    "PLUS_PHOTOS_ADDED_TO_COLLECTION_V2"
                }
                EmbedClientItemTypeItems::PlusPost => "PLUS_POST",
                EmbedClientItemTypeItems::PlusPostV2 => "PLUS_POST_V2",
                EmbedClientItemTypeItems::PlusReshareV2 => "PLUS_RESHARE_V2",
                EmbedClientItemTypeItems::PlusSoftwareApplicationV2 => {
                    "PLUS_SOFTWARE_APPLICATION_V2"
                }
                EmbedClientItemTypeItems::PoliceStation => "POLICE_STATION",
                EmbedClientItemTypeItems::PollOptionV2 => "POLL_OPTION_V2",
                EmbedClientItemTypeItems::PollV2 => "POLL_V2",
                EmbedClientItemTypeItems::Pond => "POND",
                EmbedClientItemTypeItems::PostOffice => "POST_OFFICE",
                EmbedClientItemTypeItems::PostalAddress => "POSTAL_ADDRESS",
                EmbedClientItemTypeItems::PostalAddressV2 => "POSTAL_ADDRESS_V2",
                EmbedClientItemTypeItems::Preschool => "PRESCHOOL",
                EmbedClientItemTypeItems::PresentationObject => "PRESENTATION_OBJECT",
                EmbedClientItemTypeItems::PresentationObjectV2 => "PRESENTATION_OBJECT_V2",
                EmbedClientItemTypeItems::Product => "PRODUCT",
                EmbedClientItemTypeItems::ProductReview => "PRODUCT_REVIEW",
                EmbedClientItemTypeItems::ProductReviewV2 => "PRODUCT_REVIEW_V2",
                EmbedClientItemTypeItems::ProfessionalService => "PROFESSIONAL_SERVICE",
                EmbedClientItemTypeItems::ProfilePage => "PROFILE_PAGE",
                EmbedClientItemTypeItems::PublicSwimmingPool => "PUBLIC_SWIMMING_POOL",
                EmbedClientItemTypeItems::Quantity => "QUANTITY",
                EmbedClientItemTypeItems::RVPark => "R_V_PARK",
                EmbedClientItemTypeItems::RadioStation => "RADIO_STATION",
                EmbedClientItemTypeItems::Rating => "RATING",
                EmbedClientItemTypeItems::RatingV2 => "RATING_V2",
                EmbedClientItemTypeItems::ReactActionV2 => "REACT_ACTION_V2",
                EmbedClientItemTypeItems::RealEstateAgent => "REAL_ESTATE_AGENT",
                EmbedClientItemTypeItems::Recipe => "RECIPE",
                EmbedClientItemTypeItems::RecommendedPeople => "RECOMMENDED_PEOPLE",
                EmbedClientItemTypeItems::RecyclingCenter => "RECYCLING_CENTER",
                EmbedClientItemTypeItems::Reservation => "RESERVATION",
                EmbedClientItemTypeItems::ReservationV2 => "RESERVATION_V2",
                EmbedClientItemTypeItems::ReserveActionV2 => "RESERVE_ACTION_V2",
                EmbedClientItemTypeItems::Reservoir => "RESERVOIR",
                EmbedClientItemTypeItems::Residence => "RESIDENCE",
                EmbedClientItemTypeItems::Restaurant => "RESTAURANT",
                EmbedClientItemTypeItems::Review => "REVIEW",
                EmbedClientItemTypeItems::ReviewActionV2 => "REVIEW_ACTION_V2",
                EmbedClientItemTypeItems::ReviewV2 => "REVIEW_V2",
                EmbedClientItemTypeItems::RiverBodyOfWater => "RIVER_BODY_OF_WATER",
                EmbedClientItemTypeItems::RoofingContractor => "ROOFING_CONTRACTOR",
                EmbedClientItemTypeItems::SaleEvent => "SALE_EVENT",
                EmbedClientItemTypeItems::ScholarlyArticle => "SCHOLARLY_ARTICLE",
                EmbedClientItemTypeItems::School => "SCHOOL",
                EmbedClientItemTypeItems::Sculpture => "SCULPTURE",
                EmbedClientItemTypeItems::SeaBodyOfWater => "SEA_BODY_OF_WATER",
                EmbedClientItemTypeItems::SearchResultsPage => "SEARCH_RESULTS_PAGE",
                EmbedClientItemTypeItems::SelfStorage => "SELF_STORAGE",
                EmbedClientItemTypeItems::ShoeStore => "SHOE_STORE",
                EmbedClientItemTypeItems::ShoppingCenter => "SHOPPING_CENTER",
                EmbedClientItemTypeItems::SingleFamilyResidence => "SINGLE_FAMILY_RESIDENCE",
                EmbedClientItemTypeItems::SiteNavigationElement => "SITE_NAVIGATION_ELEMENT",
                EmbedClientItemTypeItems::SkiResort => "SKI_RESORT",
                EmbedClientItemTypeItems::SocialEvent => "SOCIAL_EVENT",
                EmbedClientItemTypeItems::SoftwareApplication => "SOFTWARE_APPLICATION",
                EmbedClientItemTypeItems::SoftwareApplicationV2 => "SOFTWARE_APPLICATION_V2",
                EmbedClientItemTypeItems::SportingGoodsStore => "SPORTING_GOODS_STORE",
                EmbedClientItemTypeItems::SportsActivityLocation => "SPORTS_ACTIVITY_LOCATION",
                EmbedClientItemTypeItems::SportsClub => "SPORTS_CLUB",
                EmbedClientItemTypeItems::SportsEvent => "SPORTS_EVENT",
                EmbedClientItemTypeItems::SpreadsheetObject => "SPREADSHEET_OBJECT",
                EmbedClientItemTypeItems::SpreadsheetObjectV2 => "SPREADSHEET_OBJECT_V2",
                EmbedClientItemTypeItems::Square => "SQUARE",
                EmbedClientItemTypeItems::SquareInvite => "SQUARE_INVITE",
                EmbedClientItemTypeItems::SquareInviteV2 => "SQUARE_INVITE_V2",
                EmbedClientItemTypeItems::SquareV2 => "SQUARE_V2",
                EmbedClientItemTypeItems::StadiumOrArena => "STADIUM_OR_ARENA",
                EmbedClientItemTypeItems::State => "STATE",
                EmbedClientItemTypeItems::StickerV2 => "STICKER_V2",
                EmbedClientItemTypeItems::Store => "STORE",
                EmbedClientItemTypeItems::StoryV2 => "STORY_V2",
                EmbedClientItemTypeItems::StructuredValue => "STRUCTURED_VALUE",
                EmbedClientItemTypeItems::SubwayStation => "SUBWAY_STATION",
                EmbedClientItemTypeItems::Synagogue => "SYNAGOGUE",
                EmbedClientItemTypeItems::Table => "TABLE",
                EmbedClientItemTypeItems::TattooParlor => "TATTOO_PARLOR",
                EmbedClientItemTypeItems::TaxiStand => "TAXI_STAND",
                EmbedClientItemTypeItems::TelevisionStation => "TELEVISION_STATION",
                EmbedClientItemTypeItems::TennisComplex => "TENNIS_COMPLEX",
                EmbedClientItemTypeItems::TheaterEvent => "THEATER_EVENT",
                EmbedClientItemTypeItems::Thing => "THING",
                EmbedClientItemTypeItems::ThingV2 => "THING_V2",
                EmbedClientItemTypeItems::TireShop => "TIRE_SHOP",
                EmbedClientItemTypeItems::TouristAttraction => "TOURIST_ATTRACTION",
                EmbedClientItemTypeItems::TouristInformationCenter => "TOURIST_INFORMATION_CENTER",
                EmbedClientItemTypeItems::ToyStore => "TOY_STORE",
                EmbedClientItemTypeItems::TradeActionV2 => "TRADE_ACTION_V2",
                EmbedClientItemTypeItems::TrainStation => "TRAIN_STATION",
                EmbedClientItemTypeItems::TravelAgency => "TRAVEL_AGENCY",
                EmbedClientItemTypeItems::TravelEvent => "TRAVEL_EVENT",
                EmbedClientItemTypeItems::TvEpisode => "TV_EPISODE",
                EmbedClientItemTypeItems::TvEpisodeV2 => "TV_EPISODE_V2",
                EmbedClientItemTypeItems::TvSeason => "TV_SEASON",
                EmbedClientItemTypeItems::TvSeries => "TV_SERIES",
                EmbedClientItemTypeItems::TvSeriesV2 => "TV_SERIES_V2",
                EmbedClientItemTypeItems::Unknown => "UNKNOWN",
                EmbedClientItemTypeItems::UpdateActionV2 => "UPDATE_ACTION_V2",
                EmbedClientItemTypeItems::UserInteraction => "USER_INTERACTION",
                EmbedClientItemTypeItems::UserPlusOnes => "USER_PLUS_ONES",
                EmbedClientItemTypeItems::VeterinaryCare => "VETERINARY_CARE",
                EmbedClientItemTypeItems::VideoGallery => "VIDEO_GALLERY",
                EmbedClientItemTypeItems::VideoGalleryV2 => "VIDEO_GALLERY_V2",
                EmbedClientItemTypeItems::VideoObject => "VIDEO_OBJECT",
                EmbedClientItemTypeItems::VideoObjectV2 => "VIDEO_OBJECT_V2",
                EmbedClientItemTypeItems::ViewActionV2 => "VIEW_ACTION_V2",
                EmbedClientItemTypeItems::VisualArtsEvent => "VISUAL_ARTS_EVENT",
                EmbedClientItemTypeItems::Volcano => "VOLCANO",
                EmbedClientItemTypeItems::WantActionV2 => "WANT_ACTION_V2",
                EmbedClientItemTypeItems::Waterfall => "WATERFALL",
                EmbedClientItemTypeItems::WebApplication => "WEB_APPLICATION",
                EmbedClientItemTypeItems::WebPage => "WEB_PAGE",
                EmbedClientItemTypeItems::WebPageElement => "WEB_PAGE_ELEMENT",
                EmbedClientItemTypeItems::WebPageV2 => "WEB_PAGE_V2",
                EmbedClientItemTypeItems::WholesaleStore => "WHOLESALE_STORE",
                EmbedClientItemTypeItems::Winery => "WINERY",
                EmbedClientItemTypeItems::WpAdBlock => "WP_AD_BLOCK",
                EmbedClientItemTypeItems::WpFooter => "WP_FOOTER",
                EmbedClientItemTypeItems::WpHeader => "WP_HEADER",
                EmbedClientItemTypeItems::WpSidebar => "WP_SIDEBAR",
                EmbedClientItemTypeItems::WriteActionV2 => "WRITE_ACTION_V2",
                EmbedClientItemTypeItems::YoutubeChannelV2 => "YOUTUBE_CHANNEL_V2",
                EmbedClientItemTypeItems::Zoo => "ZOO",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EmbedClientItemTypeItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EmbedClientItemTypeItems {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<EmbedClientItemTypeItems, ()> {
            Ok(match s {
                "ABOUT_PAGE" => EmbedClientItemTypeItems::AboutPage,
                "ACCOUNTING_SERVICE" => EmbedClientItemTypeItems::AccountingService,
                "ACTION_V2" => EmbedClientItemTypeItems::ActionV2,
                "ADD_ACTION_V2" => EmbedClientItemTypeItems::AddActionV2,
                "ADMINISTRATIVE_AREA" => EmbedClientItemTypeItems::AdministrativeArea,
                "ADULT_ENTERTAINMENT" => EmbedClientItemTypeItems::AdultEntertainment,
                "AGGREGATE_RATING" => EmbedClientItemTypeItems::AggregateRating,
                "AGGREGATE_RATING_V2" => EmbedClientItemTypeItems::AggregateRatingV2,
                "AIRPORT" => EmbedClientItemTypeItems::Airport,
                "AMUSEMENT_PARK" => EmbedClientItemTypeItems::AmusementPark,
                "ANIMAL_SHELTER" => EmbedClientItemTypeItems::AnimalShelter,
                "APARTMENT_COMPLEX" => EmbedClientItemTypeItems::ApartmentComplex,
                "APP_INVITE" => EmbedClientItemTypeItems::AppInvite,
                "AQUARIUM" => EmbedClientItemTypeItems::Aquarium,
                "ART_GALLERY" => EmbedClientItemTypeItems::ArtGallery,
                "ARTICLE" => EmbedClientItemTypeItems::Article,
                "ARTICLE_V2" => EmbedClientItemTypeItems::ArticleV2,
                "ASSESS_ACTION_V2" => EmbedClientItemTypeItems::AssessActionV2,
                "ATTORNEY" => EmbedClientItemTypeItems::Attorney,
                "AUDIO_OBJECT" => EmbedClientItemTypeItems::AudioObject,
                "AUDIO_OBJECT_V2" => EmbedClientItemTypeItems::AudioObjectV2,
                "AUTO_BODY_SHOP" => EmbedClientItemTypeItems::AutoBodyShop,
                "AUTO_DEALER" => EmbedClientItemTypeItems::AutoDealer,
                "AUTO_PARTS_STORE" => EmbedClientItemTypeItems::AutoPartsStore,
                "AUTO_RENTAL" => EmbedClientItemTypeItems::AutoRental,
                "AUTO_REPAIR" => EmbedClientItemTypeItems::AutoRepair,
                "AUTO_WASH" => EmbedClientItemTypeItems::AutoWash,
                "AUTOMATED_TELLER" => EmbedClientItemTypeItems::AutomatedTeller,
                "AUTOMOTIVE_BUSINESS" => EmbedClientItemTypeItems::AutomotiveBusiness,
                "BAKERY" => EmbedClientItemTypeItems::Bakery,
                "BANK_OR_CREDIT_UNION" => EmbedClientItemTypeItems::BankOrCreditUnion,
                "BAR_OR_PUB" => EmbedClientItemTypeItems::BarOrPub,
                "BASIC_INTERACTION_V2" => EmbedClientItemTypeItems::BasicInteractionV2,
                "BEACH" => EmbedClientItemTypeItems::Beach,
                "BEAUTY_SALON" => EmbedClientItemTypeItems::BeautySalon,
                "BED_AND_BREAKFAST" => EmbedClientItemTypeItems::BedAndBreakfast,
                "BIKE_STORE" => EmbedClientItemTypeItems::BikeStore,
                "BLOG" => EmbedClientItemTypeItems::Blog,
                "BLOG_POSTING" => EmbedClientItemTypeItems::BlogPosting,
                "BLOG_POSTING_V2" => EmbedClientItemTypeItems::BlogPostingV2,
                "BLOG_V2" => EmbedClientItemTypeItems::BlogV2,
                "BODY_OF_WATER" => EmbedClientItemTypeItems::BodyOfWater,
                "BOOK" => EmbedClientItemTypeItems::Book,
                "BOOK_FORMAT_TYPE" => EmbedClientItemTypeItems::BookFormatType,
                "BOOK_STORE" => EmbedClientItemTypeItems::BookStore,
                "BOOK_V2" => EmbedClientItemTypeItems::BookV2,
                "BOWLING_ALLEY" => EmbedClientItemTypeItems::BowlingAlley,
                "BREWERY" => EmbedClientItemTypeItems::Brewery,
                "BUDDHIST_TEMPLE" => EmbedClientItemTypeItems::BuddhistTemple,
                "BUS_STATION" => EmbedClientItemTypeItems::BusStation,
                "BUS_STOP" => EmbedClientItemTypeItems::BusStop,
                "BUSINESS_EVENT" => EmbedClientItemTypeItems::BusinessEvent,
                "BUY_ACTION_V2" => EmbedClientItemTypeItems::BuyActionV2,
                "CAFE_OR_COFFEE_SHOP" => EmbedClientItemTypeItems::CafeOrCoffeeShop,
                "CAMPGROUND" => EmbedClientItemTypeItems::Campground,
                "CANAL" => EmbedClientItemTypeItems::Canal,
                "CAROUSEL_FRAME" => EmbedClientItemTypeItems::CarouselFrame,
                "CASINO" => EmbedClientItemTypeItems::Casino,
                "CATHOLIC_CHURCH" => EmbedClientItemTypeItems::CatholicChurch,
                "CEMETERY" => EmbedClientItemTypeItems::Cemetery,
                "CHECK_IN_ACTION_V2" => EmbedClientItemTypeItems::CheckInActionV2,
                "CHECKIN" => EmbedClientItemTypeItems::Checkin,
                "CHECKIN_V2" => EmbedClientItemTypeItems::CheckinV2,
                "CHECKOUT_PAGE" => EmbedClientItemTypeItems::CheckoutPage,
                "CHILD_CARE" => EmbedClientItemTypeItems::ChildCare,
                "CHILDRENS_EVENT" => EmbedClientItemTypeItems::ChildrensEvent,
                "CHURCH" => EmbedClientItemTypeItems::Church,
                "CITY" => EmbedClientItemTypeItems::City,
                "CITY_HALL" => EmbedClientItemTypeItems::CityHall,
                "CIVIC_STRUCTURE" => EmbedClientItemTypeItems::CivicStructure,
                "CLOTHING_STORE" => EmbedClientItemTypeItems::ClothingStore,
                "COLLECTION_PAGE" => EmbedClientItemTypeItems::CollectionPage,
                "COLLEGE_OR_UNIVERSITY" => EmbedClientItemTypeItems::CollegeOrUniversity,
                "COLLEXION_V2" => EmbedClientItemTypeItems::CollexionV2,
                "COMEDY_CLUB" => EmbedClientItemTypeItems::ComedyClub,
                "COMEDY_EVENT" => EmbedClientItemTypeItems::ComedyEvent,
                "COMMENT" => EmbedClientItemTypeItems::Comment,
                "COMMENT_ACTION_V2" => EmbedClientItemTypeItems::CommentActionV2,
                "COMMENT_V2" => EmbedClientItemTypeItems::CommentV2,
                "COMMUNICATE_ACTION_V2" => EmbedClientItemTypeItems::CommunicateActionV2,
                "COMPUTER_STORE" => EmbedClientItemTypeItems::ComputerStore,
                "CONSUME_ACTION_V2" => EmbedClientItemTypeItems::ConsumeActionV2,
                "CONTACT_PAGE" => EmbedClientItemTypeItems::ContactPage,
                "CONTACT_POINT" => EmbedClientItemTypeItems::ContactPoint,
                "CONTINENT" => EmbedClientItemTypeItems::Continent,
                "CONVENIENCE_STORE" => EmbedClientItemTypeItems::ConvenienceStore,
                "CORPORATION" => EmbedClientItemTypeItems::Corporation,
                "COUNTRY" => EmbedClientItemTypeItems::Country,
                "COURTHOUSE" => EmbedClientItemTypeItems::Courthouse,
                "CREATE_ACTION_V2" => EmbedClientItemTypeItems::CreateActionV2,
                "CREATIVE_WORK" => EmbedClientItemTypeItems::CreativeWork,
                "CREATIVE_WORK_V2" => EmbedClientItemTypeItems::CreativeWorkV2,
                "CREMATORIUM" => EmbedClientItemTypeItems::Crematorium,
                "DANCE_EVENT" => EmbedClientItemTypeItems::DanceEvent,
                "DATE" => EmbedClientItemTypeItems::Date,
                "DAY_SPA" => EmbedClientItemTypeItems::DaySpa,
                "DEFENCE_ESTABLISHMENT" => EmbedClientItemTypeItems::DefenceEstablishment,
                "DENTIST" => EmbedClientItemTypeItems::Dentist,
                "DEPARTMENT_STORE" => EmbedClientItemTypeItems::DepartmentStore,
                "DEPRECATED_TOUR_OBJECT" => EmbedClientItemTypeItems::DeprecatedTourObject,
                "DEPRECATED_TOUR_OBJECT_V2" => EmbedClientItemTypeItems::DeprecatedTourObjectV2,
                "DISCOVER_ACTION_V2" => EmbedClientItemTypeItems::DiscoverActionV2,
                "DISTANCE" => EmbedClientItemTypeItems::Distance,
                "DOCUMENT_OBJECT" => EmbedClientItemTypeItems::DocumentObject,
                "DOCUMENT_OBJECT_V2" => EmbedClientItemTypeItems::DocumentObjectV2,
                "DRAWING_OBJECT" => EmbedClientItemTypeItems::DrawingObject,
                "DRAWING_OBJECT_V2" => EmbedClientItemTypeItems::DrawingObjectV2,
                "DRIVE_OBJECT_COLLECTION" => EmbedClientItemTypeItems::DriveObjectCollection,
                "DRIVE_OBJECT_V2" => EmbedClientItemTypeItems::DriveObjectV2,
                "DRY_CLEANING_OR_LAUNDRY" => EmbedClientItemTypeItems::DryCleaningOrLaundry,
                "DURATION" => EmbedClientItemTypeItems::Duration,
                "DYNAMITE_ATTACHMENT_METADATA" => {
                    EmbedClientItemTypeItems::DynamiteAttachmentMetadata
                }
                "DYNAMITE_MESSAGE_METADATA" => EmbedClientItemTypeItems::DynamiteMessageMetadata,
                "EDUCATION_EVENT" => EmbedClientItemTypeItems::EducationEvent,
                "EDUCATIONAL_ORGANIZATION" => EmbedClientItemTypeItems::EducationalOrganization,
                "ELECTRICIAN" => EmbedClientItemTypeItems::Electrician,
                "ELECTRONICS_STORE" => EmbedClientItemTypeItems::ElectronicsStore,
                "ELEMENTARY_SCHOOL" => EmbedClientItemTypeItems::ElementarySchool,
                "EMBASSY" => EmbedClientItemTypeItems::Embassy,
                "EMERGENCY_SERVICE" => EmbedClientItemTypeItems::EmergencyService,
                "EMOTISHARE" => EmbedClientItemTypeItems::Emotishare,
                "EMOTISHARE_V2" => EmbedClientItemTypeItems::EmotishareV2,
                "EMPLOYMENT_AGENGY" => EmbedClientItemTypeItems::EmploymentAgengy,
                "ENERGY" => EmbedClientItemTypeItems::Energy,
                "ENTERTAINMENT_BUSINESS" => EmbedClientItemTypeItems::EntertainmentBusiness,
                "ENTRY_POINT_V2" => EmbedClientItemTypeItems::EntryPointV2,
                "ENUMERATION" => EmbedClientItemTypeItems::Enumeration,
                "EVENT" => EmbedClientItemTypeItems::Event,
                "EVENT_TIME_V2" => EmbedClientItemTypeItems::EventTimeV2,
                "EVENT_V2" => EmbedClientItemTypeItems::EventV2,
                "EVENT_VENUE" => EmbedClientItemTypeItems::EventVenue,
                "EXAMPLE_OBJECT" => EmbedClientItemTypeItems::ExampleObject,
                "EXERCISE_GYM" => EmbedClientItemTypeItems::ExerciseGym,
                "FAST_FOOD_RESTAURANT" => EmbedClientItemTypeItems::FastFoodRestaurant,
                "FESTIVAL" => EmbedClientItemTypeItems::Festival,
                "FILE_OBJECT" => EmbedClientItemTypeItems::FileObject,
                "FILE_OBJECT_V2" => EmbedClientItemTypeItems::FileObjectV2,
                "FINANCIAL_QUOTE" => EmbedClientItemTypeItems::FinancialQuote,
                "FINANCIAL_QUOTE_V2" => EmbedClientItemTypeItems::FinancialQuoteV2,
                "FINANCIAL_SERVICE" => EmbedClientItemTypeItems::FinancialService,
                "FIND_ACTION_V2" => EmbedClientItemTypeItems::FindActionV2,
                "FIRE_STATION" => EmbedClientItemTypeItems::FireStation,
                "FLORIST" => EmbedClientItemTypeItems::Florist,
                "FOOD_ESTABLISHMENT" => EmbedClientItemTypeItems::FoodEstablishment,
                "FOOD_EVENT" => EmbedClientItemTypeItems::FoodEvent,
                "FORM_OBJECT" => EmbedClientItemTypeItems::FormObject,
                "FORM_OBJECT_V2" => EmbedClientItemTypeItems::FormObjectV2,
                "FURNITURE_STORE" => EmbedClientItemTypeItems::FurnitureStore,
                "GARDEN_STORE" => EmbedClientItemTypeItems::GardenStore,
                "GAS_STATION" => EmbedClientItemTypeItems::GasStation,
                "GATED_RESIDENCE_COMMUNITY" => EmbedClientItemTypeItems::GatedResidenceCommunity,
                "GENERAL_CONTRACTOR" => EmbedClientItemTypeItems::GeneralContractor,
                "GEO_COORDINATES" => EmbedClientItemTypeItems::GeoCoordinates,
                "GEO_COORDINATES_V2" => EmbedClientItemTypeItems::GeoCoordinatesV2,
                "GEO_SHAPE" => EmbedClientItemTypeItems::GeoShape,
                "GOLF_COURSE" => EmbedClientItemTypeItems::GolfCourse,
                "GOOGLE_CHART" => EmbedClientItemTypeItems::GoogleChart,
                "GOOGLE_OFFER_V2" => EmbedClientItemTypeItems::GoogleOfferV2,
                "GOOGLE_PHOTO_RECIPE" => EmbedClientItemTypeItems::GooglePhotoRecipe,
                "GOOGLE_USER_PHOTO_ALBUM" => EmbedClientItemTypeItems::GoogleUserPhotoAlbum,
                "GOOGLE_USER_PHOTO_V2" => EmbedClientItemTypeItems::GoogleUserPhotoV2,
                "GOVERNMENT_BUILDING" => EmbedClientItemTypeItems::GovernmentBuilding,
                "GOVERNMENT_OFFICE" => EmbedClientItemTypeItems::GovernmentOffice,
                "GOVERNMENT_ORGANIZATION" => EmbedClientItemTypeItems::GovernmentOrganization,
                "GROCERY_STORE" => EmbedClientItemTypeItems::GroceryStore,
                "HAIR_SALON" => EmbedClientItemTypeItems::HairSalon,
                "HANGOUT" => EmbedClientItemTypeItems::Hangout,
                "HANGOUT_BROADCAST" => EmbedClientItemTypeItems::HangoutBroadcast,
                "HANGOUT_CHAT_MESSAGE" => EmbedClientItemTypeItems::HangoutChatMessage,
                "HANGOUT_CONSUMER" => EmbedClientItemTypeItems::HangoutConsumer,
                "HANGOUT_QUOTE" => EmbedClientItemTypeItems::HangoutQuote,
                "HANGOUT_V2" => EmbedClientItemTypeItems::HangoutV2,
                "HARDWARE_STORE" => EmbedClientItemTypeItems::HardwareStore,
                "HEALTH_AND_BEAUTY_BUSINESS" => EmbedClientItemTypeItems::HealthAndBeautyBusiness,
                "HEALTH_CLUB" => EmbedClientItemTypeItems::HealthClub,
                "HIGH_SCHOOL" => EmbedClientItemTypeItems::HighSchool,
                "HINDU_TEMPLE" => EmbedClientItemTypeItems::HinduTemple,
                "HOA_PLUS_EVENT_V2" => EmbedClientItemTypeItems::HoaPlusEventV2,
                "HOBBY_SHOP" => EmbedClientItemTypeItems::HobbyShop,
                "HOME_AND_CONSTRUCTION_BUSINESS" => {
                    EmbedClientItemTypeItems::HomeAndConstructionBusiness
                }
                "HOME_GOODS_STORE" => EmbedClientItemTypeItems::HomeGoodsStore,
                "HOSPITAL" => EmbedClientItemTypeItems::Hospital,
                "HOSTEL" => EmbedClientItemTypeItems::Hostel,
                "HOTEL" => EmbedClientItemTypeItems::Hotel,
                "HOUSE_PAINTER" => EmbedClientItemTypeItems::HousePainter,
                "HVAC_BUSINESS" => EmbedClientItemTypeItems::HvacBusiness,
                "ICE_CREAM_SHOP" => EmbedClientItemTypeItems::IceCreamShop,
                "IMAGE_GALLERY" => EmbedClientItemTypeItems::ImageGallery,
                "IMAGE_OBJECT" => EmbedClientItemTypeItems::ImageObject,
                "IMAGE_OBJECT_V2" => EmbedClientItemTypeItems::ImageObjectV2,
                "INSURANCE_AGENCY" => EmbedClientItemTypeItems::InsuranceAgency,
                "INTANGIBLE" => EmbedClientItemTypeItems::Intangible,
                "INTERACT_ACTION_V2" => EmbedClientItemTypeItems::InteractActionV2,
                "INTERACTION_V2" => EmbedClientItemTypeItems::InteractionV2,
                "INTERNET_CAFE" => EmbedClientItemTypeItems::InternetCafe,
                "ITEM_AVAILABILITY" => EmbedClientItemTypeItems::ItemAvailability,
                "ITEM_LIST" => EmbedClientItemTypeItems::ItemList,
                "ITEM_PAGE" => EmbedClientItemTypeItems::ItemPage,
                "JEWELRY_STORE" => EmbedClientItemTypeItems::JewelryStore,
                "JOB_POSTING" => EmbedClientItemTypeItems::JobPosting,
                "LAKE_BODY_OF_WATER" => EmbedClientItemTypeItems::LakeBodyOfWater,
                "LANDFORM" => EmbedClientItemTypeItems::Landform,
                "LANDMARKS_OR_HISTORICAL_BUILDINGS" => {
                    EmbedClientItemTypeItems::LandmarksOrHistoricalBuildings
                }
                "LANGUAGE" => EmbedClientItemTypeItems::Language,
                "LEGISLATIVE_BUILDING" => EmbedClientItemTypeItems::LegislativeBuilding,
                "LIBRARY" => EmbedClientItemTypeItems::Library,
                "LIQUOR_STORE" => EmbedClientItemTypeItems::LiquorStore,
                "LISTEN_ACTION_V2" => EmbedClientItemTypeItems::ListenActionV2,
                "LITERARY_EVENT" => EmbedClientItemTypeItems::LiteraryEvent,
                "LOCAL_BUSINESS" => EmbedClientItemTypeItems::LocalBusiness,
                "LOCAL_BUSINESS_V2" => EmbedClientItemTypeItems::LocalBusinessV2,
                "LOCAL_PLUS_PHOTO_ALBUM" => EmbedClientItemTypeItems::LocalPlusPhotoAlbum,
                "LOCAL_PLUS_PHOTO_ALBUM_V2" => EmbedClientItemTypeItems::LocalPlusPhotoAlbumV2,
                "LOCKSMITH" => EmbedClientItemTypeItems::Locksmith,
                "LODGING_BUSINESS" => EmbedClientItemTypeItems::LodgingBusiness,
                "MAGAZINE" => EmbedClientItemTypeItems::Magazine,
                "MAGAZINE_V2" => EmbedClientItemTypeItems::MagazineV2,
                "MAP" => EmbedClientItemTypeItems::Map,
                "MASS" => EmbedClientItemTypeItems::Mass,
                "MEDIA_OBJECT" => EmbedClientItemTypeItems::MediaObject,
                "MEDIA_OBJECT_V2" => EmbedClientItemTypeItems::MediaObjectV2,
                "MEDICAL_CLINIC" => EmbedClientItemTypeItems::MedicalClinic,
                "MEDICAL_ORGANIZATION" => EmbedClientItemTypeItems::MedicalOrganization,
                "MENS_CLOTHING_STORE" => EmbedClientItemTypeItems::MensClothingStore,
                "MIDDLE_SCHOOL" => EmbedClientItemTypeItems::MiddleSchool,
                "MOBILE_APPLICATION" => EmbedClientItemTypeItems::MobileApplication,
                "MOBILE_APPLICATION_V2" => EmbedClientItemTypeItems::MobileApplicationV2,
                "MOBILE_PHONE_STORE" => EmbedClientItemTypeItems::MobilePhoneStore,
                "MOSQUE" => EmbedClientItemTypeItems::Mosque,
                "MOTEL" => EmbedClientItemTypeItems::Motel,
                "MOTORCYCLE_DEALER" => EmbedClientItemTypeItems::MotorcycleDealer,
                "MOTORCYCLE_REPAIR" => EmbedClientItemTypeItems::MotorcycleRepair,
                "MOUNTAIN" => EmbedClientItemTypeItems::Mountain,
                "MOVIE" => EmbedClientItemTypeItems::Movie,
                "MOVIE_RENTAL_STORE" => EmbedClientItemTypeItems::MovieRentalStore,
                "MOVIE_THEATER" => EmbedClientItemTypeItems::MovieTheater,
                "MOVIE_V2" => EmbedClientItemTypeItems::MovieV2,
                "MOVING_COMPANY" => EmbedClientItemTypeItems::MovingCompany,
                "MUSEUM" => EmbedClientItemTypeItems::Museum,
                "MUSIC_ALBUM" => EmbedClientItemTypeItems::MusicAlbum,
                "MUSIC_ALBUM_V2" => EmbedClientItemTypeItems::MusicAlbumV2,
                "MUSIC_EVENT" => EmbedClientItemTypeItems::MusicEvent,
                "MUSIC_GROUP" => EmbedClientItemTypeItems::MusicGroup,
                "MUSIC_GROUP_V2" => EmbedClientItemTypeItems::MusicGroupV2,
                "MUSIC_PLAYLIST" => EmbedClientItemTypeItems::MusicPlaylist,
                "MUSIC_PLAYLIST_V2" => EmbedClientItemTypeItems::MusicPlaylistV2,
                "MUSIC_RECORDING" => EmbedClientItemTypeItems::MusicRecording,
                "MUSIC_RECORDING_V2" => EmbedClientItemTypeItems::MusicRecordingV2,
                "MUSIC_STORE" => EmbedClientItemTypeItems::MusicStore,
                "MUSIC_VENUE" => EmbedClientItemTypeItems::MusicVenue,
                "MUSIC_VIDEO_OBJECT" => EmbedClientItemTypeItems::MusicVideoObject,
                "NAIL_SALON" => EmbedClientItemTypeItems::NailSalon,
                "NEWS_ARTICLE" => EmbedClientItemTypeItems::NewsArticle,
                "NEWS_ARTICLE_V2" => EmbedClientItemTypeItems::NewsArticleV2,
                "NEWS_MEDIA_ORGANIZATION" => EmbedClientItemTypeItems::NewsMediaOrganization,
                "NIGHT_CLUB" => EmbedClientItemTypeItems::NightClub,
                "NOTARY" => EmbedClientItemTypeItems::Notary,
                "NUTRITION_INFORMATION" => EmbedClientItemTypeItems::NutritionInformation,
                "OCEAN_BODY_OF_WATER" => EmbedClientItemTypeItems::OceanBodyOfWater,
                "OFFER" => EmbedClientItemTypeItems::Offer,
                "OFFER_ITEM_CONDITION" => EmbedClientItemTypeItems::OfferItemCondition,
                "OFFER_V2" => EmbedClientItemTypeItems::OfferV2,
                "OFFICE_EQUIPMENT_STORE" => EmbedClientItemTypeItems::OfficeEquipmentStore,
                "OPTICIAN" => EmbedClientItemTypeItems::Optician,
                "ORGANIZATION" => EmbedClientItemTypeItems::Organization,
                "ORGANIZATION_V2" => EmbedClientItemTypeItems::OrganizationV2,
                "ORGANIZE_ACTION_V2" => EmbedClientItemTypeItems::OrganizeActionV2,
                "OUTLET_STORE" => EmbedClientItemTypeItems::OutletStore,
                "PAINTING" => EmbedClientItemTypeItems::Painting,
                "PARK" => EmbedClientItemTypeItems::Park,
                "PARKING_FACILITY" => EmbedClientItemTypeItems::ParkingFacility,
                "PAWN_SHOP" => EmbedClientItemTypeItems::PawnShop,
                "PERFORMING_ARTS_THEATER" => EmbedClientItemTypeItems::PerformingArtsTheater,
                "PERFORMING_GROUP" => EmbedClientItemTypeItems::PerformingGroup,
                "PERSON" => EmbedClientItemTypeItems::Person,
                "PERSON_V2" => EmbedClientItemTypeItems::PersonV2,
                "PET_STORE" => EmbedClientItemTypeItems::PetStore,
                "PHARMACY" => EmbedClientItemTypeItems::Pharmacy,
                "PHOTOGRAPH" => EmbedClientItemTypeItems::Photograph,
                "PHYSICIAN" => EmbedClientItemTypeItems::Physician,
                "PLACE" => EmbedClientItemTypeItems::Place,
                "PLACE_OF_WORSHIP" => EmbedClientItemTypeItems::PlaceOfWorship,
                "PLACE_REVIEW" => EmbedClientItemTypeItems::PlaceReview,
                "PLACE_REVIEW_V2" => EmbedClientItemTypeItems::PlaceReviewV2,
                "PLACE_V2" => EmbedClientItemTypeItems::PlaceV2,
                "PLAN_ACTION_V2" => EmbedClientItemTypeItems::PlanActionV2,
                "PLAY_MUSIC_ALBUM" => EmbedClientItemTypeItems::PlayMusicAlbum,
                "PLAY_MUSIC_ALBUM_V2" => EmbedClientItemTypeItems::PlayMusicAlbumV2,
                "PLAY_MUSIC_TRACK" => EmbedClientItemTypeItems::PlayMusicTrack,
                "PLAY_MUSIC_TRACK_V2" => EmbedClientItemTypeItems::PlayMusicTrackV2,
                "PLAY_OBJECT_V2" => EmbedClientItemTypeItems::PlayObjectV2,
                "PLAYGROUND" => EmbedClientItemTypeItems::Playground,
                "PLUMBER" => EmbedClientItemTypeItems::Plumber,
                "PLUS_AUDIO_V2" => EmbedClientItemTypeItems::PlusAudioV2,
                "PLUS_EVENT" => EmbedClientItemTypeItems::PlusEvent,
                "PLUS_EVENT_V2" => EmbedClientItemTypeItems::PlusEventV2,
                "PLUS_MEDIA_COLLECTION_V2" => EmbedClientItemTypeItems::PlusMediaCollectionV2,
                "PLUS_MEDIA_OBJECT_V2" => EmbedClientItemTypeItems::PlusMediaObjectV2,
                "PLUS_PAGE" => EmbedClientItemTypeItems::PlusPage,
                "PLUS_PAGE_V2" => EmbedClientItemTypeItems::PlusPageV2,
                "PLUS_PHOTO" => EmbedClientItemTypeItems::PlusPhoto,
                "PLUS_PHOTO_ALBUM" => EmbedClientItemTypeItems::PlusPhotoAlbum,
                "PLUS_PHOTO_ALBUM_V2" => EmbedClientItemTypeItems::PlusPhotoAlbumV2,
                "PLUS_PHOTO_COLLECTION_V2" => EmbedClientItemTypeItems::PlusPhotoCollectionV2,
                "PLUS_PHOTO_V2" => EmbedClientItemTypeItems::PlusPhotoV2,
                "PLUS_PHOTOS_ADDED_TO_COLLECTION" => {
                    EmbedClientItemTypeItems::PlusPhotosAddedToCollection
                }
                "PLUS_PHOTOS_ADDED_TO_COLLECTION_V2" => {
                    EmbedClientItemTypeItems::PlusPhotosAddedToCollectionV2
                }
                "PLUS_POST" => EmbedClientItemTypeItems::PlusPost,
                "PLUS_POST_V2" => EmbedClientItemTypeItems::PlusPostV2,
                "PLUS_RESHARE_V2" => EmbedClientItemTypeItems::PlusReshareV2,
                "PLUS_SOFTWARE_APPLICATION_V2" => {
                    EmbedClientItemTypeItems::PlusSoftwareApplicationV2
                }
                "POLICE_STATION" => EmbedClientItemTypeItems::PoliceStation,
                "POLL_OPTION_V2" => EmbedClientItemTypeItems::PollOptionV2,
                "POLL_V2" => EmbedClientItemTypeItems::PollV2,
                "POND" => EmbedClientItemTypeItems::Pond,
                "POST_OFFICE" => EmbedClientItemTypeItems::PostOffice,
                "POSTAL_ADDRESS" => EmbedClientItemTypeItems::PostalAddress,
                "POSTAL_ADDRESS_V2" => EmbedClientItemTypeItems::PostalAddressV2,
                "PRESCHOOL" => EmbedClientItemTypeItems::Preschool,
                "PRESENTATION_OBJECT" => EmbedClientItemTypeItems::PresentationObject,
                "PRESENTATION_OBJECT_V2" => EmbedClientItemTypeItems::PresentationObjectV2,
                "PRODUCT" => EmbedClientItemTypeItems::Product,
                "PRODUCT_REVIEW" => EmbedClientItemTypeItems::ProductReview,
                "PRODUCT_REVIEW_V2" => EmbedClientItemTypeItems::ProductReviewV2,
                "PROFESSIONAL_SERVICE" => EmbedClientItemTypeItems::ProfessionalService,
                "PROFILE_PAGE" => EmbedClientItemTypeItems::ProfilePage,
                "PUBLIC_SWIMMING_POOL" => EmbedClientItemTypeItems::PublicSwimmingPool,
                "QUANTITY" => EmbedClientItemTypeItems::Quantity,
                "R_V_PARK" => EmbedClientItemTypeItems::RVPark,
                "RADIO_STATION" => EmbedClientItemTypeItems::RadioStation,
                "RATING" => EmbedClientItemTypeItems::Rating,
                "RATING_V2" => EmbedClientItemTypeItems::RatingV2,
                "REACT_ACTION_V2" => EmbedClientItemTypeItems::ReactActionV2,
                "REAL_ESTATE_AGENT" => EmbedClientItemTypeItems::RealEstateAgent,
                "RECIPE" => EmbedClientItemTypeItems::Recipe,
                "RECOMMENDED_PEOPLE" => EmbedClientItemTypeItems::RecommendedPeople,
                "RECYCLING_CENTER" => EmbedClientItemTypeItems::RecyclingCenter,
                "RESERVATION" => EmbedClientItemTypeItems::Reservation,
                "RESERVATION_V2" => EmbedClientItemTypeItems::ReservationV2,
                "RESERVE_ACTION_V2" => EmbedClientItemTypeItems::ReserveActionV2,
                "RESERVOIR" => EmbedClientItemTypeItems::Reservoir,
                "RESIDENCE" => EmbedClientItemTypeItems::Residence,
                "RESTAURANT" => EmbedClientItemTypeItems::Restaurant,
                "REVIEW" => EmbedClientItemTypeItems::Review,
                "REVIEW_ACTION_V2" => EmbedClientItemTypeItems::ReviewActionV2,
                "REVIEW_V2" => EmbedClientItemTypeItems::ReviewV2,
                "RIVER_BODY_OF_WATER" => EmbedClientItemTypeItems::RiverBodyOfWater,
                "ROOFING_CONTRACTOR" => EmbedClientItemTypeItems::RoofingContractor,
                "SALE_EVENT" => EmbedClientItemTypeItems::SaleEvent,
                "SCHOLARLY_ARTICLE" => EmbedClientItemTypeItems::ScholarlyArticle,
                "SCHOOL" => EmbedClientItemTypeItems::School,
                "SCULPTURE" => EmbedClientItemTypeItems::Sculpture,
                "SEA_BODY_OF_WATER" => EmbedClientItemTypeItems::SeaBodyOfWater,
                "SEARCH_RESULTS_PAGE" => EmbedClientItemTypeItems::SearchResultsPage,
                "SELF_STORAGE" => EmbedClientItemTypeItems::SelfStorage,
                "SHOE_STORE" => EmbedClientItemTypeItems::ShoeStore,
                "SHOPPING_CENTER" => EmbedClientItemTypeItems::ShoppingCenter,
                "SINGLE_FAMILY_RESIDENCE" => EmbedClientItemTypeItems::SingleFamilyResidence,
                "SITE_NAVIGATION_ELEMENT" => EmbedClientItemTypeItems::SiteNavigationElement,
                "SKI_RESORT" => EmbedClientItemTypeItems::SkiResort,
                "SOCIAL_EVENT" => EmbedClientItemTypeItems::SocialEvent,
                "SOFTWARE_APPLICATION" => EmbedClientItemTypeItems::SoftwareApplication,
                "SOFTWARE_APPLICATION_V2" => EmbedClientItemTypeItems::SoftwareApplicationV2,
                "SPORTING_GOODS_STORE" => EmbedClientItemTypeItems::SportingGoodsStore,
                "SPORTS_ACTIVITY_LOCATION" => EmbedClientItemTypeItems::SportsActivityLocation,
                "SPORTS_CLUB" => EmbedClientItemTypeItems::SportsClub,
                "SPORTS_EVENT" => EmbedClientItemTypeItems::SportsEvent,
                "SPREADSHEET_OBJECT" => EmbedClientItemTypeItems::SpreadsheetObject,
                "SPREADSHEET_OBJECT_V2" => EmbedClientItemTypeItems::SpreadsheetObjectV2,
                "SQUARE" => EmbedClientItemTypeItems::Square,
                "SQUARE_INVITE" => EmbedClientItemTypeItems::SquareInvite,
                "SQUARE_INVITE_V2" => EmbedClientItemTypeItems::SquareInviteV2,
                "SQUARE_V2" => EmbedClientItemTypeItems::SquareV2,
                "STADIUM_OR_ARENA" => EmbedClientItemTypeItems::StadiumOrArena,
                "STATE" => EmbedClientItemTypeItems::State,
                "STICKER_V2" => EmbedClientItemTypeItems::StickerV2,
                "STORE" => EmbedClientItemTypeItems::Store,
                "STORY_V2" => EmbedClientItemTypeItems::StoryV2,
                "STRUCTURED_VALUE" => EmbedClientItemTypeItems::StructuredValue,
                "SUBWAY_STATION" => EmbedClientItemTypeItems::SubwayStation,
                "SYNAGOGUE" => EmbedClientItemTypeItems::Synagogue,
                "TABLE" => EmbedClientItemTypeItems::Table,
                "TATTOO_PARLOR" => EmbedClientItemTypeItems::TattooParlor,
                "TAXI_STAND" => EmbedClientItemTypeItems::TaxiStand,
                "TELEVISION_STATION" => EmbedClientItemTypeItems::TelevisionStation,
                "TENNIS_COMPLEX" => EmbedClientItemTypeItems::TennisComplex,
                "THEATER_EVENT" => EmbedClientItemTypeItems::TheaterEvent,
                "THING" => EmbedClientItemTypeItems::Thing,
                "THING_V2" => EmbedClientItemTypeItems::ThingV2,
                "TIRE_SHOP" => EmbedClientItemTypeItems::TireShop,
                "TOURIST_ATTRACTION" => EmbedClientItemTypeItems::TouristAttraction,
                "TOURIST_INFORMATION_CENTER" => EmbedClientItemTypeItems::TouristInformationCenter,
                "TOY_STORE" => EmbedClientItemTypeItems::ToyStore,
                "TRADE_ACTION_V2" => EmbedClientItemTypeItems::TradeActionV2,
                "TRAIN_STATION" => EmbedClientItemTypeItems::TrainStation,
                "TRAVEL_AGENCY" => EmbedClientItemTypeItems::TravelAgency,
                "TRAVEL_EVENT" => EmbedClientItemTypeItems::TravelEvent,
                "TV_EPISODE" => EmbedClientItemTypeItems::TvEpisode,
                "TV_EPISODE_V2" => EmbedClientItemTypeItems::TvEpisodeV2,
                "TV_SEASON" => EmbedClientItemTypeItems::TvSeason,
                "TV_SERIES" => EmbedClientItemTypeItems::TvSeries,
                "TV_SERIES_V2" => EmbedClientItemTypeItems::TvSeriesV2,
                "UNKNOWN" => EmbedClientItemTypeItems::Unknown,
                "UPDATE_ACTION_V2" => EmbedClientItemTypeItems::UpdateActionV2,
                "USER_INTERACTION" => EmbedClientItemTypeItems::UserInteraction,
                "USER_PLUS_ONES" => EmbedClientItemTypeItems::UserPlusOnes,
                "VETERINARY_CARE" => EmbedClientItemTypeItems::VeterinaryCare,
                "VIDEO_GALLERY" => EmbedClientItemTypeItems::VideoGallery,
                "VIDEO_GALLERY_V2" => EmbedClientItemTypeItems::VideoGalleryV2,
                "VIDEO_OBJECT" => EmbedClientItemTypeItems::VideoObject,
                "VIDEO_OBJECT_V2" => EmbedClientItemTypeItems::VideoObjectV2,
                "VIEW_ACTION_V2" => EmbedClientItemTypeItems::ViewActionV2,
                "VISUAL_ARTS_EVENT" => EmbedClientItemTypeItems::VisualArtsEvent,
                "VOLCANO" => EmbedClientItemTypeItems::Volcano,
                "WANT_ACTION_V2" => EmbedClientItemTypeItems::WantActionV2,
                "WATERFALL" => EmbedClientItemTypeItems::Waterfall,
                "WEB_APPLICATION" => EmbedClientItemTypeItems::WebApplication,
                "WEB_PAGE" => EmbedClientItemTypeItems::WebPage,
                "WEB_PAGE_ELEMENT" => EmbedClientItemTypeItems::WebPageElement,
                "WEB_PAGE_V2" => EmbedClientItemTypeItems::WebPageV2,
                "WHOLESALE_STORE" => EmbedClientItemTypeItems::WholesaleStore,
                "WINERY" => EmbedClientItemTypeItems::Winery,
                "WP_AD_BLOCK" => EmbedClientItemTypeItems::WpAdBlock,
                "WP_FOOTER" => EmbedClientItemTypeItems::WpFooter,
                "WP_HEADER" => EmbedClientItemTypeItems::WpHeader,
                "WP_SIDEBAR" => EmbedClientItemTypeItems::WpSidebar,
                "WRITE_ACTION_V2" => EmbedClientItemTypeItems::WriteActionV2,
                "YOUTUBE_CHANNEL_V2" => EmbedClientItemTypeItems::YoutubeChannelV2,
                "ZOO" => EmbedClientItemTypeItems::Zoo,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EmbedClientItemTypeItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EmbedClientItemTypeItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EmbedClientItemTypeItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ABOUT_PAGE" => EmbedClientItemTypeItems::AboutPage,
                "ACCOUNTING_SERVICE" => EmbedClientItemTypeItems::AccountingService,
                "ACTION_V2" => EmbedClientItemTypeItems::ActionV2,
                "ADD_ACTION_V2" => EmbedClientItemTypeItems::AddActionV2,
                "ADMINISTRATIVE_AREA" => EmbedClientItemTypeItems::AdministrativeArea,
                "ADULT_ENTERTAINMENT" => EmbedClientItemTypeItems::AdultEntertainment,
                "AGGREGATE_RATING" => EmbedClientItemTypeItems::AggregateRating,
                "AGGREGATE_RATING_V2" => EmbedClientItemTypeItems::AggregateRatingV2,
                "AIRPORT" => EmbedClientItemTypeItems::Airport,
                "AMUSEMENT_PARK" => EmbedClientItemTypeItems::AmusementPark,
                "ANIMAL_SHELTER" => EmbedClientItemTypeItems::AnimalShelter,
                "APARTMENT_COMPLEX" => EmbedClientItemTypeItems::ApartmentComplex,
                "APP_INVITE" => EmbedClientItemTypeItems::AppInvite,
                "AQUARIUM" => EmbedClientItemTypeItems::Aquarium,
                "ART_GALLERY" => EmbedClientItemTypeItems::ArtGallery,
                "ARTICLE" => EmbedClientItemTypeItems::Article,
                "ARTICLE_V2" => EmbedClientItemTypeItems::ArticleV2,
                "ASSESS_ACTION_V2" => EmbedClientItemTypeItems::AssessActionV2,
                "ATTORNEY" => EmbedClientItemTypeItems::Attorney,
                "AUDIO_OBJECT" => EmbedClientItemTypeItems::AudioObject,
                "AUDIO_OBJECT_V2" => EmbedClientItemTypeItems::AudioObjectV2,
                "AUTO_BODY_SHOP" => EmbedClientItemTypeItems::AutoBodyShop,
                "AUTO_DEALER" => EmbedClientItemTypeItems::AutoDealer,
                "AUTO_PARTS_STORE" => EmbedClientItemTypeItems::AutoPartsStore,
                "AUTO_RENTAL" => EmbedClientItemTypeItems::AutoRental,
                "AUTO_REPAIR" => EmbedClientItemTypeItems::AutoRepair,
                "AUTO_WASH" => EmbedClientItemTypeItems::AutoWash,
                "AUTOMATED_TELLER" => EmbedClientItemTypeItems::AutomatedTeller,
                "AUTOMOTIVE_BUSINESS" => EmbedClientItemTypeItems::AutomotiveBusiness,
                "BAKERY" => EmbedClientItemTypeItems::Bakery,
                "BANK_OR_CREDIT_UNION" => EmbedClientItemTypeItems::BankOrCreditUnion,
                "BAR_OR_PUB" => EmbedClientItemTypeItems::BarOrPub,
                "BASIC_INTERACTION_V2" => EmbedClientItemTypeItems::BasicInteractionV2,
                "BEACH" => EmbedClientItemTypeItems::Beach,
                "BEAUTY_SALON" => EmbedClientItemTypeItems::BeautySalon,
                "BED_AND_BREAKFAST" => EmbedClientItemTypeItems::BedAndBreakfast,
                "BIKE_STORE" => EmbedClientItemTypeItems::BikeStore,
                "BLOG" => EmbedClientItemTypeItems::Blog,
                "BLOG_POSTING" => EmbedClientItemTypeItems::BlogPosting,
                "BLOG_POSTING_V2" => EmbedClientItemTypeItems::BlogPostingV2,
                "BLOG_V2" => EmbedClientItemTypeItems::BlogV2,
                "BODY_OF_WATER" => EmbedClientItemTypeItems::BodyOfWater,
                "BOOK" => EmbedClientItemTypeItems::Book,
                "BOOK_FORMAT_TYPE" => EmbedClientItemTypeItems::BookFormatType,
                "BOOK_STORE" => EmbedClientItemTypeItems::BookStore,
                "BOOK_V2" => EmbedClientItemTypeItems::BookV2,
                "BOWLING_ALLEY" => EmbedClientItemTypeItems::BowlingAlley,
                "BREWERY" => EmbedClientItemTypeItems::Brewery,
                "BUDDHIST_TEMPLE" => EmbedClientItemTypeItems::BuddhistTemple,
                "BUS_STATION" => EmbedClientItemTypeItems::BusStation,
                "BUS_STOP" => EmbedClientItemTypeItems::BusStop,
                "BUSINESS_EVENT" => EmbedClientItemTypeItems::BusinessEvent,
                "BUY_ACTION_V2" => EmbedClientItemTypeItems::BuyActionV2,
                "CAFE_OR_COFFEE_SHOP" => EmbedClientItemTypeItems::CafeOrCoffeeShop,
                "CAMPGROUND" => EmbedClientItemTypeItems::Campground,
                "CANAL" => EmbedClientItemTypeItems::Canal,
                "CAROUSEL_FRAME" => EmbedClientItemTypeItems::CarouselFrame,
                "CASINO" => EmbedClientItemTypeItems::Casino,
                "CATHOLIC_CHURCH" => EmbedClientItemTypeItems::CatholicChurch,
                "CEMETERY" => EmbedClientItemTypeItems::Cemetery,
                "CHECK_IN_ACTION_V2" => EmbedClientItemTypeItems::CheckInActionV2,
                "CHECKIN" => EmbedClientItemTypeItems::Checkin,
                "CHECKIN_V2" => EmbedClientItemTypeItems::CheckinV2,
                "CHECKOUT_PAGE" => EmbedClientItemTypeItems::CheckoutPage,
                "CHILD_CARE" => EmbedClientItemTypeItems::ChildCare,
                "CHILDRENS_EVENT" => EmbedClientItemTypeItems::ChildrensEvent,
                "CHURCH" => EmbedClientItemTypeItems::Church,
                "CITY" => EmbedClientItemTypeItems::City,
                "CITY_HALL" => EmbedClientItemTypeItems::CityHall,
                "CIVIC_STRUCTURE" => EmbedClientItemTypeItems::CivicStructure,
                "CLOTHING_STORE" => EmbedClientItemTypeItems::ClothingStore,
                "COLLECTION_PAGE" => EmbedClientItemTypeItems::CollectionPage,
                "COLLEGE_OR_UNIVERSITY" => EmbedClientItemTypeItems::CollegeOrUniversity,
                "COLLEXION_V2" => EmbedClientItemTypeItems::CollexionV2,
                "COMEDY_CLUB" => EmbedClientItemTypeItems::ComedyClub,
                "COMEDY_EVENT" => EmbedClientItemTypeItems::ComedyEvent,
                "COMMENT" => EmbedClientItemTypeItems::Comment,
                "COMMENT_ACTION_V2" => EmbedClientItemTypeItems::CommentActionV2,
                "COMMENT_V2" => EmbedClientItemTypeItems::CommentV2,
                "COMMUNICATE_ACTION_V2" => EmbedClientItemTypeItems::CommunicateActionV2,
                "COMPUTER_STORE" => EmbedClientItemTypeItems::ComputerStore,
                "CONSUME_ACTION_V2" => EmbedClientItemTypeItems::ConsumeActionV2,
                "CONTACT_PAGE" => EmbedClientItemTypeItems::ContactPage,
                "CONTACT_POINT" => EmbedClientItemTypeItems::ContactPoint,
                "CONTINENT" => EmbedClientItemTypeItems::Continent,
                "CONVENIENCE_STORE" => EmbedClientItemTypeItems::ConvenienceStore,
                "CORPORATION" => EmbedClientItemTypeItems::Corporation,
                "COUNTRY" => EmbedClientItemTypeItems::Country,
                "COURTHOUSE" => EmbedClientItemTypeItems::Courthouse,
                "CREATE_ACTION_V2" => EmbedClientItemTypeItems::CreateActionV2,
                "CREATIVE_WORK" => EmbedClientItemTypeItems::CreativeWork,
                "CREATIVE_WORK_V2" => EmbedClientItemTypeItems::CreativeWorkV2,
                "CREMATORIUM" => EmbedClientItemTypeItems::Crematorium,
                "DANCE_EVENT" => EmbedClientItemTypeItems::DanceEvent,
                "DATE" => EmbedClientItemTypeItems::Date,
                "DAY_SPA" => EmbedClientItemTypeItems::DaySpa,
                "DEFENCE_ESTABLISHMENT" => EmbedClientItemTypeItems::DefenceEstablishment,
                "DENTIST" => EmbedClientItemTypeItems::Dentist,
                "DEPARTMENT_STORE" => EmbedClientItemTypeItems::DepartmentStore,
                "DEPRECATED_TOUR_OBJECT" => EmbedClientItemTypeItems::DeprecatedTourObject,
                "DEPRECATED_TOUR_OBJECT_V2" => EmbedClientItemTypeItems::DeprecatedTourObjectV2,
                "DISCOVER_ACTION_V2" => EmbedClientItemTypeItems::DiscoverActionV2,
                "DISTANCE" => EmbedClientItemTypeItems::Distance,
                "DOCUMENT_OBJECT" => EmbedClientItemTypeItems::DocumentObject,
                "DOCUMENT_OBJECT_V2" => EmbedClientItemTypeItems::DocumentObjectV2,
                "DRAWING_OBJECT" => EmbedClientItemTypeItems::DrawingObject,
                "DRAWING_OBJECT_V2" => EmbedClientItemTypeItems::DrawingObjectV2,
                "DRIVE_OBJECT_COLLECTION" => EmbedClientItemTypeItems::DriveObjectCollection,
                "DRIVE_OBJECT_V2" => EmbedClientItemTypeItems::DriveObjectV2,
                "DRY_CLEANING_OR_LAUNDRY" => EmbedClientItemTypeItems::DryCleaningOrLaundry,
                "DURATION" => EmbedClientItemTypeItems::Duration,
                "DYNAMITE_ATTACHMENT_METADATA" => {
                    EmbedClientItemTypeItems::DynamiteAttachmentMetadata
                }
                "DYNAMITE_MESSAGE_METADATA" => EmbedClientItemTypeItems::DynamiteMessageMetadata,
                "EDUCATION_EVENT" => EmbedClientItemTypeItems::EducationEvent,
                "EDUCATIONAL_ORGANIZATION" => EmbedClientItemTypeItems::EducationalOrganization,
                "ELECTRICIAN" => EmbedClientItemTypeItems::Electrician,
                "ELECTRONICS_STORE" => EmbedClientItemTypeItems::ElectronicsStore,
                "ELEMENTARY_SCHOOL" => EmbedClientItemTypeItems::ElementarySchool,
                "EMBASSY" => EmbedClientItemTypeItems::Embassy,
                "EMERGENCY_SERVICE" => EmbedClientItemTypeItems::EmergencyService,
                "EMOTISHARE" => EmbedClientItemTypeItems::Emotishare,
                "EMOTISHARE_V2" => EmbedClientItemTypeItems::EmotishareV2,
                "EMPLOYMENT_AGENGY" => EmbedClientItemTypeItems::EmploymentAgengy,
                "ENERGY" => EmbedClientItemTypeItems::Energy,
                "ENTERTAINMENT_BUSINESS" => EmbedClientItemTypeItems::EntertainmentBusiness,
                "ENTRY_POINT_V2" => EmbedClientItemTypeItems::EntryPointV2,
                "ENUMERATION" => EmbedClientItemTypeItems::Enumeration,
                "EVENT" => EmbedClientItemTypeItems::Event,
                "EVENT_TIME_V2" => EmbedClientItemTypeItems::EventTimeV2,
                "EVENT_V2" => EmbedClientItemTypeItems::EventV2,
                "EVENT_VENUE" => EmbedClientItemTypeItems::EventVenue,
                "EXAMPLE_OBJECT" => EmbedClientItemTypeItems::ExampleObject,
                "EXERCISE_GYM" => EmbedClientItemTypeItems::ExerciseGym,
                "FAST_FOOD_RESTAURANT" => EmbedClientItemTypeItems::FastFoodRestaurant,
                "FESTIVAL" => EmbedClientItemTypeItems::Festival,
                "FILE_OBJECT" => EmbedClientItemTypeItems::FileObject,
                "FILE_OBJECT_V2" => EmbedClientItemTypeItems::FileObjectV2,
                "FINANCIAL_QUOTE" => EmbedClientItemTypeItems::FinancialQuote,
                "FINANCIAL_QUOTE_V2" => EmbedClientItemTypeItems::FinancialQuoteV2,
                "FINANCIAL_SERVICE" => EmbedClientItemTypeItems::FinancialService,
                "FIND_ACTION_V2" => EmbedClientItemTypeItems::FindActionV2,
                "FIRE_STATION" => EmbedClientItemTypeItems::FireStation,
                "FLORIST" => EmbedClientItemTypeItems::Florist,
                "FOOD_ESTABLISHMENT" => EmbedClientItemTypeItems::FoodEstablishment,
                "FOOD_EVENT" => EmbedClientItemTypeItems::FoodEvent,
                "FORM_OBJECT" => EmbedClientItemTypeItems::FormObject,
                "FORM_OBJECT_V2" => EmbedClientItemTypeItems::FormObjectV2,
                "FURNITURE_STORE" => EmbedClientItemTypeItems::FurnitureStore,
                "GARDEN_STORE" => EmbedClientItemTypeItems::GardenStore,
                "GAS_STATION" => EmbedClientItemTypeItems::GasStation,
                "GATED_RESIDENCE_COMMUNITY" => EmbedClientItemTypeItems::GatedResidenceCommunity,
                "GENERAL_CONTRACTOR" => EmbedClientItemTypeItems::GeneralContractor,
                "GEO_COORDINATES" => EmbedClientItemTypeItems::GeoCoordinates,
                "GEO_COORDINATES_V2" => EmbedClientItemTypeItems::GeoCoordinatesV2,
                "GEO_SHAPE" => EmbedClientItemTypeItems::GeoShape,
                "GOLF_COURSE" => EmbedClientItemTypeItems::GolfCourse,
                "GOOGLE_CHART" => EmbedClientItemTypeItems::GoogleChart,
                "GOOGLE_OFFER_V2" => EmbedClientItemTypeItems::GoogleOfferV2,
                "GOOGLE_PHOTO_RECIPE" => EmbedClientItemTypeItems::GooglePhotoRecipe,
                "GOOGLE_USER_PHOTO_ALBUM" => EmbedClientItemTypeItems::GoogleUserPhotoAlbum,
                "GOOGLE_USER_PHOTO_V2" => EmbedClientItemTypeItems::GoogleUserPhotoV2,
                "GOVERNMENT_BUILDING" => EmbedClientItemTypeItems::GovernmentBuilding,
                "GOVERNMENT_OFFICE" => EmbedClientItemTypeItems::GovernmentOffice,
                "GOVERNMENT_ORGANIZATION" => EmbedClientItemTypeItems::GovernmentOrganization,
                "GROCERY_STORE" => EmbedClientItemTypeItems::GroceryStore,
                "HAIR_SALON" => EmbedClientItemTypeItems::HairSalon,
                "HANGOUT" => EmbedClientItemTypeItems::Hangout,
                "HANGOUT_BROADCAST" => EmbedClientItemTypeItems::HangoutBroadcast,
                "HANGOUT_CHAT_MESSAGE" => EmbedClientItemTypeItems::HangoutChatMessage,
                "HANGOUT_CONSUMER" => EmbedClientItemTypeItems::HangoutConsumer,
                "HANGOUT_QUOTE" => EmbedClientItemTypeItems::HangoutQuote,
                "HANGOUT_V2" => EmbedClientItemTypeItems::HangoutV2,
                "HARDWARE_STORE" => EmbedClientItemTypeItems::HardwareStore,
                "HEALTH_AND_BEAUTY_BUSINESS" => EmbedClientItemTypeItems::HealthAndBeautyBusiness,
                "HEALTH_CLUB" => EmbedClientItemTypeItems::HealthClub,
                "HIGH_SCHOOL" => EmbedClientItemTypeItems::HighSchool,
                "HINDU_TEMPLE" => EmbedClientItemTypeItems::HinduTemple,
                "HOA_PLUS_EVENT_V2" => EmbedClientItemTypeItems::HoaPlusEventV2,
                "HOBBY_SHOP" => EmbedClientItemTypeItems::HobbyShop,
                "HOME_AND_CONSTRUCTION_BUSINESS" => {
                    EmbedClientItemTypeItems::HomeAndConstructionBusiness
                }
                "HOME_GOODS_STORE" => EmbedClientItemTypeItems::HomeGoodsStore,
                "HOSPITAL" => EmbedClientItemTypeItems::Hospital,
                "HOSTEL" => EmbedClientItemTypeItems::Hostel,
                "HOTEL" => EmbedClientItemTypeItems::Hotel,
                "HOUSE_PAINTER" => EmbedClientItemTypeItems::HousePainter,
                "HVAC_BUSINESS" => EmbedClientItemTypeItems::HvacBusiness,
                "ICE_CREAM_SHOP" => EmbedClientItemTypeItems::IceCreamShop,
                "IMAGE_GALLERY" => EmbedClientItemTypeItems::ImageGallery,
                "IMAGE_OBJECT" => EmbedClientItemTypeItems::ImageObject,
                "IMAGE_OBJECT_V2" => EmbedClientItemTypeItems::ImageObjectV2,
                "INSURANCE_AGENCY" => EmbedClientItemTypeItems::InsuranceAgency,
                "INTANGIBLE" => EmbedClientItemTypeItems::Intangible,
                "INTERACT_ACTION_V2" => EmbedClientItemTypeItems::InteractActionV2,
                "INTERACTION_V2" => EmbedClientItemTypeItems::InteractionV2,
                "INTERNET_CAFE" => EmbedClientItemTypeItems::InternetCafe,
                "ITEM_AVAILABILITY" => EmbedClientItemTypeItems::ItemAvailability,
                "ITEM_LIST" => EmbedClientItemTypeItems::ItemList,
                "ITEM_PAGE" => EmbedClientItemTypeItems::ItemPage,
                "JEWELRY_STORE" => EmbedClientItemTypeItems::JewelryStore,
                "JOB_POSTING" => EmbedClientItemTypeItems::JobPosting,
                "LAKE_BODY_OF_WATER" => EmbedClientItemTypeItems::LakeBodyOfWater,
                "LANDFORM" => EmbedClientItemTypeItems::Landform,
                "LANDMARKS_OR_HISTORICAL_BUILDINGS" => {
                    EmbedClientItemTypeItems::LandmarksOrHistoricalBuildings
                }
                "LANGUAGE" => EmbedClientItemTypeItems::Language,
                "LEGISLATIVE_BUILDING" => EmbedClientItemTypeItems::LegislativeBuilding,
                "LIBRARY" => EmbedClientItemTypeItems::Library,
                "LIQUOR_STORE" => EmbedClientItemTypeItems::LiquorStore,
                "LISTEN_ACTION_V2" => EmbedClientItemTypeItems::ListenActionV2,
                "LITERARY_EVENT" => EmbedClientItemTypeItems::LiteraryEvent,
                "LOCAL_BUSINESS" => EmbedClientItemTypeItems::LocalBusiness,
                "LOCAL_BUSINESS_V2" => EmbedClientItemTypeItems::LocalBusinessV2,
                "LOCAL_PLUS_PHOTO_ALBUM" => EmbedClientItemTypeItems::LocalPlusPhotoAlbum,
                "LOCAL_PLUS_PHOTO_ALBUM_V2" => EmbedClientItemTypeItems::LocalPlusPhotoAlbumV2,
                "LOCKSMITH" => EmbedClientItemTypeItems::Locksmith,
                "LODGING_BUSINESS" => EmbedClientItemTypeItems::LodgingBusiness,
                "MAGAZINE" => EmbedClientItemTypeItems::Magazine,
                "MAGAZINE_V2" => EmbedClientItemTypeItems::MagazineV2,
                "MAP" => EmbedClientItemTypeItems::Map,
                "MASS" => EmbedClientItemTypeItems::Mass,
                "MEDIA_OBJECT" => EmbedClientItemTypeItems::MediaObject,
                "MEDIA_OBJECT_V2" => EmbedClientItemTypeItems::MediaObjectV2,
                "MEDICAL_CLINIC" => EmbedClientItemTypeItems::MedicalClinic,
                "MEDICAL_ORGANIZATION" => EmbedClientItemTypeItems::MedicalOrganization,
                "MENS_CLOTHING_STORE" => EmbedClientItemTypeItems::MensClothingStore,
                "MIDDLE_SCHOOL" => EmbedClientItemTypeItems::MiddleSchool,
                "MOBILE_APPLICATION" => EmbedClientItemTypeItems::MobileApplication,
                "MOBILE_APPLICATION_V2" => EmbedClientItemTypeItems::MobileApplicationV2,
                "MOBILE_PHONE_STORE" => EmbedClientItemTypeItems::MobilePhoneStore,
                "MOSQUE" => EmbedClientItemTypeItems::Mosque,
                "MOTEL" => EmbedClientItemTypeItems::Motel,
                "MOTORCYCLE_DEALER" => EmbedClientItemTypeItems::MotorcycleDealer,
                "MOTORCYCLE_REPAIR" => EmbedClientItemTypeItems::MotorcycleRepair,
                "MOUNTAIN" => EmbedClientItemTypeItems::Mountain,
                "MOVIE" => EmbedClientItemTypeItems::Movie,
                "MOVIE_RENTAL_STORE" => EmbedClientItemTypeItems::MovieRentalStore,
                "MOVIE_THEATER" => EmbedClientItemTypeItems::MovieTheater,
                "MOVIE_V2" => EmbedClientItemTypeItems::MovieV2,
                "MOVING_COMPANY" => EmbedClientItemTypeItems::MovingCompany,
                "MUSEUM" => EmbedClientItemTypeItems::Museum,
                "MUSIC_ALBUM" => EmbedClientItemTypeItems::MusicAlbum,
                "MUSIC_ALBUM_V2" => EmbedClientItemTypeItems::MusicAlbumV2,
                "MUSIC_EVENT" => EmbedClientItemTypeItems::MusicEvent,
                "MUSIC_GROUP" => EmbedClientItemTypeItems::MusicGroup,
                "MUSIC_GROUP_V2" => EmbedClientItemTypeItems::MusicGroupV2,
                "MUSIC_PLAYLIST" => EmbedClientItemTypeItems::MusicPlaylist,
                "MUSIC_PLAYLIST_V2" => EmbedClientItemTypeItems::MusicPlaylistV2,
                "MUSIC_RECORDING" => EmbedClientItemTypeItems::MusicRecording,
                "MUSIC_RECORDING_V2" => EmbedClientItemTypeItems::MusicRecordingV2,
                "MUSIC_STORE" => EmbedClientItemTypeItems::MusicStore,
                "MUSIC_VENUE" => EmbedClientItemTypeItems::MusicVenue,
                "MUSIC_VIDEO_OBJECT" => EmbedClientItemTypeItems::MusicVideoObject,
                "NAIL_SALON" => EmbedClientItemTypeItems::NailSalon,
                "NEWS_ARTICLE" => EmbedClientItemTypeItems::NewsArticle,
                "NEWS_ARTICLE_V2" => EmbedClientItemTypeItems::NewsArticleV2,
                "NEWS_MEDIA_ORGANIZATION" => EmbedClientItemTypeItems::NewsMediaOrganization,
                "NIGHT_CLUB" => EmbedClientItemTypeItems::NightClub,
                "NOTARY" => EmbedClientItemTypeItems::Notary,
                "NUTRITION_INFORMATION" => EmbedClientItemTypeItems::NutritionInformation,
                "OCEAN_BODY_OF_WATER" => EmbedClientItemTypeItems::OceanBodyOfWater,
                "OFFER" => EmbedClientItemTypeItems::Offer,
                "OFFER_ITEM_CONDITION" => EmbedClientItemTypeItems::OfferItemCondition,
                "OFFER_V2" => EmbedClientItemTypeItems::OfferV2,
                "OFFICE_EQUIPMENT_STORE" => EmbedClientItemTypeItems::OfficeEquipmentStore,
                "OPTICIAN" => EmbedClientItemTypeItems::Optician,
                "ORGANIZATION" => EmbedClientItemTypeItems::Organization,
                "ORGANIZATION_V2" => EmbedClientItemTypeItems::OrganizationV2,
                "ORGANIZE_ACTION_V2" => EmbedClientItemTypeItems::OrganizeActionV2,
                "OUTLET_STORE" => EmbedClientItemTypeItems::OutletStore,
                "PAINTING" => EmbedClientItemTypeItems::Painting,
                "PARK" => EmbedClientItemTypeItems::Park,
                "PARKING_FACILITY" => EmbedClientItemTypeItems::ParkingFacility,
                "PAWN_SHOP" => EmbedClientItemTypeItems::PawnShop,
                "PERFORMING_ARTS_THEATER" => EmbedClientItemTypeItems::PerformingArtsTheater,
                "PERFORMING_GROUP" => EmbedClientItemTypeItems::PerformingGroup,
                "PERSON" => EmbedClientItemTypeItems::Person,
                "PERSON_V2" => EmbedClientItemTypeItems::PersonV2,
                "PET_STORE" => EmbedClientItemTypeItems::PetStore,
                "PHARMACY" => EmbedClientItemTypeItems::Pharmacy,
                "PHOTOGRAPH" => EmbedClientItemTypeItems::Photograph,
                "PHYSICIAN" => EmbedClientItemTypeItems::Physician,
                "PLACE" => EmbedClientItemTypeItems::Place,
                "PLACE_OF_WORSHIP" => EmbedClientItemTypeItems::PlaceOfWorship,
                "PLACE_REVIEW" => EmbedClientItemTypeItems::PlaceReview,
                "PLACE_REVIEW_V2" => EmbedClientItemTypeItems::PlaceReviewV2,
                "PLACE_V2" => EmbedClientItemTypeItems::PlaceV2,
                "PLAN_ACTION_V2" => EmbedClientItemTypeItems::PlanActionV2,
                "PLAY_MUSIC_ALBUM" => EmbedClientItemTypeItems::PlayMusicAlbum,
                "PLAY_MUSIC_ALBUM_V2" => EmbedClientItemTypeItems::PlayMusicAlbumV2,
                "PLAY_MUSIC_TRACK" => EmbedClientItemTypeItems::PlayMusicTrack,
                "PLAY_MUSIC_TRACK_V2" => EmbedClientItemTypeItems::PlayMusicTrackV2,
                "PLAY_OBJECT_V2" => EmbedClientItemTypeItems::PlayObjectV2,
                "PLAYGROUND" => EmbedClientItemTypeItems::Playground,
                "PLUMBER" => EmbedClientItemTypeItems::Plumber,
                "PLUS_AUDIO_V2" => EmbedClientItemTypeItems::PlusAudioV2,
                "PLUS_EVENT" => EmbedClientItemTypeItems::PlusEvent,
                "PLUS_EVENT_V2" => EmbedClientItemTypeItems::PlusEventV2,
                "PLUS_MEDIA_COLLECTION_V2" => EmbedClientItemTypeItems::PlusMediaCollectionV2,
                "PLUS_MEDIA_OBJECT_V2" => EmbedClientItemTypeItems::PlusMediaObjectV2,
                "PLUS_PAGE" => EmbedClientItemTypeItems::PlusPage,
                "PLUS_PAGE_V2" => EmbedClientItemTypeItems::PlusPageV2,
                "PLUS_PHOTO" => EmbedClientItemTypeItems::PlusPhoto,
                "PLUS_PHOTO_ALBUM" => EmbedClientItemTypeItems::PlusPhotoAlbum,
                "PLUS_PHOTO_ALBUM_V2" => EmbedClientItemTypeItems::PlusPhotoAlbumV2,
                "PLUS_PHOTO_COLLECTION_V2" => EmbedClientItemTypeItems::PlusPhotoCollectionV2,
                "PLUS_PHOTO_V2" => EmbedClientItemTypeItems::PlusPhotoV2,
                "PLUS_PHOTOS_ADDED_TO_COLLECTION" => {
                    EmbedClientItemTypeItems::PlusPhotosAddedToCollection
                }
                "PLUS_PHOTOS_ADDED_TO_COLLECTION_V2" => {
                    EmbedClientItemTypeItems::PlusPhotosAddedToCollectionV2
                }
                "PLUS_POST" => EmbedClientItemTypeItems::PlusPost,
                "PLUS_POST_V2" => EmbedClientItemTypeItems::PlusPostV2,
                "PLUS_RESHARE_V2" => EmbedClientItemTypeItems::PlusReshareV2,
                "PLUS_SOFTWARE_APPLICATION_V2" => {
                    EmbedClientItemTypeItems::PlusSoftwareApplicationV2
                }
                "POLICE_STATION" => EmbedClientItemTypeItems::PoliceStation,
                "POLL_OPTION_V2" => EmbedClientItemTypeItems::PollOptionV2,
                "POLL_V2" => EmbedClientItemTypeItems::PollV2,
                "POND" => EmbedClientItemTypeItems::Pond,
                "POST_OFFICE" => EmbedClientItemTypeItems::PostOffice,
                "POSTAL_ADDRESS" => EmbedClientItemTypeItems::PostalAddress,
                "POSTAL_ADDRESS_V2" => EmbedClientItemTypeItems::PostalAddressV2,
                "PRESCHOOL" => EmbedClientItemTypeItems::Preschool,
                "PRESENTATION_OBJECT" => EmbedClientItemTypeItems::PresentationObject,
                "PRESENTATION_OBJECT_V2" => EmbedClientItemTypeItems::PresentationObjectV2,
                "PRODUCT" => EmbedClientItemTypeItems::Product,
                "PRODUCT_REVIEW" => EmbedClientItemTypeItems::ProductReview,
                "PRODUCT_REVIEW_V2" => EmbedClientItemTypeItems::ProductReviewV2,
                "PROFESSIONAL_SERVICE" => EmbedClientItemTypeItems::ProfessionalService,
                "PROFILE_PAGE" => EmbedClientItemTypeItems::ProfilePage,
                "PUBLIC_SWIMMING_POOL" => EmbedClientItemTypeItems::PublicSwimmingPool,
                "QUANTITY" => EmbedClientItemTypeItems::Quantity,
                "R_V_PARK" => EmbedClientItemTypeItems::RVPark,
                "RADIO_STATION" => EmbedClientItemTypeItems::RadioStation,
                "RATING" => EmbedClientItemTypeItems::Rating,
                "RATING_V2" => EmbedClientItemTypeItems::RatingV2,
                "REACT_ACTION_V2" => EmbedClientItemTypeItems::ReactActionV2,
                "REAL_ESTATE_AGENT" => EmbedClientItemTypeItems::RealEstateAgent,
                "RECIPE" => EmbedClientItemTypeItems::Recipe,
                "RECOMMENDED_PEOPLE" => EmbedClientItemTypeItems::RecommendedPeople,
                "RECYCLING_CENTER" => EmbedClientItemTypeItems::RecyclingCenter,
                "RESERVATION" => EmbedClientItemTypeItems::Reservation,
                "RESERVATION_V2" => EmbedClientItemTypeItems::ReservationV2,
                "RESERVE_ACTION_V2" => EmbedClientItemTypeItems::ReserveActionV2,
                "RESERVOIR" => EmbedClientItemTypeItems::Reservoir,
                "RESIDENCE" => EmbedClientItemTypeItems::Residence,
                "RESTAURANT" => EmbedClientItemTypeItems::Restaurant,
                "REVIEW" => EmbedClientItemTypeItems::Review,
                "REVIEW_ACTION_V2" => EmbedClientItemTypeItems::ReviewActionV2,
                "REVIEW_V2" => EmbedClientItemTypeItems::ReviewV2,
                "RIVER_BODY_OF_WATER" => EmbedClientItemTypeItems::RiverBodyOfWater,
                "ROOFING_CONTRACTOR" => EmbedClientItemTypeItems::RoofingContractor,
                "SALE_EVENT" => EmbedClientItemTypeItems::SaleEvent,
                "SCHOLARLY_ARTICLE" => EmbedClientItemTypeItems::ScholarlyArticle,
                "SCHOOL" => EmbedClientItemTypeItems::School,
                "SCULPTURE" => EmbedClientItemTypeItems::Sculpture,
                "SEA_BODY_OF_WATER" => EmbedClientItemTypeItems::SeaBodyOfWater,
                "SEARCH_RESULTS_PAGE" => EmbedClientItemTypeItems::SearchResultsPage,
                "SELF_STORAGE" => EmbedClientItemTypeItems::SelfStorage,
                "SHOE_STORE" => EmbedClientItemTypeItems::ShoeStore,
                "SHOPPING_CENTER" => EmbedClientItemTypeItems::ShoppingCenter,
                "SINGLE_FAMILY_RESIDENCE" => EmbedClientItemTypeItems::SingleFamilyResidence,
                "SITE_NAVIGATION_ELEMENT" => EmbedClientItemTypeItems::SiteNavigationElement,
                "SKI_RESORT" => EmbedClientItemTypeItems::SkiResort,
                "SOCIAL_EVENT" => EmbedClientItemTypeItems::SocialEvent,
                "SOFTWARE_APPLICATION" => EmbedClientItemTypeItems::SoftwareApplication,
                "SOFTWARE_APPLICATION_V2" => EmbedClientItemTypeItems::SoftwareApplicationV2,
                "SPORTING_GOODS_STORE" => EmbedClientItemTypeItems::SportingGoodsStore,
                "SPORTS_ACTIVITY_LOCATION" => EmbedClientItemTypeItems::SportsActivityLocation,
                "SPORTS_CLUB" => EmbedClientItemTypeItems::SportsClub,
                "SPORTS_EVENT" => EmbedClientItemTypeItems::SportsEvent,
                "SPREADSHEET_OBJECT" => EmbedClientItemTypeItems::SpreadsheetObject,
                "SPREADSHEET_OBJECT_V2" => EmbedClientItemTypeItems::SpreadsheetObjectV2,
                "SQUARE" => EmbedClientItemTypeItems::Square,
                "SQUARE_INVITE" => EmbedClientItemTypeItems::SquareInvite,
                "SQUARE_INVITE_V2" => EmbedClientItemTypeItems::SquareInviteV2,
                "SQUARE_V2" => EmbedClientItemTypeItems::SquareV2,
                "STADIUM_OR_ARENA" => EmbedClientItemTypeItems::StadiumOrArena,
                "STATE" => EmbedClientItemTypeItems::State,
                "STICKER_V2" => EmbedClientItemTypeItems::StickerV2,
                "STORE" => EmbedClientItemTypeItems::Store,
                "STORY_V2" => EmbedClientItemTypeItems::StoryV2,
                "STRUCTURED_VALUE" => EmbedClientItemTypeItems::StructuredValue,
                "SUBWAY_STATION" => EmbedClientItemTypeItems::SubwayStation,
                "SYNAGOGUE" => EmbedClientItemTypeItems::Synagogue,
                "TABLE" => EmbedClientItemTypeItems::Table,
                "TATTOO_PARLOR" => EmbedClientItemTypeItems::TattooParlor,
                "TAXI_STAND" => EmbedClientItemTypeItems::TaxiStand,
                "TELEVISION_STATION" => EmbedClientItemTypeItems::TelevisionStation,
                "TENNIS_COMPLEX" => EmbedClientItemTypeItems::TennisComplex,
                "THEATER_EVENT" => EmbedClientItemTypeItems::TheaterEvent,
                "THING" => EmbedClientItemTypeItems::Thing,
                "THING_V2" => EmbedClientItemTypeItems::ThingV2,
                "TIRE_SHOP" => EmbedClientItemTypeItems::TireShop,
                "TOURIST_ATTRACTION" => EmbedClientItemTypeItems::TouristAttraction,
                "TOURIST_INFORMATION_CENTER" => EmbedClientItemTypeItems::TouristInformationCenter,
                "TOY_STORE" => EmbedClientItemTypeItems::ToyStore,
                "TRADE_ACTION_V2" => EmbedClientItemTypeItems::TradeActionV2,
                "TRAIN_STATION" => EmbedClientItemTypeItems::TrainStation,
                "TRAVEL_AGENCY" => EmbedClientItemTypeItems::TravelAgency,
                "TRAVEL_EVENT" => EmbedClientItemTypeItems::TravelEvent,
                "TV_EPISODE" => EmbedClientItemTypeItems::TvEpisode,
                "TV_EPISODE_V2" => EmbedClientItemTypeItems::TvEpisodeV2,
                "TV_SEASON" => EmbedClientItemTypeItems::TvSeason,
                "TV_SERIES" => EmbedClientItemTypeItems::TvSeries,
                "TV_SERIES_V2" => EmbedClientItemTypeItems::TvSeriesV2,
                "UNKNOWN" => EmbedClientItemTypeItems::Unknown,
                "UPDATE_ACTION_V2" => EmbedClientItemTypeItems::UpdateActionV2,
                "USER_INTERACTION" => EmbedClientItemTypeItems::UserInteraction,
                "USER_PLUS_ONES" => EmbedClientItemTypeItems::UserPlusOnes,
                "VETERINARY_CARE" => EmbedClientItemTypeItems::VeterinaryCare,
                "VIDEO_GALLERY" => EmbedClientItemTypeItems::VideoGallery,
                "VIDEO_GALLERY_V2" => EmbedClientItemTypeItems::VideoGalleryV2,
                "VIDEO_OBJECT" => EmbedClientItemTypeItems::VideoObject,
                "VIDEO_OBJECT_V2" => EmbedClientItemTypeItems::VideoObjectV2,
                "VIEW_ACTION_V2" => EmbedClientItemTypeItems::ViewActionV2,
                "VISUAL_ARTS_EVENT" => EmbedClientItemTypeItems::VisualArtsEvent,
                "VOLCANO" => EmbedClientItemTypeItems::Volcano,
                "WANT_ACTION_V2" => EmbedClientItemTypeItems::WantActionV2,
                "WATERFALL" => EmbedClientItemTypeItems::Waterfall,
                "WEB_APPLICATION" => EmbedClientItemTypeItems::WebApplication,
                "WEB_PAGE" => EmbedClientItemTypeItems::WebPage,
                "WEB_PAGE_ELEMENT" => EmbedClientItemTypeItems::WebPageElement,
                "WEB_PAGE_V2" => EmbedClientItemTypeItems::WebPageV2,
                "WHOLESALE_STORE" => EmbedClientItemTypeItems::WholesaleStore,
                "WINERY" => EmbedClientItemTypeItems::Winery,
                "WP_AD_BLOCK" => EmbedClientItemTypeItems::WpAdBlock,
                "WP_FOOTER" => EmbedClientItemTypeItems::WpFooter,
                "WP_HEADER" => EmbedClientItemTypeItems::WpHeader,
                "WP_SIDEBAR" => EmbedClientItemTypeItems::WpSidebar,
                "WRITE_ACTION_V2" => EmbedClientItemTypeItems::WriteActionV2,
                "YOUTUBE_CHANNEL_V2" => EmbedClientItemTypeItems::YoutubeChannelV2,
                "ZOO" => EmbedClientItemTypeItems::Zoo,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EmbedClientItemTypeItems {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EmbedClientItemTypeItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnumOperatorOptions {
        #[doc = "Indicates the operator name required in the query in order to isolate the enum property. For example, if operatorName is *priority* and the property’s name is *priorityVal*, then queries like *priority:<value>* show results only where the value of the property named *priorityVal* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnumOperatorOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnumOperatorOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnumPropertyOptions {
        #[doc = "If set, describes how the enum should be used as a search operator."]
        #[serde(
            rename = "operatorOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_options: ::std::option::Option<crate::schemas::EnumOperatorOptions>,
        #[doc = "Used to specify the ordered ranking for the enumeration that determines how the integer values provided in the possible EnumValuePairs are used to rank results. If specified, integer values must be provided for all possible EnumValuePair values given for this property. Can only be used if isRepeatable is false."]
        #[serde(
            rename = "orderedRanking",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ordered_ranking:
            ::std::option::Option<crate::schemas::EnumPropertyOptionsOrderedRanking>,
        #[doc = "The list of possible values for the enumeration property. All EnumValuePairs must provide a string value. If you specify an integer value for one EnumValuePair, then all possible EnumValuePairs must provide an integer value. Both the string value and integer value must be unique over all possible values. Once set, possible values cannot be removed or modified. If you supply an ordered ranking and think you might insert additional enum values in the future, leave gaps in the initial integer values to allow adding a value in between previously registered values. The maximum number of elements is 100."]
        #[serde(
            rename = "possibleValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub possible_values: ::std::option::Option<Vec<crate::schemas::EnumValuePair>>,
    }
    impl ::google_field_selector::FieldSelector for EnumPropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnumPropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnumPropertyOptionsOrderedRanking {
        #[doc = "This property is ranked in ascending order. Lower values indicate lower ranking."]
        Ascending,
        #[doc = "This property is ranked in descending order. Lower values indicate higher ranking."]
        Descending,
        #[doc = "There is no ranking order for the property. Results aren’t adjusted by this property’s value."]
        NoOrder,
    }
    impl EnumPropertyOptionsOrderedRanking {
        pub fn as_str(self) -> &'static str {
            match self {
                EnumPropertyOptionsOrderedRanking::Ascending => "ASCENDING",
                EnumPropertyOptionsOrderedRanking::Descending => "DESCENDING",
                EnumPropertyOptionsOrderedRanking::NoOrder => "NO_ORDER",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnumPropertyOptionsOrderedRanking {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnumPropertyOptionsOrderedRanking {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<EnumPropertyOptionsOrderedRanking, ()> {
            Ok(match s {
                "ASCENDING" => EnumPropertyOptionsOrderedRanking::Ascending,
                "DESCENDING" => EnumPropertyOptionsOrderedRanking::Descending,
                "NO_ORDER" => EnumPropertyOptionsOrderedRanking::NoOrder,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnumPropertyOptionsOrderedRanking {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnumPropertyOptionsOrderedRanking {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnumPropertyOptionsOrderedRanking {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ASCENDING" => EnumPropertyOptionsOrderedRanking::Ascending,
                "DESCENDING" => EnumPropertyOptionsOrderedRanking::Descending,
                "NO_ORDER" => EnumPropertyOptionsOrderedRanking::NoOrder,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnumPropertyOptionsOrderedRanking {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnumPropertyOptionsOrderedRanking {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnumValuePair {
        #[doc = "The integer value of the EnumValuePair which must be non-negative. Optional."]
        #[serde(
            rename = "integerValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integer_value: ::std::option::Option<i32>,
        #[doc = "The string value of the EnumValuePair. The maximum length is 32 characters."]
        #[serde(
            rename = "stringValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnumValuePair {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnumValuePair {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnumValues {
        #[doc = "The maximum allowable length for string values is 32 characters."]
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for EnumValues {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnumValues {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ErrorInfo {
        #[serde(
            rename = "errorMessages",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_messages: ::std::option::Option<Vec<crate::schemas::ErrorMessage>>,
    }
    impl ::google_field_selector::FieldSelector for ErrorInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ErrorInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ErrorMessage {
        #[serde(
            rename = "errorMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_message: ::std::option::Option<String>,
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source: ::std::option::Option<crate::schemas::Source>,
    }
    impl ::google_field_selector::FieldSelector for ErrorMessage {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ErrorMessage {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EventAnnotation {
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<i32>,
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EventAnnotation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EventAnnotation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EventProto {
        #[doc = "Event IDs consist of alphanumeric characters and colons. Currently required."]
        #[serde(
            rename = "eventId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_id: ::std::option::Option<String>,
        #[doc = "The type of Event members to consider, e.g. “all members” vs. “owners” vs. “admins”. These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See event.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with event. Currently required."]
        #[serde(
            rename = "memberType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub member_type: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for EventProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EventProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct FacetBucket {
        #[doc = "Number of results that match the bucket value. Counts are only returned for searches when count accuracy is ensured. Cloud Search does not guarantee facet counts for any query and facet counts might be present only intermittently, even for identical queries. Do not build dependencies on facet count existence; instead use facet ount percentages which are always returned."]
        #[serde(
            rename = "count",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub count: ::std::option::Option<i32>,
        #[doc = "Filter to be passed in the search request if the corresponding bucket is selected."]
        #[serde(
            rename = "filter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter: ::std::option::Option<crate::schemas::Filter>,
        #[doc = "Percent of results that match the bucket value. The returned value is between (0-100\\], and is rounded down to an integer if fractional. If the value is not explicitly returned, it represents a percentage value that rounds to 0. Percentages are returned for all searches, but are an estimate. Because percentages are always returned, you should render percentages instead of counts."]
        #[serde(
            rename = "percentage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub percentage: ::std::option::Option<i32>,
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<crate::schemas::Value>,
    }
    impl ::google_field_selector::FieldSelector for FacetBucket {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FacetBucket {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FacetOptions {
        #[doc = "If set, describes integer faceting options for the given integer property. The corresponding integer property in the schema should be marked isFacetable. The number of buckets returned would be minimum of this and num_facet_buckets."]
        #[serde(
            rename = "integerFacetingOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integer_faceting_options: ::std::option::Option<crate::schemas::IntegerFacetingOptions>,
        #[doc = "Maximum number of facet buckets that should be returned for this facet. Defaults to 10. Maximum value is 100."]
        #[serde(
            rename = "numFacetBuckets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_facet_buckets: ::std::option::Option<i32>,
        #[doc = "If object_type is set, only those objects of that type will be used to compute facets. If empty, then all objects will be used to compute facets."]
        #[serde(
            rename = "objectType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_type: ::std::option::Option<String>,
        #[doc = "The name of the operator chosen for faceting. @see cloudsearch.SchemaPropertyOptions"]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
        #[doc = "Source name to facet on. Format: datasources/{source_id} If empty, all data sources will be used."]
        #[serde(
            rename = "sourceName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for FacetOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FacetOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct FacetResult {
        #[doc = "FacetBuckets for values in response containing at least a single result with the corresponding filter."]
        #[serde(
            rename = "buckets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub buckets: ::std::option::Option<Vec<crate::schemas::FacetBucket>>,
        #[doc = "Object type for which facet results are returned. Can be empty."]
        #[serde(
            rename = "objectType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_type: ::std::option::Option<String>,
        #[doc = "The name of the operator chosen for faceting. @see cloudsearch.SchemaPropertyOptions"]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
        #[doc = "Source name for which facet results are returned. Will not be empty."]
        #[serde(
            rename = "sourceName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for FacetResult {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FacetResult {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FieldViolation {
        #[doc = "The description of the error."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Path of field with violation."]
        #[serde(
            rename = "field",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub field: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for FieldViolation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FieldViolation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Filter {
        #[serde(
            rename = "compositeFilter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub composite_filter: ::std::option::Option<crate::schemas::CompositeFilter>,
        #[serde(
            rename = "valueFilter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value_filter: ::std::option::Option<crate::schemas::ValueFilter>,
    }
    impl ::google_field_selector::FieldSelector for Filter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Filter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FilterCreated {}
    impl ::google_field_selector::FieldSelector for FilterCreated {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FilterCreated {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FilterDeleted {}
    impl ::google_field_selector::FieldSelector for FilterDeleted {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FilterDeleted {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct FilterOptions {
        #[doc = "Generic filter to restrict the search, such as `lang:en`, `site:xyz`."]
        #[serde(
            rename = "filter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter: ::std::option::Option<crate::schemas::Filter>,
        #[doc = "If object_type is set, only objects of that type are returned. This should correspond to the name of the object that was registered within the definition of schema. The maximum length is 256 characters."]
        #[serde(
            rename = "objectType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_type: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for FilterOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FilterOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FilterUpdate {
        #[serde(
            rename = "filterCreated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter_created: ::std::option::Option<crate::schemas::FilterCreated>,
        #[serde(
            rename = "filterDeleted",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter_deleted: ::std::option::Option<crate::schemas::FilterDeleted>,
        #[serde(
            rename = "filterId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for FilterUpdate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FilterUpdate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FixedFooter {
        #[serde(
            rename = "buttons",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub buttons: ::std::option::Option<Vec<crate::schemas::Button>>,
        #[serde(
            rename = "primaryButton",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub primary_button: ::std::option::Option<crate::schemas::TextButton>,
        #[serde(
            rename = "secondaryButton",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub secondary_button: ::std::option::Option<crate::schemas::TextButton>,
    }
    impl ::google_field_selector::FieldSelector for FixedFooter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FixedFooter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Folder {
        #[doc = "Folder mapping id."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub id: ::std::option::Option<u64>,
        #[doc = "One for each copy of the message in the IMAP folder."]
        #[serde(
            rename = "message",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message:
            ::std::option::Option<Vec<crate::schemas::ImapsyncFolderAttributeFolderMessage>>,
    }
    impl ::google_field_selector::FieldSelector for Folder {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Folder {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FolderAttribute {
        #[doc = "List of all IMAP folders where the message presents."]
        #[serde(
            rename = "folder",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub folder: ::std::option::Option<Vec<crate::schemas::Folder>>,
    }
    impl ::google_field_selector::FieldSelector for FolderAttribute {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FolderAttribute {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FormAction {
        #[doc = "Apps script function that should be invoked in the developer’s apps script when the containing element is clicked/activated."]
        #[serde(
            rename = "actionMethodName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_method_name: ::std::option::Option<String>,
        #[serde(
            rename = "loadIndicator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub load_indicator: ::std::option::Option<crate::schemas::FormActionLoadIndicator>,
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<Vec<crate::schemas::ActionParameter>>,
        #[doc = "Indicates whether form values persist after the action. When false, the Apps Script is responsible for persisting values, by setting any form field values using the formInputs in the event. Disabling this behavior can be used if the add-on needs the ability to clear form fields, for example, as with persistent values, there is no means for clearing existing values. When disabling persistent values, it is strongly recommended that the add-on use LoadIndicator.SPINNER for all events, as this locks the UI to ensure no changes are made by the user while the action is being processed. When using LoadIndicator.NONE for any of the actions, persistent values are recommended, as it ensures that any changes made by the user after form / on change actions are sent to the server are not overwritten by the response. Persistent values disabled by default. While we recommend persistent values be used in the typical use case, we do not enable by default, as doing so would change the current behavior of existing add-ons in prod."]
        #[serde(
            rename = "persistValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub persist_values: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for FormAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FormAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FormActionLoadIndicator {
        None,
        Spinner,
    }
    impl FormActionLoadIndicator {
        pub fn as_str(self) -> &'static str {
            match self {
                FormActionLoadIndicator::None => "NONE",
                FormActionLoadIndicator::Spinner => "SPINNER",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FormActionLoadIndicator {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FormActionLoadIndicator {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FormActionLoadIndicator, ()> {
            Ok(match s {
                "NONE" => FormActionLoadIndicator::None,
                "SPINNER" => FormActionLoadIndicator::Spinner,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FormActionLoadIndicator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FormActionLoadIndicator {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FormActionLoadIndicator {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NONE" => FormActionLoadIndicator::None,
                "SPINNER" => FormActionLoadIndicator::Spinner,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FormActionLoadIndicator {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FormActionLoadIndicator {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FormatMetadata {
        #[doc = "Font color is set if and only if format_type is FONT_COLOR. The components are stored as (alpha \\<\\< 24) | (red \\<\\< 16) | (green \\<\\< 8) | blue. Clients should always set the alpha component to 0xFF. NEXT TAG: 3"]
        #[serde(
            rename = "fontColor",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub font_color: ::std::option::Option<u32>,
        #[doc = "LINT.ThenChange(//depot/google3/apps/dynamite/v1/web/datakeys/annotated_span.proto)"]
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub format_type: ::std::option::Option<crate::schemas::FormatMetadataFormatType>,
    }
    impl ::google_field_selector::FieldSelector for FormatMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FormatMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FormatMetadataFormatType {
        Bold,
        #[doc = "Encloses BULLETED_LIST_ITEM annotations."]
        BulletedList,
        #[doc = "Must cover the whole line including the newline"]
        BulletedListItem,
        #[doc = "character at the end. Not used anymore."]
        ClientHidden,
        FontColor,
        Hidden,
        Italic,
        #[doc = "Inline monospace."]
        Monospace,
        #[doc = "Multi-line monospace block."]
        MonospaceBlock,
        SourceCode,
        Strike,
        #[doc = "Default value for the enum."]
        TypeUnspecified,
        Underline,
    }
    impl FormatMetadataFormatType {
        pub fn as_str(self) -> &'static str {
            match self {
                FormatMetadataFormatType::Bold => "BOLD",
                FormatMetadataFormatType::BulletedList => "BULLETED_LIST",
                FormatMetadataFormatType::BulletedListItem => "BULLETED_LIST_ITEM",
                FormatMetadataFormatType::ClientHidden => "CLIENT_HIDDEN",
                FormatMetadataFormatType::FontColor => "FONT_COLOR",
                FormatMetadataFormatType::Hidden => "HIDDEN",
                FormatMetadataFormatType::Italic => "ITALIC",
                FormatMetadataFormatType::Monospace => "MONOSPACE",
                FormatMetadataFormatType::MonospaceBlock => "MONOSPACE_BLOCK",
                FormatMetadataFormatType::SourceCode => "SOURCE_CODE",
                FormatMetadataFormatType::Strike => "STRIKE",
                FormatMetadataFormatType::TypeUnspecified => "TYPE_UNSPECIFIED",
                FormatMetadataFormatType::Underline => "UNDERLINE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FormatMetadataFormatType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FormatMetadataFormatType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FormatMetadataFormatType, ()> {
            Ok(match s {
                "BOLD" => FormatMetadataFormatType::Bold,
                "BULLETED_LIST" => FormatMetadataFormatType::BulletedList,
                "BULLETED_LIST_ITEM" => FormatMetadataFormatType::BulletedListItem,
                "CLIENT_HIDDEN" => FormatMetadataFormatType::ClientHidden,
                "FONT_COLOR" => FormatMetadataFormatType::FontColor,
                "HIDDEN" => FormatMetadataFormatType::Hidden,
                "ITALIC" => FormatMetadataFormatType::Italic,
                "MONOSPACE" => FormatMetadataFormatType::Monospace,
                "MONOSPACE_BLOCK" => FormatMetadataFormatType::MonospaceBlock,
                "SOURCE_CODE" => FormatMetadataFormatType::SourceCode,
                "STRIKE" => FormatMetadataFormatType::Strike,
                "TYPE_UNSPECIFIED" => FormatMetadataFormatType::TypeUnspecified,
                "UNDERLINE" => FormatMetadataFormatType::Underline,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FormatMetadataFormatType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FormatMetadataFormatType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FormatMetadataFormatType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOLD" => FormatMetadataFormatType::Bold,
                "BULLETED_LIST" => FormatMetadataFormatType::BulletedList,
                "BULLETED_LIST_ITEM" => FormatMetadataFormatType::BulletedListItem,
                "CLIENT_HIDDEN" => FormatMetadataFormatType::ClientHidden,
                "FONT_COLOR" => FormatMetadataFormatType::FontColor,
                "HIDDEN" => FormatMetadataFormatType::Hidden,
                "ITALIC" => FormatMetadataFormatType::Italic,
                "MONOSPACE" => FormatMetadataFormatType::Monospace,
                "MONOSPACE_BLOCK" => FormatMetadataFormatType::MonospaceBlock,
                "SOURCE_CODE" => FormatMetadataFormatType::SourceCode,
                "STRIKE" => FormatMetadataFormatType::Strike,
                "TYPE_UNSPECIFIED" => FormatMetadataFormatType::TypeUnspecified,
                "UNDERLINE" => FormatMetadataFormatType::Underline,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FormatMetadataFormatType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FormatMetadataFormatType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Formatting {
        #[serde(
            rename = "bold",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bold: ::std::option::Option<bool>,
        #[doc = "This indicates that the segment should be rendered as highlighted or visually emphasized."]
        #[serde(
            rename = "highlight",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub highlight: ::std::option::Option<bool>,
        #[serde(
            rename = "italics",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub italics: ::std::option::Option<bool>,
        #[serde(
            rename = "strikethrough",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub strikethrough: ::std::option::Option<bool>,
        #[doc = "If set, this indicates that the segment should be rendered with the specified style. The absence of an explicit style represents “no style”, i.e. the segment can be rendered with the default style chosen by the application."]
        #[serde(
            rename = "style",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub style: ::std::option::Option<crate::schemas::FormattingStyle>,
        #[serde(
            rename = "underline",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub underline: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for Formatting {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Formatting {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FormattingStyle {
        #[doc = "The most important heading to the least important heading."]
        Heading1,
        Heading2,
        Heading3,
        Heading4,
        #[doc = "This represents a style that is unknown (e.g. a new style was introduced but not supported by older mobile app versions) and should generally not be used as a value in a proto. If the segment does not need to be rendered with a special style, the ‘style’ field should simply be left unset. A reasonable fallback for an unknown style is to render the segment in the default style."]
        UnknownStyle,
    }
    impl FormattingStyle {
        pub fn as_str(self) -> &'static str {
            match self {
                FormattingStyle::Heading1 => "HEADING_1",
                FormattingStyle::Heading2 => "HEADING_2",
                FormattingStyle::Heading3 => "HEADING_3",
                FormattingStyle::Heading4 => "HEADING_4",
                FormattingStyle::UnknownStyle => "UNKNOWN_STYLE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FormattingStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FormattingStyle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FormattingStyle, ()> {
            Ok(match s {
                "HEADING_1" => FormattingStyle::Heading1,
                "HEADING_2" => FormattingStyle::Heading2,
                "HEADING_3" => FormattingStyle::Heading3,
                "HEADING_4" => FormattingStyle::Heading4,
                "UNKNOWN_STYLE" => FormattingStyle::UnknownStyle,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FormattingStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FormattingStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FormattingStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "HEADING_1" => FormattingStyle::Heading1,
                "HEADING_2" => FormattingStyle::Heading2,
                "HEADING_3" => FormattingStyle::Heading3,
                "HEADING_4" => FormattingStyle::Heading4,
                "UNKNOWN_STYLE" => FormattingStyle::UnknownStyle,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FormattingStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FormattingStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FreshnessOptions {
        #[doc = "The duration after which an object should be considered stale. The default value is 180 days (in seconds)."]
        #[serde(
            rename = "freshnessDuration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub freshness_duration: ::std::option::Option<String>,
        #[doc = "This property indicates the freshness level of the object in the index. If set, this property must be a top-level property within the property definitions and it must be a timestamp type or date type. Otherwise, the Indexing API uses updateTime as the freshness indicator. The maximum length is 256 characters. When a property is used to calculate freshness, the value defaults to 2 years from the current time."]
        #[serde(
            rename = "freshnessProperty",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub freshness_property: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for FreshnessOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FreshnessOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FuseboxItem {
        #[serde(
            rename = "attributes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attributes: ::std::option::Option<crate::schemas::Attributes>,
        #[doc = "The creation time of the Item in micro seconds."]
        #[serde(
            rename = "creationTimeMicroseconds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub creation_time_microseconds: ::std::option::Option<u64>,
        #[serde(
            rename = "history",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub history: ::std::option::Option<crate::schemas::History>,
        #[doc = "The key is used to refer to an item. Note that every field of the MultiKey is unique to the Item, and thus the Item can be looked up by any of the fields."]
        #[serde(
            rename = "itemKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item_key: ::std::option::Option<crate::schemas::MultiKey>,
        #[serde(
            rename = "labels",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub labels: ::std::option::Option<crate::schemas::Labels>,
        #[doc = "The modification time of the Item in micro seconds. Modifications to the message include label addition, deletion, etc."]
        #[serde(
            rename = "lastModificationTimeUs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_modification_time_us: ::std::option::Option<u64>,
        #[doc = "go/lockpicker Locker counterpart of references."]
        #[serde(
            rename = "lockerReferences",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub locker_references: ::std::option::Option<crate::schemas::References>,
        #[serde(
            rename = "matchInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub match_info: ::std::option::Option<crate::schemas::MatchInfo>,
        #[doc = "Type-specific data are represented as extensions to the ItemParts message."]
        #[serde(
            rename = "parts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parts: ::std::option::Option<crate::schemas::ItemParts>,
        #[doc = "The read timestamp at which this item was read. This is a temporary field used to check if two items streamed during dual reading were read at the same timestamp. This will be populated by Fusebox RPCs. “DO NOT USE UNLESS YOU TALK TO FUSEBOX TEAM (gmail-fusebox@)”."]
        #[serde(
            rename = "readTs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub read_ts: ::std::option::Option<i64>,
        #[doc = "References to attachments, video attachments in Youtube and Hangout messages."]
        #[serde(
            rename = "references",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub references: ::std::option::Option<crate::schemas::References>,
        #[doc = "The snippet is a brief bit of text describing this item."]
        #[serde(
            rename = "snippet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snippet: ::std::option::Option<String>,
        #[doc = "The key of the Thread with which this Item is associated."]
        #[serde(
            rename = "threadKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_key: ::std::option::Option<crate::schemas::MultiKey>,
        #[doc = "A base64 encoded and encrypted string generated from the Gaia Id and the thread id. Used to generate the permalink for this thread, exposed from Gmail API."]
        #[serde(
            rename = "threadLocator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_locator: ::std::option::Option<String>,
        #[serde(
            rename = "triggers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub triggers: ::std::option::Option<crate::schemas::Triggers>,
        #[doc = "The latest history operation id that resulted in a mutation of the item."]
        #[serde(
            rename = "version",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub version: ::std::option::Option<u64>,
    }
    impl ::google_field_selector::FieldSelector for FuseboxItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FuseboxItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FuseboxItemThreadMatchInfo {
        #[doc = "If SearchQuery.Options.Clustering is present, the query will be treated as a cluster query, and this field may be populated with the cluster ID of the cluster to which this thread belongs, if any. The cluster ID will be a label on the message."]
        #[serde(
            rename = "clusterId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cluster_id: ::std::option::Option<String>,
        #[doc = "The server id of the last item that matched the query. This is always set, regardless of the compute_matching_items_per_thread option. This is the value by which search results are sorted, in descending (i.e. newest first) order."]
        #[serde(
            rename = "lastMatchingItemId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_matching_item_id: ::std::option::Option<u64>,
        #[doc = "The MultiKey of the last item that matched the query. This is always set, regardless of the compute_matching_items_per_thread option. This is the value by which search results are sorted, in descending (i.e. newest first) order."]
        #[serde(
            rename = "lastMatchingItemKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_matching_item_key: ::std::option::Option<crate::schemas::MultiKey>,
        #[doc = "If SearchQuery.Options.compute_matching_items_per_thread, this field will contain the keys of all items that matched the query, in ascending order. Note that this option requires extra computation."]
        #[serde(
            rename = "matchingItemKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub matching_item_key: ::std::option::Option<Vec<crate::schemas::MultiKey>>,
        #[doc = "The rank of this ItemThread in the result set of the query. This rank may be used to sort ItemThreads in proper order. Ranks are specific to a query, and stable for a given query at a specific time."]
        #[serde(
            rename = "rank",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rank: ::std::option::Option<crate::schemas::Rank>,
    }
    impl ::google_field_selector::FieldSelector for FuseboxItemThreadMatchInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FuseboxItemThreadMatchInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FuseboxPrefUpdatePreState {
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector for FuseboxPrefUpdatePreState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FuseboxPrefUpdatePreState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GaiaGroupProto {
        #[serde(
            rename = "groupId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub group_id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for GaiaGroupProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GaiaGroupProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GaiaUserProto {
        #[serde(
            rename = "userId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub user_id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for GaiaUserProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GaiaUserProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GatewayAccess {
        #[doc = "Whether third-party gateway accesses are enabled for this meeting space. If enabled, the actual access code can be retrieved by calling the GetGatewayAccess RPC method."]
        #[serde(
            rename = "enabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enabled: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for GatewayAccess {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GatewayAccess {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GatewaySipAccess {
        #[doc = "Permanent numeric code for manual entry on specially configured devices, currently the same as the PSTN “Universal pin”."]
        #[serde(
            rename = "sipAccessCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sip_access_code: ::std::option::Option<String>,
        #[doc = "The SIP URI the conference can be reached through. The string is on one of the formats: “sip:@” “sips:@” where currently is the 13-digit universal pin (with the future option to support using a Meet meeting code as well), and is a valid address to be resolved using a DNS SRV lookup, or a dotted quad."]
        #[serde(
            rename = "uri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GatewaySipAccess {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GatewaySipAccess {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetCustomerIndexStatsResponse {
        #[doc = "Average item count for the given date range for which billing is done."]
        #[serde(
            rename = "averageIndexedItemCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub average_indexed_item_count: ::std::option::Option<i64>,
        #[doc = "Summary of indexed item counts, one for each day in the requested range."]
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::CustomerIndexStats>>,
    }
    impl ::google_field_selector::FieldSelector for GetCustomerIndexStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetCustomerIndexStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetCustomerQueryStatsResponse {
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::CustomerQueryStats>>,
        #[doc = "Total successful query count (status code 200) for the given date range."]
        #[serde(
            rename = "totalQueryCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub total_query_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for GetCustomerQueryStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetCustomerQueryStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetCustomerSearchApplicationStatsResponse {
        #[doc = "Average search application count for the given date range."]
        #[serde(
            rename = "averageSearchApplicationCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub average_search_application_count: ::std::option::Option<i64>,
        #[doc = "Search application stats by date."]
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::CustomerSearchApplicationStats>>,
    }
    impl ::google_field_selector::FieldSelector for GetCustomerSearchApplicationStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetCustomerSearchApplicationStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetCustomerSessionStatsResponse {
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::CustomerSessionStats>>,
    }
    impl ::google_field_selector::FieldSelector for GetCustomerSessionStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetCustomerSessionStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetCustomerUserStatsResponse {
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::CustomerUserStats>>,
    }
    impl ::google_field_selector::FieldSelector for GetCustomerUserStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetCustomerUserStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetDataSourceIndexStatsResponse {
        #[doc = "Average item count for the given date range for which billing is done."]
        #[serde(
            rename = "averageIndexedItemCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub average_indexed_item_count: ::std::option::Option<i64>,
        #[doc = "Summary of indexed item counts, one for each day in the requested range."]
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::DataSourceIndexStats>>,
    }
    impl ::google_field_selector::FieldSelector for GetDataSourceIndexStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetDataSourceIndexStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetSearchApplicationQueryStatsResponse {
        #[doc = "Query stats per date for a search application."]
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::SearchApplicationQueryStats>>,
        #[doc = "Total successful query count (status code 200) for the given date range."]
        #[serde(
            rename = "totalQueryCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub total_query_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for GetSearchApplicationQueryStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetSearchApplicationQueryStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetSearchApplicationSessionStatsResponse {
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::SearchApplicationSessionStats>>,
    }
    impl ::google_field_selector::FieldSelector for GetSearchApplicationSessionStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetSearchApplicationSessionStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GetSearchApplicationUserStatsResponse {
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<Vec<crate::schemas::SearchApplicationUserStats>>,
    }
    impl ::google_field_selector::FieldSelector for GetSearchApplicationUserStatsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetSearchApplicationUserStatsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GmailClientActionMarkup {
        #[serde(
            rename = "addonComposeUiActionMarkup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub addon_compose_ui_action_markup:
            ::std::option::Option<crate::schemas::AddonComposeUiActionMarkup>,
        #[serde(
            rename = "openCreatedDraftActionMarkup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub open_created_draft_action_markup:
            ::std::option::Option<crate::schemas::OpenCreatedDraftActionMarkup>,
        #[serde(
            rename = "taskAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_action: ::std::option::Option<crate::schemas::TaskActionMarkup>,
        #[serde(
            rename = "updateDraftActionMarkup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_draft_action_markup:
            ::std::option::Option<crate::schemas::UpdateDraftActionMarkup>,
    }
    impl ::google_field_selector::FieldSelector for GmailClientActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GmailClientActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleChatV1ContextualAddOnMarkup {
        #[doc = "A list of cards. A card must contain a header and at least 1 section."]
        #[serde(
            rename = "cards",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cards:
            ::std::option::Option<Vec<crate::schemas::GoogleChatV1ContextualAddOnMarkupCard>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1ContextualAddOnMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1ContextualAddOnMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleChatV1ContextualAddOnMarkupCard {
        #[doc = "The actions of this card."]
        #[serde(
            rename = "cardActions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub card_actions: ::std::option::Option<
            Vec<crate::schemas::GoogleChatV1ContextualAddOnMarkupCardCardAction>,
        >,
        #[doc = "The header of the card. A header usually contains a title and an image."]
        #[serde(
            rename = "header",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub header:
            ::std::option::Option<crate::schemas::GoogleChatV1ContextualAddOnMarkupCardCardHeader>,
        #[doc = "Name of the card."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Sections are separated by a line divider."]
        #[serde(
            rename = "sections",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sections: ::std::option::Option<
            Vec<crate::schemas::GoogleChatV1ContextualAddOnMarkupCardSection>,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1ContextualAddOnMarkupCard {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1ContextualAddOnMarkupCard {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1ContextualAddOnMarkupCardCardAction {
        #[doc = "The label used to be displayed in the action menu item."]
        #[serde(
            rename = "actionLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_label: ::std::option::Option<String>,
        #[doc = "The onclick action for this action item."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupOnClick>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1ContextualAddOnMarkupCardCardAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1ContextualAddOnMarkupCardCardAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1ContextualAddOnMarkupCardCardHeader {
        #[doc = "The image’s type (e.g. square border or circular border)."]
        #[serde(
            rename = "imageStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_style: ::std::option::Option<
            crate::schemas::GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle,
        >,
        #[doc = "The URL of the image in the card header."]
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
        #[doc = "The subtitle of the card header."]
        #[serde(
            rename = "subtitle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub subtitle: ::std::option::Option<String>,
        #[doc = "The title must be specified. The header has a fixed height: if both a title and subtitle is specified, each will take up 1 line. If only the title is specified, it will take up both lines."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1ContextualAddOnMarkupCardCardHeader {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1ContextualAddOnMarkupCardCardHeader {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle {
        #[doc = "Circular border."]
        Avatar,
        #[doc = "Square border."]
        Image,
        ImageStyleUnspecified,
    }
    impl GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle {
        pub fn as_str(self) -> &'static str {
            match self { GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle :: Avatar => "AVATAR" , GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle :: Image => "IMAGE" , GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle :: ImageStyleUnspecified => "IMAGE_STYLE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle, ()>
        {
            Ok(match s {
                "AVATAR" => GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle::Avatar,
                "IMAGE" => GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle::Image,
                "IMAGE_STYLE_UNSPECIFIED" => {
                    GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle::ImageStyleUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AVATAR" => GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle::Avatar,
                "IMAGE" => GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle::Image,
                "IMAGE_STYLE_UNSPECIFIED" => {
                    GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle::ImageStyleUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleChatV1ContextualAddOnMarkupCardCardHeaderImageStyle
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleChatV1ContextualAddOnMarkupCardSection {
        #[doc = "The header of the section, text formatted supported."]
        #[serde(
            rename = "header",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub header: ::std::option::Option<String>,
        #[doc = "A section must contain at least 1 widget."]
        #[serde(
            rename = "widgets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub widgets: ::std::option::Option<Vec<crate::schemas::GoogleChatV1WidgetMarkup>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1ContextualAddOnMarkupCardSection {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1ContextualAddOnMarkupCardSection {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkup {
        #[doc = "A list of buttons. Buttons is also oneof data and only one of these fields should be set."]
        #[serde(
            rename = "buttons",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub buttons: ::std::option::Option<Vec<crate::schemas::GoogleChatV1WidgetMarkupButton>>,
        #[doc = "Display an image in this widget."]
        #[serde(
            rename = "image",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupImage>,
        #[doc = "Display a key value item in this widget."]
        #[serde(
            rename = "keyValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key_value: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupKeyValue>,
        #[doc = "Display a text paragraph in this widget."]
        #[serde(
            rename = "textParagraph",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_paragraph:
            ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupTextParagraph>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupButton {
        #[doc = "A button with image and onclick action."]
        #[serde(
            rename = "imageButton",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_button:
            ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupImageButton>,
        #[doc = "A button with text and onclick action."]
        #[serde(
            rename = "textButton",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_button: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupTextButton>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupButton {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupButton {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupFormAction {
        #[doc = "The method name is used to identify which part of the form triggered the form submission. This information is echoed back to the Chat app as part of the card click event. The same method name can be used for several elements that trigger a common behavior if desired."]
        #[serde(
            rename = "actionMethodName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_method_name: ::std::option::Option<String>,
        #[doc = "List of action parameters."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            Vec<crate::schemas::GoogleChatV1WidgetMarkupFormActionActionParameter>,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupFormAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupFormAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupFormActionActionParameter {
        #[doc = "The name of the parameter for the action script."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "The value of the parameter."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupFormActionActionParameter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupFormActionActionParameter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupImage {
        #[doc = "The aspect ratio of this image (width/height). This field allows clients to reserve the right height for the image while waiting for it to load. It’s not meant to override the native aspect ratio of the image. If unset, the server fills it by prefetching the image."]
        #[serde(
            rename = "aspectRatio",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub aspect_ratio: ::std::option::Option<f64>,
        #[doc = "The URL of the image."]
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
        #[doc = "The onclick action."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupOnClick>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupImage {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupImage {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupImageButton {
        #[doc = "The icon specified by an enum that indices to an icon provided by Chat API."]
        #[serde(
            rename = "icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupImageButtonIcon>,
        #[doc = "The icon specified by a URL."]
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[doc = "The name of this image_button which will be used for accessibility. Default value will be provided if developers don’t specify."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The onclick action."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupOnClick>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupImageButton {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupImageButton {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleChatV1WidgetMarkupImageButtonIcon {
        Airplane,
        Bookmark,
        Bus,
        Car,
        Clock,
        ConfirmationNumberIcon,
        Description,
        Dollar,
        Email,
        EventPerformer,
        EventSeat,
        FlightArrival,
        FlightDeparture,
        Hotel,
        HotelRoomType,
        IconUnspecified,
        Invite,
        MapPin,
        Membership,
        MultiplePeople,
        Offer,
        Person,
        Phone,
        RestaurantIcon,
        ShoppingCart,
        Star,
        Store,
        Ticket,
        Train,
        VideoCamera,
        VideoPlay,
    }
    impl GoogleChatV1WidgetMarkupImageButtonIcon {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleChatV1WidgetMarkupImageButtonIcon::Airplane => "AIRPLANE",
                GoogleChatV1WidgetMarkupImageButtonIcon::Bookmark => "BOOKMARK",
                GoogleChatV1WidgetMarkupImageButtonIcon::Bus => "BUS",
                GoogleChatV1WidgetMarkupImageButtonIcon::Car => "CAR",
                GoogleChatV1WidgetMarkupImageButtonIcon::Clock => "CLOCK",
                GoogleChatV1WidgetMarkupImageButtonIcon::ConfirmationNumberIcon => {
                    "CONFIRMATION_NUMBER_ICON"
                }
                GoogleChatV1WidgetMarkupImageButtonIcon::Description => "DESCRIPTION",
                GoogleChatV1WidgetMarkupImageButtonIcon::Dollar => "DOLLAR",
                GoogleChatV1WidgetMarkupImageButtonIcon::Email => "EMAIL",
                GoogleChatV1WidgetMarkupImageButtonIcon::EventPerformer => "EVENT_PERFORMER",
                GoogleChatV1WidgetMarkupImageButtonIcon::EventSeat => "EVENT_SEAT",
                GoogleChatV1WidgetMarkupImageButtonIcon::FlightArrival => "FLIGHT_ARRIVAL",
                GoogleChatV1WidgetMarkupImageButtonIcon::FlightDeparture => "FLIGHT_DEPARTURE",
                GoogleChatV1WidgetMarkupImageButtonIcon::Hotel => "HOTEL",
                GoogleChatV1WidgetMarkupImageButtonIcon::HotelRoomType => "HOTEL_ROOM_TYPE",
                GoogleChatV1WidgetMarkupImageButtonIcon::IconUnspecified => "ICON_UNSPECIFIED",
                GoogleChatV1WidgetMarkupImageButtonIcon::Invite => "INVITE",
                GoogleChatV1WidgetMarkupImageButtonIcon::MapPin => "MAP_PIN",
                GoogleChatV1WidgetMarkupImageButtonIcon::Membership => "MEMBERSHIP",
                GoogleChatV1WidgetMarkupImageButtonIcon::MultiplePeople => "MULTIPLE_PEOPLE",
                GoogleChatV1WidgetMarkupImageButtonIcon::Offer => "OFFER",
                GoogleChatV1WidgetMarkupImageButtonIcon::Person => "PERSON",
                GoogleChatV1WidgetMarkupImageButtonIcon::Phone => "PHONE",
                GoogleChatV1WidgetMarkupImageButtonIcon::RestaurantIcon => "RESTAURANT_ICON",
                GoogleChatV1WidgetMarkupImageButtonIcon::ShoppingCart => "SHOPPING_CART",
                GoogleChatV1WidgetMarkupImageButtonIcon::Star => "STAR",
                GoogleChatV1WidgetMarkupImageButtonIcon::Store => "STORE",
                GoogleChatV1WidgetMarkupImageButtonIcon::Ticket => "TICKET",
                GoogleChatV1WidgetMarkupImageButtonIcon::Train => "TRAIN",
                GoogleChatV1WidgetMarkupImageButtonIcon::VideoCamera => "VIDEO_CAMERA",
                GoogleChatV1WidgetMarkupImageButtonIcon::VideoPlay => "VIDEO_PLAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleChatV1WidgetMarkupImageButtonIcon {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleChatV1WidgetMarkupImageButtonIcon {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GoogleChatV1WidgetMarkupImageButtonIcon, ()> {
            Ok(match s {
                "AIRPLANE" => GoogleChatV1WidgetMarkupImageButtonIcon::Airplane,
                "BOOKMARK" => GoogleChatV1WidgetMarkupImageButtonIcon::Bookmark,
                "BUS" => GoogleChatV1WidgetMarkupImageButtonIcon::Bus,
                "CAR" => GoogleChatV1WidgetMarkupImageButtonIcon::Car,
                "CLOCK" => GoogleChatV1WidgetMarkupImageButtonIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => {
                    GoogleChatV1WidgetMarkupImageButtonIcon::ConfirmationNumberIcon
                }
                "DESCRIPTION" => GoogleChatV1WidgetMarkupImageButtonIcon::Description,
                "DOLLAR" => GoogleChatV1WidgetMarkupImageButtonIcon::Dollar,
                "EMAIL" => GoogleChatV1WidgetMarkupImageButtonIcon::Email,
                "EVENT_PERFORMER" => GoogleChatV1WidgetMarkupImageButtonIcon::EventPerformer,
                "EVENT_SEAT" => GoogleChatV1WidgetMarkupImageButtonIcon::EventSeat,
                "FLIGHT_ARRIVAL" => GoogleChatV1WidgetMarkupImageButtonIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => GoogleChatV1WidgetMarkupImageButtonIcon::FlightDeparture,
                "HOTEL" => GoogleChatV1WidgetMarkupImageButtonIcon::Hotel,
                "HOTEL_ROOM_TYPE" => GoogleChatV1WidgetMarkupImageButtonIcon::HotelRoomType,
                "ICON_UNSPECIFIED" => GoogleChatV1WidgetMarkupImageButtonIcon::IconUnspecified,
                "INVITE" => GoogleChatV1WidgetMarkupImageButtonIcon::Invite,
                "MAP_PIN" => GoogleChatV1WidgetMarkupImageButtonIcon::MapPin,
                "MEMBERSHIP" => GoogleChatV1WidgetMarkupImageButtonIcon::Membership,
                "MULTIPLE_PEOPLE" => GoogleChatV1WidgetMarkupImageButtonIcon::MultiplePeople,
                "OFFER" => GoogleChatV1WidgetMarkupImageButtonIcon::Offer,
                "PERSON" => GoogleChatV1WidgetMarkupImageButtonIcon::Person,
                "PHONE" => GoogleChatV1WidgetMarkupImageButtonIcon::Phone,
                "RESTAURANT_ICON" => GoogleChatV1WidgetMarkupImageButtonIcon::RestaurantIcon,
                "SHOPPING_CART" => GoogleChatV1WidgetMarkupImageButtonIcon::ShoppingCart,
                "STAR" => GoogleChatV1WidgetMarkupImageButtonIcon::Star,
                "STORE" => GoogleChatV1WidgetMarkupImageButtonIcon::Store,
                "TICKET" => GoogleChatV1WidgetMarkupImageButtonIcon::Ticket,
                "TRAIN" => GoogleChatV1WidgetMarkupImageButtonIcon::Train,
                "VIDEO_CAMERA" => GoogleChatV1WidgetMarkupImageButtonIcon::VideoCamera,
                "VIDEO_PLAY" => GoogleChatV1WidgetMarkupImageButtonIcon::VideoPlay,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleChatV1WidgetMarkupImageButtonIcon {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleChatV1WidgetMarkupImageButtonIcon {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleChatV1WidgetMarkupImageButtonIcon {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AIRPLANE" => GoogleChatV1WidgetMarkupImageButtonIcon::Airplane,
                "BOOKMARK" => GoogleChatV1WidgetMarkupImageButtonIcon::Bookmark,
                "BUS" => GoogleChatV1WidgetMarkupImageButtonIcon::Bus,
                "CAR" => GoogleChatV1WidgetMarkupImageButtonIcon::Car,
                "CLOCK" => GoogleChatV1WidgetMarkupImageButtonIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => {
                    GoogleChatV1WidgetMarkupImageButtonIcon::ConfirmationNumberIcon
                }
                "DESCRIPTION" => GoogleChatV1WidgetMarkupImageButtonIcon::Description,
                "DOLLAR" => GoogleChatV1WidgetMarkupImageButtonIcon::Dollar,
                "EMAIL" => GoogleChatV1WidgetMarkupImageButtonIcon::Email,
                "EVENT_PERFORMER" => GoogleChatV1WidgetMarkupImageButtonIcon::EventPerformer,
                "EVENT_SEAT" => GoogleChatV1WidgetMarkupImageButtonIcon::EventSeat,
                "FLIGHT_ARRIVAL" => GoogleChatV1WidgetMarkupImageButtonIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => GoogleChatV1WidgetMarkupImageButtonIcon::FlightDeparture,
                "HOTEL" => GoogleChatV1WidgetMarkupImageButtonIcon::Hotel,
                "HOTEL_ROOM_TYPE" => GoogleChatV1WidgetMarkupImageButtonIcon::HotelRoomType,
                "ICON_UNSPECIFIED" => GoogleChatV1WidgetMarkupImageButtonIcon::IconUnspecified,
                "INVITE" => GoogleChatV1WidgetMarkupImageButtonIcon::Invite,
                "MAP_PIN" => GoogleChatV1WidgetMarkupImageButtonIcon::MapPin,
                "MEMBERSHIP" => GoogleChatV1WidgetMarkupImageButtonIcon::Membership,
                "MULTIPLE_PEOPLE" => GoogleChatV1WidgetMarkupImageButtonIcon::MultiplePeople,
                "OFFER" => GoogleChatV1WidgetMarkupImageButtonIcon::Offer,
                "PERSON" => GoogleChatV1WidgetMarkupImageButtonIcon::Person,
                "PHONE" => GoogleChatV1WidgetMarkupImageButtonIcon::Phone,
                "RESTAURANT_ICON" => GoogleChatV1WidgetMarkupImageButtonIcon::RestaurantIcon,
                "SHOPPING_CART" => GoogleChatV1WidgetMarkupImageButtonIcon::ShoppingCart,
                "STAR" => GoogleChatV1WidgetMarkupImageButtonIcon::Star,
                "STORE" => GoogleChatV1WidgetMarkupImageButtonIcon::Store,
                "TICKET" => GoogleChatV1WidgetMarkupImageButtonIcon::Ticket,
                "TRAIN" => GoogleChatV1WidgetMarkupImageButtonIcon::Train,
                "VIDEO_CAMERA" => GoogleChatV1WidgetMarkupImageButtonIcon::VideoCamera,
                "VIDEO_PLAY" => GoogleChatV1WidgetMarkupImageButtonIcon::VideoPlay,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupImageButtonIcon {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupImageButtonIcon {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupKeyValue {
        #[doc = "The text of the bottom label. Formatted text supported."]
        #[serde(
            rename = "bottomLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bottom_label: ::std::option::Option<String>,
        #[doc = "A button that can be clicked to trigger an action."]
        #[serde(
            rename = "button",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub button: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupButton>,
        #[doc = "The text of the content. Formatted text supported and always required."]
        #[serde(
            rename = "content",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content: ::std::option::Option<String>,
        #[doc = "If the content should be multiline."]
        #[serde(
            rename = "contentMultiline",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_multiline: ::std::option::Option<bool>,
        #[doc = "An enum value that will be replaced by the Chat API with the corresponding icon image."]
        #[serde(
            rename = "icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupKeyValueIcon>,
        #[doc = "The icon specified by a URL."]
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[doc = "The onclick action. Only the top label, bottom label and content region are clickable."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupOnClick>,
        #[doc = "The text of the top label. Formatted text supported."]
        #[serde(
            rename = "topLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub top_label: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupKeyValue {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupKeyValue {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleChatV1WidgetMarkupKeyValueIcon {
        Airplane,
        Bookmark,
        Bus,
        Car,
        Clock,
        ConfirmationNumberIcon,
        Description,
        Dollar,
        Email,
        EventPerformer,
        EventSeat,
        FlightArrival,
        FlightDeparture,
        Hotel,
        HotelRoomType,
        IconUnspecified,
        Invite,
        MapPin,
        Membership,
        MultiplePeople,
        Offer,
        Person,
        Phone,
        RestaurantIcon,
        ShoppingCart,
        Star,
        Store,
        Ticket,
        Train,
        VideoCamera,
        VideoPlay,
    }
    impl GoogleChatV1WidgetMarkupKeyValueIcon {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleChatV1WidgetMarkupKeyValueIcon::Airplane => "AIRPLANE",
                GoogleChatV1WidgetMarkupKeyValueIcon::Bookmark => "BOOKMARK",
                GoogleChatV1WidgetMarkupKeyValueIcon::Bus => "BUS",
                GoogleChatV1WidgetMarkupKeyValueIcon::Car => "CAR",
                GoogleChatV1WidgetMarkupKeyValueIcon::Clock => "CLOCK",
                GoogleChatV1WidgetMarkupKeyValueIcon::ConfirmationNumberIcon => {
                    "CONFIRMATION_NUMBER_ICON"
                }
                GoogleChatV1WidgetMarkupKeyValueIcon::Description => "DESCRIPTION",
                GoogleChatV1WidgetMarkupKeyValueIcon::Dollar => "DOLLAR",
                GoogleChatV1WidgetMarkupKeyValueIcon::Email => "EMAIL",
                GoogleChatV1WidgetMarkupKeyValueIcon::EventPerformer => "EVENT_PERFORMER",
                GoogleChatV1WidgetMarkupKeyValueIcon::EventSeat => "EVENT_SEAT",
                GoogleChatV1WidgetMarkupKeyValueIcon::FlightArrival => "FLIGHT_ARRIVAL",
                GoogleChatV1WidgetMarkupKeyValueIcon::FlightDeparture => "FLIGHT_DEPARTURE",
                GoogleChatV1WidgetMarkupKeyValueIcon::Hotel => "HOTEL",
                GoogleChatV1WidgetMarkupKeyValueIcon::HotelRoomType => "HOTEL_ROOM_TYPE",
                GoogleChatV1WidgetMarkupKeyValueIcon::IconUnspecified => "ICON_UNSPECIFIED",
                GoogleChatV1WidgetMarkupKeyValueIcon::Invite => "INVITE",
                GoogleChatV1WidgetMarkupKeyValueIcon::MapPin => "MAP_PIN",
                GoogleChatV1WidgetMarkupKeyValueIcon::Membership => "MEMBERSHIP",
                GoogleChatV1WidgetMarkupKeyValueIcon::MultiplePeople => "MULTIPLE_PEOPLE",
                GoogleChatV1WidgetMarkupKeyValueIcon::Offer => "OFFER",
                GoogleChatV1WidgetMarkupKeyValueIcon::Person => "PERSON",
                GoogleChatV1WidgetMarkupKeyValueIcon::Phone => "PHONE",
                GoogleChatV1WidgetMarkupKeyValueIcon::RestaurantIcon => "RESTAURANT_ICON",
                GoogleChatV1WidgetMarkupKeyValueIcon::ShoppingCart => "SHOPPING_CART",
                GoogleChatV1WidgetMarkupKeyValueIcon::Star => "STAR",
                GoogleChatV1WidgetMarkupKeyValueIcon::Store => "STORE",
                GoogleChatV1WidgetMarkupKeyValueIcon::Ticket => "TICKET",
                GoogleChatV1WidgetMarkupKeyValueIcon::Train => "TRAIN",
                GoogleChatV1WidgetMarkupKeyValueIcon::VideoCamera => "VIDEO_CAMERA",
                GoogleChatV1WidgetMarkupKeyValueIcon::VideoPlay => "VIDEO_PLAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleChatV1WidgetMarkupKeyValueIcon {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleChatV1WidgetMarkupKeyValueIcon {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GoogleChatV1WidgetMarkupKeyValueIcon, ()> {
            Ok(match s {
                "AIRPLANE" => GoogleChatV1WidgetMarkupKeyValueIcon::Airplane,
                "BOOKMARK" => GoogleChatV1WidgetMarkupKeyValueIcon::Bookmark,
                "BUS" => GoogleChatV1WidgetMarkupKeyValueIcon::Bus,
                "CAR" => GoogleChatV1WidgetMarkupKeyValueIcon::Car,
                "CLOCK" => GoogleChatV1WidgetMarkupKeyValueIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => {
                    GoogleChatV1WidgetMarkupKeyValueIcon::ConfirmationNumberIcon
                }
                "DESCRIPTION" => GoogleChatV1WidgetMarkupKeyValueIcon::Description,
                "DOLLAR" => GoogleChatV1WidgetMarkupKeyValueIcon::Dollar,
                "EMAIL" => GoogleChatV1WidgetMarkupKeyValueIcon::Email,
                "EVENT_PERFORMER" => GoogleChatV1WidgetMarkupKeyValueIcon::EventPerformer,
                "EVENT_SEAT" => GoogleChatV1WidgetMarkupKeyValueIcon::EventSeat,
                "FLIGHT_ARRIVAL" => GoogleChatV1WidgetMarkupKeyValueIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => GoogleChatV1WidgetMarkupKeyValueIcon::FlightDeparture,
                "HOTEL" => GoogleChatV1WidgetMarkupKeyValueIcon::Hotel,
                "HOTEL_ROOM_TYPE" => GoogleChatV1WidgetMarkupKeyValueIcon::HotelRoomType,
                "ICON_UNSPECIFIED" => GoogleChatV1WidgetMarkupKeyValueIcon::IconUnspecified,
                "INVITE" => GoogleChatV1WidgetMarkupKeyValueIcon::Invite,
                "MAP_PIN" => GoogleChatV1WidgetMarkupKeyValueIcon::MapPin,
                "MEMBERSHIP" => GoogleChatV1WidgetMarkupKeyValueIcon::Membership,
                "MULTIPLE_PEOPLE" => GoogleChatV1WidgetMarkupKeyValueIcon::MultiplePeople,
                "OFFER" => GoogleChatV1WidgetMarkupKeyValueIcon::Offer,
                "PERSON" => GoogleChatV1WidgetMarkupKeyValueIcon::Person,
                "PHONE" => GoogleChatV1WidgetMarkupKeyValueIcon::Phone,
                "RESTAURANT_ICON" => GoogleChatV1WidgetMarkupKeyValueIcon::RestaurantIcon,
                "SHOPPING_CART" => GoogleChatV1WidgetMarkupKeyValueIcon::ShoppingCart,
                "STAR" => GoogleChatV1WidgetMarkupKeyValueIcon::Star,
                "STORE" => GoogleChatV1WidgetMarkupKeyValueIcon::Store,
                "TICKET" => GoogleChatV1WidgetMarkupKeyValueIcon::Ticket,
                "TRAIN" => GoogleChatV1WidgetMarkupKeyValueIcon::Train,
                "VIDEO_CAMERA" => GoogleChatV1WidgetMarkupKeyValueIcon::VideoCamera,
                "VIDEO_PLAY" => GoogleChatV1WidgetMarkupKeyValueIcon::VideoPlay,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleChatV1WidgetMarkupKeyValueIcon {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleChatV1WidgetMarkupKeyValueIcon {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleChatV1WidgetMarkupKeyValueIcon {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AIRPLANE" => GoogleChatV1WidgetMarkupKeyValueIcon::Airplane,
                "BOOKMARK" => GoogleChatV1WidgetMarkupKeyValueIcon::Bookmark,
                "BUS" => GoogleChatV1WidgetMarkupKeyValueIcon::Bus,
                "CAR" => GoogleChatV1WidgetMarkupKeyValueIcon::Car,
                "CLOCK" => GoogleChatV1WidgetMarkupKeyValueIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => {
                    GoogleChatV1WidgetMarkupKeyValueIcon::ConfirmationNumberIcon
                }
                "DESCRIPTION" => GoogleChatV1WidgetMarkupKeyValueIcon::Description,
                "DOLLAR" => GoogleChatV1WidgetMarkupKeyValueIcon::Dollar,
                "EMAIL" => GoogleChatV1WidgetMarkupKeyValueIcon::Email,
                "EVENT_PERFORMER" => GoogleChatV1WidgetMarkupKeyValueIcon::EventPerformer,
                "EVENT_SEAT" => GoogleChatV1WidgetMarkupKeyValueIcon::EventSeat,
                "FLIGHT_ARRIVAL" => GoogleChatV1WidgetMarkupKeyValueIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => GoogleChatV1WidgetMarkupKeyValueIcon::FlightDeparture,
                "HOTEL" => GoogleChatV1WidgetMarkupKeyValueIcon::Hotel,
                "HOTEL_ROOM_TYPE" => GoogleChatV1WidgetMarkupKeyValueIcon::HotelRoomType,
                "ICON_UNSPECIFIED" => GoogleChatV1WidgetMarkupKeyValueIcon::IconUnspecified,
                "INVITE" => GoogleChatV1WidgetMarkupKeyValueIcon::Invite,
                "MAP_PIN" => GoogleChatV1WidgetMarkupKeyValueIcon::MapPin,
                "MEMBERSHIP" => GoogleChatV1WidgetMarkupKeyValueIcon::Membership,
                "MULTIPLE_PEOPLE" => GoogleChatV1WidgetMarkupKeyValueIcon::MultiplePeople,
                "OFFER" => GoogleChatV1WidgetMarkupKeyValueIcon::Offer,
                "PERSON" => GoogleChatV1WidgetMarkupKeyValueIcon::Person,
                "PHONE" => GoogleChatV1WidgetMarkupKeyValueIcon::Phone,
                "RESTAURANT_ICON" => GoogleChatV1WidgetMarkupKeyValueIcon::RestaurantIcon,
                "SHOPPING_CART" => GoogleChatV1WidgetMarkupKeyValueIcon::ShoppingCart,
                "STAR" => GoogleChatV1WidgetMarkupKeyValueIcon::Star,
                "STORE" => GoogleChatV1WidgetMarkupKeyValueIcon::Store,
                "TICKET" => GoogleChatV1WidgetMarkupKeyValueIcon::Ticket,
                "TRAIN" => GoogleChatV1WidgetMarkupKeyValueIcon::Train,
                "VIDEO_CAMERA" => GoogleChatV1WidgetMarkupKeyValueIcon::VideoCamera,
                "VIDEO_PLAY" => GoogleChatV1WidgetMarkupKeyValueIcon::VideoPlay,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupKeyValueIcon {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupKeyValueIcon {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupOnClick {
        #[doc = "A form action will be triggered by this onclick if specified."]
        #[serde(
            rename = "action",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupFormAction>,
        #[doc = "This onclick triggers an open link action if specified."]
        #[serde(
            rename = "openLink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub open_link: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupOpenLink>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupOnClick {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupOnClick {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupOpenLink {
        #[doc = "The URL to open."]
        #[serde(
            rename = "url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupOpenLink {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupOpenLink {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupTextButton {
        #[doc = "The onclick action of the button."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::GoogleChatV1WidgetMarkupOnClick>,
        #[doc = "The text of the button."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupTextButton {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupTextButton {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleChatV1WidgetMarkupTextParagraph {
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleChatV1WidgetMarkupTextParagraph {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleChatV1WidgetMarkupTextParagraph {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleDocsMetadata {
        #[doc = "Contains number of users and groups which can access the document."]
        #[serde(
            rename = "aclInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub acl_info: ::std::option::Option<crate::schemas::AclInfo>,
        #[doc = "The conceptual type (presentation, document, etc.) of this document."]
        #[serde(
            rename = "documentType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub document_type: ::std::option::Option<crate::schemas::GoogleDocsMetadataDocumentType>,
        #[doc = "The file extension of the document. NOTE: As of October 2018 this field is not backfilled for old documents."]
        #[serde(
            rename = "fileExtension",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub file_extension: ::std::option::Option<String>,
        #[doc = "The last time this document was modified, in seconds since epoch. Only counts content modifications."]
        #[serde(
            rename = "lastContentModifiedTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_content_modified_timestamp: ::std::option::Option<i64>,
        #[doc = "Contains number of subscribers for the document."]
        #[serde(
            rename = "numSubscribers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_subscribers: ::std::option::Option<i32>,
        #[doc = "Size of untruncated viewers list."]
        #[serde(
            rename = "numViewers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_viewers: ::std::option::Option<i32>,
        #[doc = "Additional per-result information, akin to Gmail’s SingleThreadResponse. Note: GWS no longer seems to use this field, but there’s still one reference to it for Scribe, so we can’t remove it."]
        #[serde(
            rename = "resultInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub result_info: ::std::option::Option<crate::schemas::GoogleDocsResultInfo>,
        #[doc = "Contains additional information about the document depending on its type."]
        #[serde(
            rename = "typeInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub type_info: ::std::option::Option<crate::schemas::TypeInfo>,
    }
    impl ::google_field_selector::FieldSelector for GoogleDocsMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleDocsMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleDocsMetadataDocumentType {
        #[doc = "Fall-back for unknown Gdrive types."]
        BinaryBlob,
        #[doc = "Writely, Word, etc."]
        Document,
        #[doc = "For Atari page and site drafts"]
        DraftSite,
        DraftSitePage,
        Drawing,
        Folder,
        Form,
        FusionTable,
        Image,
        #[doc = "Jamboard Jams (go/jam)"]
        Jam,
        #[doc = "File types for Gdrive objects are below."]
        Pdf,
        #[doc = "Presently, PowerPoint, etc."]
        Presentation,
        Script,
        #[doc = "Drive Shortcuts (go/shortcuts)"]
        Shortcut,
        #[doc = "Trix, Excel, etc."]
        Spreadsheet,
        #[doc = "If the type is unknown or not represented in this enum."]
        Unknown,
        Video,
    }
    impl GoogleDocsMetadataDocumentType {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleDocsMetadataDocumentType::BinaryBlob => "BINARY_BLOB",
                GoogleDocsMetadataDocumentType::Document => "DOCUMENT",
                GoogleDocsMetadataDocumentType::DraftSite => "DRAFT_SITE",
                GoogleDocsMetadataDocumentType::DraftSitePage => "DRAFT_SITE_PAGE",
                GoogleDocsMetadataDocumentType::Drawing => "DRAWING",
                GoogleDocsMetadataDocumentType::Folder => "FOLDER",
                GoogleDocsMetadataDocumentType::Form => "FORM",
                GoogleDocsMetadataDocumentType::FusionTable => "FUSION_TABLE",
                GoogleDocsMetadataDocumentType::Image => "IMAGE",
                GoogleDocsMetadataDocumentType::Jam => "JAM",
                GoogleDocsMetadataDocumentType::Pdf => "PDF",
                GoogleDocsMetadataDocumentType::Presentation => "PRESENTATION",
                GoogleDocsMetadataDocumentType::Script => "SCRIPT",
                GoogleDocsMetadataDocumentType::Shortcut => "SHORTCUT",
                GoogleDocsMetadataDocumentType::Spreadsheet => "SPREADSHEET",
                GoogleDocsMetadataDocumentType::Unknown => "UNKNOWN",
                GoogleDocsMetadataDocumentType::Video => "VIDEO",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleDocsMetadataDocumentType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleDocsMetadataDocumentType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GoogleDocsMetadataDocumentType, ()> {
            Ok(match s {
                "BINARY_BLOB" => GoogleDocsMetadataDocumentType::BinaryBlob,
                "DOCUMENT" => GoogleDocsMetadataDocumentType::Document,
                "DRAFT_SITE" => GoogleDocsMetadataDocumentType::DraftSite,
                "DRAFT_SITE_PAGE" => GoogleDocsMetadataDocumentType::DraftSitePage,
                "DRAWING" => GoogleDocsMetadataDocumentType::Drawing,
                "FOLDER" => GoogleDocsMetadataDocumentType::Folder,
                "FORM" => GoogleDocsMetadataDocumentType::Form,
                "FUSION_TABLE" => GoogleDocsMetadataDocumentType::FusionTable,
                "IMAGE" => GoogleDocsMetadataDocumentType::Image,
                "JAM" => GoogleDocsMetadataDocumentType::Jam,
                "PDF" => GoogleDocsMetadataDocumentType::Pdf,
                "PRESENTATION" => GoogleDocsMetadataDocumentType::Presentation,
                "SCRIPT" => GoogleDocsMetadataDocumentType::Script,
                "SHORTCUT" => GoogleDocsMetadataDocumentType::Shortcut,
                "SPREADSHEET" => GoogleDocsMetadataDocumentType::Spreadsheet,
                "UNKNOWN" => GoogleDocsMetadataDocumentType::Unknown,
                "VIDEO" => GoogleDocsMetadataDocumentType::Video,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleDocsMetadataDocumentType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleDocsMetadataDocumentType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleDocsMetadataDocumentType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BINARY_BLOB" => GoogleDocsMetadataDocumentType::BinaryBlob,
                "DOCUMENT" => GoogleDocsMetadataDocumentType::Document,
                "DRAFT_SITE" => GoogleDocsMetadataDocumentType::DraftSite,
                "DRAFT_SITE_PAGE" => GoogleDocsMetadataDocumentType::DraftSitePage,
                "DRAWING" => GoogleDocsMetadataDocumentType::Drawing,
                "FOLDER" => GoogleDocsMetadataDocumentType::Folder,
                "FORM" => GoogleDocsMetadataDocumentType::Form,
                "FUSION_TABLE" => GoogleDocsMetadataDocumentType::FusionTable,
                "IMAGE" => GoogleDocsMetadataDocumentType::Image,
                "JAM" => GoogleDocsMetadataDocumentType::Jam,
                "PDF" => GoogleDocsMetadataDocumentType::Pdf,
                "PRESENTATION" => GoogleDocsMetadataDocumentType::Presentation,
                "SCRIPT" => GoogleDocsMetadataDocumentType::Script,
                "SHORTCUT" => GoogleDocsMetadataDocumentType::Shortcut,
                "SPREADSHEET" => GoogleDocsMetadataDocumentType::Spreadsheet,
                "UNKNOWN" => GoogleDocsMetadataDocumentType::Unknown,
                "VIDEO" => GoogleDocsMetadataDocumentType::Video,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleDocsMetadataDocumentType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleDocsMetadataDocumentType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleDocsResultInfo {
        #[doc = "The SHA1 hash of the object in Drive, if any."]
        #[serde(
            rename = "attachmentSha1",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment_sha_1: ::std::option::Option<String>,
        #[doc = "The storage identifier for the object in Cosmo. This field is intended to used by Stratus/Moonshine integration only. It should not be exposed externally (please refer to encrypted_id for that purpose)."]
        #[serde(
            rename = "cosmoId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cosmo_id: ::std::option::Option<crate::schemas::Id>,
        #[doc = "For Cosmo objects, the Cosmo namespace the object was in. This allows downstream clients to identify whether a document was created in Writely or Kix, Presently or Punch, or whether it was uploaded from GDrive. See storage_cosmo.Id.NAME_SPACE for a list of all Cosmo name spaces."]
        #[serde(
            rename = "cosmoNameSpace",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cosmo_name_space: ::std::option::Option<i32>,
        #[doc = "The encrypted (user-visible) id of this object. Knowing the id is sufficient to create a canonical URL for this document."]
        #[serde(
            rename = "encryptedId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub encrypted_id: ::std::option::Option<String>,
        #[doc = "The mimetype of the document."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "The visibility indicator in the UI will be based upon this."]
        #[serde(
            rename = "shareScope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub share_scope: ::std::option::Option<crate::schemas::ShareScope>,
    }
    impl ::google_field_selector::FieldSelector for GoogleDocsResultInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleDocsResultInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Grid {
        #[doc = "The border style to apply to each grid item."]
        #[serde(
            rename = "borderStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub border_style: ::std::option::Option<crate::schemas::BorderStyle>,
        #[doc = "The items to display in the grid."]
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<Vec<crate::schemas::GridItem>>,
        #[doc = "The number of columns to display in the grid. Note that a default value will be used if this field is not specified, and that default value will be different depending on where the grid is shown (dialog vs companion)."]
        #[serde(
            rename = "numColumns",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_columns: ::std::option::Option<i32>,
        #[doc = "This callback will be reused by each individual GridItem, but with the item’s identifier and index in the items list added to the callback’s parameters."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::OnClick>,
        #[doc = "The text to display in the grid header."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Grid {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Grid {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GridItem {
        #[doc = "A user-specified identifier for this grid item. This identifier will be returned in the parent Grid’s on_click callback’s parameters."]
        #[serde(
            rename = "identifier",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub identifier: ::std::option::Option<String>,
        #[serde(
            rename = "image",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image: ::std::option::Option<crate::schemas::ImageComponent>,
        #[serde(
            rename = "layout",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub layout: ::std::option::Option<crate::schemas::GridItemLayout>,
        #[serde(
            rename = "subtitle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub subtitle: ::std::option::Option<String>,
        #[serde(
            rename = "textAlignment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_alignment: ::std::option::Option<crate::schemas::GridItemTextAlignment>,
        #[doc = "Text properties."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GridItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GridItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GridItemLayout {
        NotSet,
        #[doc = "The title and subtitle are shown above the grid item’s image."]
        TextAbove,
        #[doc = "The title and subtitle are shown below the grid item’s image."]
        TextBelow,
    }
    impl GridItemLayout {
        pub fn as_str(self) -> &'static str {
            match self {
                GridItemLayout::NotSet => "NOT_SET",
                GridItemLayout::TextAbove => "TEXT_ABOVE",
                GridItemLayout::TextBelow => "TEXT_BELOW",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GridItemLayout {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GridItemLayout {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GridItemLayout, ()> {
            Ok(match s {
                "NOT_SET" => GridItemLayout::NotSet,
                "TEXT_ABOVE" => GridItemLayout::TextAbove,
                "TEXT_BELOW" => GridItemLayout::TextBelow,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GridItemLayout {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GridItemLayout {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GridItemLayout {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NOT_SET" => GridItemLayout::NotSet,
                "TEXT_ABOVE" => GridItemLayout::TextAbove,
                "TEXT_BELOW" => GridItemLayout::TextBelow,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GridItemLayout {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GridItemLayout {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GridItemTextAlignment {
        Center,
        End,
        HorizontalAlignmentUnspecified,
        Start,
    }
    impl GridItemTextAlignment {
        pub fn as_str(self) -> &'static str {
            match self {
                GridItemTextAlignment::Center => "CENTER",
                GridItemTextAlignment::End => "END",
                GridItemTextAlignment::HorizontalAlignmentUnspecified => {
                    "HORIZONTAL_ALIGNMENT_UNSPECIFIED"
                }
                GridItemTextAlignment::Start => "START",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GridItemTextAlignment {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GridItemTextAlignment {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GridItemTextAlignment, ()> {
            Ok(match s {
                "CENTER" => GridItemTextAlignment::Center,
                "END" => GridItemTextAlignment::End,
                "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                    GridItemTextAlignment::HorizontalAlignmentUnspecified
                }
                "START" => GridItemTextAlignment::Start,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GridItemTextAlignment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GridItemTextAlignment {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GridItemTextAlignment {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CENTER" => GridItemTextAlignment::Center,
                "END" => GridItemTextAlignment::End,
                "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                    GridItemTextAlignment::HorizontalAlignmentUnspecified
                }
                "START" => GridItemTextAlignment::Start,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GridItemTextAlignment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GridItemTextAlignment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GroupDetailsUpdatedMetadata {
        #[serde(
            rename = "newGroupDetails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub new_group_details:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedGroupDetails>,
        #[serde(
            rename = "prevGroupDetails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub prev_group_details:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedGroupDetails>,
    }
    impl ::google_field_selector::FieldSelector for GroupDetailsUpdatedMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GroupDetailsUpdatedMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GroupId {
        #[doc = "Unique, immutable ID of the Direct Message Space"]
        #[serde(
            rename = "dmId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dm_id: ::std::option::Option<crate::schemas::DmId>,
        #[doc = "Unique, immutable ID of the Space"]
        #[serde(
            rename = "spaceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub space_id: ::std::option::Option<crate::schemas::SpaceId>,
    }
    impl ::google_field_selector::FieldSelector for GroupId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GroupId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GroupLinkSharingModificationEvent {
        #[serde(
            rename = "newStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub new_status:
            ::std::option::Option<crate::schemas::GroupLinkSharingModificationEventNewStatus>,
    }
    impl ::google_field_selector::FieldSelector for GroupLinkSharingModificationEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GroupLinkSharingModificationEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GroupLinkSharingModificationEventNewStatus {
        #[doc = "Link sharing is turned off."]
        LinkSharingOff,
        #[doc = "Link sharing is turned on."]
        LinkSharingOn,
        #[doc = "Link sharing is not available for the conversation."]
        NotAvailable,
        UnknownLinkSharingStatus,
    }
    impl GroupLinkSharingModificationEventNewStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                GroupLinkSharingModificationEventNewStatus::LinkSharingOff => "LINK_SHARING_OFF",
                GroupLinkSharingModificationEventNewStatus::LinkSharingOn => "LINK_SHARING_ON",
                GroupLinkSharingModificationEventNewStatus::NotAvailable => "NOT_AVAILABLE",
                GroupLinkSharingModificationEventNewStatus::UnknownLinkSharingStatus => {
                    "UNKNOWN_LINK_SHARING_STATUS"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GroupLinkSharingModificationEventNewStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GroupLinkSharingModificationEventNewStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GroupLinkSharingModificationEventNewStatus, ()> {
            Ok(match s {
                "LINK_SHARING_OFF" => GroupLinkSharingModificationEventNewStatus::LinkSharingOff,
                "LINK_SHARING_ON" => GroupLinkSharingModificationEventNewStatus::LinkSharingOn,
                "NOT_AVAILABLE" => GroupLinkSharingModificationEventNewStatus::NotAvailable,
                "UNKNOWN_LINK_SHARING_STATUS" => {
                    GroupLinkSharingModificationEventNewStatus::UnknownLinkSharingStatus
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GroupLinkSharingModificationEventNewStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GroupLinkSharingModificationEventNewStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GroupLinkSharingModificationEventNewStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "LINK_SHARING_OFF" => GroupLinkSharingModificationEventNewStatus::LinkSharingOff,
                "LINK_SHARING_ON" => GroupLinkSharingModificationEventNewStatus::LinkSharingOn,
                "NOT_AVAILABLE" => GroupLinkSharingModificationEventNewStatus::NotAvailable,
                "UNKNOWN_LINK_SHARING_STATUS" => {
                    GroupLinkSharingModificationEventNewStatus::UnknownLinkSharingStatus
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GroupLinkSharingModificationEventNewStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GroupLinkSharingModificationEventNewStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GroupRetentionSettingsUpdatedMetaData {
        #[doc = "The user who triggered the retention settings update"]
        #[serde(
            rename = "initiator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "The updated space retention settings"]
        #[serde(
            rename = "retentionSettings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retention_settings:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedRetentionSettings>,
    }
    impl ::google_field_selector::FieldSelector for GroupRetentionSettingsUpdatedMetaData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GroupRetentionSettingsUpdatedMetaData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GsuiteIntegrationMetadata {
        #[serde(
            rename = "activityFeedData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub activity_feed_data:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedActivityFeedAnnotationData>,
        #[serde(
            rename = "assistantData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub assistant_data:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedAssistantAnnotationData>,
        #[serde(
            rename = "calendarEventData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub calendar_event_data:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedCalendarEventAnnotationData>,
        #[doc = "Data used to render call artifacts."]
        #[serde(
            rename = "callData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub call_data: ::std::option::Option<crate::schemas::AppsDynamiteSharedCallAnnotationData>,
        #[serde(
            rename = "clientType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_type: ::std::option::Option<crate::schemas::GsuiteIntegrationMetadataClientType>,
        #[doc = "A list of all strings that are to be indexed for this 1P chip. Each string in this list would be the contents of a single string field in the 1P chip. Eg. For Tasks\\[title = “hello world”, description = “good bye”\\]. If we want to index only the title, this would be set to \\[“hello world”\\]. If both title and description, then this would be \\[“hello world”, “good bye”\\]. Please make sure that the contents of this field is a subset of strings that are rendered as part of the 1P Chip."]
        #[serde(
            rename = "indexableTexts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub indexable_texts: ::std::option::Option<Vec<String>>,
        #[serde(
            rename = "tasksData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tasks_data:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedTasksAnnotationData>,
    }
    impl ::google_field_selector::FieldSelector for GsuiteIntegrationMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GsuiteIntegrationMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GsuiteIntegrationMetadataClientType {
        ActivityFeedService,
        Assistant,
        CalendarEvent,
        Meet,
        Tasks,
        UnknownClientType,
    }
    impl GsuiteIntegrationMetadataClientType {
        pub fn as_str(self) -> &'static str {
            match self {
                GsuiteIntegrationMetadataClientType::ActivityFeedService => "ACTIVITY_FEED_SERVICE",
                GsuiteIntegrationMetadataClientType::Assistant => "ASSISTANT",
                GsuiteIntegrationMetadataClientType::CalendarEvent => "CALENDAR_EVENT",
                GsuiteIntegrationMetadataClientType::Meet => "MEET",
                GsuiteIntegrationMetadataClientType::Tasks => "TASKS",
                GsuiteIntegrationMetadataClientType::UnknownClientType => "UNKNOWN_CLIENT_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GsuiteIntegrationMetadataClientType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GsuiteIntegrationMetadataClientType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GsuiteIntegrationMetadataClientType, ()> {
            Ok(match s {
                "ACTIVITY_FEED_SERVICE" => GsuiteIntegrationMetadataClientType::ActivityFeedService,
                "ASSISTANT" => GsuiteIntegrationMetadataClientType::Assistant,
                "CALENDAR_EVENT" => GsuiteIntegrationMetadataClientType::CalendarEvent,
                "MEET" => GsuiteIntegrationMetadataClientType::Meet,
                "TASKS" => GsuiteIntegrationMetadataClientType::Tasks,
                "UNKNOWN_CLIENT_TYPE" => GsuiteIntegrationMetadataClientType::UnknownClientType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GsuiteIntegrationMetadataClientType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GsuiteIntegrationMetadataClientType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GsuiteIntegrationMetadataClientType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVITY_FEED_SERVICE" => GsuiteIntegrationMetadataClientType::ActivityFeedService,
                "ASSISTANT" => GsuiteIntegrationMetadataClientType::Assistant,
                "CALENDAR_EVENT" => GsuiteIntegrationMetadataClientType::CalendarEvent,
                "MEET" => GsuiteIntegrationMetadataClientType::Meet,
                "TASKS" => GsuiteIntegrationMetadataClientType::Tasks,
                "UNKNOWN_CLIENT_TYPE" => GsuiteIntegrationMetadataClientType::UnknownClientType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GsuiteIntegrationMetadataClientType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GsuiteIntegrationMetadataClientType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GsuitePrincipal {
        #[doc = "This principal represents all users of the Google Workspace domain of the customer."]
        #[serde(
            rename = "gsuiteDomain",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gsuite_domain: ::std::option::Option<bool>,
        #[doc = "This principal references a Google Workspace group name."]
        #[serde(
            rename = "gsuiteGroupEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gsuite_group_email: ::std::option::Option<String>,
        #[doc = "This principal references a Google Workspace user account."]
        #[serde(
            rename = "gsuiteUserEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gsuite_user_email: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GsuitePrincipal {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GsuitePrincipal {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HangoutEvent {
        #[serde(
            rename = "hangoutDurationSecs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub hangout_duration_secs: ::std::option::Option<i64>,
        #[serde(
            rename = "mediaType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub media_type: ::std::option::Option<crate::schemas::HangoutEventMediaType>,
        #[serde(
            rename = "participantId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub participant_id: ::std::option::Option<Vec<crate::schemas::StoredParticipantId>>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::HangoutEventType>,
    }
    impl ::google_field_selector::FieldSelector for HangoutEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HangoutEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum HangoutEventMediaType {
        AudioOnly,
        AudioVideo,
        #[doc = "A user has started a PTT broadcast. When receiving a notification with this HangoutMediaType, other users in the conversation will take different actions depending on their active clients: a) If there is a recent “reasonable” active client, the user will join hangout and play audio. b) If there is no “reasonable” active client an invite will be displayed on all clients."]
        PushToTalk,
    }
    impl HangoutEventMediaType {
        pub fn as_str(self) -> &'static str {
            match self {
                HangoutEventMediaType::AudioOnly => "AUDIO_ONLY",
                HangoutEventMediaType::AudioVideo => "AUDIO_VIDEO",
                HangoutEventMediaType::PushToTalk => "PUSH_TO_TALK",
            }
        }
    }
    impl ::std::convert::AsRef<str> for HangoutEventMediaType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for HangoutEventMediaType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<HangoutEventMediaType, ()> {
            Ok(match s {
                "AUDIO_ONLY" => HangoutEventMediaType::AudioOnly,
                "AUDIO_VIDEO" => HangoutEventMediaType::AudioVideo,
                "PUSH_TO_TALK" => HangoutEventMediaType::PushToTalk,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for HangoutEventMediaType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for HangoutEventMediaType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HangoutEventMediaType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AUDIO_ONLY" => HangoutEventMediaType::AudioOnly,
                "AUDIO_VIDEO" => HangoutEventMediaType::AudioVideo,
                "PUSH_TO_TALK" => HangoutEventMediaType::PushToTalk,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for HangoutEventMediaType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HangoutEventMediaType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum HangoutEventType {
        EndHangout,
        HangoutComingSoon,
        JoinHangout,
        LeaveHangout,
        OngoingHangout,
        StartHangout,
    }
    impl HangoutEventType {
        pub fn as_str(self) -> &'static str {
            match self {
                HangoutEventType::EndHangout => "END_HANGOUT",
                HangoutEventType::HangoutComingSoon => "HANGOUT_COMING_SOON",
                HangoutEventType::JoinHangout => "JOIN_HANGOUT",
                HangoutEventType::LeaveHangout => "LEAVE_HANGOUT",
                HangoutEventType::OngoingHangout => "ONGOING_HANGOUT",
                HangoutEventType::StartHangout => "START_HANGOUT",
            }
        }
    }
    impl ::std::convert::AsRef<str> for HangoutEventType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for HangoutEventType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<HangoutEventType, ()> {
            Ok(match s {
                "END_HANGOUT" => HangoutEventType::EndHangout,
                "HANGOUT_COMING_SOON" => HangoutEventType::HangoutComingSoon,
                "JOIN_HANGOUT" => HangoutEventType::JoinHangout,
                "LEAVE_HANGOUT" => HangoutEventType::LeaveHangout,
                "ONGOING_HANGOUT" => HangoutEventType::OngoingHangout,
                "START_HANGOUT" => HangoutEventType::StartHangout,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for HangoutEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for HangoutEventType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HangoutEventType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "END_HANGOUT" => HangoutEventType::EndHangout,
                "HANGOUT_COMING_SOON" => HangoutEventType::HangoutComingSoon,
                "JOIN_HANGOUT" => HangoutEventType::JoinHangout,
                "LEAVE_HANGOUT" => HangoutEventType::LeaveHangout,
                "ONGOING_HANGOUT" => HangoutEventType::OngoingHangout,
                "START_HANGOUT" => HangoutEventType::StartHangout,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for HangoutEventType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HangoutEventType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HangoutVideoEventMetadata {
        #[serde(
            rename = "hangoutVideoType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hangout_video_type:
            ::std::option::Option<crate::schemas::HangoutVideoEventMetadataHangoutVideoType>,
    }
    impl ::google_field_selector::FieldSelector for HangoutVideoEventMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HangoutVideoEventMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum HangoutVideoEventMetadataHangoutVideoType {
        UnknownHangoutVideoEventType,
        VideoEnd,
        VideoStart,
    }
    impl HangoutVideoEventMetadataHangoutVideoType {
        pub fn as_str(self) -> &'static str {
            match self {
                HangoutVideoEventMetadataHangoutVideoType::UnknownHangoutVideoEventType => {
                    "UNKNOWN_HANGOUT_VIDEO_EVENT_TYPE"
                }
                HangoutVideoEventMetadataHangoutVideoType::VideoEnd => "VIDEO_END",
                HangoutVideoEventMetadataHangoutVideoType::VideoStart => "VIDEO_START",
            }
        }
    }
    impl ::std::convert::AsRef<str> for HangoutVideoEventMetadataHangoutVideoType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for HangoutVideoEventMetadataHangoutVideoType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<HangoutVideoEventMetadataHangoutVideoType, ()> {
            Ok(match s {
                "UNKNOWN_HANGOUT_VIDEO_EVENT_TYPE" => {
                    HangoutVideoEventMetadataHangoutVideoType::UnknownHangoutVideoEventType
                }
                "VIDEO_END" => HangoutVideoEventMetadataHangoutVideoType::VideoEnd,
                "VIDEO_START" => HangoutVideoEventMetadataHangoutVideoType::VideoStart,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for HangoutVideoEventMetadataHangoutVideoType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for HangoutVideoEventMetadataHangoutVideoType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HangoutVideoEventMetadataHangoutVideoType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "UNKNOWN_HANGOUT_VIDEO_EVENT_TYPE" => {
                    HangoutVideoEventMetadataHangoutVideoType::UnknownHangoutVideoEventType
                }
                "VIDEO_END" => HangoutVideoEventMetadataHangoutVideoType::VideoEnd,
                "VIDEO_START" => HangoutVideoEventMetadataHangoutVideoType::VideoStart,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for HangoutVideoEventMetadataHangoutVideoType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HangoutVideoEventMetadataHangoutVideoType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HashtagData {
        #[serde(
            rename = "searchText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub search_text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for HashtagData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HashtagData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct History {
        #[serde(
            rename = "record",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub record: ::std::option::Option<Vec<crate::schemas::HistoryRecord>>,
    }
    impl ::google_field_selector::FieldSelector for History {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for History {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HistoryRecord {
        #[doc = "This will almost always be set, but there are corner cases in which the information is not available, and thus applications must handle its absence appropriately."]
        #[serde(
            rename = "clientContext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_context: ::std::option::Option<crate::schemas::ClientContext>,
        #[serde(
            rename = "filterUpdate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter_update: ::std::option::Option<crate::schemas::FilterUpdate>,
        #[serde(
            rename = "imapUpdate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub imap_update: ::std::option::Option<crate::schemas::ImapUpdate>,
        #[serde(
            rename = "labelUpdate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_update: ::std::option::Option<crate::schemas::LabelUpdate>,
        #[serde(
            rename = "prefUpdate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pref_update: ::std::option::Option<crate::schemas::PrefUpdate>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::HistoryRecordType>,
        #[doc = "Each HistoryRecord has a unique id. Ids are monotonically increasing, and not necessarily contiguous."]
        #[serde(
            rename = "recordId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub record_id: ::std::option::Option<u64>,
        #[serde(
            rename = "threadUpdate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_update: ::std::option::Option<crate::schemas::ThreadUpdate>,
        #[doc = "This will almost always be set, but there are corner cases in which the information is not available, and thus applications must handle its absence appropriately."]
        #[serde(
            rename = "transactionContext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transaction_context: ::std::option::Option<crate::schemas::TransactionContext>,
        #[serde(
            rename = "txnDebugInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub txn_debug_info: ::std::option::Option<crate::schemas::TransactionDebugInfo>,
    }
    impl ::google_field_selector::FieldSelector for HistoryRecord {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HistoryRecord {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum HistoryRecordType {
        AttributeRemoved,
        AttributeSet,
        #[doc = "FilterUpdate:"]
        FilterCreated,
        FilterDeleted,
        #[doc = "IMAP"]
        ImapUidsReassign,
        #[doc = "Represents a change internal to the Fusebox. HistoryRecords for Fusebox internal changes contribute to the user’s version, which is defined as the latest HistoryRecord’s record_id. INTERNAL HistoryRecords exist to allow a client to update its notion of the latest record_id it has processed, but do not necessarily contain any other information."]
        Internal,
        LabelAdded,
        #[doc = "LabelUpdate:"]
        LabelCreated,
        LabelDeleted,
        LabelRemoved,
        LabelRenamed,
        LabelUpdated,
        #[doc = "ThreadUpdate:"]
        MessageAdded,
        MessageDeleted,
        PrefDeleted,
        #[doc = "PrefUpdate:"]
        PrefWritten,
        ThreadKeySet,
        #[doc = "EAI"]
        TopicStateUpdated,
        #[doc = "TXN_DEBUG_INFO"]
        TxnDebugInfo,
        #[doc = "Represents a type that is deprecated or not known by the executing code. Even if Fusebox sends a HistoryRecord with Type not UNKNOWN, it may send Type values that are not yet defined on the client-side, in which case they will be appear as Type.UNKNOWN on the client."]
        Unknown,
    }
    impl HistoryRecordType {
        pub fn as_str(self) -> &'static str {
            match self {
                HistoryRecordType::AttributeRemoved => "ATTRIBUTE_REMOVED",
                HistoryRecordType::AttributeSet => "ATTRIBUTE_SET",
                HistoryRecordType::FilterCreated => "FILTER_CREATED",
                HistoryRecordType::FilterDeleted => "FILTER_DELETED",
                HistoryRecordType::ImapUidsReassign => "IMAP_UIDS_REASSIGN",
                HistoryRecordType::Internal => "INTERNAL",
                HistoryRecordType::LabelAdded => "LABEL_ADDED",
                HistoryRecordType::LabelCreated => "LABEL_CREATED",
                HistoryRecordType::LabelDeleted => "LABEL_DELETED",
                HistoryRecordType::LabelRemoved => "LABEL_REMOVED",
                HistoryRecordType::LabelRenamed => "LABEL_RENAMED",
                HistoryRecordType::LabelUpdated => "LABEL_UPDATED",
                HistoryRecordType::MessageAdded => "MESSAGE_ADDED",
                HistoryRecordType::MessageDeleted => "MESSAGE_DELETED",
                HistoryRecordType::PrefDeleted => "PREF_DELETED",
                HistoryRecordType::PrefWritten => "PREF_WRITTEN",
                HistoryRecordType::ThreadKeySet => "THREAD_KEY_SET",
                HistoryRecordType::TopicStateUpdated => "TOPIC_STATE_UPDATED",
                HistoryRecordType::TxnDebugInfo => "TXN_DEBUG_INFO",
                HistoryRecordType::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for HistoryRecordType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for HistoryRecordType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<HistoryRecordType, ()> {
            Ok(match s {
                "ATTRIBUTE_REMOVED" => HistoryRecordType::AttributeRemoved,
                "ATTRIBUTE_SET" => HistoryRecordType::AttributeSet,
                "FILTER_CREATED" => HistoryRecordType::FilterCreated,
                "FILTER_DELETED" => HistoryRecordType::FilterDeleted,
                "IMAP_UIDS_REASSIGN" => HistoryRecordType::ImapUidsReassign,
                "INTERNAL" => HistoryRecordType::Internal,
                "LABEL_ADDED" => HistoryRecordType::LabelAdded,
                "LABEL_CREATED" => HistoryRecordType::LabelCreated,
                "LABEL_DELETED" => HistoryRecordType::LabelDeleted,
                "LABEL_REMOVED" => HistoryRecordType::LabelRemoved,
                "LABEL_RENAMED" => HistoryRecordType::LabelRenamed,
                "LABEL_UPDATED" => HistoryRecordType::LabelUpdated,
                "MESSAGE_ADDED" => HistoryRecordType::MessageAdded,
                "MESSAGE_DELETED" => HistoryRecordType::MessageDeleted,
                "PREF_DELETED" => HistoryRecordType::PrefDeleted,
                "PREF_WRITTEN" => HistoryRecordType::PrefWritten,
                "THREAD_KEY_SET" => HistoryRecordType::ThreadKeySet,
                "TOPIC_STATE_UPDATED" => HistoryRecordType::TopicStateUpdated,
                "TXN_DEBUG_INFO" => HistoryRecordType::TxnDebugInfo,
                "UNKNOWN" => HistoryRecordType::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for HistoryRecordType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for HistoryRecordType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HistoryRecordType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ATTRIBUTE_REMOVED" => HistoryRecordType::AttributeRemoved,
                "ATTRIBUTE_SET" => HistoryRecordType::AttributeSet,
                "FILTER_CREATED" => HistoryRecordType::FilterCreated,
                "FILTER_DELETED" => HistoryRecordType::FilterDeleted,
                "IMAP_UIDS_REASSIGN" => HistoryRecordType::ImapUidsReassign,
                "INTERNAL" => HistoryRecordType::Internal,
                "LABEL_ADDED" => HistoryRecordType::LabelAdded,
                "LABEL_CREATED" => HistoryRecordType::LabelCreated,
                "LABEL_DELETED" => HistoryRecordType::LabelDeleted,
                "LABEL_REMOVED" => HistoryRecordType::LabelRemoved,
                "LABEL_RENAMED" => HistoryRecordType::LabelRenamed,
                "LABEL_UPDATED" => HistoryRecordType::LabelUpdated,
                "MESSAGE_ADDED" => HistoryRecordType::MessageAdded,
                "MESSAGE_DELETED" => HistoryRecordType::MessageDeleted,
                "PREF_DELETED" => HistoryRecordType::PrefDeleted,
                "PREF_WRITTEN" => HistoryRecordType::PrefWritten,
                "THREAD_KEY_SET" => HistoryRecordType::ThreadKeySet,
                "TOPIC_STATE_UPDATED" => HistoryRecordType::TopicStateUpdated,
                "TXN_DEBUG_INFO" => HistoryRecordType::TxnDebugInfo,
                "UNKNOWN" => HistoryRecordType::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for HistoryRecordType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HistoryRecordType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct HostAppActionMarkup {
        #[doc = "Actions handled by Calendar."]
        #[serde(
            rename = "calendarAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub calendar_action: ::std::option::Option<crate::schemas::CalendarClientActionMarkup>,
        #[doc = "Actions handled by Chat."]
        #[serde(
            rename = "chatAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub chat_action: ::std::option::Option<crate::schemas::ChatClientActionMarkup>,
        #[doc = "Actions handled by Drive."]
        #[serde(
            rename = "driveAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_action: ::std::option::Option<crate::schemas::DriveClientActionMarkup>,
        #[doc = "Actions handled by Docs, Sheets, or Slides."]
        #[serde(
            rename = "editorAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub editor_action: ::std::option::Option<crate::schemas::EditorClientActionMarkup>,
        #[doc = "Actions handled by Gmail."]
        #[serde(
            rename = "gmailAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gmail_action: ::std::option::Option<crate::schemas::GmailClientActionMarkup>,
        #[doc = "Actions handled by Sheets."]
        #[serde(
            rename = "sheetsAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sheets_action: ::std::option::Option<crate::schemas::SheetsClientActionMarkup>,
    }
    impl ::google_field_selector::FieldSelector for HostAppActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HostAppActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HostProto {
        #[doc = "Lower-case, fully qualified hostname."]
        #[serde(
            rename = "hostName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub host_name: ::std::option::Option<String>,
        #[doc = "If present, then any checks that compare this Principal to LOAS peer info must confirm the peer’s machine owner is equal to ‘host_owner’. If absent, then any peer machine owner is acceptable."]
        #[serde(
            rename = "hostOwner",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub host_owner: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for HostProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HostProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HtmlOperatorOptions {
        #[doc = "Indicates the operator name required in the query in order to isolate the html property. For example, if operatorName is *subject* and the property’s name is *subjectLine*, then queries like *subject:<value>* show results only where the value of the property named *subjectLine* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator return all items where *<value>* matches the value of any html properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for HtmlOperatorOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HtmlOperatorOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HtmlPropertyOptions {
        #[doc = "If set, describes how the property should be used as a search operator."]
        #[serde(
            rename = "operatorOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_options: ::std::option::Option<crate::schemas::HtmlOperatorOptions>,
        #[doc = "Indicates the search quality importance of the tokens within the field when used for retrieval. Can only be set to DEFAULT or NONE."]
        #[serde(
            rename = "retrievalImportance",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retrieval_importance: ::std::option::Option<crate::schemas::RetrievalImportance>,
    }
    impl ::google_field_selector::FieldSelector for HtmlPropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HtmlPropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HtmlValues {
        #[doc = "The maximum allowable length for html values is 2048 characters."]
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for HtmlValues {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HtmlValues {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IconImage {
        #[doc = "The alternative text of this icon_url which will be used for accessibility."]
        #[serde(
            rename = "altText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alt_text: ::std::option::Option<String>,
        #[serde(
            rename = "icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon: ::std::option::Option<crate::schemas::IconImageIcon>,
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[doc = "The image cropping style. Note that icons with a CIRCLE style are rendered larger than the default icon size."]
        #[serde(
            rename = "imageStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_style: ::std::option::Option<crate::schemas::IconImageImageStyle>,
    }
    impl ::google_field_selector::FieldSelector for IconImage {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IconImage {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IconImageIcon {
        Airplane,
        Bookmark,
        Bus,
        Car,
        Clock,
        ConfirmationNumberIcon,
        Description,
        Dollar,
        Edit,
        EditNote,
        Email,
        EventPerformer,
        EventSeat,
        FlightArrival,
        FlightDeparture,
        Hotel,
        HotelRoomType,
        Invite,
        MapPin,
        Membership,
        MultiplePeople,
        None,
        Offer,
        OpenInNew,
        Person,
        Phone,
        RestaurantIcon,
        ShoppingCart,
        Star,
        Store,
        Ticket,
        Train,
        VideoCamera,
        #[doc = "Add new items in alphabetical order. Next Available ID: 34"]
        VideoPlay,
    }
    impl IconImageIcon {
        pub fn as_str(self) -> &'static str {
            match self {
                IconImageIcon::Airplane => "AIRPLANE",
                IconImageIcon::Bookmark => "BOOKMARK",
                IconImageIcon::Bus => "BUS",
                IconImageIcon::Car => "CAR",
                IconImageIcon::Clock => "CLOCK",
                IconImageIcon::ConfirmationNumberIcon => "CONFIRMATION_NUMBER_ICON",
                IconImageIcon::Description => "DESCRIPTION",
                IconImageIcon::Dollar => "DOLLAR",
                IconImageIcon::Edit => "EDIT",
                IconImageIcon::EditNote => "EDIT_NOTE",
                IconImageIcon::Email => "EMAIL",
                IconImageIcon::EventPerformer => "EVENT_PERFORMER",
                IconImageIcon::EventSeat => "EVENT_SEAT",
                IconImageIcon::FlightArrival => "FLIGHT_ARRIVAL",
                IconImageIcon::FlightDeparture => "FLIGHT_DEPARTURE",
                IconImageIcon::Hotel => "HOTEL",
                IconImageIcon::HotelRoomType => "HOTEL_ROOM_TYPE",
                IconImageIcon::Invite => "INVITE",
                IconImageIcon::MapPin => "MAP_PIN",
                IconImageIcon::Membership => "MEMBERSHIP",
                IconImageIcon::MultiplePeople => "MULTIPLE_PEOPLE",
                IconImageIcon::None => "NONE",
                IconImageIcon::Offer => "OFFER",
                IconImageIcon::OpenInNew => "OPEN_IN_NEW",
                IconImageIcon::Person => "PERSON",
                IconImageIcon::Phone => "PHONE",
                IconImageIcon::RestaurantIcon => "RESTAURANT_ICON",
                IconImageIcon::ShoppingCart => "SHOPPING_CART",
                IconImageIcon::Star => "STAR",
                IconImageIcon::Store => "STORE",
                IconImageIcon::Ticket => "TICKET",
                IconImageIcon::Train => "TRAIN",
                IconImageIcon::VideoCamera => "VIDEO_CAMERA",
                IconImageIcon::VideoPlay => "VIDEO_PLAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for IconImageIcon {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IconImageIcon {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<IconImageIcon, ()> {
            Ok(match s {
                "AIRPLANE" => IconImageIcon::Airplane,
                "BOOKMARK" => IconImageIcon::Bookmark,
                "BUS" => IconImageIcon::Bus,
                "CAR" => IconImageIcon::Car,
                "CLOCK" => IconImageIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => IconImageIcon::ConfirmationNumberIcon,
                "DESCRIPTION" => IconImageIcon::Description,
                "DOLLAR" => IconImageIcon::Dollar,
                "EDIT" => IconImageIcon::Edit,
                "EDIT_NOTE" => IconImageIcon::EditNote,
                "EMAIL" => IconImageIcon::Email,
                "EVENT_PERFORMER" => IconImageIcon::EventPerformer,
                "EVENT_SEAT" => IconImageIcon::EventSeat,
                "FLIGHT_ARRIVAL" => IconImageIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => IconImageIcon::FlightDeparture,
                "HOTEL" => IconImageIcon::Hotel,
                "HOTEL_ROOM_TYPE" => IconImageIcon::HotelRoomType,
                "INVITE" => IconImageIcon::Invite,
                "MAP_PIN" => IconImageIcon::MapPin,
                "MEMBERSHIP" => IconImageIcon::Membership,
                "MULTIPLE_PEOPLE" => IconImageIcon::MultiplePeople,
                "NONE" => IconImageIcon::None,
                "OFFER" => IconImageIcon::Offer,
                "OPEN_IN_NEW" => IconImageIcon::OpenInNew,
                "PERSON" => IconImageIcon::Person,
                "PHONE" => IconImageIcon::Phone,
                "RESTAURANT_ICON" => IconImageIcon::RestaurantIcon,
                "SHOPPING_CART" => IconImageIcon::ShoppingCart,
                "STAR" => IconImageIcon::Star,
                "STORE" => IconImageIcon::Store,
                "TICKET" => IconImageIcon::Ticket,
                "TRAIN" => IconImageIcon::Train,
                "VIDEO_CAMERA" => IconImageIcon::VideoCamera,
                "VIDEO_PLAY" => IconImageIcon::VideoPlay,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for IconImageIcon {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IconImageIcon {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for IconImageIcon {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AIRPLANE" => IconImageIcon::Airplane,
                "BOOKMARK" => IconImageIcon::Bookmark,
                "BUS" => IconImageIcon::Bus,
                "CAR" => IconImageIcon::Car,
                "CLOCK" => IconImageIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => IconImageIcon::ConfirmationNumberIcon,
                "DESCRIPTION" => IconImageIcon::Description,
                "DOLLAR" => IconImageIcon::Dollar,
                "EDIT" => IconImageIcon::Edit,
                "EDIT_NOTE" => IconImageIcon::EditNote,
                "EMAIL" => IconImageIcon::Email,
                "EVENT_PERFORMER" => IconImageIcon::EventPerformer,
                "EVENT_SEAT" => IconImageIcon::EventSeat,
                "FLIGHT_ARRIVAL" => IconImageIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => IconImageIcon::FlightDeparture,
                "HOTEL" => IconImageIcon::Hotel,
                "HOTEL_ROOM_TYPE" => IconImageIcon::HotelRoomType,
                "INVITE" => IconImageIcon::Invite,
                "MAP_PIN" => IconImageIcon::MapPin,
                "MEMBERSHIP" => IconImageIcon::Membership,
                "MULTIPLE_PEOPLE" => IconImageIcon::MultiplePeople,
                "NONE" => IconImageIcon::None,
                "OFFER" => IconImageIcon::Offer,
                "OPEN_IN_NEW" => IconImageIcon::OpenInNew,
                "PERSON" => IconImageIcon::Person,
                "PHONE" => IconImageIcon::Phone,
                "RESTAURANT_ICON" => IconImageIcon::RestaurantIcon,
                "SHOPPING_CART" => IconImageIcon::ShoppingCart,
                "STAR" => IconImageIcon::Star,
                "STORE" => IconImageIcon::Store,
                "TICKET" => IconImageIcon::Ticket,
                "TRAIN" => IconImageIcon::Train,
                "VIDEO_CAMERA" => IconImageIcon::VideoCamera,
                "VIDEO_PLAY" => IconImageIcon::VideoPlay,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for IconImageIcon {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IconImageIcon {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IconImageImageStyle {
        #[doc = "Applies a circular crop."]
        Circle,
        #[doc = "No value specified."]
        CropTypeNotSet,
        #[doc = "Applies a rectangular crop with a 4:3 aspect ratio."]
        Rectangle43,
        #[doc = "Applies a rectangular crop with a custom aspect ratio."]
        RectangleCustom,
        #[doc = "Applies a square crop."]
        Square,
    }
    impl IconImageImageStyle {
        pub fn as_str(self) -> &'static str {
            match self {
                IconImageImageStyle::Circle => "CIRCLE",
                IconImageImageStyle::CropTypeNotSet => "CROP_TYPE_NOT_SET",
                IconImageImageStyle::Rectangle43 => "RECTANGLE_4_3",
                IconImageImageStyle::RectangleCustom => "RECTANGLE_CUSTOM",
                IconImageImageStyle::Square => "SQUARE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for IconImageImageStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IconImageImageStyle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<IconImageImageStyle, ()> {
            Ok(match s {
                "CIRCLE" => IconImageImageStyle::Circle,
                "CROP_TYPE_NOT_SET" => IconImageImageStyle::CropTypeNotSet,
                "RECTANGLE_4_3" => IconImageImageStyle::Rectangle43,
                "RECTANGLE_CUSTOM" => IconImageImageStyle::RectangleCustom,
                "SQUARE" => IconImageImageStyle::Square,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for IconImageImageStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IconImageImageStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for IconImageImageStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CIRCLE" => IconImageImageStyle::Circle,
                "CROP_TYPE_NOT_SET" => IconImageImageStyle::CropTypeNotSet,
                "RECTANGLE_4_3" => IconImageImageStyle::Rectangle43,
                "RECTANGLE_CUSTOM" => IconImageImageStyle::RectangleCustom,
                "SQUARE" => IconImageImageStyle::Square,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for IconImageImageStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IconImageImageStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Id {
        #[doc = "The User account in which the DirEntry was originally created. If name_space==GAIA, then it’s the gaia_id of the user this id is referring to."]
        #[serde(
            rename = "creatorUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub creator_user_id: ::std::option::Option<u64>,
        #[doc = "The local identifier for the DirEntry (local to the creator’s account). local_id + app_name is guaranteed to be unique within the creator account, but not across all User accounts. The string is case sensitive. Ignore if name_space==GAIA. NB For name_space==COSMO, all local_id’s should be defined in google3/java/com/google/storage/cosmo/server/api/SpecialObjectIds.java as they have a special predefined meaning. See cosmo.client.CosmoIdFactory.createObjectId(long,String) for IMPORTANT recommendations when generating IDs."]
        #[serde(
            rename = "localId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub local_id: ::std::option::Option<String>,
        #[doc = "The name space in which this id is unique (typically the application that created it). Values should be drawn from the above enum, but for experimentation, use values greater than 1000."]
        #[serde(
            rename = "nameSpace",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name_space: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for Id {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Id {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Image {
        #[doc = "The alternative text of this image which will be used for accessibility."]
        #[serde(
            rename = "altText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alt_text: ::std::option::Option<String>,
        #[doc = "The aspect ratio of this image (width/height)."]
        #[serde(
            rename = "aspectRatio",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub aspect_ratio: ::std::option::Option<f64>,
        #[doc = "Image url specified by developers. Server side, we will wrap with FIFE so client apps can configure size/cropping/etc."]
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::OnClick>,
    }
    impl ::google_field_selector::FieldSelector for Image {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Image {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ImageButton {
        #[serde(
            rename = "icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon: ::std::option::Option<crate::schemas::ImageButtonIcon>,
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::OnClick>,
    }
    impl ::google_field_selector::FieldSelector for ImageButton {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImageButton {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ImageButtonIcon {
        Airplane,
        Bookmark,
        Bus,
        Car,
        Clock,
        ConfirmationNumberIcon,
        Description,
        Dollar,
        Edit,
        EditNote,
        Email,
        EventPerformer,
        EventSeat,
        FlightArrival,
        FlightDeparture,
        Hotel,
        HotelRoomType,
        Invite,
        MapPin,
        Membership,
        MultiplePeople,
        None,
        Offer,
        OpenInNew,
        Person,
        Phone,
        RestaurantIcon,
        ShoppingCart,
        Star,
        Store,
        Ticket,
        Train,
        VideoCamera,
        #[doc = "Add new items in alphabetical order. Next Available ID: 34"]
        VideoPlay,
    }
    impl ImageButtonIcon {
        pub fn as_str(self) -> &'static str {
            match self {
                ImageButtonIcon::Airplane => "AIRPLANE",
                ImageButtonIcon::Bookmark => "BOOKMARK",
                ImageButtonIcon::Bus => "BUS",
                ImageButtonIcon::Car => "CAR",
                ImageButtonIcon::Clock => "CLOCK",
                ImageButtonIcon::ConfirmationNumberIcon => "CONFIRMATION_NUMBER_ICON",
                ImageButtonIcon::Description => "DESCRIPTION",
                ImageButtonIcon::Dollar => "DOLLAR",
                ImageButtonIcon::Edit => "EDIT",
                ImageButtonIcon::EditNote => "EDIT_NOTE",
                ImageButtonIcon::Email => "EMAIL",
                ImageButtonIcon::EventPerformer => "EVENT_PERFORMER",
                ImageButtonIcon::EventSeat => "EVENT_SEAT",
                ImageButtonIcon::FlightArrival => "FLIGHT_ARRIVAL",
                ImageButtonIcon::FlightDeparture => "FLIGHT_DEPARTURE",
                ImageButtonIcon::Hotel => "HOTEL",
                ImageButtonIcon::HotelRoomType => "HOTEL_ROOM_TYPE",
                ImageButtonIcon::Invite => "INVITE",
                ImageButtonIcon::MapPin => "MAP_PIN",
                ImageButtonIcon::Membership => "MEMBERSHIP",
                ImageButtonIcon::MultiplePeople => "MULTIPLE_PEOPLE",
                ImageButtonIcon::None => "NONE",
                ImageButtonIcon::Offer => "OFFER",
                ImageButtonIcon::OpenInNew => "OPEN_IN_NEW",
                ImageButtonIcon::Person => "PERSON",
                ImageButtonIcon::Phone => "PHONE",
                ImageButtonIcon::RestaurantIcon => "RESTAURANT_ICON",
                ImageButtonIcon::ShoppingCart => "SHOPPING_CART",
                ImageButtonIcon::Star => "STAR",
                ImageButtonIcon::Store => "STORE",
                ImageButtonIcon::Ticket => "TICKET",
                ImageButtonIcon::Train => "TRAIN",
                ImageButtonIcon::VideoCamera => "VIDEO_CAMERA",
                ImageButtonIcon::VideoPlay => "VIDEO_PLAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ImageButtonIcon {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ImageButtonIcon {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ImageButtonIcon, ()> {
            Ok(match s {
                "AIRPLANE" => ImageButtonIcon::Airplane,
                "BOOKMARK" => ImageButtonIcon::Bookmark,
                "BUS" => ImageButtonIcon::Bus,
                "CAR" => ImageButtonIcon::Car,
                "CLOCK" => ImageButtonIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => ImageButtonIcon::ConfirmationNumberIcon,
                "DESCRIPTION" => ImageButtonIcon::Description,
                "DOLLAR" => ImageButtonIcon::Dollar,
                "EDIT" => ImageButtonIcon::Edit,
                "EDIT_NOTE" => ImageButtonIcon::EditNote,
                "EMAIL" => ImageButtonIcon::Email,
                "EVENT_PERFORMER" => ImageButtonIcon::EventPerformer,
                "EVENT_SEAT" => ImageButtonIcon::EventSeat,
                "FLIGHT_ARRIVAL" => ImageButtonIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => ImageButtonIcon::FlightDeparture,
                "HOTEL" => ImageButtonIcon::Hotel,
                "HOTEL_ROOM_TYPE" => ImageButtonIcon::HotelRoomType,
                "INVITE" => ImageButtonIcon::Invite,
                "MAP_PIN" => ImageButtonIcon::MapPin,
                "MEMBERSHIP" => ImageButtonIcon::Membership,
                "MULTIPLE_PEOPLE" => ImageButtonIcon::MultiplePeople,
                "NONE" => ImageButtonIcon::None,
                "OFFER" => ImageButtonIcon::Offer,
                "OPEN_IN_NEW" => ImageButtonIcon::OpenInNew,
                "PERSON" => ImageButtonIcon::Person,
                "PHONE" => ImageButtonIcon::Phone,
                "RESTAURANT_ICON" => ImageButtonIcon::RestaurantIcon,
                "SHOPPING_CART" => ImageButtonIcon::ShoppingCart,
                "STAR" => ImageButtonIcon::Star,
                "STORE" => ImageButtonIcon::Store,
                "TICKET" => ImageButtonIcon::Ticket,
                "TRAIN" => ImageButtonIcon::Train,
                "VIDEO_CAMERA" => ImageButtonIcon::VideoCamera,
                "VIDEO_PLAY" => ImageButtonIcon::VideoPlay,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ImageButtonIcon {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ImageButtonIcon {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImageButtonIcon {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AIRPLANE" => ImageButtonIcon::Airplane,
                "BOOKMARK" => ImageButtonIcon::Bookmark,
                "BUS" => ImageButtonIcon::Bus,
                "CAR" => ImageButtonIcon::Car,
                "CLOCK" => ImageButtonIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => ImageButtonIcon::ConfirmationNumberIcon,
                "DESCRIPTION" => ImageButtonIcon::Description,
                "DOLLAR" => ImageButtonIcon::Dollar,
                "EDIT" => ImageButtonIcon::Edit,
                "EDIT_NOTE" => ImageButtonIcon::EditNote,
                "EMAIL" => ImageButtonIcon::Email,
                "EVENT_PERFORMER" => ImageButtonIcon::EventPerformer,
                "EVENT_SEAT" => ImageButtonIcon::EventSeat,
                "FLIGHT_ARRIVAL" => ImageButtonIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => ImageButtonIcon::FlightDeparture,
                "HOTEL" => ImageButtonIcon::Hotel,
                "HOTEL_ROOM_TYPE" => ImageButtonIcon::HotelRoomType,
                "INVITE" => ImageButtonIcon::Invite,
                "MAP_PIN" => ImageButtonIcon::MapPin,
                "MEMBERSHIP" => ImageButtonIcon::Membership,
                "MULTIPLE_PEOPLE" => ImageButtonIcon::MultiplePeople,
                "NONE" => ImageButtonIcon::None,
                "OFFER" => ImageButtonIcon::Offer,
                "OPEN_IN_NEW" => ImageButtonIcon::OpenInNew,
                "PERSON" => ImageButtonIcon::Person,
                "PHONE" => ImageButtonIcon::Phone,
                "RESTAURANT_ICON" => ImageButtonIcon::RestaurantIcon,
                "SHOPPING_CART" => ImageButtonIcon::ShoppingCart,
                "STAR" => ImageButtonIcon::Star,
                "STORE" => ImageButtonIcon::Store,
                "TICKET" => ImageButtonIcon::Ticket,
                "TRAIN" => ImageButtonIcon::Train,
                "VIDEO_CAMERA" => ImageButtonIcon::VideoCamera,
                "VIDEO_PLAY" => ImageButtonIcon::VideoPlay,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ImageButtonIcon {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImageButtonIcon {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ImageComponent {
        #[serde(
            rename = "altText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alt_text: ::std::option::Option<String>,
        #[serde(
            rename = "borderStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub border_style: ::std::option::Option<crate::schemas::BorderStyle>,
        #[serde(
            rename = "cropStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub crop_style: ::std::option::Option<crate::schemas::ImageCropStyle>,
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ImageComponent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImageComponent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ImageCropStyle {
        #[doc = "The aspect ratio to use if the crop type is RECTANGLE_CUSTOM."]
        #[serde(
            rename = "aspectRatio",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub aspect_ratio: ::std::option::Option<f64>,
        #[doc = "The crop type."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::ImageCropStyleType>,
    }
    impl ::google_field_selector::FieldSelector for ImageCropStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImageCropStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ImageCropStyleType {
        #[doc = "Applies a circular crop."]
        Circle,
        #[doc = "No value specified."]
        CropTypeNotSet,
        #[doc = "Applies a rectangular crop with a 4:3 aspect ratio."]
        Rectangle43,
        #[doc = "Applies a rectangular crop with a custom aspect ratio."]
        RectangleCustom,
        #[doc = "Applies a square crop."]
        Square,
    }
    impl ImageCropStyleType {
        pub fn as_str(self) -> &'static str {
            match self {
                ImageCropStyleType::Circle => "CIRCLE",
                ImageCropStyleType::CropTypeNotSet => "CROP_TYPE_NOT_SET",
                ImageCropStyleType::Rectangle43 => "RECTANGLE_4_3",
                ImageCropStyleType::RectangleCustom => "RECTANGLE_CUSTOM",
                ImageCropStyleType::Square => "SQUARE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ImageCropStyleType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ImageCropStyleType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ImageCropStyleType, ()> {
            Ok(match s {
                "CIRCLE" => ImageCropStyleType::Circle,
                "CROP_TYPE_NOT_SET" => ImageCropStyleType::CropTypeNotSet,
                "RECTANGLE_4_3" => ImageCropStyleType::Rectangle43,
                "RECTANGLE_CUSTOM" => ImageCropStyleType::RectangleCustom,
                "SQUARE" => ImageCropStyleType::Square,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ImageCropStyleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ImageCropStyleType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImageCropStyleType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CIRCLE" => ImageCropStyleType::Circle,
                "CROP_TYPE_NOT_SET" => ImageCropStyleType::CropTypeNotSet,
                "RECTANGLE_4_3" => ImageCropStyleType::Rectangle43,
                "RECTANGLE_CUSTOM" => ImageCropStyleType::RectangleCustom,
                "SQUARE" => ImageCropStyleType::Square,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ImageCropStyleType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImageCropStyleType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ImageKeyValue {
        #[serde(
            rename = "icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon: ::std::option::Option<crate::schemas::ImageKeyValueIcon>,
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::OnClick>,
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ImageKeyValue {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImageKeyValue {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ImageKeyValueIcon {
        Airplane,
        Bookmark,
        Bus,
        Car,
        Clock,
        ConfirmationNumberIcon,
        Description,
        Dollar,
        Edit,
        EditNote,
        Email,
        EventPerformer,
        EventSeat,
        FlightArrival,
        FlightDeparture,
        Hotel,
        HotelRoomType,
        Invite,
        MapPin,
        Membership,
        MultiplePeople,
        None,
        Offer,
        OpenInNew,
        Person,
        Phone,
        RestaurantIcon,
        ShoppingCart,
        Star,
        Store,
        Ticket,
        Train,
        VideoCamera,
        #[doc = "Add new items in alphabetical order. Next Available ID: 34"]
        VideoPlay,
    }
    impl ImageKeyValueIcon {
        pub fn as_str(self) -> &'static str {
            match self {
                ImageKeyValueIcon::Airplane => "AIRPLANE",
                ImageKeyValueIcon::Bookmark => "BOOKMARK",
                ImageKeyValueIcon::Bus => "BUS",
                ImageKeyValueIcon::Car => "CAR",
                ImageKeyValueIcon::Clock => "CLOCK",
                ImageKeyValueIcon::ConfirmationNumberIcon => "CONFIRMATION_NUMBER_ICON",
                ImageKeyValueIcon::Description => "DESCRIPTION",
                ImageKeyValueIcon::Dollar => "DOLLAR",
                ImageKeyValueIcon::Edit => "EDIT",
                ImageKeyValueIcon::EditNote => "EDIT_NOTE",
                ImageKeyValueIcon::Email => "EMAIL",
                ImageKeyValueIcon::EventPerformer => "EVENT_PERFORMER",
                ImageKeyValueIcon::EventSeat => "EVENT_SEAT",
                ImageKeyValueIcon::FlightArrival => "FLIGHT_ARRIVAL",
                ImageKeyValueIcon::FlightDeparture => "FLIGHT_DEPARTURE",
                ImageKeyValueIcon::Hotel => "HOTEL",
                ImageKeyValueIcon::HotelRoomType => "HOTEL_ROOM_TYPE",
                ImageKeyValueIcon::Invite => "INVITE",
                ImageKeyValueIcon::MapPin => "MAP_PIN",
                ImageKeyValueIcon::Membership => "MEMBERSHIP",
                ImageKeyValueIcon::MultiplePeople => "MULTIPLE_PEOPLE",
                ImageKeyValueIcon::None => "NONE",
                ImageKeyValueIcon::Offer => "OFFER",
                ImageKeyValueIcon::OpenInNew => "OPEN_IN_NEW",
                ImageKeyValueIcon::Person => "PERSON",
                ImageKeyValueIcon::Phone => "PHONE",
                ImageKeyValueIcon::RestaurantIcon => "RESTAURANT_ICON",
                ImageKeyValueIcon::ShoppingCart => "SHOPPING_CART",
                ImageKeyValueIcon::Star => "STAR",
                ImageKeyValueIcon::Store => "STORE",
                ImageKeyValueIcon::Ticket => "TICKET",
                ImageKeyValueIcon::Train => "TRAIN",
                ImageKeyValueIcon::VideoCamera => "VIDEO_CAMERA",
                ImageKeyValueIcon::VideoPlay => "VIDEO_PLAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ImageKeyValueIcon {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ImageKeyValueIcon {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ImageKeyValueIcon, ()> {
            Ok(match s {
                "AIRPLANE" => ImageKeyValueIcon::Airplane,
                "BOOKMARK" => ImageKeyValueIcon::Bookmark,
                "BUS" => ImageKeyValueIcon::Bus,
                "CAR" => ImageKeyValueIcon::Car,
                "CLOCK" => ImageKeyValueIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => ImageKeyValueIcon::ConfirmationNumberIcon,
                "DESCRIPTION" => ImageKeyValueIcon::Description,
                "DOLLAR" => ImageKeyValueIcon::Dollar,
                "EDIT" => ImageKeyValueIcon::Edit,
                "EDIT_NOTE" => ImageKeyValueIcon::EditNote,
                "EMAIL" => ImageKeyValueIcon::Email,
                "EVENT_PERFORMER" => ImageKeyValueIcon::EventPerformer,
                "EVENT_SEAT" => ImageKeyValueIcon::EventSeat,
                "FLIGHT_ARRIVAL" => ImageKeyValueIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => ImageKeyValueIcon::FlightDeparture,
                "HOTEL" => ImageKeyValueIcon::Hotel,
                "HOTEL_ROOM_TYPE" => ImageKeyValueIcon::HotelRoomType,
                "INVITE" => ImageKeyValueIcon::Invite,
                "MAP_PIN" => ImageKeyValueIcon::MapPin,
                "MEMBERSHIP" => ImageKeyValueIcon::Membership,
                "MULTIPLE_PEOPLE" => ImageKeyValueIcon::MultiplePeople,
                "NONE" => ImageKeyValueIcon::None,
                "OFFER" => ImageKeyValueIcon::Offer,
                "OPEN_IN_NEW" => ImageKeyValueIcon::OpenInNew,
                "PERSON" => ImageKeyValueIcon::Person,
                "PHONE" => ImageKeyValueIcon::Phone,
                "RESTAURANT_ICON" => ImageKeyValueIcon::RestaurantIcon,
                "SHOPPING_CART" => ImageKeyValueIcon::ShoppingCart,
                "STAR" => ImageKeyValueIcon::Star,
                "STORE" => ImageKeyValueIcon::Store,
                "TICKET" => ImageKeyValueIcon::Ticket,
                "TRAIN" => ImageKeyValueIcon::Train,
                "VIDEO_CAMERA" => ImageKeyValueIcon::VideoCamera,
                "VIDEO_PLAY" => ImageKeyValueIcon::VideoPlay,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ImageKeyValueIcon {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ImageKeyValueIcon {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImageKeyValueIcon {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AIRPLANE" => ImageKeyValueIcon::Airplane,
                "BOOKMARK" => ImageKeyValueIcon::Bookmark,
                "BUS" => ImageKeyValueIcon::Bus,
                "CAR" => ImageKeyValueIcon::Car,
                "CLOCK" => ImageKeyValueIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => ImageKeyValueIcon::ConfirmationNumberIcon,
                "DESCRIPTION" => ImageKeyValueIcon::Description,
                "DOLLAR" => ImageKeyValueIcon::Dollar,
                "EDIT" => ImageKeyValueIcon::Edit,
                "EDIT_NOTE" => ImageKeyValueIcon::EditNote,
                "EMAIL" => ImageKeyValueIcon::Email,
                "EVENT_PERFORMER" => ImageKeyValueIcon::EventPerformer,
                "EVENT_SEAT" => ImageKeyValueIcon::EventSeat,
                "FLIGHT_ARRIVAL" => ImageKeyValueIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => ImageKeyValueIcon::FlightDeparture,
                "HOTEL" => ImageKeyValueIcon::Hotel,
                "HOTEL_ROOM_TYPE" => ImageKeyValueIcon::HotelRoomType,
                "INVITE" => ImageKeyValueIcon::Invite,
                "MAP_PIN" => ImageKeyValueIcon::MapPin,
                "MEMBERSHIP" => ImageKeyValueIcon::Membership,
                "MULTIPLE_PEOPLE" => ImageKeyValueIcon::MultiplePeople,
                "NONE" => ImageKeyValueIcon::None,
                "OFFER" => ImageKeyValueIcon::Offer,
                "OPEN_IN_NEW" => ImageKeyValueIcon::OpenInNew,
                "PERSON" => ImageKeyValueIcon::Person,
                "PHONE" => ImageKeyValueIcon::Phone,
                "RESTAURANT_ICON" => ImageKeyValueIcon::RestaurantIcon,
                "SHOPPING_CART" => ImageKeyValueIcon::ShoppingCart,
                "STAR" => ImageKeyValueIcon::Star,
                "STORE" => ImageKeyValueIcon::Store,
                "TICKET" => ImageKeyValueIcon::Ticket,
                "TRAIN" => ImageKeyValueIcon::Train,
                "VIDEO_CAMERA" => ImageKeyValueIcon::VideoCamera,
                "VIDEO_PLAY" => ImageKeyValueIcon::VideoPlay,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ImageKeyValueIcon {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImageKeyValueIcon {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ImapSessionContext {
        #[serde(
            rename = "app",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app: ::std::option::Option<crate::schemas::ImapSessionContextApp>,
        #[doc = "User agent information"]
        #[serde(
            rename = "deviceType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub device_type: ::std::option::Option<crate::schemas::ImapSessionContextDeviceType>,
        #[doc = "As agreed with Bond team, this holds the fingerprint of any “aguid” or “guid” provided by the ID command. The fingerprint should be calculated by fingerprint2011. Note that not all clients will provide aguid or guid through ID command."]
        #[serde(
            rename = "guidFingerprint",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub guid_fingerprint: ::std::option::Option<u64>,
        #[serde(
            rename = "os",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub os: ::std::option::Option<crate::schemas::ImapSessionContextOs>,
        #[serde(
            rename = "osVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub os_version: ::std::option::Option<crate::schemas::OsVersion>,
        #[serde(
            rename = "possiblyTrimmedModel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub possibly_trimmed_model: ::std::option::Option<crate::schemas::PossiblyTrimmedModel>,
    }
    impl ::google_field_selector::FieldSelector for ImapSessionContext {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapSessionContext {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ImapSessionContextApp {
        #[doc = "AdSense"]
        AdsenseApp,
        #[doc = "AdWords"]
        AdwordsApp,
        #[doc = "Allo"]
        AlloApp,
        #[doc = "Android’s legacy default AOSP browser (distinct"]
        AndroidBrowser,
        #[doc = "Android Device Manager"]
        AndroidDeviceManagerApp,
        #[doc = "Native Android email app"]
        AndroidEmailApp,
        #[doc = "Apple apps (mail, contacts & calendar)"]
        AppleNativeApp,
        #[doc = "Google Arts & Culture"]
        ArtsAndCultureApp,
        #[doc = "Google Assistant standalone app. iOS only,"]
        AssistantApp,
        #[doc = "Battlestar (go/battlestar)"]
        BattlestarApp,
        #[doc = "BlackBerry Internet Service"]
        BisApp,
        #[doc = "Boxer"]
        BoxerApp,
        #[doc = "Calendar"]
        CalendarApp,
        #[doc = "Browsers Google Chrome"]
        Chrome,
        #[doc = "Chrome Sync"]
        ChromeSyncApp,
        #[doc = "Chrome Webview"]
        ChromeWebviewApp,
        #[doc = "Google Classroom"]
        ClassroomApp,
        #[doc = "Popoular browser in Vietnam"]
        CocCocBrowser,
        #[doc = "Datally"]
        DatallyApp,
        DeprecatedIosMailApp,
        #[doc = "Do not remove this fields - remvoing them caused issues in the past (see cl/180425348 for reference)."]
        DeprecatedMacOsxMailApp,
        #[doc = "Docs"]
        DocsApp,
        #[doc = "Drive"]
        DriveApp,
        #[doc = "Drive Sync"]
        DriveSyncApp,
        #[doc = "Duo"]
        DuoApp,
        #[doc = "Google Earth"]
        EarthApp,
        #[doc = "Tag #7 used to be CHROME_WEBVIEW, which was deprecated and replaced by CHROME_WEBVIEW_APP. When adding a new browser, skip #7 for safety. Microsoft Edge"]
        Edge,
        #[doc = "Google Express (formerly Shopping Express)"]
        ExpressApp,
        #[doc = "Google Family Link"]
        FamilyLinkApp,
        #[doc = "Files Go"]
        FilesGoApp,
        #[doc = "Mozilla Firefox"]
        Firefox,
        #[doc = "since on Android OPA is integrated in GSA. Gboard - the Google Keyboard"]
        GboardApp,
        #[doc = "Email apps Gmail"]
        GmailApp,
        #[doc = "Inbox by Gmail"]
        GmailInboxApp,
        #[doc = "Maps"]
        GmmApp,
        #[doc = "Google Analytics"]
        GoogleAnalyticsApp,
        #[doc = "Google Go"]
        GoogleGoApp,
        #[doc = "Google My Business"]
        GoogleMyBusinessApp,
        #[doc = "Google Pay (formerly Android Pay)"]
        GooglePayApp,
        #[doc = "Includes both Now and Search on GSA."]
        GsaApp,
        #[doc = "Hangouts Classic"]
        HangoutsApp,
        #[doc = "Hangouts Meet"]
        HangoutsMeetApp,
        #[doc = "Google Home app (rebranded from Chromecast app)"]
        HomeApp,
        #[doc = "Jamboard app (go/jamboard)"]
        JamboardApp,
        #[doc = "Keep"]
        KeepApp,
        #[doc = "Mail.dll by Limilabs"]
        LimilabsMailDll,
        #[doc = "Non-browser, non-mail, non-first-party apps LogDog (https://getlogdog.com/)"]
        LogdogApp,
        #[doc = "Tag for the maximum enum value that represents a browser. Enum values (strictly) between OTHER_APP and this value represent browsers. This should never appear in real data."]
        MaxBrowserAppValue,
        #[doc = "Motorola email app"]
        MotoEmailApp,
        #[doc = "Microsoft Internet Explorer"]
        Msie,
        #[doc = "MSIE in Compatibility View. See b/22467241."]
        MsieCompatibility,
        #[doc = "Google News & Weather"]
        NewsApp,
        #[doc = "Opera"]
        Opera,
        #[doc = "Google Opinion Rewards"]
        OpinionRewardsApp,
        #[doc = "Unknown"]
        OtherApp,
        #[doc = "Browser not otherwise specified"]
        OtherBrowser,
        #[doc = "Microsoft Outlook"]
        OutlookMailApp,
        #[doc = "Photos"]
        PhotosApp,
        #[doc = "Google Play"]
        PlayApp,
        #[doc = "Google Play Books"]
        PlayBooksApp,
        #[doc = "Google Play Games"]
        PlayGamesApp,
        #[doc = "Google Play Movies & TV"]
        PlayMoviesApp,
        #[doc = "Google Play Music"]
        PlayMusicApp,
        #[doc = "Google Play Newsstand"]
        PlayNewsstandApp,
        #[doc = "Google+"]
        PlusApp,
        #[doc = "Pokemon GO (uses Google to sign in)"]
        PokemonGoApp,
        #[doc = "Apple Safari"]
        Safari,
        #[doc = "Safari Webview"]
        SafariWebviewApp,
        #[doc = "Samsung browser on Android"]
        SamsungBrowser,
        #[doc = "(replaced by Gmail in Lollipop) Samsung mail"]
        SamsungMailApp,
        #[doc = "Sheets"]
        SheetsApp,
        #[doc = "Amazon Silk browser"]
        SilkBrowser,
        #[doc = "Slides"]
        SlidesApp,
        #[doc = "SmartLock"]
        SmartLockApp,
        #[doc = "Stadia (go/stadia)"]
        StadiaApp,
        #[doc = "Google Street View"]
        StreetViewApp,
        #[doc = "Tez payment app for India (go/paisa)"]
        TezApp,
        #[doc = "Translate"]
        TranslateApp,
        #[doc = "Google Trips"]
        TripsApp,
        #[doc = "UC Browser"]
        UcBrowser,
        #[doc = "Google Voice"]
        VoiceApp,
        #[doc = "Google Wallet"]
        WalletApp,
        #[doc = "Waze"]
        WazeApp,
        #[doc = "Android Wear companion app"]
        WearApp,
        #[doc = "WhatsApp in Drive"]
        WhatsAppInDriveApp,
        #[doc = "Google Wifi (incl. OnHub)"]
        WifiApp,
        #[doc = "from customized OEM flavours). Yandex Browser"]
        YandexBrowser,
        #[doc = "YouTube"]
        YoutubeApp,
        #[doc = "YouTube Capture"]
        YoutubeCaptureApp,
        #[doc = "YouTube Creator Studio"]
        YoutubeCreatorApp,
        #[doc = "YouTube Gaming"]
        YoutubeGamingApp,
        #[doc = "YouTube Go"]
        YoutubeGoApp,
        #[doc = "YouTube Kids"]
        YoutubeKidsApp,
        #[doc = "YouTube Music"]
        YoutubeMusicApp,
        #[doc = "YouTube TV"]
        YoutubeTvApp,
        #[doc = "YouTube VR"]
        YoutubeVrApp,
    }
    impl ImapSessionContextApp {
        pub fn as_str(self) -> &'static str {
            match self {
                ImapSessionContextApp::AdsenseApp => "ADSENSE_APP",
                ImapSessionContextApp::AdwordsApp => "ADWORDS_APP",
                ImapSessionContextApp::AlloApp => "ALLO_APP",
                ImapSessionContextApp::AndroidBrowser => "ANDROID_BROWSER",
                ImapSessionContextApp::AndroidDeviceManagerApp => "ANDROID_DEVICE_MANAGER_APP",
                ImapSessionContextApp::AndroidEmailApp => "ANDROID_EMAIL_APP",
                ImapSessionContextApp::AppleNativeApp => "APPLE_NATIVE_APP",
                ImapSessionContextApp::ArtsAndCultureApp => "ARTS_AND_CULTURE_APP",
                ImapSessionContextApp::AssistantApp => "ASSISTANT_APP",
                ImapSessionContextApp::BattlestarApp => "BATTLESTAR_APP",
                ImapSessionContextApp::BisApp => "BIS_APP",
                ImapSessionContextApp::BoxerApp => "BOXER_APP",
                ImapSessionContextApp::CalendarApp => "CALENDAR_APP",
                ImapSessionContextApp::Chrome => "CHROME",
                ImapSessionContextApp::ChromeSyncApp => "CHROME_SYNC_APP",
                ImapSessionContextApp::ChromeWebviewApp => "CHROME_WEBVIEW_APP",
                ImapSessionContextApp::ClassroomApp => "CLASSROOM_APP",
                ImapSessionContextApp::CocCocBrowser => "COC_COC_BROWSER",
                ImapSessionContextApp::DatallyApp => "DATALLY_APP",
                ImapSessionContextApp::DeprecatedIosMailApp => "DEPRECATED_IOS_MAIL_APP",
                ImapSessionContextApp::DeprecatedMacOsxMailApp => "DEPRECATED_MAC_OSX_MAIL_APP",
                ImapSessionContextApp::DocsApp => "DOCS_APP",
                ImapSessionContextApp::DriveApp => "DRIVE_APP",
                ImapSessionContextApp::DriveSyncApp => "DRIVE_SYNC_APP",
                ImapSessionContextApp::DuoApp => "DUO_APP",
                ImapSessionContextApp::EarthApp => "EARTH_APP",
                ImapSessionContextApp::Edge => "EDGE",
                ImapSessionContextApp::ExpressApp => "EXPRESS_APP",
                ImapSessionContextApp::FamilyLinkApp => "FAMILY_LINK_APP",
                ImapSessionContextApp::FilesGoApp => "FILES_GO_APP",
                ImapSessionContextApp::Firefox => "FIREFOX",
                ImapSessionContextApp::GboardApp => "GBOARD_APP",
                ImapSessionContextApp::GmailApp => "GMAIL_APP",
                ImapSessionContextApp::GmailInboxApp => "GMAIL_INBOX_APP",
                ImapSessionContextApp::GmmApp => "GMM_APP",
                ImapSessionContextApp::GoogleAnalyticsApp => "GOOGLE_ANALYTICS_APP",
                ImapSessionContextApp::GoogleGoApp => "GOOGLE_GO_APP",
                ImapSessionContextApp::GoogleMyBusinessApp => "GOOGLE_MY_BUSINESS_APP",
                ImapSessionContextApp::GooglePayApp => "GOOGLE_PAY_APP",
                ImapSessionContextApp::GsaApp => "GSA_APP",
                ImapSessionContextApp::HangoutsApp => "HANGOUTS_APP",
                ImapSessionContextApp::HangoutsMeetApp => "HANGOUTS_MEET_APP",
                ImapSessionContextApp::HomeApp => "HOME_APP",
                ImapSessionContextApp::JamboardApp => "JAMBOARD_APP",
                ImapSessionContextApp::KeepApp => "KEEP_APP",
                ImapSessionContextApp::LimilabsMailDll => "LIMILABS_MAIL_DLL",
                ImapSessionContextApp::LogdogApp => "LOGDOG_APP",
                ImapSessionContextApp::MaxBrowserAppValue => "MAX_BROWSER_APP_VALUE",
                ImapSessionContextApp::MotoEmailApp => "MOTO_EMAIL_APP",
                ImapSessionContextApp::Msie => "MSIE",
                ImapSessionContextApp::MsieCompatibility => "MSIE_COMPATIBILITY",
                ImapSessionContextApp::NewsApp => "NEWS_APP",
                ImapSessionContextApp::Opera => "OPERA",
                ImapSessionContextApp::OpinionRewardsApp => "OPINION_REWARDS_APP",
                ImapSessionContextApp::OtherApp => "OTHER_APP",
                ImapSessionContextApp::OtherBrowser => "OTHER_BROWSER",
                ImapSessionContextApp::OutlookMailApp => "OUTLOOK_MAIL_APP",
                ImapSessionContextApp::PhotosApp => "PHOTOS_APP",
                ImapSessionContextApp::PlayApp => "PLAY_APP",
                ImapSessionContextApp::PlayBooksApp => "PLAY_BOOKS_APP",
                ImapSessionContextApp::PlayGamesApp => "PLAY_GAMES_APP",
                ImapSessionContextApp::PlayMoviesApp => "PLAY_MOVIES_APP",
                ImapSessionContextApp::PlayMusicApp => "PLAY_MUSIC_APP",
                ImapSessionContextApp::PlayNewsstandApp => "PLAY_NEWSSTAND_APP",
                ImapSessionContextApp::PlusApp => "PLUS_APP",
                ImapSessionContextApp::PokemonGoApp => "POKEMON_GO_APP",
                ImapSessionContextApp::Safari => "SAFARI",
                ImapSessionContextApp::SafariWebviewApp => "SAFARI_WEBVIEW_APP",
                ImapSessionContextApp::SamsungBrowser => "SAMSUNG_BROWSER",
                ImapSessionContextApp::SamsungMailApp => "SAMSUNG_MAIL_APP",
                ImapSessionContextApp::SheetsApp => "SHEETS_APP",
                ImapSessionContextApp::SilkBrowser => "SILK_BROWSER",
                ImapSessionContextApp::SlidesApp => "SLIDES_APP",
                ImapSessionContextApp::SmartLockApp => "SMART_LOCK_APP",
                ImapSessionContextApp::StadiaApp => "STADIA_APP",
                ImapSessionContextApp::StreetViewApp => "STREET_VIEW_APP",
                ImapSessionContextApp::TezApp => "TEZ_APP",
                ImapSessionContextApp::TranslateApp => "TRANSLATE_APP",
                ImapSessionContextApp::TripsApp => "TRIPS_APP",
                ImapSessionContextApp::UcBrowser => "UC_BROWSER",
                ImapSessionContextApp::VoiceApp => "VOICE_APP",
                ImapSessionContextApp::WalletApp => "WALLET_APP",
                ImapSessionContextApp::WazeApp => "WAZE_APP",
                ImapSessionContextApp::WearApp => "WEAR_APP",
                ImapSessionContextApp::WhatsAppInDriveApp => "WHATS_APP_IN_DRIVE_APP",
                ImapSessionContextApp::WifiApp => "WIFI_APP",
                ImapSessionContextApp::YandexBrowser => "YANDEX_BROWSER",
                ImapSessionContextApp::YoutubeApp => "YOUTUBE_APP",
                ImapSessionContextApp::YoutubeCaptureApp => "YOUTUBE_CAPTURE_APP",
                ImapSessionContextApp::YoutubeCreatorApp => "YOUTUBE_CREATOR_APP",
                ImapSessionContextApp::YoutubeGamingApp => "YOUTUBE_GAMING_APP",
                ImapSessionContextApp::YoutubeGoApp => "YOUTUBE_GO_APP",
                ImapSessionContextApp::YoutubeKidsApp => "YOUTUBE_KIDS_APP",
                ImapSessionContextApp::YoutubeMusicApp => "YOUTUBE_MUSIC_APP",
                ImapSessionContextApp::YoutubeTvApp => "YOUTUBE_TV_APP",
                ImapSessionContextApp::YoutubeVrApp => "YOUTUBE_VR_APP",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ImapSessionContextApp {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ImapSessionContextApp {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ImapSessionContextApp, ()> {
            Ok(match s {
                "ADSENSE_APP" => ImapSessionContextApp::AdsenseApp,
                "ADWORDS_APP" => ImapSessionContextApp::AdwordsApp,
                "ALLO_APP" => ImapSessionContextApp::AlloApp,
                "ANDROID_BROWSER" => ImapSessionContextApp::AndroidBrowser,
                "ANDROID_DEVICE_MANAGER_APP" => ImapSessionContextApp::AndroidDeviceManagerApp,
                "ANDROID_EMAIL_APP" => ImapSessionContextApp::AndroidEmailApp,
                "APPLE_NATIVE_APP" => ImapSessionContextApp::AppleNativeApp,
                "ARTS_AND_CULTURE_APP" => ImapSessionContextApp::ArtsAndCultureApp,
                "ASSISTANT_APP" => ImapSessionContextApp::AssistantApp,
                "BATTLESTAR_APP" => ImapSessionContextApp::BattlestarApp,
                "BIS_APP" => ImapSessionContextApp::BisApp,
                "BOXER_APP" => ImapSessionContextApp::BoxerApp,
                "CALENDAR_APP" => ImapSessionContextApp::CalendarApp,
                "CHROME" => ImapSessionContextApp::Chrome,
                "CHROME_SYNC_APP" => ImapSessionContextApp::ChromeSyncApp,
                "CHROME_WEBVIEW_APP" => ImapSessionContextApp::ChromeWebviewApp,
                "CLASSROOM_APP" => ImapSessionContextApp::ClassroomApp,
                "COC_COC_BROWSER" => ImapSessionContextApp::CocCocBrowser,
                "DATALLY_APP" => ImapSessionContextApp::DatallyApp,
                "DEPRECATED_IOS_MAIL_APP" => ImapSessionContextApp::DeprecatedIosMailApp,
                "DEPRECATED_MAC_OSX_MAIL_APP" => ImapSessionContextApp::DeprecatedMacOsxMailApp,
                "DOCS_APP" => ImapSessionContextApp::DocsApp,
                "DRIVE_APP" => ImapSessionContextApp::DriveApp,
                "DRIVE_SYNC_APP" => ImapSessionContextApp::DriveSyncApp,
                "DUO_APP" => ImapSessionContextApp::DuoApp,
                "EARTH_APP" => ImapSessionContextApp::EarthApp,
                "EDGE" => ImapSessionContextApp::Edge,
                "EXPRESS_APP" => ImapSessionContextApp::ExpressApp,
                "FAMILY_LINK_APP" => ImapSessionContextApp::FamilyLinkApp,
                "FILES_GO_APP" => ImapSessionContextApp::FilesGoApp,
                "FIREFOX" => ImapSessionContextApp::Firefox,
                "GBOARD_APP" => ImapSessionContextApp::GboardApp,
                "GMAIL_APP" => ImapSessionContextApp::GmailApp,
                "GMAIL_INBOX_APP" => ImapSessionContextApp::GmailInboxApp,
                "GMM_APP" => ImapSessionContextApp::GmmApp,
                "GOOGLE_ANALYTICS_APP" => ImapSessionContextApp::GoogleAnalyticsApp,
                "GOOGLE_GO_APP" => ImapSessionContextApp::GoogleGoApp,
                "GOOGLE_MY_BUSINESS_APP" => ImapSessionContextApp::GoogleMyBusinessApp,
                "GOOGLE_PAY_APP" => ImapSessionContextApp::GooglePayApp,
                "GSA_APP" => ImapSessionContextApp::GsaApp,
                "HANGOUTS_APP" => ImapSessionContextApp::HangoutsApp,
                "HANGOUTS_MEET_APP" => ImapSessionContextApp::HangoutsMeetApp,
                "HOME_APP" => ImapSessionContextApp::HomeApp,
                "JAMBOARD_APP" => ImapSessionContextApp::JamboardApp,
                "KEEP_APP" => ImapSessionContextApp::KeepApp,
                "LIMILABS_MAIL_DLL" => ImapSessionContextApp::LimilabsMailDll,
                "LOGDOG_APP" => ImapSessionContextApp::LogdogApp,
                "MAX_BROWSER_APP_VALUE" => ImapSessionContextApp::MaxBrowserAppValue,
                "MOTO_EMAIL_APP" => ImapSessionContextApp::MotoEmailApp,
                "MSIE" => ImapSessionContextApp::Msie,
                "MSIE_COMPATIBILITY" => ImapSessionContextApp::MsieCompatibility,
                "NEWS_APP" => ImapSessionContextApp::NewsApp,
                "OPERA" => ImapSessionContextApp::Opera,
                "OPINION_REWARDS_APP" => ImapSessionContextApp::OpinionRewardsApp,
                "OTHER_APP" => ImapSessionContextApp::OtherApp,
                "OTHER_BROWSER" => ImapSessionContextApp::OtherBrowser,
                "OUTLOOK_MAIL_APP" => ImapSessionContextApp::OutlookMailApp,
                "PHOTOS_APP" => ImapSessionContextApp::PhotosApp,
                "PLAY_APP" => ImapSessionContextApp::PlayApp,
                "PLAY_BOOKS_APP" => ImapSessionContextApp::PlayBooksApp,
                "PLAY_GAMES_APP" => ImapSessionContextApp::PlayGamesApp,
                "PLAY_MOVIES_APP" => ImapSessionContextApp::PlayMoviesApp,
                "PLAY_MUSIC_APP" => ImapSessionContextApp::PlayMusicApp,
                "PLAY_NEWSSTAND_APP" => ImapSessionContextApp::PlayNewsstandApp,
                "PLUS_APP" => ImapSessionContextApp::PlusApp,
                "POKEMON_GO_APP" => ImapSessionContextApp::PokemonGoApp,
                "SAFARI" => ImapSessionContextApp::Safari,
                "SAFARI_WEBVIEW_APP" => ImapSessionContextApp::SafariWebviewApp,
                "SAMSUNG_BROWSER" => ImapSessionContextApp::SamsungBrowser,
                "SAMSUNG_MAIL_APP" => ImapSessionContextApp::SamsungMailApp,
                "SHEETS_APP" => ImapSessionContextApp::SheetsApp,
                "SILK_BROWSER" => ImapSessionContextApp::SilkBrowser,
                "SLIDES_APP" => ImapSessionContextApp::SlidesApp,
                "SMART_LOCK_APP" => ImapSessionContextApp::SmartLockApp,
                "STADIA_APP" => ImapSessionContextApp::StadiaApp,
                "STREET_VIEW_APP" => ImapSessionContextApp::StreetViewApp,
                "TEZ_APP" => ImapSessionContextApp::TezApp,
                "TRANSLATE_APP" => ImapSessionContextApp::TranslateApp,
                "TRIPS_APP" => ImapSessionContextApp::TripsApp,
                "UC_BROWSER" => ImapSessionContextApp::UcBrowser,
                "VOICE_APP" => ImapSessionContextApp::VoiceApp,
                "WALLET_APP" => ImapSessionContextApp::WalletApp,
                "WAZE_APP" => ImapSessionContextApp::WazeApp,
                "WEAR_APP" => ImapSessionContextApp::WearApp,
                "WHATS_APP_IN_DRIVE_APP" => ImapSessionContextApp::WhatsAppInDriveApp,
                "WIFI_APP" => ImapSessionContextApp::WifiApp,
                "YANDEX_BROWSER" => ImapSessionContextApp::YandexBrowser,
                "YOUTUBE_APP" => ImapSessionContextApp::YoutubeApp,
                "YOUTUBE_CAPTURE_APP" => ImapSessionContextApp::YoutubeCaptureApp,
                "YOUTUBE_CREATOR_APP" => ImapSessionContextApp::YoutubeCreatorApp,
                "YOUTUBE_GAMING_APP" => ImapSessionContextApp::YoutubeGamingApp,
                "YOUTUBE_GO_APP" => ImapSessionContextApp::YoutubeGoApp,
                "YOUTUBE_KIDS_APP" => ImapSessionContextApp::YoutubeKidsApp,
                "YOUTUBE_MUSIC_APP" => ImapSessionContextApp::YoutubeMusicApp,
                "YOUTUBE_TV_APP" => ImapSessionContextApp::YoutubeTvApp,
                "YOUTUBE_VR_APP" => ImapSessionContextApp::YoutubeVrApp,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ImapSessionContextApp {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ImapSessionContextApp {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImapSessionContextApp {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADSENSE_APP" => ImapSessionContextApp::AdsenseApp,
                "ADWORDS_APP" => ImapSessionContextApp::AdwordsApp,
                "ALLO_APP" => ImapSessionContextApp::AlloApp,
                "ANDROID_BROWSER" => ImapSessionContextApp::AndroidBrowser,
                "ANDROID_DEVICE_MANAGER_APP" => ImapSessionContextApp::AndroidDeviceManagerApp,
                "ANDROID_EMAIL_APP" => ImapSessionContextApp::AndroidEmailApp,
                "APPLE_NATIVE_APP" => ImapSessionContextApp::AppleNativeApp,
                "ARTS_AND_CULTURE_APP" => ImapSessionContextApp::ArtsAndCultureApp,
                "ASSISTANT_APP" => ImapSessionContextApp::AssistantApp,
                "BATTLESTAR_APP" => ImapSessionContextApp::BattlestarApp,
                "BIS_APP" => ImapSessionContextApp::BisApp,
                "BOXER_APP" => ImapSessionContextApp::BoxerApp,
                "CALENDAR_APP" => ImapSessionContextApp::CalendarApp,
                "CHROME" => ImapSessionContextApp::Chrome,
                "CHROME_SYNC_APP" => ImapSessionContextApp::ChromeSyncApp,
                "CHROME_WEBVIEW_APP" => ImapSessionContextApp::ChromeWebviewApp,
                "CLASSROOM_APP" => ImapSessionContextApp::ClassroomApp,
                "COC_COC_BROWSER" => ImapSessionContextApp::CocCocBrowser,
                "DATALLY_APP" => ImapSessionContextApp::DatallyApp,
                "DEPRECATED_IOS_MAIL_APP" => ImapSessionContextApp::DeprecatedIosMailApp,
                "DEPRECATED_MAC_OSX_MAIL_APP" => ImapSessionContextApp::DeprecatedMacOsxMailApp,
                "DOCS_APP" => ImapSessionContextApp::DocsApp,
                "DRIVE_APP" => ImapSessionContextApp::DriveApp,
                "DRIVE_SYNC_APP" => ImapSessionContextApp::DriveSyncApp,
                "DUO_APP" => ImapSessionContextApp::DuoApp,
                "EARTH_APP" => ImapSessionContextApp::EarthApp,
                "EDGE" => ImapSessionContextApp::Edge,
                "EXPRESS_APP" => ImapSessionContextApp::ExpressApp,
                "FAMILY_LINK_APP" => ImapSessionContextApp::FamilyLinkApp,
                "FILES_GO_APP" => ImapSessionContextApp::FilesGoApp,
                "FIREFOX" => ImapSessionContextApp::Firefox,
                "GBOARD_APP" => ImapSessionContextApp::GboardApp,
                "GMAIL_APP" => ImapSessionContextApp::GmailApp,
                "GMAIL_INBOX_APP" => ImapSessionContextApp::GmailInboxApp,
                "GMM_APP" => ImapSessionContextApp::GmmApp,
                "GOOGLE_ANALYTICS_APP" => ImapSessionContextApp::GoogleAnalyticsApp,
                "GOOGLE_GO_APP" => ImapSessionContextApp::GoogleGoApp,
                "GOOGLE_MY_BUSINESS_APP" => ImapSessionContextApp::GoogleMyBusinessApp,
                "GOOGLE_PAY_APP" => ImapSessionContextApp::GooglePayApp,
                "GSA_APP" => ImapSessionContextApp::GsaApp,
                "HANGOUTS_APP" => ImapSessionContextApp::HangoutsApp,
                "HANGOUTS_MEET_APP" => ImapSessionContextApp::HangoutsMeetApp,
                "HOME_APP" => ImapSessionContextApp::HomeApp,
                "JAMBOARD_APP" => ImapSessionContextApp::JamboardApp,
                "KEEP_APP" => ImapSessionContextApp::KeepApp,
                "LIMILABS_MAIL_DLL" => ImapSessionContextApp::LimilabsMailDll,
                "LOGDOG_APP" => ImapSessionContextApp::LogdogApp,
                "MAX_BROWSER_APP_VALUE" => ImapSessionContextApp::MaxBrowserAppValue,
                "MOTO_EMAIL_APP" => ImapSessionContextApp::MotoEmailApp,
                "MSIE" => ImapSessionContextApp::Msie,
                "MSIE_COMPATIBILITY" => ImapSessionContextApp::MsieCompatibility,
                "NEWS_APP" => ImapSessionContextApp::NewsApp,
                "OPERA" => ImapSessionContextApp::Opera,
                "OPINION_REWARDS_APP" => ImapSessionContextApp::OpinionRewardsApp,
                "OTHER_APP" => ImapSessionContextApp::OtherApp,
                "OTHER_BROWSER" => ImapSessionContextApp::OtherBrowser,
                "OUTLOOK_MAIL_APP" => ImapSessionContextApp::OutlookMailApp,
                "PHOTOS_APP" => ImapSessionContextApp::PhotosApp,
                "PLAY_APP" => ImapSessionContextApp::PlayApp,
                "PLAY_BOOKS_APP" => ImapSessionContextApp::PlayBooksApp,
                "PLAY_GAMES_APP" => ImapSessionContextApp::PlayGamesApp,
                "PLAY_MOVIES_APP" => ImapSessionContextApp::PlayMoviesApp,
                "PLAY_MUSIC_APP" => ImapSessionContextApp::PlayMusicApp,
                "PLAY_NEWSSTAND_APP" => ImapSessionContextApp::PlayNewsstandApp,
                "PLUS_APP" => ImapSessionContextApp::PlusApp,
                "POKEMON_GO_APP" => ImapSessionContextApp::PokemonGoApp,
                "SAFARI" => ImapSessionContextApp::Safari,
                "SAFARI_WEBVIEW_APP" => ImapSessionContextApp::SafariWebviewApp,
                "SAMSUNG_BROWSER" => ImapSessionContextApp::SamsungBrowser,
                "SAMSUNG_MAIL_APP" => ImapSessionContextApp::SamsungMailApp,
                "SHEETS_APP" => ImapSessionContextApp::SheetsApp,
                "SILK_BROWSER" => ImapSessionContextApp::SilkBrowser,
                "SLIDES_APP" => ImapSessionContextApp::SlidesApp,
                "SMART_LOCK_APP" => ImapSessionContextApp::SmartLockApp,
                "STADIA_APP" => ImapSessionContextApp::StadiaApp,
                "STREET_VIEW_APP" => ImapSessionContextApp::StreetViewApp,
                "TEZ_APP" => ImapSessionContextApp::TezApp,
                "TRANSLATE_APP" => ImapSessionContextApp::TranslateApp,
                "TRIPS_APP" => ImapSessionContextApp::TripsApp,
                "UC_BROWSER" => ImapSessionContextApp::UcBrowser,
                "VOICE_APP" => ImapSessionContextApp::VoiceApp,
                "WALLET_APP" => ImapSessionContextApp::WalletApp,
                "WAZE_APP" => ImapSessionContextApp::WazeApp,
                "WEAR_APP" => ImapSessionContextApp::WearApp,
                "WHATS_APP_IN_DRIVE_APP" => ImapSessionContextApp::WhatsAppInDriveApp,
                "WIFI_APP" => ImapSessionContextApp::WifiApp,
                "YANDEX_BROWSER" => ImapSessionContextApp::YandexBrowser,
                "YOUTUBE_APP" => ImapSessionContextApp::YoutubeApp,
                "YOUTUBE_CAPTURE_APP" => ImapSessionContextApp::YoutubeCaptureApp,
                "YOUTUBE_CREATOR_APP" => ImapSessionContextApp::YoutubeCreatorApp,
                "YOUTUBE_GAMING_APP" => ImapSessionContextApp::YoutubeGamingApp,
                "YOUTUBE_GO_APP" => ImapSessionContextApp::YoutubeGoApp,
                "YOUTUBE_KIDS_APP" => ImapSessionContextApp::YoutubeKidsApp,
                "YOUTUBE_MUSIC_APP" => ImapSessionContextApp::YoutubeMusicApp,
                "YOUTUBE_TV_APP" => ImapSessionContextApp::YoutubeTvApp,
                "YOUTUBE_VR_APP" => ImapSessionContextApp::YoutubeVrApp,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ImapSessionContextApp {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapSessionContextApp {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ImapSessionContextDeviceType {
        #[doc = "Examples: Android Auto (Embedded mode, not mirrored from phone)."]
        Car,
        #[doc = "Other connected home devices which do not fit in any of the above categories; that is, neither media- or gaming-focused, nor primarily a voice-enabled speaker."]
        ConnectedHomeOther,
        #[doc = "Devices whose primary purpose is playing games. Examples: Xbox, Playstation."]
        GameConsole,
        #[doc = "Google Glass."]
        Glass,
        #[doc = "Add-on devices (i.e. devices which require connecting to another device, such as screens/TVs/speakers) whose primary purpose is media consumption (excludes physical TV screens). Examples: Chromecast, Roku, Apple TV, Nexus Player."]
        MediaPlayer,
        #[doc = "Primarily used for phones, but also set as default for OSes that are predominantly for phones (Android, iOS etc.) when we can’t determine otherwise."]
        Mobile,
        #[doc = "PCs (incl. Macs). Desktops, laptops and various niche form factors that typically run desktop-class OSes (all-in-ones, HTPCs etc.)."]
        Pc,
        #[doc = "Mobile devices which are not phones, but are capable of storing and playing digital media such as audio, images, and video files. Example: iPod."]
        PortableMediaPlayer,
        #[doc = "Examples: Google Home Display (Quartz/Manhattan/Jasper/Dragonglass), Amazon Echo Spot, Amazon Echo Show."]
        SmartDisplay,
        #[doc = "Examples: Google Home, Amazon Echo."]
        SmartSpeaker,
        #[doc = "Tablets."]
        Tablet,
        #[doc = "Smart TVs which interact with Google products without an external additional device. Includes TV sets which run Android TV directly. Refers to actual TV screens, rather than connected boxes or dongles."]
        Tv,
        #[doc = "Unknown device type."]
        Unknown,
        #[doc = "Standalone VR headsets, such as the Lenovo Mirage Solo. Does not include phone-based VR (such as Daydream View or Gear VR) or PC/Console-based such as Oculus Rift, HTC Vive and PSVR; in such cases, the form factor may be PHONE, PC or GAME_CONSOLE as applicable."]
        VrHeadset,
        #[doc = "Wearable devices such as smartwatches."]
        Wearable,
    }
    impl ImapSessionContextDeviceType {
        pub fn as_str(self) -> &'static str {
            match self {
                ImapSessionContextDeviceType::Car => "CAR",
                ImapSessionContextDeviceType::ConnectedHomeOther => "CONNECTED_HOME_OTHER",
                ImapSessionContextDeviceType::GameConsole => "GAME_CONSOLE",
                ImapSessionContextDeviceType::Glass => "GLASS",
                ImapSessionContextDeviceType::MediaPlayer => "MEDIA_PLAYER",
                ImapSessionContextDeviceType::Mobile => "MOBILE",
                ImapSessionContextDeviceType::Pc => "PC",
                ImapSessionContextDeviceType::PortableMediaPlayer => "PORTABLE_MEDIA_PLAYER",
                ImapSessionContextDeviceType::SmartDisplay => "SMART_DISPLAY",
                ImapSessionContextDeviceType::SmartSpeaker => "SMART_SPEAKER",
                ImapSessionContextDeviceType::Tablet => "TABLET",
                ImapSessionContextDeviceType::Tv => "TV",
                ImapSessionContextDeviceType::Unknown => "UNKNOWN",
                ImapSessionContextDeviceType::VrHeadset => "VR_HEADSET",
                ImapSessionContextDeviceType::Wearable => "WEARABLE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ImapSessionContextDeviceType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ImapSessionContextDeviceType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ImapSessionContextDeviceType, ()> {
            Ok(match s {
                "CAR" => ImapSessionContextDeviceType::Car,
                "CONNECTED_HOME_OTHER" => ImapSessionContextDeviceType::ConnectedHomeOther,
                "GAME_CONSOLE" => ImapSessionContextDeviceType::GameConsole,
                "GLASS" => ImapSessionContextDeviceType::Glass,
                "MEDIA_PLAYER" => ImapSessionContextDeviceType::MediaPlayer,
                "MOBILE" => ImapSessionContextDeviceType::Mobile,
                "PC" => ImapSessionContextDeviceType::Pc,
                "PORTABLE_MEDIA_PLAYER" => ImapSessionContextDeviceType::PortableMediaPlayer,
                "SMART_DISPLAY" => ImapSessionContextDeviceType::SmartDisplay,
                "SMART_SPEAKER" => ImapSessionContextDeviceType::SmartSpeaker,
                "TABLET" => ImapSessionContextDeviceType::Tablet,
                "TV" => ImapSessionContextDeviceType::Tv,
                "UNKNOWN" => ImapSessionContextDeviceType::Unknown,
                "VR_HEADSET" => ImapSessionContextDeviceType::VrHeadset,
                "WEARABLE" => ImapSessionContextDeviceType::Wearable,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ImapSessionContextDeviceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ImapSessionContextDeviceType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImapSessionContextDeviceType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CAR" => ImapSessionContextDeviceType::Car,
                "CONNECTED_HOME_OTHER" => ImapSessionContextDeviceType::ConnectedHomeOther,
                "GAME_CONSOLE" => ImapSessionContextDeviceType::GameConsole,
                "GLASS" => ImapSessionContextDeviceType::Glass,
                "MEDIA_PLAYER" => ImapSessionContextDeviceType::MediaPlayer,
                "MOBILE" => ImapSessionContextDeviceType::Mobile,
                "PC" => ImapSessionContextDeviceType::Pc,
                "PORTABLE_MEDIA_PLAYER" => ImapSessionContextDeviceType::PortableMediaPlayer,
                "SMART_DISPLAY" => ImapSessionContextDeviceType::SmartDisplay,
                "SMART_SPEAKER" => ImapSessionContextDeviceType::SmartSpeaker,
                "TABLET" => ImapSessionContextDeviceType::Tablet,
                "TV" => ImapSessionContextDeviceType::Tv,
                "UNKNOWN" => ImapSessionContextDeviceType::Unknown,
                "VR_HEADSET" => ImapSessionContextDeviceType::VrHeadset,
                "WEARABLE" => ImapSessionContextDeviceType::Wearable,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ImapSessionContextDeviceType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapSessionContextDeviceType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ImapSessionContextOs {
        #[doc = "Mobile operating systems (1-99)."]
        AndroidOs,
        #[doc = "Android optimized for IoT devices. go/things"]
        AndroidThingsOs,
        #[doc = "Apple tvOS (powering the Apple TV)."]
        AppleTvOs,
        BlackberryOs,
        #[doc = "Cast family devices, including Chromecast, Google Home, and third-party speaker with integrated Assistant."]
        CastOs,
        ChromeOs,
        #[doc = "Amazon Fire OS (for Kindle Fire devices or Fire TV)."]
        FireOs,
        IosOs,
        #[doc = "KaiOS, a fork from Firefox OS that is between a full smartphone and a feature phone. Notably, it supports the Google Assistant. go/kaiosama"]
        KaiOs,
        LinuxOs,
        MacOs,
        #[doc = "Tag for the maximum enum value that represents a mobile OS. Enum values (strictly) between UNKNOWN_OS and this value represent mobile OSes. This should never appear in real data."]
        MaxMobileOsValue,
        #[doc = "The OS powering Playstation consoles. Ignores OS changes across console generations."]
        PlaystationOs,
        #[doc = "Stadia on Cast devices. This is not truly an OS, but it’s a temporary setting since Stadia uses a different sign-in flow (and is revoked differently) from Cast. See http://go/stadia-in-google-account. Do not use without discussing with id-devices-eng@."]
        StadiaOs,
        #[doc = "Tizen OS, popular in Samsung TVs, watches and more."]
        TizenOs,
        UnknownOs,
        WinPhoneOs,
        #[doc = "PC operating systems."]
        WindowsOs,
        #[doc = "The Windows-derived OS used on Xbox consoles."]
        XboxOs,
    }
    impl ImapSessionContextOs {
        pub fn as_str(self) -> &'static str {
            match self {
                ImapSessionContextOs::AndroidOs => "ANDROID_OS",
                ImapSessionContextOs::AndroidThingsOs => "ANDROID_THINGS_OS",
                ImapSessionContextOs::AppleTvOs => "APPLE_TV_OS",
                ImapSessionContextOs::BlackberryOs => "BLACKBERRY_OS",
                ImapSessionContextOs::CastOs => "CAST_OS",
                ImapSessionContextOs::ChromeOs => "CHROME_OS",
                ImapSessionContextOs::FireOs => "FIRE_OS",
                ImapSessionContextOs::IosOs => "IOS_OS",
                ImapSessionContextOs::KaiOs => "KAI_OS",
                ImapSessionContextOs::LinuxOs => "LINUX_OS",
                ImapSessionContextOs::MacOs => "MAC_OS",
                ImapSessionContextOs::MaxMobileOsValue => "MAX_MOBILE_OS_VALUE",
                ImapSessionContextOs::PlaystationOs => "PLAYSTATION_OS",
                ImapSessionContextOs::StadiaOs => "STADIA_OS",
                ImapSessionContextOs::TizenOs => "TIZEN_OS",
                ImapSessionContextOs::UnknownOs => "UNKNOWN_OS",
                ImapSessionContextOs::WinPhoneOs => "WIN_PHONE_OS",
                ImapSessionContextOs::WindowsOs => "WINDOWS_OS",
                ImapSessionContextOs::XboxOs => "XBOX_OS",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ImapSessionContextOs {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ImapSessionContextOs {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ImapSessionContextOs, ()> {
            Ok(match s {
                "ANDROID_OS" => ImapSessionContextOs::AndroidOs,
                "ANDROID_THINGS_OS" => ImapSessionContextOs::AndroidThingsOs,
                "APPLE_TV_OS" => ImapSessionContextOs::AppleTvOs,
                "BLACKBERRY_OS" => ImapSessionContextOs::BlackberryOs,
                "CAST_OS" => ImapSessionContextOs::CastOs,
                "CHROME_OS" => ImapSessionContextOs::ChromeOs,
                "FIRE_OS" => ImapSessionContextOs::FireOs,
                "IOS_OS" => ImapSessionContextOs::IosOs,
                "KAI_OS" => ImapSessionContextOs::KaiOs,
                "LINUX_OS" => ImapSessionContextOs::LinuxOs,
                "MAC_OS" => ImapSessionContextOs::MacOs,
                "MAX_MOBILE_OS_VALUE" => ImapSessionContextOs::MaxMobileOsValue,
                "PLAYSTATION_OS" => ImapSessionContextOs::PlaystationOs,
                "STADIA_OS" => ImapSessionContextOs::StadiaOs,
                "TIZEN_OS" => ImapSessionContextOs::TizenOs,
                "UNKNOWN_OS" => ImapSessionContextOs::UnknownOs,
                "WIN_PHONE_OS" => ImapSessionContextOs::WinPhoneOs,
                "WINDOWS_OS" => ImapSessionContextOs::WindowsOs,
                "XBOX_OS" => ImapSessionContextOs::XboxOs,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ImapSessionContextOs {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ImapSessionContextOs {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ImapSessionContextOs {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ANDROID_OS" => ImapSessionContextOs::AndroidOs,
                "ANDROID_THINGS_OS" => ImapSessionContextOs::AndroidThingsOs,
                "APPLE_TV_OS" => ImapSessionContextOs::AppleTvOs,
                "BLACKBERRY_OS" => ImapSessionContextOs::BlackberryOs,
                "CAST_OS" => ImapSessionContextOs::CastOs,
                "CHROME_OS" => ImapSessionContextOs::ChromeOs,
                "FIRE_OS" => ImapSessionContextOs::FireOs,
                "IOS_OS" => ImapSessionContextOs::IosOs,
                "KAI_OS" => ImapSessionContextOs::KaiOs,
                "LINUX_OS" => ImapSessionContextOs::LinuxOs,
                "MAC_OS" => ImapSessionContextOs::MacOs,
                "MAX_MOBILE_OS_VALUE" => ImapSessionContextOs::MaxMobileOsValue,
                "PLAYSTATION_OS" => ImapSessionContextOs::PlaystationOs,
                "STADIA_OS" => ImapSessionContextOs::StadiaOs,
                "TIZEN_OS" => ImapSessionContextOs::TizenOs,
                "UNKNOWN_OS" => ImapSessionContextOs::UnknownOs,
                "WIN_PHONE_OS" => ImapSessionContextOs::WinPhoneOs,
                "WINDOWS_OS" => ImapSessionContextOs::WindowsOs,
                "XBOX_OS" => ImapSessionContextOs::XboxOs,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ImapSessionContextOs {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapSessionContextOs {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ImapSyncDelete {
        #[doc = "Contains the value of //imapsync/folder attribute of deleted message."]
        #[serde(
            rename = "mappings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mappings: ::std::option::Option<crate::schemas::FolderAttribute>,
        #[serde(
            rename = "msgId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub msg_id: ::std::option::Option<u64>,
    }
    impl ::google_field_selector::FieldSelector for ImapSyncDelete {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapSyncDelete {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ImapUidsReassign {
        #[doc = "Label"]
        #[serde(
            rename = "labelId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_id: ::std::option::Option<String>,
        #[doc = "The message Ids"]
        #[serde(
            rename = "messageId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_id: ::std::option::Option<Vec<u64>>,
    }
    impl ::google_field_selector::FieldSelector for ImapUidsReassign {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapUidsReassign {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ImapUpdate {
        #[serde(
            rename = "imapUidsReassign",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub imap_uids_reassign: ::std::option::Option<crate::schemas::ImapUidsReassign>,
    }
    impl ::google_field_selector::FieldSelector for ImapUpdate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapUpdate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ImapsyncFolderAttributeFolderMessage {
        #[doc = "Flags of the message. Represents unseen and flagged state."]
        #[serde(
            rename = "flags",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub flags: ::std::option::Option<crate::schemas::ImapsyncFolderAttributeFolderMessageFlags>,
        #[doc = "UID of the message."]
        #[serde(
            rename = "uid",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub uid: ::std::option::Option<u64>,
    }
    impl ::google_field_selector::FieldSelector for ImapsyncFolderAttributeFolderMessage {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapsyncFolderAttributeFolderMessage {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ImapsyncFolderAttributeFolderMessageFlags {
        #[doc = "Flagged state of the message."]
        #[serde(
            rename = "flagged",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub flagged: ::std::option::Option<bool>,
        #[doc = "Seen state of the message."]
        #[serde(
            rename = "seen",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub seen: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for ImapsyncFolderAttributeFolderMessageFlags {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ImapsyncFolderAttributeFolderMessageFlags {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IncomingWebhookChangedMetadata {
        #[doc = "The webhook name at the time of the change. Used in Spanner storage, BE API responses and FE API responses."]
        #[serde(
            rename = "incomingWebhookName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub incoming_webhook_name: ::std::option::Option<String>,
        #[doc = "The user id of the user whose action triggered this system message. Used in Spanner storage, BE API responses and FE API responses."]
        #[serde(
            rename = "initiatorId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Complete profile when ListTopicsRequest FetchOptions.USER is set. Otherwise, only the id will be filled in. Used in FE API responses."]
        #[serde(
            rename = "initiatorProfile",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator_profile: ::std::option::Option<crate::schemas::User>,
        #[doc = "The webhook id of the incoming webhook in question. This field should not be used to load webhook information dynamically and is only present for debugging purposes. Used in Spanner storage, BE API responses and FE API responses."]
        #[serde(
            rename = "obfuscatedIncomingWebhookId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub obfuscated_incoming_webhook_id: ::std::option::Option<String>,
        #[doc = "Only populated for UPDATED_NAME and UPDATED_NAME_AND_AVATAR events, where the webhook name was changed. Used in Spanner storage, BE API responses and FE API responses."]
        #[serde(
            rename = "oldIncomingWebhookName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub old_incoming_webhook_name: ::std::option::Option<String>,
        #[doc = "Used in Spanner storage, BE API responses and FE API responses."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::IncomingWebhookChangedMetadataType>,
    }
    impl ::google_field_selector::FieldSelector for IncomingWebhookChangedMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IncomingWebhookChangedMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IncomingWebhookChangedMetadataType {
        Added,
        Removed,
        Unspecified,
        #[doc = "TODO (b/154857280): remove UPDATED field."]
        Updated,
        UpdatedAvatar,
        UpdatedName,
        UpdatedNameAndAvatar,
    }
    impl IncomingWebhookChangedMetadataType {
        pub fn as_str(self) -> &'static str {
            match self {
                IncomingWebhookChangedMetadataType::Added => "ADDED",
                IncomingWebhookChangedMetadataType::Removed => "REMOVED",
                IncomingWebhookChangedMetadataType::Unspecified => "UNSPECIFIED",
                IncomingWebhookChangedMetadataType::Updated => "UPDATED",
                IncomingWebhookChangedMetadataType::UpdatedAvatar => "UPDATED_AVATAR",
                IncomingWebhookChangedMetadataType::UpdatedName => "UPDATED_NAME",
                IncomingWebhookChangedMetadataType::UpdatedNameAndAvatar => {
                    "UPDATED_NAME_AND_AVATAR"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for IncomingWebhookChangedMetadataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IncomingWebhookChangedMetadataType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<IncomingWebhookChangedMetadataType, ()> {
            Ok(match s {
                "ADDED" => IncomingWebhookChangedMetadataType::Added,
                "REMOVED" => IncomingWebhookChangedMetadataType::Removed,
                "UNSPECIFIED" => IncomingWebhookChangedMetadataType::Unspecified,
                "UPDATED" => IncomingWebhookChangedMetadataType::Updated,
                "UPDATED_AVATAR" => IncomingWebhookChangedMetadataType::UpdatedAvatar,
                "UPDATED_NAME" => IncomingWebhookChangedMetadataType::UpdatedName,
                "UPDATED_NAME_AND_AVATAR" => {
                    IncomingWebhookChangedMetadataType::UpdatedNameAndAvatar
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for IncomingWebhookChangedMetadataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IncomingWebhookChangedMetadataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for IncomingWebhookChangedMetadataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADDED" => IncomingWebhookChangedMetadataType::Added,
                "REMOVED" => IncomingWebhookChangedMetadataType::Removed,
                "UNSPECIFIED" => IncomingWebhookChangedMetadataType::Unspecified,
                "UPDATED" => IncomingWebhookChangedMetadataType::Updated,
                "UPDATED_AVATAR" => IncomingWebhookChangedMetadataType::UpdatedAvatar,
                "UPDATED_NAME" => IncomingWebhookChangedMetadataType::UpdatedName,
                "UPDATED_NAME_AND_AVATAR" => {
                    IncomingWebhookChangedMetadataType::UpdatedNameAndAvatar
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for IncomingWebhookChangedMetadataType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IncomingWebhookChangedMetadataType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IndexItemOptions {
        #[doc = "Specifies if the index request should allow Google Workspace principals that do not exist or are deleted."]
        #[serde(
            rename = "allowUnknownGsuitePrincipals",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub allow_unknown_gsuite_principals: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for IndexItemOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IndexItemOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct IndexItemRequest {
        #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
        #[serde(
            rename = "connectorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connector_name: ::std::option::Option<String>,
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[serde(
            rename = "indexItemOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub index_item_options: ::std::option::Option<crate::schemas::IndexItemOptions>,
        #[doc = "The name of the item. Format: datasources/{source_id}/items/{item_id}"]
        #[serde(
            rename = "item",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item: ::std::option::Option<crate::schemas::Item>,
        #[doc = "Required. The RequestMode for this request."]
        #[serde(
            rename = "mode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mode: ::std::option::Option<crate::schemas::IndexItemRequestMode>,
    }
    impl ::google_field_selector::FieldSelector for IndexItemRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IndexItemRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IndexItemRequestMode {
        #[doc = "For changes that are executed after the response is sent back to the caller."]
        Asynchronous,
        #[doc = "For real-time updates."]
        Synchronous,
        #[doc = "The priority is not specified in the update request. Leaving priority unspecified results in an update failure."]
        Unspecified,
    }
    impl IndexItemRequestMode {
        pub fn as_str(self) -> &'static str {
            match self {
                IndexItemRequestMode::Asynchronous => "ASYNCHRONOUS",
                IndexItemRequestMode::Synchronous => "SYNCHRONOUS",
                IndexItemRequestMode::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for IndexItemRequestMode {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IndexItemRequestMode {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<IndexItemRequestMode, ()> {
            Ok(match s {
                "ASYNCHRONOUS" => IndexItemRequestMode::Asynchronous,
                "SYNCHRONOUS" => IndexItemRequestMode::Synchronous,
                "UNSPECIFIED" => IndexItemRequestMode::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for IndexItemRequestMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IndexItemRequestMode {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for IndexItemRequestMode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ASYNCHRONOUS" => IndexItemRequestMode::Asynchronous,
                "SYNCHRONOUS" => IndexItemRequestMode::Synchronous,
                "UNSPECIFIED" => IndexItemRequestMode::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for IndexItemRequestMode {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IndexItemRequestMode {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct InitializeCustomerRequest {}
    impl ::google_field_selector::FieldSelector for InitializeCustomerRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for InitializeCustomerRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct InsertContent {
        #[doc = "The content to be inserted."]
        #[serde(
            rename = "content",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content: ::std::option::Option<String>,
        #[doc = "The type of inserted content."]
        #[serde(
            rename = "contentType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_type: ::std::option::Option<crate::schemas::InsertContentContentType>,
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<crate::schemas::InsertContentMimeType>,
    }
    impl ::google_field_selector::FieldSelector for InsertContent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for InsertContent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum InsertContentContentType {
        #[doc = "Specifies that the content is in HTML and is immutable (cannot be edited)."]
        ImmutableHtml,
        #[doc = "Specifies that the content is in HTML and is mutable (can be edited)."]
        MutableHtml,
        #[doc = "Specifies that the content is in plain text."]
        Text,
        #[doc = "Default value when nothing is set for ContentType."]
        UnspecifiedContentType,
    }
    impl InsertContentContentType {
        pub fn as_str(self) -> &'static str {
            match self {
                InsertContentContentType::ImmutableHtml => "IMMUTABLE_HTML",
                InsertContentContentType::MutableHtml => "MUTABLE_HTML",
                InsertContentContentType::Text => "TEXT",
                InsertContentContentType::UnspecifiedContentType => "UNSPECIFIED_CONTENT_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for InsertContentContentType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for InsertContentContentType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<InsertContentContentType, ()> {
            Ok(match s {
                "IMMUTABLE_HTML" => InsertContentContentType::ImmutableHtml,
                "MUTABLE_HTML" => InsertContentContentType::MutableHtml,
                "TEXT" => InsertContentContentType::Text,
                "UNSPECIFIED_CONTENT_TYPE" => InsertContentContentType::UnspecifiedContentType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for InsertContentContentType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for InsertContentContentType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InsertContentContentType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "IMMUTABLE_HTML" => InsertContentContentType::ImmutableHtml,
                "MUTABLE_HTML" => InsertContentContentType::MutableHtml,
                "TEXT" => InsertContentContentType::Text,
                "UNSPECIFIED_CONTENT_TYPE" => InsertContentContentType::UnspecifiedContentType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for InsertContentContentType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for InsertContentContentType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum InsertContentMimeType {
        #[doc = "Specifies that the inserted content is in HTML."]
        Html,
        #[doc = "Specifies that the inserted content is in plain text."]
        PlainText,
        #[doc = "Default value when nothing is set for EmailMimeType."]
        UnspecifiedEmailMimeType,
    }
    impl InsertContentMimeType {
        pub fn as_str(self) -> &'static str {
            match self {
                InsertContentMimeType::Html => "HTML",
                InsertContentMimeType::PlainText => "PLAIN_TEXT",
                InsertContentMimeType::UnspecifiedEmailMimeType => "UNSPECIFIED_EMAIL_MIME_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for InsertContentMimeType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for InsertContentMimeType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<InsertContentMimeType, ()> {
            Ok(match s {
                "HTML" => InsertContentMimeType::Html,
                "PLAIN_TEXT" => InsertContentMimeType::PlainText,
                "UNSPECIFIED_EMAIL_MIME_TYPE" => InsertContentMimeType::UnspecifiedEmailMimeType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for InsertContentMimeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for InsertContentMimeType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InsertContentMimeType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "HTML" => InsertContentMimeType::Html,
                "PLAIN_TEXT" => InsertContentMimeType::PlainText,
                "UNSPECIFIED_EMAIL_MIME_TYPE" => InsertContentMimeType::UnspecifiedEmailMimeType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for InsertContentMimeType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for InsertContentMimeType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IntegerFacetingOptions {
        #[doc = "Buckets for given integer values should be in strictly ascending order. For example, if values supplied are (1,5,10,100), the following facet buckets will be formed {\\<1, \\[1,5), \\[5-10), \\[10-100), >=100}."]
        #[serde(
            rename = "integerBuckets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integer_buckets: ::std::option::Option<Vec<i64>>,
    }
    impl ::google_field_selector::FieldSelector for IntegerFacetingOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IntegerFacetingOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IntegerOperatorOptions {
        #[doc = "Indicates the operator name required in the query in order to isolate the integer property using the greater-than operator. For example, if greaterThanOperatorName is *priorityabove* and the property’s name is *priorityVal*, then queries like *priorityabove:<value>* show results only where the value of the property named *priorityVal* is greater than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "greaterThanOperatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub greater_than_operator_name: ::std::option::Option<String>,
        #[doc = "Indicates the operator name required in the query in order to isolate the integer property using the less-than operator. For example, if lessThanOperatorName is *prioritybelow* and the property’s name is *priorityVal*, then queries like *prioritybelow:<value>* show results only where the value of the property named *priorityVal* is less than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "lessThanOperatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub less_than_operator_name: ::std::option::Option<String>,
        #[doc = "Indicates the operator name required in the query in order to isolate the integer property. For example, if operatorName is *priority* and the property’s name is *priorityVal*, then queries like *priority:<value>* show results only where the value of the property named *priorityVal* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for IntegerOperatorOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IntegerOperatorOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IntegerPropertyOptions {
        #[doc = "If set, describes integer faceting options for the given integer property. The corresponding integer property should be marked isFacetable."]
        #[serde(
            rename = "integerFacetingOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integer_faceting_options: ::std::option::Option<crate::schemas::IntegerFacetingOptions>,
        #[doc = "The maximum value of the property. The minimum and maximum values for the property are used to rank results according to the ordered ranking. Indexing requests with values greater than the maximum are accepted and ranked with the same weight as items indexed with the maximum value."]
        #[serde(
            rename = "maximumValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub maximum_value: ::std::option::Option<i64>,
        #[doc = "The minimum value of the property. The minimum and maximum values for the property are used to rank results according to the ordered ranking. Indexing requests with values less than the minimum are accepted and ranked with the same weight as items indexed with the minimum value."]
        #[serde(
            rename = "minimumValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub minimum_value: ::std::option::Option<i64>,
        #[doc = "If set, describes how the integer should be used as a search operator."]
        #[serde(
            rename = "operatorOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_options: ::std::option::Option<crate::schemas::IntegerOperatorOptions>,
        #[doc = "Used to specify the ordered ranking for the integer. Can only be used if isRepeatable is false."]
        #[serde(
            rename = "orderedRanking",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ordered_ranking:
            ::std::option::Option<crate::schemas::IntegerPropertyOptionsOrderedRanking>,
    }
    impl ::google_field_selector::FieldSelector for IntegerPropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IntegerPropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IntegerPropertyOptionsOrderedRanking {
        #[doc = "This property is ranked in ascending order. Lower values indicate lower ranking."]
        Ascending,
        #[doc = "This property is ranked in descending order. Lower values indicate higher ranking."]
        Descending,
        #[doc = "There is no ranking order for the property. Results are not adjusted by this property’s value."]
        NoOrder,
    }
    impl IntegerPropertyOptionsOrderedRanking {
        pub fn as_str(self) -> &'static str {
            match self {
                IntegerPropertyOptionsOrderedRanking::Ascending => "ASCENDING",
                IntegerPropertyOptionsOrderedRanking::Descending => "DESCENDING",
                IntegerPropertyOptionsOrderedRanking::NoOrder => "NO_ORDER",
            }
        }
    }
    impl ::std::convert::AsRef<str> for IntegerPropertyOptionsOrderedRanking {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IntegerPropertyOptionsOrderedRanking {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<IntegerPropertyOptionsOrderedRanking, ()> {
            Ok(match s {
                "ASCENDING" => IntegerPropertyOptionsOrderedRanking::Ascending,
                "DESCENDING" => IntegerPropertyOptionsOrderedRanking::Descending,
                "NO_ORDER" => IntegerPropertyOptionsOrderedRanking::NoOrder,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for IntegerPropertyOptionsOrderedRanking {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IntegerPropertyOptionsOrderedRanking {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for IntegerPropertyOptionsOrderedRanking {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ASCENDING" => IntegerPropertyOptionsOrderedRanking::Ascending,
                "DESCENDING" => IntegerPropertyOptionsOrderedRanking::Descending,
                "NO_ORDER" => IntegerPropertyOptionsOrderedRanking::NoOrder,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for IntegerPropertyOptionsOrderedRanking {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IntegerPropertyOptionsOrderedRanking {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IntegerValues {
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<i64>>,
    }
    impl ::google_field_selector::FieldSelector for IntegerValues {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IntegerValues {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IntegrationConfigMutation {
        #[doc = "Add an app using its identifier."]
        #[serde(
            rename = "addApp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub add_app: ::std::option::Option<crate::schemas::AppId>,
        #[doc = "Add a pinned tab using its identifier."]
        #[serde(
            rename = "addPinnedItem",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub add_pinned_item: ::std::option::Option<crate::schemas::PinnedItemId>,
        #[doc = "Remove an active app using its identifier."]
        #[serde(
            rename = "removeApp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub remove_app: ::std::option::Option<crate::schemas::AppId>,
        #[doc = "Remove an active pinned tab using its identifier."]
        #[serde(
            rename = "removePinnedItem",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub remove_pinned_item: ::std::option::Option<crate::schemas::PinnedItemId>,
    }
    impl ::google_field_selector::FieldSelector for IntegrationConfigMutation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IntegrationConfigMutation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IntegrationConfigUpdatedMetadata {
        #[doc = "The user whose action triggered this system message."]
        #[serde(
            rename = "initiatorId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "A list of updates applied on the integration config."]
        #[serde(
            rename = "mutations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mutations: ::std::option::Option<Vec<crate::schemas::IntegrationConfigMutation>>,
    }
    impl ::google_field_selector::FieldSelector for IntegrationConfigUpdatedMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IntegrationConfigUpdatedMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Interaction {
        #[doc = "The time when the user acted on the item. If multiple actions of the same type exist for a single user, only the most recent action is recorded."]
        #[serde(
            rename = "interactionTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub interaction_time: ::std::option::Option<String>,
        #[doc = "The user that acted on the item."]
        #[serde(
            rename = "principal",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub principal: ::std::option::Option<crate::schemas::Principal>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::InteractionType>,
    }
    impl ::google_field_selector::FieldSelector for Interaction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Interaction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum InteractionType {
        #[doc = "This interaction indicates the user edited the item."]
        Edit,
        #[doc = "Invalid value."]
        Unspecified,
        #[doc = "This interaction indicates the user viewed the item."]
        View,
    }
    impl InteractionType {
        pub fn as_str(self) -> &'static str {
            match self {
                InteractionType::Edit => "EDIT",
                InteractionType::Unspecified => "UNSPECIFIED",
                InteractionType::View => "VIEW",
            }
        }
    }
    impl ::std::convert::AsRef<str> for InteractionType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for InteractionType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<InteractionType, ()> {
            Ok(match s {
                "EDIT" => InteractionType::Edit,
                "UNSPECIFIED" => InteractionType::Unspecified,
                "VIEW" => InteractionType::View,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for InteractionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for InteractionType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InteractionType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EDIT" => InteractionType::Edit,
                "UNSPECIFIED" => InteractionType::Unspecified,
                "VIEW" => InteractionType::View,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for InteractionType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for InteractionType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct InviteAcceptedEvent {
        #[serde(
            rename = "participantId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub participant_id: ::std::option::Option<Vec<crate::schemas::StoredParticipantId>>,
    }
    impl ::google_field_selector::FieldSelector for InviteAcceptedEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for InviteAcceptedEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct InviteeInfo {
        #[doc = "Email as typed by the user when invited to Room or DM. This value will be canonicalized and hashed before retained in storage."]
        #[serde(
            rename = "email",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email: ::std::option::Option<String>,
        #[doc = "Unique, immutable ID of the User."]
        #[serde(
            rename = "userId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_id: ::std::option::Option<crate::schemas::UserId>,
    }
    impl ::google_field_selector::FieldSelector for InviteeInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for InviteeInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Item {
        #[doc = "Access control list for this item."]
        #[serde(
            rename = "acl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub acl: ::std::option::Option<crate::schemas::ItemAcl>,
        #[doc = "Item content to be indexed and made text searchable."]
        #[serde(
            rename = "content",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content: ::std::option::Option<crate::schemas::ItemContent>,
        #[doc = "The type for this item."]
        #[serde(
            rename = "itemType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item_type: ::std::option::Option<crate::schemas::ItemItemType>,
        #[doc = "The metadata information."]
        #[serde(
            rename = "metadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metadata: ::std::option::Option<crate::schemas::ItemMetadata>,
        #[doc = "The name of the Item. Format: datasources/{source_id}/items/{item_id} This is a required field. The maximum length is 1536 characters."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Additional state connector can store for this item. The maximum length is 10000 bytes."]
        #[serde(
            rename = "payload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub payload: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "Queue this item belongs to. The maximum length is 100 characters."]
        #[serde(
            rename = "queue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub queue: ::std::option::Option<String>,
        #[doc = "Status of the item. Output only field."]
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status: ::std::option::Option<crate::schemas::ItemStatus>,
        #[doc = "The structured data for the item that should conform to a registered object definition in the schema for the data source."]
        #[serde(
            rename = "structuredData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub structured_data: ::std::option::Option<crate::schemas::ItemStructuredData>,
        #[doc = "Required. The indexing system stores the version from the datasource as a byte string and compares the Item version in the index to the version of the queued Item using lexical ordering. Cloud Search Indexing won’t index or delete any queued item with a version value that is less than or equal to the version of the currently indexed item. The maximum length for this field is 1024 bytes. For information on how item version affects the deletion process, refer to [Handle revisions after manual deletes](https://developers.google.com/cloud-search/docs/guides/operations)."]
        #[serde(
            rename = "version",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub version: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector for Item {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Item {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ItemItemType {
        #[doc = "An item that gets indexed and whose purpose is to supply other items with ACLs and/or contain other items."]
        ContainerItem,
        #[doc = "An item that is indexed for the only purpose of serving information. These items cannot be referred in containerName or inheritAclFrom fields."]
        ContentItem,
        Unspecified,
        #[doc = "An item that does not get indexed, but otherwise has the same purpose as CONTAINER_ITEM."]
        VirtualContainerItem,
    }
    impl ItemItemType {
        pub fn as_str(self) -> &'static str {
            match self {
                ItemItemType::ContainerItem => "CONTAINER_ITEM",
                ItemItemType::ContentItem => "CONTENT_ITEM",
                ItemItemType::Unspecified => "UNSPECIFIED",
                ItemItemType::VirtualContainerItem => "VIRTUAL_CONTAINER_ITEM",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ItemItemType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ItemItemType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ItemItemType, ()> {
            Ok(match s {
                "CONTAINER_ITEM" => ItemItemType::ContainerItem,
                "CONTENT_ITEM" => ItemItemType::ContentItem,
                "UNSPECIFIED" => ItemItemType::Unspecified,
                "VIRTUAL_CONTAINER_ITEM" => ItemItemType::VirtualContainerItem,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ItemItemType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ItemItemType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ItemItemType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CONTAINER_ITEM" => ItemItemType::ContainerItem,
                "CONTENT_ITEM" => ItemItemType::ContentItem,
                "UNSPECIFIED" => ItemItemType::Unspecified,
                "VIRTUAL_CONTAINER_ITEM" => ItemItemType::VirtualContainerItem,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ItemItemType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemItemType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ItemAcl {
        #[doc = "Sets the type of access rules to apply when an item inherits its ACL from a parent. This should always be set in tandem with the inheritAclFrom field. Also, when the inheritAclFrom field is set, this field should be set to a valid AclInheritanceType."]
        #[serde(
            rename = "aclInheritanceType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub acl_inheritance_type: ::std::option::Option<crate::schemas::ItemAclAclInheritanceType>,
        #[doc = "List of principals who are explicitly denied access to the item in search results. While principals are denied access by default, use denied readers to handle exceptions and override the list allowed readers. The maximum number of elements is 100."]
        #[serde(
            rename = "deniedReaders",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub denied_readers: ::std::option::Option<Vec<crate::schemas::Principal>>,
        #[doc = "The name of the item to inherit the Access Permission List (ACL) from. Note: ACL inheritance *only* provides access permissions to child items and does not define structural relationships, nor does it provide convenient ways to delete large groups of items. Deleting an ACL parent from the index only alters the access permissions of child items that reference the parent in the inheritAclFrom field. The item is still in the index, but may not visible in search results. By contrast, deletion of a container item also deletes all items that reference the container via the containerName field. The maximum length for this field is 1536 characters."]
        #[serde(
            rename = "inheritAclFrom",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub inherit_acl_from: ::std::option::Option<String>,
        #[doc = "Optional. List of owners for the item. This field has no bearing on document access permissions. It does, however, offer a slight ranking boosts items where the querying user is an owner. The maximum number of elements is 5."]
        #[serde(
            rename = "owners",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub owners: ::std::option::Option<Vec<crate::schemas::Principal>>,
        #[doc = "List of principals who are allowed to see the item in search results. Optional if inheriting permissions from another item or if the item is not intended to be visible, such as virtual containers. The maximum number of elements is 1000."]
        #[serde(
            rename = "readers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub readers: ::std::option::Option<Vec<crate::schemas::Principal>>,
    }
    impl ::google_field_selector::FieldSelector for ItemAcl {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemAcl {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ItemAclAclInheritanceType {
        #[doc = "Access is granted only if this item and the parent item specified in the inheritAclFrom field both permit read access."]
        BothPermit,
        #[doc = "During an authorization conflict, the ACL of the child item determines its read access."]
        ChildOverride,
        #[doc = "The default value when this item does not inherit an ACL. Use NOT_APPLICABLE when inheritAclFrom is empty. An item without ACL inheritance can still have ACLs supplied by its own readers and deniedReaders fields."]
        NotApplicable,
        #[doc = "During an authorization conflict, the ACL of the parent item specified in the inheritAclFrom field determines read access."]
        ParentOverride,
    }
    impl ItemAclAclInheritanceType {
        pub fn as_str(self) -> &'static str {
            match self {
                ItemAclAclInheritanceType::BothPermit => "BOTH_PERMIT",
                ItemAclAclInheritanceType::ChildOverride => "CHILD_OVERRIDE",
                ItemAclAclInheritanceType::NotApplicable => "NOT_APPLICABLE",
                ItemAclAclInheritanceType::ParentOverride => "PARENT_OVERRIDE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ItemAclAclInheritanceType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ItemAclAclInheritanceType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ItemAclAclInheritanceType, ()> {
            Ok(match s {
                "BOTH_PERMIT" => ItemAclAclInheritanceType::BothPermit,
                "CHILD_OVERRIDE" => ItemAclAclInheritanceType::ChildOverride,
                "NOT_APPLICABLE" => ItemAclAclInheritanceType::NotApplicable,
                "PARENT_OVERRIDE" => ItemAclAclInheritanceType::ParentOverride,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ItemAclAclInheritanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ItemAclAclInheritanceType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ItemAclAclInheritanceType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOTH_PERMIT" => ItemAclAclInheritanceType::BothPermit,
                "CHILD_OVERRIDE" => ItemAclAclInheritanceType::ChildOverride,
                "NOT_APPLICABLE" => ItemAclAclInheritanceType::NotApplicable,
                "PARENT_OVERRIDE" => ItemAclAclInheritanceType::ParentOverride,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ItemAclAclInheritanceType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemAclAclInheritanceType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ItemContent {
        #[doc = "Upload reference ID of a previously uploaded content via write method."]
        #[serde(
            rename = "contentDataRef",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_data_ref: ::std::option::Option<crate::schemas::UploadItemRef>,
        #[serde(
            rename = "contentFormat",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_format: ::std::option::Option<crate::schemas::ItemContentContentFormat>,
        #[doc = "Hashing info calculated and provided by the API client for content. Can be used with the items.push method to calculate modified state. The maximum length is 2048 characters."]
        #[serde(
            rename = "hash",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hash: ::std::option::Option<String>,
        #[doc = "Content that is supplied inlined within the update method. The maximum length is 102400 bytes (100 KiB)."]
        #[serde(
            rename = "inlineContent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub inline_content: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector for ItemContent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemContent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ItemContentContentFormat {
        #[doc = "contentFormat is HTML."]
        Html,
        #[doc = "contentFormat is raw bytes."]
        Raw,
        #[doc = "contentFormat is free text."]
        Text,
        #[doc = "Invalid value."]
        Unspecified,
    }
    impl ItemContentContentFormat {
        pub fn as_str(self) -> &'static str {
            match self {
                ItemContentContentFormat::Html => "HTML",
                ItemContentContentFormat::Raw => "RAW",
                ItemContentContentFormat::Text => "TEXT",
                ItemContentContentFormat::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ItemContentContentFormat {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ItemContentContentFormat {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ItemContentContentFormat, ()> {
            Ok(match s {
                "HTML" => ItemContentContentFormat::Html,
                "RAW" => ItemContentContentFormat::Raw,
                "TEXT" => ItemContentContentFormat::Text,
                "UNSPECIFIED" => ItemContentContentFormat::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ItemContentContentFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ItemContentContentFormat {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ItemContentContentFormat {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "HTML" => ItemContentContentFormat::Html,
                "RAW" => ItemContentContentFormat::Raw,
                "TEXT" => ItemContentContentFormat::Text,
                "UNSPECIFIED" => ItemContentContentFormat::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ItemContentContentFormat {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemContentContentFormat {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ItemCountByStatus {
        #[doc = "Number of items matching the status code."]
        #[serde(
            rename = "count",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub count: ::std::option::Option<i64>,
        #[doc = "Number of items matching the status code for which billing is done. This excludes virtual container items from the total count. This count would not be applicable for items with ERROR or NEW_ITEM status code."]
        #[serde(
            rename = "indexedItemsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub indexed_items_count: ::std::option::Option<i64>,
        #[doc = "Status of the items."]
        #[serde(
            rename = "statusCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status_code: ::std::option::Option<crate::schemas::ItemCountByStatusStatusCode>,
    }
    impl ::google_field_selector::FieldSelector for ItemCountByStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemCountByStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ItemCountByStatusStatusCode {
        #[doc = "API has accepted the up-to-date data of this item."]
        Accepted,
        #[doc = "Input-only value. Used with Items.list to list all items in the queue, regardless of status."]
        CodeUnspecified,
        #[doc = "Error encountered by Cloud Search while processing this item. Details of the error are in repositoryError."]
        Error,
        #[doc = "Item has been modified in the repository, and is out of date with the version previously accepted into Cloud Search."]
        Modified,
        #[doc = "Item is known to exist in the repository, but is not yet accepted by Cloud Search. An item can be in this state when Items.push has been called for an item of this name that did not exist previously."]
        NewItem,
    }
    impl ItemCountByStatusStatusCode {
        pub fn as_str(self) -> &'static str {
            match self {
                ItemCountByStatusStatusCode::Accepted => "ACCEPTED",
                ItemCountByStatusStatusCode::CodeUnspecified => "CODE_UNSPECIFIED",
                ItemCountByStatusStatusCode::Error => "ERROR",
                ItemCountByStatusStatusCode::Modified => "MODIFIED",
                ItemCountByStatusStatusCode::NewItem => "NEW_ITEM",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ItemCountByStatusStatusCode {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ItemCountByStatusStatusCode {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ItemCountByStatusStatusCode, ()> {
            Ok(match s {
                "ACCEPTED" => ItemCountByStatusStatusCode::Accepted,
                "CODE_UNSPECIFIED" => ItemCountByStatusStatusCode::CodeUnspecified,
                "ERROR" => ItemCountByStatusStatusCode::Error,
                "MODIFIED" => ItemCountByStatusStatusCode::Modified,
                "NEW_ITEM" => ItemCountByStatusStatusCode::NewItem,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ItemCountByStatusStatusCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ItemCountByStatusStatusCode {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ItemCountByStatusStatusCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACCEPTED" => ItemCountByStatusStatusCode::Accepted,
                "CODE_UNSPECIFIED" => ItemCountByStatusStatusCode::CodeUnspecified,
                "ERROR" => ItemCountByStatusStatusCode::Error,
                "MODIFIED" => ItemCountByStatusStatusCode::Modified,
                "NEW_ITEM" => ItemCountByStatusStatusCode::NewItem,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ItemCountByStatusStatusCode {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemCountByStatusStatusCode {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ItemMetadata {
        #[doc = "The name of the container for this item. Deletion of the container item leads to automatic deletion of this item. Note: ACLs are not inherited from a container item. To provide ACL inheritance for an item, use the inheritAclFrom field. The maximum length is 1536 characters."]
        #[serde(
            rename = "containerName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub container_name: ::std::option::Option<String>,
        #[doc = "The BCP-47 language code for the item, such as “en-US” or “sr-Latn”. For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. The maximum length is 32 characters."]
        #[serde(
            rename = "contentLanguage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_language: ::std::option::Option<String>,
        #[doc = "A set of named attributes associated with the item. This can be used for influencing the ranking of the item based on the context in the request. The maximum number of elements is 10."]
        #[serde(
            rename = "contextAttributes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub context_attributes: ::std::option::Option<Vec<crate::schemas::ContextAttribute>>,
        #[doc = "The time when the item was created in the source repository."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Hashing value provided by the API caller. This can be used with the items.push method to calculate modified state. The maximum length is 2048 characters."]
        #[serde(
            rename = "hash",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hash: ::std::option::Option<String>,
        #[doc = "A list of interactions for the item. Interactions are used to improve Search quality, but are not exposed to end users. The maximum number of elements is 1000."]
        #[serde(
            rename = "interactions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub interactions: ::std::option::Option<Vec<crate::schemas::Interaction>>,
        #[doc = "Additional keywords or phrases that should match the item. Used internally for user generated content. The maximum number of elements is 100. The maximum length is 8192 characters."]
        #[serde(
            rename = "keywords",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub keywords: ::std::option::Option<Vec<String>>,
        #[doc = "The original mime-type of ItemContent.content in the source repository. The maximum length is 256 characters."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "The type of the item. This should correspond to the name of an object definition in the schema registered for the data source. For example, if the schema for the data source contains an object definition with name ‘document’, then item indexing requests for objects of that type should set objectType to ‘document’. The maximum length is 256 characters."]
        #[serde(
            rename = "objectType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_type: ::std::option::Option<String>,
        #[doc = "Additional search quality metadata of the item"]
        #[serde(
            rename = "searchQualityMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub search_quality_metadata: ::std::option::Option<crate::schemas::SearchQualityMetadata>,
        #[doc = "Link to the source repository serving the data. Seach results apply this link to the title. Whitespace or special characters may cause Cloud Seach result links to trigger a redirect notice; to avoid this, encode the URL. The maximum length is 2048 characters."]
        #[serde(
            rename = "sourceRepositoryUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source_repository_url: ::std::option::Option<String>,
        #[doc = "The title of the item. If given, this will be the displayed title of the Search result. The maximum length is 2048 characters."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
        #[doc = "The time when the item was last modified in the source repository."]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ItemMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ItemParts {}
    impl ::google_field_selector::FieldSelector for ItemParts {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemParts {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ItemStatus {
        #[doc = "Status code."]
        #[serde(
            rename = "code",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub code: ::std::option::Option<crate::schemas::ItemStatusCode>,
        #[doc = "Error details in case the item is in ERROR state."]
        #[serde(
            rename = "processingErrors",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub processing_errors: ::std::option::Option<Vec<crate::schemas::ProcessingError>>,
        #[doc = "Repository error reported by connector."]
        #[serde(
            rename = "repositoryErrors",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub repository_errors: ::std::option::Option<Vec<crate::schemas::RepositoryError>>,
    }
    impl ::google_field_selector::FieldSelector for ItemStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ItemStatusCode {
        #[doc = "API has accepted the up-to-date data of this item."]
        Accepted,
        #[doc = "Input-only value. Used with Items.list to list all items in the queue, regardless of status."]
        CodeUnspecified,
        #[doc = "Error encountered by Cloud Search while processing this item. Details of the error are in repositoryError."]
        Error,
        #[doc = "Item has been modified in the repository, and is out of date with the version previously accepted into Cloud Search."]
        Modified,
        #[doc = "Item is known to exist in the repository, but is not yet accepted by Cloud Search. An item can be in this state when Items.push has been called for an item of this name that did not exist previously."]
        NewItem,
    }
    impl ItemStatusCode {
        pub fn as_str(self) -> &'static str {
            match self {
                ItemStatusCode::Accepted => "ACCEPTED",
                ItemStatusCode::CodeUnspecified => "CODE_UNSPECIFIED",
                ItemStatusCode::Error => "ERROR",
                ItemStatusCode::Modified => "MODIFIED",
                ItemStatusCode::NewItem => "NEW_ITEM",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ItemStatusCode {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ItemStatusCode {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ItemStatusCode, ()> {
            Ok(match s {
                "ACCEPTED" => ItemStatusCode::Accepted,
                "CODE_UNSPECIFIED" => ItemStatusCode::CodeUnspecified,
                "ERROR" => ItemStatusCode::Error,
                "MODIFIED" => ItemStatusCode::Modified,
                "NEW_ITEM" => ItemStatusCode::NewItem,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ItemStatusCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ItemStatusCode {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ItemStatusCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACCEPTED" => ItemStatusCode::Accepted,
                "CODE_UNSPECIFIED" => ItemStatusCode::CodeUnspecified,
                "ERROR" => ItemStatusCode::Error,
                "MODIFIED" => ItemStatusCode::Modified,
                "NEW_ITEM" => ItemStatusCode::NewItem,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ItemStatusCode {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemStatusCode {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ItemStructuredData {
        #[doc = "Hashing value provided by the API caller. This can be used with the items.push method to calculate modified state. The maximum length is 2048 characters."]
        #[serde(
            rename = "hash",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hash: ::std::option::Option<String>,
        #[doc = "The structured data object that should conform to a registered object definition in the schema for the data source."]
        #[serde(
            rename = "object",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object: ::std::option::Option<crate::schemas::StructuredDataObject>,
    }
    impl ::google_field_selector::FieldSelector for ItemStructuredData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemStructuredData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ItemThread {
        #[serde(
            rename = "clusterInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cluster_info: ::std::option::Option<crate::schemas::ClusterInfo>,
        #[doc = "The Items in the ItemThread. In the context of a search, the list of Items may be a subset of those that logically belong to the ItemThread. The details of which items are included are available in the ItemThreadView returned in the overall rpc response."]
        #[serde(
            rename = "item",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item: ::std::option::Option<Vec<crate::schemas::FuseboxItem>>,
        #[doc = "The server id of the last item returned in the ItemThread. This can be deduced from the \\[item\\] list but is provided for convenience. When manually constructing an ItemThreadViewSpec to perform operations on the ItemThread, this value can be used as the \\[high_item_id_watermark\\]."]
        #[serde(
            rename = "lastItemId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_item_id: ::std::option::Option<u64>,
        #[serde(
            rename = "matchInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub match_info: ::std::option::Option<crate::schemas::FuseboxItemThreadMatchInfo>,
        #[doc = "A snippet summarizing the thread. This field is only populated for searches."]
        #[serde(
            rename = "snippet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snippet: ::std::option::Option<String>,
        #[doc = "The MultiKey that identifies this thread. This value never changes, i.e. remains constant across modifications to the thread, including addition, relabeling, or deletion of contained Items. As such, the thread key may not necessarily correspond to the key of an contained Item. Legacy note: The “server_id” of the thread key is equivalent to the notion of the “original thread id” in the CSS API."]
        #[serde(
            rename = "threadKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_key: ::std::option::Option<crate::schemas::MultiKey>,
        #[doc = "A base64 encoded and encrypted string generated from the Gaia Id and the thread id. Used to generate the permalink for this thread, exposed from Gmail API."]
        #[serde(
            rename = "threadLocator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_locator: ::std::option::Option<String>,
        #[doc = "Next available id : 10"]
        #[serde(
            rename = "topicState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub topic_state: ::std::option::Option<crate::schemas::TopicState>,
        #[doc = "The latest history operation id that resulted in a mutation of any item in the thread."]
        #[serde(
            rename = "version",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub version: ::std::option::Option<u64>,
    }
    impl ::google_field_selector::FieldSelector for ItemThread {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ItemThread {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct JobsettedServerSpec {
        #[doc = "E.g. “gateway”, “stubby” etc. Leave unset to use the default unnamed port."]
        #[serde(
            rename = "portName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub port_name: ::std::option::Option<String>,
        #[doc = "E.g. “satellite-server”, “bigtop-sync”, etc."]
        #[serde(
            rename = "serverName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub server_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for JobsettedServerSpec {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for JobsettedServerSpec {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct KeyValue {
        #[doc = "Formatted text supported."]
        #[serde(
            rename = "bottomLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bottom_label: ::std::option::Option<String>,
        #[serde(
            rename = "button",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub button: ::std::option::Option<crate::schemas::Button>,
        #[doc = "Formatted text supported and always required."]
        #[serde(
            rename = "content",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content: ::std::option::Option<String>,
        #[serde(
            rename = "contentMultiline",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_multiline: ::std::option::Option<bool>,
        #[serde(
            rename = "endIcon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub end_icon: ::std::option::Option<crate::schemas::IconImage>,
        #[serde(
            rename = "icon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon: ::std::option::Option<crate::schemas::KeyValueIcon>,
        #[doc = "The alternative text of this icon_url which will be used for accessibility."]
        #[serde(
            rename = "iconAltText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_alt_text: ::std::option::Option<String>,
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[serde(
            rename = "imageStyle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_style: ::std::option::Option<crate::schemas::KeyValueImageStyle>,
        #[doc = "Only the top/bottom label + content region is clickable."]
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::OnClick>,
        #[doc = "The optional icon to display before the text content."]
        #[serde(
            rename = "startIcon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_icon: ::std::option::Option<crate::schemas::IconImage>,
        #[serde(
            rename = "switchWidget",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub switch_widget: ::std::option::Option<crate::schemas::SwitchWidget>,
        #[doc = "Formatted text supported."]
        #[serde(
            rename = "topLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub top_label: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for KeyValue {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for KeyValue {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum KeyValueIcon {
        Airplane,
        Bookmark,
        Bus,
        Car,
        Clock,
        ConfirmationNumberIcon,
        Description,
        Dollar,
        Edit,
        EditNote,
        Email,
        EventPerformer,
        EventSeat,
        FlightArrival,
        FlightDeparture,
        Hotel,
        HotelRoomType,
        Invite,
        MapPin,
        Membership,
        MultiplePeople,
        None,
        Offer,
        OpenInNew,
        Person,
        Phone,
        RestaurantIcon,
        ShoppingCart,
        Star,
        Store,
        Ticket,
        Train,
        VideoCamera,
        #[doc = "Add new items in alphabetical order. Next Available ID: 34"]
        VideoPlay,
    }
    impl KeyValueIcon {
        pub fn as_str(self) -> &'static str {
            match self {
                KeyValueIcon::Airplane => "AIRPLANE",
                KeyValueIcon::Bookmark => "BOOKMARK",
                KeyValueIcon::Bus => "BUS",
                KeyValueIcon::Car => "CAR",
                KeyValueIcon::Clock => "CLOCK",
                KeyValueIcon::ConfirmationNumberIcon => "CONFIRMATION_NUMBER_ICON",
                KeyValueIcon::Description => "DESCRIPTION",
                KeyValueIcon::Dollar => "DOLLAR",
                KeyValueIcon::Edit => "EDIT",
                KeyValueIcon::EditNote => "EDIT_NOTE",
                KeyValueIcon::Email => "EMAIL",
                KeyValueIcon::EventPerformer => "EVENT_PERFORMER",
                KeyValueIcon::EventSeat => "EVENT_SEAT",
                KeyValueIcon::FlightArrival => "FLIGHT_ARRIVAL",
                KeyValueIcon::FlightDeparture => "FLIGHT_DEPARTURE",
                KeyValueIcon::Hotel => "HOTEL",
                KeyValueIcon::HotelRoomType => "HOTEL_ROOM_TYPE",
                KeyValueIcon::Invite => "INVITE",
                KeyValueIcon::MapPin => "MAP_PIN",
                KeyValueIcon::Membership => "MEMBERSHIP",
                KeyValueIcon::MultiplePeople => "MULTIPLE_PEOPLE",
                KeyValueIcon::None => "NONE",
                KeyValueIcon::Offer => "OFFER",
                KeyValueIcon::OpenInNew => "OPEN_IN_NEW",
                KeyValueIcon::Person => "PERSON",
                KeyValueIcon::Phone => "PHONE",
                KeyValueIcon::RestaurantIcon => "RESTAURANT_ICON",
                KeyValueIcon::ShoppingCart => "SHOPPING_CART",
                KeyValueIcon::Star => "STAR",
                KeyValueIcon::Store => "STORE",
                KeyValueIcon::Ticket => "TICKET",
                KeyValueIcon::Train => "TRAIN",
                KeyValueIcon::VideoCamera => "VIDEO_CAMERA",
                KeyValueIcon::VideoPlay => "VIDEO_PLAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for KeyValueIcon {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for KeyValueIcon {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<KeyValueIcon, ()> {
            Ok(match s {
                "AIRPLANE" => KeyValueIcon::Airplane,
                "BOOKMARK" => KeyValueIcon::Bookmark,
                "BUS" => KeyValueIcon::Bus,
                "CAR" => KeyValueIcon::Car,
                "CLOCK" => KeyValueIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => KeyValueIcon::ConfirmationNumberIcon,
                "DESCRIPTION" => KeyValueIcon::Description,
                "DOLLAR" => KeyValueIcon::Dollar,
                "EDIT" => KeyValueIcon::Edit,
                "EDIT_NOTE" => KeyValueIcon::EditNote,
                "EMAIL" => KeyValueIcon::Email,
                "EVENT_PERFORMER" => KeyValueIcon::EventPerformer,
                "EVENT_SEAT" => KeyValueIcon::EventSeat,
                "FLIGHT_ARRIVAL" => KeyValueIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => KeyValueIcon::FlightDeparture,
                "HOTEL" => KeyValueIcon::Hotel,
                "HOTEL_ROOM_TYPE" => KeyValueIcon::HotelRoomType,
                "INVITE" => KeyValueIcon::Invite,
                "MAP_PIN" => KeyValueIcon::MapPin,
                "MEMBERSHIP" => KeyValueIcon::Membership,
                "MULTIPLE_PEOPLE" => KeyValueIcon::MultiplePeople,
                "NONE" => KeyValueIcon::None,
                "OFFER" => KeyValueIcon::Offer,
                "OPEN_IN_NEW" => KeyValueIcon::OpenInNew,
                "PERSON" => KeyValueIcon::Person,
                "PHONE" => KeyValueIcon::Phone,
                "RESTAURANT_ICON" => KeyValueIcon::RestaurantIcon,
                "SHOPPING_CART" => KeyValueIcon::ShoppingCart,
                "STAR" => KeyValueIcon::Star,
                "STORE" => KeyValueIcon::Store,
                "TICKET" => KeyValueIcon::Ticket,
                "TRAIN" => KeyValueIcon::Train,
                "VIDEO_CAMERA" => KeyValueIcon::VideoCamera,
                "VIDEO_PLAY" => KeyValueIcon::VideoPlay,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for KeyValueIcon {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for KeyValueIcon {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for KeyValueIcon {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AIRPLANE" => KeyValueIcon::Airplane,
                "BOOKMARK" => KeyValueIcon::Bookmark,
                "BUS" => KeyValueIcon::Bus,
                "CAR" => KeyValueIcon::Car,
                "CLOCK" => KeyValueIcon::Clock,
                "CONFIRMATION_NUMBER_ICON" => KeyValueIcon::ConfirmationNumberIcon,
                "DESCRIPTION" => KeyValueIcon::Description,
                "DOLLAR" => KeyValueIcon::Dollar,
                "EDIT" => KeyValueIcon::Edit,
                "EDIT_NOTE" => KeyValueIcon::EditNote,
                "EMAIL" => KeyValueIcon::Email,
                "EVENT_PERFORMER" => KeyValueIcon::EventPerformer,
                "EVENT_SEAT" => KeyValueIcon::EventSeat,
                "FLIGHT_ARRIVAL" => KeyValueIcon::FlightArrival,
                "FLIGHT_DEPARTURE" => KeyValueIcon::FlightDeparture,
                "HOTEL" => KeyValueIcon::Hotel,
                "HOTEL_ROOM_TYPE" => KeyValueIcon::HotelRoomType,
                "INVITE" => KeyValueIcon::Invite,
                "MAP_PIN" => KeyValueIcon::MapPin,
                "MEMBERSHIP" => KeyValueIcon::Membership,
                "MULTIPLE_PEOPLE" => KeyValueIcon::MultiplePeople,
                "NONE" => KeyValueIcon::None,
                "OFFER" => KeyValueIcon::Offer,
                "OPEN_IN_NEW" => KeyValueIcon::OpenInNew,
                "PERSON" => KeyValueIcon::Person,
                "PHONE" => KeyValueIcon::Phone,
                "RESTAURANT_ICON" => KeyValueIcon::RestaurantIcon,
                "SHOPPING_CART" => KeyValueIcon::ShoppingCart,
                "STAR" => KeyValueIcon::Star,
                "STORE" => KeyValueIcon::Store,
                "TICKET" => KeyValueIcon::Ticket,
                "TRAIN" => KeyValueIcon::Train,
                "VIDEO_CAMERA" => KeyValueIcon::VideoCamera,
                "VIDEO_PLAY" => KeyValueIcon::VideoPlay,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for KeyValueIcon {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for KeyValueIcon {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum KeyValueImageStyle {
        #[doc = "Applies a circular crop."]
        Circle,
        #[doc = "No value specified."]
        CropTypeNotSet,
        #[doc = "Applies a rectangular crop with a 4:3 aspect ratio."]
        Rectangle43,
        #[doc = "Applies a rectangular crop with a custom aspect ratio."]
        RectangleCustom,
        #[doc = "Applies a square crop."]
        Square,
    }
    impl KeyValueImageStyle {
        pub fn as_str(self) -> &'static str {
            match self {
                KeyValueImageStyle::Circle => "CIRCLE",
                KeyValueImageStyle::CropTypeNotSet => "CROP_TYPE_NOT_SET",
                KeyValueImageStyle::Rectangle43 => "RECTANGLE_4_3",
                KeyValueImageStyle::RectangleCustom => "RECTANGLE_CUSTOM",
                KeyValueImageStyle::Square => "SQUARE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for KeyValueImageStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for KeyValueImageStyle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<KeyValueImageStyle, ()> {
            Ok(match s {
                "CIRCLE" => KeyValueImageStyle::Circle,
                "CROP_TYPE_NOT_SET" => KeyValueImageStyle::CropTypeNotSet,
                "RECTANGLE_4_3" => KeyValueImageStyle::Rectangle43,
                "RECTANGLE_CUSTOM" => KeyValueImageStyle::RectangleCustom,
                "SQUARE" => KeyValueImageStyle::Square,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for KeyValueImageStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for KeyValueImageStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for KeyValueImageStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CIRCLE" => KeyValueImageStyle::Circle,
                "CROP_TYPE_NOT_SET" => KeyValueImageStyle::CropTypeNotSet,
                "RECTANGLE_4_3" => KeyValueImageStyle::Rectangle43,
                "RECTANGLE_CUSTOM" => KeyValueImageStyle::RectangleCustom,
                "SQUARE" => KeyValueImageStyle::Square,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for KeyValueImageStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for KeyValueImageStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LabelAdded {
        #[serde(
            rename = "labelId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_id: ::std::option::Option<String>,
        #[serde(
            rename = "labelName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_name: ::std::option::Option<String>,
        #[serde(
            rename = "messageKeys",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_keys: ::std::option::Option<Vec<crate::schemas::MultiKey>>,
        #[serde(
            rename = "syncId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sync_id: ::std::option::Option<u32>,
    }
    impl ::google_field_selector::FieldSelector for LabelAdded {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LabelAdded {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LabelCreated {}
    impl ::google_field_selector::FieldSelector for LabelCreated {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LabelCreated {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LabelDeleted {}
    impl ::google_field_selector::FieldSelector for LabelDeleted {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LabelDeleted {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LabelRemoved {
        #[serde(
            rename = "labelId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_id: ::std::option::Option<String>,
        #[serde(
            rename = "labelName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_name: ::std::option::Option<String>,
        #[serde(
            rename = "messageKeys",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_keys: ::std::option::Option<Vec<crate::schemas::MultiKey>>,
        #[serde(
            rename = "syncId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sync_id: ::std::option::Option<u32>,
    }
    impl ::google_field_selector::FieldSelector for LabelRemoved {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LabelRemoved {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LabelRenamed {
        #[serde(
            rename = "oldCanonicalName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub old_canonical_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for LabelRenamed {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LabelRenamed {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LabelUpdate {
        #[serde(
            rename = "canonicalName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub canonical_name: ::std::option::Option<String>,
        #[serde(
            rename = "labelCreated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_created: ::std::option::Option<crate::schemas::LabelCreated>,
        #[serde(
            rename = "labelDeleted",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_deleted: ::std::option::Option<crate::schemas::LabelDeleted>,
        #[serde(
            rename = "labelId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_id: ::std::option::Option<String>,
        #[serde(
            rename = "labelRenamed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_renamed: ::std::option::Option<crate::schemas::LabelRenamed>,
        #[serde(
            rename = "labelUpdated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_updated: ::std::option::Option<crate::schemas::LabelUpdated>,
        #[serde(
            rename = "syncId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sync_id: ::std::option::Option<u32>,
    }
    impl ::google_field_selector::FieldSelector for LabelUpdate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LabelUpdate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LabelUpdated {}
    impl ::google_field_selector::FieldSelector for LabelUpdated {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LabelUpdated {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Labels {
        #[doc = "The display name of the labels. This is populated (instead of the id) when the request fetch_spec has LABEL_DISPLAY_NAMES."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<Vec<String>>,
        #[doc = "The ids of the labels attached to the Item, e.g. “^i”, “^x_1”"]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for Labels {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Labels {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LanguageConfig {
        #[doc = "The spoken language(s) in BCP47 language code."]
        #[serde(
            rename = "spokenLanguages",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub spoken_languages: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for LanguageConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LanguageConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LdapGroupProto {
        #[serde(
            rename = "groupName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for LdapGroupProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LdapGroupProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LdapUserProto {
        #[serde(
            rename = "userName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for LdapUserProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LdapUserProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LegacyUploadMetadata {
        #[doc = "A unique ID generated from legacy UploadMetadata. This is used for interopping URLs after uploading blob to shared drive. Links in Classic might break without this. go/drive-file-attachment-interop-from-dynamite."]
        #[serde(
            rename = "legacyUniqueId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub legacy_unique_id: ::std::option::Option<String>,
        #[doc = "The blob in this UploadMetadata has been uploaded to shared drive. This UploadMetadata is no longer attached to a message. go/shared-drive-data-migration."]
        #[serde(
            rename = "uploadMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub upload_metadata: ::std::option::Option<crate::schemas::UploadMetadata>,
    }
    impl ::google_field_selector::FieldSelector for LegacyUploadMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LegacyUploadMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LinkData {
        #[doc = "An Attachment represents the structured entity to which we are linking. It contains an Embed (apps/tacotown/proto/embeds/embed_client.proto) with fields specific to the appropriate type of linked entity. For example, if we are linking to a photo album, the Embed may include the album ID and gaia ID of the creator. Clients that understand the Embed type within the Attachment may construct and/or decorate their link appropriately e.g. to make use of type-specific functionality or first-party integrations. The link_target and (if appropriate) display_url fields must still be set even when an Attachment is present, so that clients who do not know how to interpret the Attachment can fall back to those fields, and render the Segment as an ordinary web link. N.B. Even when an Attachment is present, the intention of a “LINK” Segment is for the Segment to be presented inline with the rest of the text of a post or comment, with a clickable link or other UI suitable for inlining (though the client may modify the UI based on Attachment data, e.g. to add appropriate hovers, icons, etc.). When an entity is intended to be rendered separately from the main body of the post/comment, a separate Attachment proto can be added outside the set of Segments. N.B. Within the Attachment, fields of EmbedClientItem have their own visibility annotations, which should be enforced separately from Segment visibility annotations. See: apps/tacotown/proto/embeds/embed_annotations.proto"]
        #[serde(
            rename = "attachment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment: ::std::option::Option<crate::schemas::SocialCommonAttachmentAttachment>,
        #[doc = "The hint to use when rendering the associated attachment. Ignored if there is no associated attachment."]
        #[serde(
            rename = "attachmentRenderHint",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment_render_hint:
            ::std::option::Option<crate::schemas::LinkDataAttachmentRenderHint>,
        #[doc = "If we wish to show the user a different (e.g. shortened) version of the URL for display purposes, then that version should be set here. If this field isn’t set, link_target will be used for both purposes."]
        #[serde(
            rename = "displayUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_url: ::std::option::Option<String>,
        #[doc = "link_target is the URL to navigate to when clicked. This could be the original URL, or a URL signed by the GWS URL signing service."]
        #[serde(
            rename = "linkTarget",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub link_target: ::std::option::Option<String>,
        #[doc = "LinkType is an optional field that provides additional information regarding link target. For example, link type can be identified as the SELF_LINK when the request was executed from the same link as the link target."]
        #[serde(
            rename = "linkType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub link_type: ::std::option::Option<crate::schemas::LinkDataLinkType>,
        #[doc = "Title is an optional field that provides a short string that describes the link or its destination. User interfaces often use title as a tooltip or for accessibility purposes. However, they are of course free to present this data in any form. This field is plain text."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for LinkData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LinkData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LinkDataAttachmentRenderHint {
        #[doc = "Render any associated attachment at the end of the block, after all sibling Segments. Leave the link in place in the text and render it normally as well."]
        AttachmentRenderHintAfter,
        #[doc = "Render any associated attachment inline in the text in place of the link text, forcing a line break before and after the attachment so the text and the attachment are “interleaved”. If this is not possible, render as if AFTER."]
        AttachmentRenderHintInterleaved,
        #[doc = "No rendering hint; should not be used (equivalent to having no hint)"]
        AttachmentRenderHintUnknown,
    }
    impl LinkDataAttachmentRenderHint {
        pub fn as_str(self) -> &'static str {
            match self {
                LinkDataAttachmentRenderHint::AttachmentRenderHintAfter => {
                    "ATTACHMENT_RENDER_HINT_AFTER"
                }
                LinkDataAttachmentRenderHint::AttachmentRenderHintInterleaved => {
                    "ATTACHMENT_RENDER_HINT_INTERLEAVED"
                }
                LinkDataAttachmentRenderHint::AttachmentRenderHintUnknown => {
                    "ATTACHMENT_RENDER_HINT_UNKNOWN"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LinkDataAttachmentRenderHint {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LinkDataAttachmentRenderHint {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LinkDataAttachmentRenderHint, ()> {
            Ok(match s {
                "ATTACHMENT_RENDER_HINT_AFTER" => {
                    LinkDataAttachmentRenderHint::AttachmentRenderHintAfter
                }
                "ATTACHMENT_RENDER_HINT_INTERLEAVED" => {
                    LinkDataAttachmentRenderHint::AttachmentRenderHintInterleaved
                }
                "ATTACHMENT_RENDER_HINT_UNKNOWN" => {
                    LinkDataAttachmentRenderHint::AttachmentRenderHintUnknown
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LinkDataAttachmentRenderHint {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LinkDataAttachmentRenderHint {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkDataAttachmentRenderHint {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ATTACHMENT_RENDER_HINT_AFTER" => {
                    LinkDataAttachmentRenderHint::AttachmentRenderHintAfter
                }
                "ATTACHMENT_RENDER_HINT_INTERLEAVED" => {
                    LinkDataAttachmentRenderHint::AttachmentRenderHintInterleaved
                }
                "ATTACHMENT_RENDER_HINT_UNKNOWN" => {
                    LinkDataAttachmentRenderHint::AttachmentRenderHintUnknown
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LinkDataAttachmentRenderHint {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LinkDataAttachmentRenderHint {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LinkDataLinkType {
        #[doc = "This indicates that the link target points to the same object related to this segment. Example: A YouTube link with text=“0.07” and link_target: “https://www.youtube.com/watch?v=leHVmSqd4_w&t=0m07s” points to the same YouTube video where this segment appears. See http://go/ignore-badwords-filtering-for-selflink for adding link_type design document."]
        SelfLink,
        #[doc = "No link type specified."]
        UnknownLinkType,
    }
    impl LinkDataLinkType {
        pub fn as_str(self) -> &'static str {
            match self {
                LinkDataLinkType::SelfLink => "SELF_LINK",
                LinkDataLinkType::UnknownLinkType => "UNKNOWN_LINK_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LinkDataLinkType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LinkDataLinkType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LinkDataLinkType, ()> {
            Ok(match s {
                "SELF_LINK" => LinkDataLinkType::SelfLink,
                "UNKNOWN_LINK_TYPE" => LinkDataLinkType::UnknownLinkType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LinkDataLinkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LinkDataLinkType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkDataLinkType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "SELF_LINK" => LinkDataLinkType::SelfLink,
                "UNKNOWN_LINK_TYPE" => LinkDataLinkType::UnknownLinkType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LinkDataLinkType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LinkDataLinkType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ListDataSourceResponse {
        #[doc = "Token to retrieve the next page of results, or empty if there are no more results in the list."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[serde(
            rename = "sources",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sources: ::std::option::Option<Vec<crate::schemas::DataSource>>,
    }
    impl ::google_field_selector::FieldSelector for ListDataSourceResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ListDataSourceResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for ListDataSourceResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ListItemNamesForUnmappedIdentityResponse {
        #[serde(
            rename = "itemNames",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item_names: ::std::option::Option<Vec<String>>,
        #[doc = "Token to retrieve the next page of results, or empty if there are no more results in the list."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ListItemNamesForUnmappedIdentityResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ListItemNamesForUnmappedIdentityResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for ListItemNamesForUnmappedIdentityResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ListItemsResponse {
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<Vec<crate::schemas::Item>>,
        #[doc = "Token to retrieve the next page of results, or empty if there are no more results in the list."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ListItemsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ListItemsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for ListItemsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct ListOperationsResponse {
        #[doc = "The standard List next-page token."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "A list of operations that matches the specified filter in the request."]
        #[serde(
            rename = "operations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operations: ::std::option::Option<Vec<crate::schemas::Operation>>,
    }
    impl ::google_field_selector::FieldSelector for ListOperationsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ListOperationsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for ListOperationsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ListQuerySourcesResponse {
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[serde(
            rename = "sources",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sources: ::std::option::Option<Vec<crate::schemas::QuerySource>>,
    }
    impl ::google_field_selector::FieldSelector for ListQuerySourcesResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ListQuerySourcesResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for ListQuerySourcesResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ListSearchApplicationsResponse {
        #[doc = "Token to retrieve the next page of results, or empty if there are no more results in the list."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[serde(
            rename = "searchApplications",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub search_applications: ::std::option::Option<Vec<crate::schemas::SearchApplication>>,
    }
    impl ::google_field_selector::FieldSelector for ListSearchApplicationsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ListSearchApplicationsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for ListSearchApplicationsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ListUnmappedIdentitiesResponse {
        #[doc = "Token to retrieve the next page of results, or empty if there are no more results in the list."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[serde(
            rename = "unmappedIdentities",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub unmapped_identities: ::std::option::Option<Vec<crate::schemas::UnmappedIdentity>>,
    }
    impl ::google_field_selector::FieldSelector for ListUnmappedIdentitiesResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ListUnmappedIdentitiesResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for ListUnmappedIdentitiesResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MatchInfo {
        #[doc = "Reference keys for image attachments that matches search query."]
        #[serde(
            rename = "matchingImageReferenceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub matching_image_reference_key: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for MatchInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MatchInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MatchRange {
        #[doc = "End of the match in the snippet."]
        #[serde(
            rename = "end",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub end: ::std::option::Option<i32>,
        #[doc = "Starting position of the match in the snippet."]
        #[serde(
            rename = "start",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for MatchRange {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MatchRange {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MdbGroupProto {
        #[serde(
            rename = "groupName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for MdbGroupProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MdbGroupProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MdbUserProto {
        #[doc = "Do not set this field. Contact credentials-eng@ if you believe you absolutely need to use it. This is the @prod.google.com Gaia ID that corresponds to the MDB user, see go/authn-merge for details. This field may always be safely ignored when performing an authorization check."]
        #[serde(
            rename = "gaiaId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub gaia_id: ::std::option::Option<i64>,
        #[serde(
            rename = "userName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for MdbUserProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MdbUserProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Media {
        #[doc = "Name of the media resource."]
        #[serde(
            rename = "resourceName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resource_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Media {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Media {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MeetingSpace {
        #[doc = "Which number classes are accepted by this meeting at the moment? When there is no ongoing conference, this field may change independent of the version number of the MeetingSpace. When a conference starts, this field will be locked to the value at that time, and then will be unlocked again at the end of the conference."]
        #[serde(
            rename = "acceptedNumberClass",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub accepted_number_class:
            ::std::option::Option<Vec<crate::schemas::MeetingSpaceAcceptedNumberClassItems>>,
        #[doc = "Broadcast access information for this meeting space."]
        #[serde(
            rename = "broadcastAccess",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub broadcast_access: ::std::option::Option<crate::schemas::BroadcastAccess>,
        #[doc = "Information relevant to an ongoing conference. This field will be set in responses if the client requesting the meeting space has a device in one of the JOINED, HIDDEN, or MISSING_PREREQUISITES states. The field will also be set without a created device if the client requesting the meeting space is eligible to directly create a device in the JOINED state without knocking, eg a same-domain joiner. Can also only be updated by clients with a device in the JOINED state."]
        #[serde(
            rename = "callInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub call_info: ::std::option::Option<crate::schemas::CallInfo>,
        #[doc = "The interop gateway access information for the meeting space. A gateway access can be used when joining conferences from non-Google equipment through an interop gateway."]
        #[serde(
            rename = "gatewayAccess",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gateway_access: ::std::option::Option<crate::schemas::GatewayAccess>,
        #[doc = "The SIP based access methods that can be used to join the conference."]
        #[serde(
            rename = "gatewaySipAccess",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gateway_sip_access: ::std::option::Option<Vec<crate::schemas::GatewaySipAccess>>,
        #[doc = "An optional alias for the meeting space. The alias can in some cases be resolved to the meeting space, similar to the meeting code. The limitation is that the user needs to be in the same meeting domain as the meeting space."]
        #[serde(
            rename = "meetingAlias",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_alias: ::std::option::Option<String>,
        #[doc = "A meeting code is a globally unique code which points to a meeting space. Note: Meeting codes may be regenerated, which will cause old meeting codes to become invalid."]
        #[serde(
            rename = "meetingCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_code: ::std::option::Option<String>,
        #[doc = "A unique server-generated ID for the meeting space. This is the resource name of the meeting space resource and has the form `spaces/`, where is a sequence of characters in the [base64url set](https://tools.ietf.org/html/rfc4648#section-5), without any `=` characters."]
        #[serde(
            rename = "meetingSpaceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_space_id: ::std::option::Option<String>,
        #[doc = "A URL to identify and access the meeting space. Output only."]
        #[serde(
            rename = "meetingUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_url: ::std::option::Option<String>,
        #[doc = "Output only. A URL that clients (e.g. Calendar) can use to show the web page with all join methods available for this meeting space. This link is also used in iOS universal links and Android intents, used for opening the “More ways to join” view in the Meet mobile apps. Example: https://tel.meet/mee-ting-cod?pin=1234567891011 Here, “pin” is the universal phone PIN. We include it explicitly to better support the offline case on the mobile. This is set when the meeting space has either a universal PIN or an interop PIN and clients who can show a “more ways to join” button should show it whenever this field is set."]
        #[serde(
            rename = "moreJoinUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub more_join_url: ::std::option::Option<String>,
        #[doc = "All regional phone access methods for this meeting space. Can be empty."]
        #[serde(
            rename = "phoneAccess",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub phone_access: ::std::option::Option<Vec<crate::schemas::PhoneAccess>>,
        #[doc = "Settings of the meeting space."]
        #[serde(
            rename = "settings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub settings: ::std::option::Option<crate::schemas::Settings>,
        #[doc = "A universal phone access method for this meeting space. Can be unset."]
        #[serde(
            rename = "universalPhoneAccess",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub universal_phone_access: ::std::option::Option<crate::schemas::UniversalPhoneAccess>,
    }
    impl ::google_field_selector::FieldSelector for MeetingSpace {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MeetingSpace {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MeetingSpaceAcceptedNumberClassItems {
        #[doc = "The number has a high cost to receive calls on."]
        HighCost,
        #[doc = "Class for legacy numbers."]
        Legacy,
        #[doc = "The number has a low cost to receive calls on."]
        LowCost,
        #[doc = "No number class has been specified."]
        NumberClassUnspecified,
    }
    impl MeetingSpaceAcceptedNumberClassItems {
        pub fn as_str(self) -> &'static str {
            match self {
                MeetingSpaceAcceptedNumberClassItems::HighCost => "HIGH_COST",
                MeetingSpaceAcceptedNumberClassItems::Legacy => "LEGACY",
                MeetingSpaceAcceptedNumberClassItems::LowCost => "LOW_COST",
                MeetingSpaceAcceptedNumberClassItems::NumberClassUnspecified => {
                    "NUMBER_CLASS_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MeetingSpaceAcceptedNumberClassItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MeetingSpaceAcceptedNumberClassItems {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MeetingSpaceAcceptedNumberClassItems, ()> {
            Ok(match s {
                "HIGH_COST" => MeetingSpaceAcceptedNumberClassItems::HighCost,
                "LEGACY" => MeetingSpaceAcceptedNumberClassItems::Legacy,
                "LOW_COST" => MeetingSpaceAcceptedNumberClassItems::LowCost,
                "NUMBER_CLASS_UNSPECIFIED" => {
                    MeetingSpaceAcceptedNumberClassItems::NumberClassUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MeetingSpaceAcceptedNumberClassItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MeetingSpaceAcceptedNumberClassItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MeetingSpaceAcceptedNumberClassItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "HIGH_COST" => MeetingSpaceAcceptedNumberClassItems::HighCost,
                "LEGACY" => MeetingSpaceAcceptedNumberClassItems::Legacy,
                "LOW_COST" => MeetingSpaceAcceptedNumberClassItems::LowCost,
                "NUMBER_CLASS_UNSPECIFIED" => {
                    MeetingSpaceAcceptedNumberClassItems::NumberClassUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MeetingSpaceAcceptedNumberClassItems {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MeetingSpaceAcceptedNumberClassItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Member {
        #[serde(
            rename = "roster",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub roster: ::std::option::Option<crate::schemas::Roster>,
        #[serde(
            rename = "user",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user: ::std::option::Option<crate::schemas::User>,
    }
    impl ::google_field_selector::FieldSelector for Member {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Member {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MemberId {
        #[doc = "Unique, immutable ID of the Roster."]
        #[serde(
            rename = "rosterId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub roster_id: ::std::option::Option<crate::schemas::RosterId>,
        #[doc = "Unique, immutable ID of the User."]
        #[serde(
            rename = "userId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_id: ::std::option::Option<crate::schemas::UserId>,
    }
    impl ::google_field_selector::FieldSelector for MemberId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MemberId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MembershipChangeEvent {
        #[doc = "This should only be set when MembershipChange type is LEAVE."]
        #[serde(
            rename = "leaveReason",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub leave_reason: ::std::option::Option<crate::schemas::MembershipChangeEventLeaveReason>,
        #[serde(
            rename = "participantId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub participant_id: ::std::option::Option<Vec<crate::schemas::StoredParticipantId>>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::MembershipChangeEventType>,
    }
    impl ::google_field_selector::FieldSelector for MembershipChangeEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MembershipChangeEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MembershipChangeEventLeaveReason {
        ForceHistoryPolicyChange,
        LeaveReasonUnknown,
        UserInitiated,
    }
    impl MembershipChangeEventLeaveReason {
        pub fn as_str(self) -> &'static str {
            match self {
                MembershipChangeEventLeaveReason::ForceHistoryPolicyChange => {
                    "FORCE_HISTORY_POLICY_CHANGE"
                }
                MembershipChangeEventLeaveReason::LeaveReasonUnknown => "LEAVE_REASON_UNKNOWN",
                MembershipChangeEventLeaveReason::UserInitiated => "USER_INITIATED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MembershipChangeEventLeaveReason {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MembershipChangeEventLeaveReason {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MembershipChangeEventLeaveReason, ()> {
            Ok(match s {
                "FORCE_HISTORY_POLICY_CHANGE" => {
                    MembershipChangeEventLeaveReason::ForceHistoryPolicyChange
                }
                "LEAVE_REASON_UNKNOWN" => MembershipChangeEventLeaveReason::LeaveReasonUnknown,
                "USER_INITIATED" => MembershipChangeEventLeaveReason::UserInitiated,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MembershipChangeEventLeaveReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MembershipChangeEventLeaveReason {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MembershipChangeEventLeaveReason {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FORCE_HISTORY_POLICY_CHANGE" => {
                    MembershipChangeEventLeaveReason::ForceHistoryPolicyChange
                }
                "LEAVE_REASON_UNKNOWN" => MembershipChangeEventLeaveReason::LeaveReasonUnknown,
                "USER_INITIATED" => MembershipChangeEventLeaveReason::UserInitiated,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MembershipChangeEventLeaveReason {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MembershipChangeEventLeaveReason {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MembershipChangeEventType {
        Join,
        Leave,
    }
    impl MembershipChangeEventType {
        pub fn as_str(self) -> &'static str {
            match self {
                MembershipChangeEventType::Join => "JOIN",
                MembershipChangeEventType::Leave => "LEAVE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MembershipChangeEventType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MembershipChangeEventType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MembershipChangeEventType, ()> {
            Ok(match s {
                "JOIN" => MembershipChangeEventType::Join,
                "LEAVE" => MembershipChangeEventType::Leave,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MembershipChangeEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MembershipChangeEventType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MembershipChangeEventType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "JOIN" => MembershipChangeEventType::Join,
                "LEAVE" => MembershipChangeEventType::Leave,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MembershipChangeEventType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MembershipChangeEventType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MembershipChangedMetadata {
        #[serde(
            rename = "affectedMemberProfiles",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub affected_member_profiles: ::std::option::Option<Vec<crate::schemas::Member>>,
        #[doc = "List of users and rosters whose membership status changed."]
        #[serde(
            rename = "affectedMembers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub affected_members: ::std::option::Option<Vec<crate::schemas::MemberId>>,
        #[serde(
            rename = "affectedMemberships",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub affected_memberships: ::std::option::Option<Vec<crate::schemas::AffectedMembership>>,
        #[doc = "The user whose action triggered this system message."]
        #[serde(
            rename = "initiator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Complete member profiles, when ListTopicsRequest FetchOptions.USER is set. Otherwise, only the id will be filled in."]
        #[serde(
            rename = "initiatorProfile",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator_profile: ::std::option::Option<crate::schemas::User>,
        #[doc = "The type of the user who initiated this membership change."]
        #[serde(
            rename = "initiatorType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator_type:
            ::std::option::Option<crate::schemas::MembershipChangedMetadataInitiatorType>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::MembershipChangedMetadataType>,
    }
    impl ::google_field_selector::FieldSelector for MembershipChangedMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MembershipChangedMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MembershipChangedMetadataInitiatorType {
        InitiatorTypeAdmin,
        InitiatorTypeEndUser,
        InitiatorTypeUnspecified,
    }
    impl MembershipChangedMetadataInitiatorType {
        pub fn as_str(self) -> &'static str {
            match self {
                MembershipChangedMetadataInitiatorType::InitiatorTypeAdmin => {
                    "INITIATOR_TYPE_ADMIN"
                }
                MembershipChangedMetadataInitiatorType::InitiatorTypeEndUser => {
                    "INITIATOR_TYPE_END_USER"
                }
                MembershipChangedMetadataInitiatorType::InitiatorTypeUnspecified => {
                    "INITIATOR_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MembershipChangedMetadataInitiatorType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MembershipChangedMetadataInitiatorType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MembershipChangedMetadataInitiatorType, ()> {
            Ok(match s {
                "INITIATOR_TYPE_ADMIN" => {
                    MembershipChangedMetadataInitiatorType::InitiatorTypeAdmin
                }
                "INITIATOR_TYPE_END_USER" => {
                    MembershipChangedMetadataInitiatorType::InitiatorTypeEndUser
                }
                "INITIATOR_TYPE_UNSPECIFIED" => {
                    MembershipChangedMetadataInitiatorType::InitiatorTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MembershipChangedMetadataInitiatorType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MembershipChangedMetadataInitiatorType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MembershipChangedMetadataInitiatorType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "INITIATOR_TYPE_ADMIN" => {
                    MembershipChangedMetadataInitiatorType::InitiatorTypeAdmin
                }
                "INITIATOR_TYPE_END_USER" => {
                    MembershipChangedMetadataInitiatorType::InitiatorTypeEndUser
                }
                "INITIATOR_TYPE_UNSPECIFIED" => {
                    MembershipChangedMetadataInitiatorType::InitiatorTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MembershipChangedMetadataInitiatorType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MembershipChangedMetadataInitiatorType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MembershipChangedMetadataType {
        #[doc = "Non-member -> Member. Multiple users."]
        Added,
        #[doc = "Bot added to the room."]
        BotAdded,
        #[doc = "Bot removed from the room."]
        BotRemoved,
        #[doc = "Non-member -> Can join. Multiple groups and users."]
        Invited,
        #[doc = "Can join -> Member. One user."]
        Joined,
        #[doc = "This signifies the user is kicked because the user’s OTR policy is conflicted with the room history settings. Joined -> Non-member. One user."]
        KickedDueToOtrConflict,
        #[doc = "Member -> Can join. One user."]
        Left,
        #[doc = "Can join -> Non-member. One group or user."]
        Removed,
        #[doc = "The room is now joinable by an"]
        RoleTargetAudienceUpdated,
        #[doc = "MembershipRole changed. Multiple users."]
        RoleUpdated,
        #[doc = "Default value for the enum. DO NOT USE."]
        TypeUnspecified,
    }
    impl MembershipChangedMetadataType {
        pub fn as_str(self) -> &'static str {
            match self {
                MembershipChangedMetadataType::Added => "ADDED",
                MembershipChangedMetadataType::BotAdded => "BOT_ADDED",
                MembershipChangedMetadataType::BotRemoved => "BOT_REMOVED",
                MembershipChangedMetadataType::Invited => "INVITED",
                MembershipChangedMetadataType::Joined => "JOINED",
                MembershipChangedMetadataType::KickedDueToOtrConflict => {
                    "KICKED_DUE_TO_OTR_CONFLICT"
                }
                MembershipChangedMetadataType::Left => "LEFT",
                MembershipChangedMetadataType::Removed => "REMOVED",
                MembershipChangedMetadataType::RoleTargetAudienceUpdated => {
                    "ROLE_TARGET_AUDIENCE_UPDATED"
                }
                MembershipChangedMetadataType::RoleUpdated => "ROLE_UPDATED",
                MembershipChangedMetadataType::TypeUnspecified => "TYPE_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MembershipChangedMetadataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MembershipChangedMetadataType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MembershipChangedMetadataType, ()> {
            Ok(match s {
                "ADDED" => MembershipChangedMetadataType::Added,
                "BOT_ADDED" => MembershipChangedMetadataType::BotAdded,
                "BOT_REMOVED" => MembershipChangedMetadataType::BotRemoved,
                "INVITED" => MembershipChangedMetadataType::Invited,
                "JOINED" => MembershipChangedMetadataType::Joined,
                "KICKED_DUE_TO_OTR_CONFLICT" => {
                    MembershipChangedMetadataType::KickedDueToOtrConflict
                }
                "LEFT" => MembershipChangedMetadataType::Left,
                "REMOVED" => MembershipChangedMetadataType::Removed,
                "ROLE_TARGET_AUDIENCE_UPDATED" => {
                    MembershipChangedMetadataType::RoleTargetAudienceUpdated
                }
                "ROLE_UPDATED" => MembershipChangedMetadataType::RoleUpdated,
                "TYPE_UNSPECIFIED" => MembershipChangedMetadataType::TypeUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MembershipChangedMetadataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MembershipChangedMetadataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MembershipChangedMetadataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADDED" => MembershipChangedMetadataType::Added,
                "BOT_ADDED" => MembershipChangedMetadataType::BotAdded,
                "BOT_REMOVED" => MembershipChangedMetadataType::BotRemoved,
                "INVITED" => MembershipChangedMetadataType::Invited,
                "JOINED" => MembershipChangedMetadataType::Joined,
                "KICKED_DUE_TO_OTR_CONFLICT" => {
                    MembershipChangedMetadataType::KickedDueToOtrConflict
                }
                "LEFT" => MembershipChangedMetadataType::Left,
                "REMOVED" => MembershipChangedMetadataType::Removed,
                "ROLE_TARGET_AUDIENCE_UPDATED" => {
                    MembershipChangedMetadataType::RoleTargetAudienceUpdated
                }
                "ROLE_UPDATED" => MembershipChangedMetadataType::RoleUpdated,
                "TYPE_UNSPECIFIED" => MembershipChangedMetadataType::TypeUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MembershipChangedMetadataType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MembershipChangedMetadataType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Menu {
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<Vec<crate::schemas::MenuItem>>,
        #[doc = "Label used to be displayed ahead of the menu. It is optional."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "The name of the text field which is will be used in FormInput."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "If specified, form is submitted when selection changed. If not specified, developer will need to specify a separate button."]
        #[serde(
            rename = "onChange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change: ::std::option::Option<crate::schemas::FormAction>,
    }
    impl ::google_field_selector::FieldSelector for Menu {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Menu {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MenuItem {
        #[serde(
            rename = "selected",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub selected: ::std::option::Option<bool>,
        #[doc = "The text to be displayed."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "The value associated with this item which will be sent back to app scripts. Client should use as a form input value."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for MenuItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MenuItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct Message {
        #[doc = "Annotations parsed and extracted from the text body."]
        #[serde(
            rename = "annotations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotations: ::std::option::Option<Vec<crate::schemas::Annotation>>,
        #[doc = "Custom display profile info for apps. Leave the field empty for real users."]
        #[serde(
            rename = "appProfile",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app_profile: ::std::option::Option<crate::schemas::AppsDynamiteSharedAppProfile>,
        #[doc = "Attachments parsed from incoming webhooks"]
        #[serde(
            rename = "attachments",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachments: ::std::option::Option<Vec<crate::schemas::Attachment>>,
        #[doc = "Lightweight message attributes which values are calculated and set in the servers."]
        #[serde(
            rename = "attributes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attributes: ::std::option::Option<crate::schemas::MessageAttributes>,
        #[doc = "Responses from bots indicating if extra auth/config is needed."]
        #[serde(
            rename = "botResponses",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bot_responses: ::std::option::Option<Vec<crate::schemas::BotResponse>>,
        #[doc = "Communal labels associated with a message. These exist on the message itself regardless of which user fetches them. Order of entries is arbitrary and will not list duplicates of the same label_id. See go/chat-labels-design for details."]
        #[serde(
            rename = "communalLabels",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub communal_labels: ::std::option::Option<Vec<crate::schemas::CommunalLabelTag>>,
        #[serde(
            rename = "contentReportSummary",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_report_summary: ::std::option::Option<crate::schemas::ContentReportSummary>,
        #[doc = "Time when the Message was posted in microseconds."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub create_time: ::std::option::Option<i64>,
        #[doc = "ID of the User who posted the Message. This includes information to identify if this was posted by an App on behalf of a user."]
        #[serde(
            rename = "creatorId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub creator_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Indicates who can delete the message. This field is set on the read path (e.g. ListTopics) but doesn’t have any effect on the write path (e.g. CreateMessageRequest)."]
        #[serde(
            rename = "deletableBy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deletable_by: ::std::option::Option<crate::schemas::MessageDeletableBy>,
        #[doc = "Time when the Message was deleted in microseconds. This field is set to nonzero value only for Messages deleted globally."]
        #[serde(
            rename = "deleteTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub delete_time: ::std::option::Option<i64>,
        #[doc = "Time when the Message was per-user deleted by the message requester in microseconds. This field is set to nonzero value only for Message per-user deleted by the requester."]
        #[serde(
            rename = "deleteTimeForRequester",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub delete_time_for_requester: ::std::option::Option<i64>,
        #[doc = "Was this message deleted by Vault (Only used for Vault support) This is false if message is live or message was deleted by user."]
        #[serde(
            rename = "deletedByVault",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deleted_by_vault: ::std::option::Option<bool>,
        #[doc = "Data Loss Prevention scan information for this message. Messages are evaluated in the backend on create message/topic and edit message actions. DEPRECATED: use dlp_scan_summary instead."]
        #[serde(
            rename = "dlpScanOutcome",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dlp_scan_outcome: ::std::option::Option<crate::schemas::MessageDlpScanOutcome>,
        #[doc = "Data Loss Prevention scan information for this message. Messages are evaluated in the backend on create message/topic and edit message actions."]
        #[serde(
            rename = "dlpScanSummary",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dlp_scan_summary: ::std::option::Option<crate::schemas::DlpScanSummary>,
        #[doc = "Indicates who can edit the message. This field is set on the read path (e.g. ListTopics) but doesn’t have any effect on the write path (e.g. CreateMessageRequest)."]
        #[serde(
            rename = "editableBy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub editable_by: ::std::option::Option<crate::schemas::MessageEditableBy>,
        #[doc = "A plain-text description of the attachment, used when clients cannot display formatted attachment (e.g. mobile push notifications)."]
        #[serde(
            rename = "fallbackText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fallback_text: ::std::option::Option<String>,
        #[doc = "ID of the resource."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<crate::schemas::MessageId>,
        #[doc = "Whether the message is content purged. Content purged messages contain only data required for tombstone (see go/chat-infinite-tombstone). This field is only used by Vault to display tombstone and should only be set to true if the message is a tombstone."]
        #[serde(
            rename = "isContentPurged",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_content_purged: ::std::option::Option<bool>,
        #[doc = "Output only. Indicates if the message is an inline reply. Set to true only if the message’s ParentPath is non-NULL. Currently, only inline replies have non-NULL ParentPath. See go/chat-be-inline-reply-indicator."]
        #[serde(
            rename = "isInlineReply",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_inline_reply: ::std::option::Option<bool>,
        #[doc = "If the message was edited by a user, timestamp of the last edit, in microseconds."]
        #[serde(
            rename = "lastEditTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_edit_time: ::std::option::Option<i64>,
        #[doc = "Time when the Message text was last updated in microseconds."]
        #[serde(
            rename = "lastUpdateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_update_time: ::std::option::Option<i64>,
        #[doc = "A unique id specified on the client side."]
        #[serde(
            rename = "localId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub local_id: ::std::option::Option<String>,
        #[doc = "An optional payload (restricted to 1P applications) that will be stored with this message. This can only be set by the 1P API and should be used to deliver additional data such a 1P sync version, 1P entity ID to the client for more advanced functionality \\[Eg. inform Group Tasks tab of new version while linking, fetch & render a live Task/Meet call tile\\]."]
        #[serde(
            rename = "messageIntegrationPayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_integration_payload:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedMessageIntegrationPayload>,
        #[doc = "Where the message was posted from"]
        #[serde(
            rename = "messageOrigin",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_origin: ::std::option::Option<crate::schemas::MessageMessageOrigin>,
        #[doc = "State of the message, indicating whether the message is visible to all members in the group or is only visible to the sender only, or the private_message_viewer if it is set."]
        #[serde(
            rename = "messageState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_state: ::std::option::Option<crate::schemas::MessageMessageState>,
        #[doc = "Indicates if this message contains any suggestions that were provided by any Apps."]
        #[serde(
            rename = "originAppSuggestions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub origin_app_suggestions:
            ::std::option::Option<Vec<crate::schemas::AppsDynamiteSharedOriginAppSuggestion>>,
        #[doc = "Personal labels associated with a message for the viewing user. Order of entries is arbitrary and will not list duplicates of the same label_id. See go/chat-labels-design for details. NOTE: This will be unpopulated in the case of SpaceChangelog events."]
        #[serde(
            rename = "personalLabels",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub personal_labels: ::std::option::Option<Vec<crate::schemas::PersonalLabelTag>>,
        #[doc = "A list of per-user private information. This is deprecated, because we no longer plan to support partially private messages or private messages for multiple users. The message_state and private_message_viewer fields should be sufficient for this infrastructure."]
        #[serde(
            rename = "privateMessageInfos",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_message_infos: ::std::option::Option<Vec<crate::schemas::PrivateMessageInfo>>,
        #[doc = "Should only be set if the Message State is PRIVATE. If set, the message content is only visible to this user (and any apps associated with the message), as well as the message creator. If unset, a private message is visible to the message creator only."]
        #[serde(
            rename = "privateMessageViewer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_message_viewer: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Contains additional (currently Hangouts Classic only) properties applicable to this message."]
        #[serde(
            rename = "props",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub props: ::std::option::Option<crate::schemas::MessageProps>,
        #[doc = "Output only. Whether this message has been quoted by another message or not. Used by clients to handle message edit flows for messages that have been quoted."]
        #[serde(
            rename = "quotedByState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub quoted_by_state: ::std::option::Option<crate::schemas::MessageQuotedByState>,
        #[doc = "Output only. Metadata for a message that is quoted by this message."]
        #[serde(
            rename = "quotedMessageMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub quoted_message_metadata: ::std::option::Option<crate::schemas::QuotedMessageMetadata>,
        #[doc = "A list of user reactions to this message. Ordered by the timestamp of the first reaction, ascending (oldest to newest)."]
        #[serde(
            rename = "reactions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reactions: ::std::option::Option<Vec<crate::schemas::AppsDynamiteSharedReaction>>,
        #[doc = "Output only. Details of content reports. Set only when the request asks for it."]
        #[serde(
            rename = "reports",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reports: ::std::option::Option<Vec<crate::schemas::ContentReport>>,
        #[doc = "The retention settings of the message."]
        #[serde(
            rename = "retentionSettings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retention_settings:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedRetentionSettings>,
        #[doc = "Used by clients to correctly log format type for message creation due to complexity with client side optimistic update (see go/content-metric-post-send-logging for details). Currently, only set by server in the message or topic creation path."]
        #[serde(
            rename = "richTextFormattingType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rich_text_formatting_type:
            ::std::option::Option<crate::schemas::MessageRichTextFormattingType>,
        #[doc = "A client-specified string that can be used to uniquely identify a message in a space, in lieu of `id.message_id`."]
        #[serde(
            rename = "secondaryMessageKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub secondary_message_key: ::std::option::Option<String>,
        #[doc = "Plaintext body of the Message."]
        #[serde(
            rename = "textBody",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_body: ::std::option::Option<String>,
        #[doc = "Information for the stoning of a Message."]
        #[serde(
            rename = "tombstoneMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tombstone_metadata: ::std::option::Option<crate::schemas::TombstoneMetadata>,
        #[doc = "ID of the User who last updated (created/edited/deleted) the Message. This includes information to identify if this was updated by an App on behalf of a user."]
        #[serde(
            rename = "updaterId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub updater_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "UploadMetadata b/36864213 is an ongoing effort to move UploadMetadata out of annotations field and save it to upload_metadata field only. After the migration, UploadMetadata will only be saved in this field."]
        #[serde(
            rename = "uploadMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub upload_metadata: ::std::option::Option<Vec<crate::schemas::UploadMetadata>>,
    }
    impl ::google_field_selector::FieldSelector for Message {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Message {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MessageDeletableBy {
        #[doc = "The message creator can mutate regardless of request origin. Use case: for messages created by human via Chat UI or Chat API. These messages can be mutated by the same human user via Chat UI or via any app on Chat API."]
        PermissionCreator,
        #[doc = "Every human member of a space or the creator can mutate the entity. This excludes app acting on behalf of human via Chat API. Use case: This is to enable humans to delete messages created by apps."]
        PermissionMember,
        #[doc = "No one except for the message creator/origin pair can mutate. This permission checks both gaia id and the request origin. Request origin can be Chat API or Chat UI. Mutation is allowed iff both attributes of the request match the original message creation. Use case: this allows historical 1P apps lock down message edit permission i.e. In Chat UI, humans cannot edit their messages created via these 1P apps. Do not use this for additional use cases."]
        PermissionNoOne,
        #[doc = "Default case, should never be used. If this data is encountered in the DB any request should throw an exception."]
        PermissionUnspecified,
    }
    impl MessageDeletableBy {
        pub fn as_str(self) -> &'static str {
            match self {
                MessageDeletableBy::PermissionCreator => "PERMISSION_CREATOR",
                MessageDeletableBy::PermissionMember => "PERMISSION_MEMBER",
                MessageDeletableBy::PermissionNoOne => "PERMISSION_NO_ONE",
                MessageDeletableBy::PermissionUnspecified => "PERMISSION_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MessageDeletableBy {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MessageDeletableBy {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MessageDeletableBy, ()> {
            Ok(match s {
                "PERMISSION_CREATOR" => MessageDeletableBy::PermissionCreator,
                "PERMISSION_MEMBER" => MessageDeletableBy::PermissionMember,
                "PERMISSION_NO_ONE" => MessageDeletableBy::PermissionNoOne,
                "PERMISSION_UNSPECIFIED" => MessageDeletableBy::PermissionUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MessageDeletableBy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MessageDeletableBy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MessageDeletableBy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "PERMISSION_CREATOR" => MessageDeletableBy::PermissionCreator,
                "PERMISSION_MEMBER" => MessageDeletableBy::PermissionMember,
                "PERMISSION_NO_ONE" => MessageDeletableBy::PermissionNoOne,
                "PERMISSION_UNSPECIFIED" => MessageDeletableBy::PermissionUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MessageDeletableBy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageDeletableBy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MessageDlpScanOutcome {
        #[doc = "Rule fetch completed and evaluation were attempted, but all of the rules failed to be evaluated."]
        ScanFailureAllRulesFailed,
        #[doc = "Rule fetch and evaluation were attempted but an exception occurred."]
        ScanFailureException,
        #[doc = "An IllegalStateException is thrown when executing DLP on attachments. This could happen if the space row is missing."]
        ScanFailureIllegalStateForAttachments,
        #[doc = "Rule fetch was attempted but failed, so rule evaluation could not be performed."]
        ScanFailureRuleFetchFailed,
        #[doc = "Rule fetch and evaluation were attempted but the scanning timed out."]
        ScanFailureTimeout,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because Changeling returned an empty response while converting the attachment to text."]
        ScanRuleEvaluationSkippedChangelingEmptyResponse,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because Changeling returned permanent failure while converting the attachment to text."]
        ScanRuleEvaluationSkippedChangelingPermanentError,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because none of the rules are applicable to the given action params."]
        ScanRuleEvaluationSkippedNoApplicableRulesForActionParams,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because none of the rules are applicable to the given trigger."]
        ScanRuleEvaluationSkippedNoApplicableRulesForTrigger,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because no rules were found."]
        ScanRuleEvaluationSkippedNoRulesFound,
        #[doc = "Rule fetch happened, but rule evaluation is skipped because file type is unsupported."]
        ScanRuleEvaluationSkippedUnsupportedFileType,
        #[doc = "Rule fetch and evaluation are skipped because the user sending message is consumer."]
        ScanSkippedConsumer,
        #[doc = "Rule fetch and evaluation is skipped because DLP is not enabled for the user."]
        ScanSkippedExperimentDisabled,
        #[doc = "Scanning was skipped because the message originated from Interop or Babel."]
        ScanSkippedMessageFromUnsupportedOrigin,
        #[doc = "Rule fetch and evaluation are skipped because there is no message to scan. Deprecated: this should not happen since there must be message or attachment for DLP scan."]
        ScanSkippedNoMessage,
        #[doc = "Rule fetch and evaluation are skipped because the user sending message is a non-human user (i.e. a bot)."]
        ScanSkippedNonHumanUser,
        #[doc = "Rule fetch and evaluation are skipped because the user has acknowledged the warning on the message that triggered the Warn violation and sent the message anyway."]
        ScanSkippedUserAcknowledgedWarning,
        #[doc = "Violation is detected and will be logged to BIP (no user-facing action performed)."]
        ScanSucceededAuditOnly,
        #[doc = "Violation is detected. The message/attachment will be blocked (or deleted if this happens in failure recovery), the user will be warned, and the violation will be logged to BIP."]
        ScanSucceededBlock,
        #[doc = "This means no violation is detected on the given message/attachment."]
        ScanSucceededNoViolation,
        #[doc = "Violation is detected. The user will be warned, and the violation will be logged to BIP."]
        ScanSucceededWarn,
        #[doc = "Rules were fetched but some evaluations failed. An audit-only violation was found in the rules that were successfully evaluated. The violation will be logged to BIP (no user-facing action performed)."]
        ScanSucceededWithFailuresAuditOnly,
        #[doc = "Rules were fetched but some evaluations failed. A blocking violation was found in the rules that were successfully evaluated. The message/attachment will be blocked, the user will be notified, and the violation will be logged to BIP. A blocking violation takes precedence over all other violation types."]
        ScanSucceededWithFailuresBlock,
        #[doc = "Rules were fetched but some evaluations failed. No violation was found in the rules that were successfully evaluated."]
        ScanSucceededWithFailuresNoViolation,
        #[doc = "Rules were fetched but some evaluations failed. A warn violation was found in the rules that were successfully evaluated. The user will be warned, and the violation will be logged to BIP."]
        ScanSucceededWithFailuresWarn,
        ScanUnknownOutcome,
    }
    impl MessageDlpScanOutcome {
        pub fn as_str(self) -> &'static str {
            match self { MessageDlpScanOutcome :: ScanFailureAllRulesFailed => "SCAN_FAILURE_ALL_RULES_FAILED" , MessageDlpScanOutcome :: ScanFailureException => "SCAN_FAILURE_EXCEPTION" , MessageDlpScanOutcome :: ScanFailureIllegalStateForAttachments => "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" , MessageDlpScanOutcome :: ScanFailureRuleFetchFailed => "SCAN_FAILURE_RULE_FETCH_FAILED" , MessageDlpScanOutcome :: ScanFailureTimeout => "SCAN_FAILURE_TIMEOUT" , MessageDlpScanOutcome :: ScanRuleEvaluationSkippedChangelingEmptyResponse => "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" , MessageDlpScanOutcome :: ScanRuleEvaluationSkippedChangelingPermanentError => "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" , MessageDlpScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForActionParams => "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" , MessageDlpScanOutcome :: ScanRuleEvaluationSkippedNoApplicableRulesForTrigger => "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" , MessageDlpScanOutcome :: ScanRuleEvaluationSkippedNoRulesFound => "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" , MessageDlpScanOutcome :: ScanRuleEvaluationSkippedUnsupportedFileType => "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" , MessageDlpScanOutcome :: ScanSkippedConsumer => "SCAN_SKIPPED_CONSUMER" , MessageDlpScanOutcome :: ScanSkippedExperimentDisabled => "SCAN_SKIPPED_EXPERIMENT_DISABLED" , MessageDlpScanOutcome :: ScanSkippedMessageFromUnsupportedOrigin => "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" , MessageDlpScanOutcome :: ScanSkippedNoMessage => "SCAN_SKIPPED_NO_MESSAGE" , MessageDlpScanOutcome :: ScanSkippedNonHumanUser => "SCAN_SKIPPED_NON_HUMAN_USER" , MessageDlpScanOutcome :: ScanSkippedUserAcknowledgedWarning => "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" , MessageDlpScanOutcome :: ScanSucceededAuditOnly => "SCAN_SUCCEEDED_AUDIT_ONLY" , MessageDlpScanOutcome :: ScanSucceededBlock => "SCAN_SUCCEEDED_BLOCK" , MessageDlpScanOutcome :: ScanSucceededNoViolation => "SCAN_SUCCEEDED_NO_VIOLATION" , MessageDlpScanOutcome :: ScanSucceededWarn => "SCAN_SUCCEEDED_WARN" , MessageDlpScanOutcome :: ScanSucceededWithFailuresAuditOnly => "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" , MessageDlpScanOutcome :: ScanSucceededWithFailuresBlock => "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" , MessageDlpScanOutcome :: ScanSucceededWithFailuresNoViolation => "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" , MessageDlpScanOutcome :: ScanSucceededWithFailuresWarn => "SCAN_SUCCEEDED_WITH_FAILURES_WARN" , MessageDlpScanOutcome :: ScanUnknownOutcome => "SCAN_UNKNOWN_OUTCOME" , }
        }
    }
    impl ::std::convert::AsRef<str> for MessageDlpScanOutcome {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MessageDlpScanOutcome {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MessageDlpScanOutcome, ()> {
            Ok(match s {
                "SCAN_FAILURE_ALL_RULES_FAILED" => MessageDlpScanOutcome::ScanFailureAllRulesFailed,
                "SCAN_FAILURE_EXCEPTION" => MessageDlpScanOutcome::ScanFailureException,
                "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" => {
                    MessageDlpScanOutcome::ScanFailureIllegalStateForAttachments
                }
                "SCAN_FAILURE_RULE_FETCH_FAILED" => {
                    MessageDlpScanOutcome::ScanFailureRuleFetchFailed
                }
                "SCAN_FAILURE_TIMEOUT" => MessageDlpScanOutcome::ScanFailureTimeout,
                "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedChangelingEmptyResponse
                }
                "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedChangelingPermanentError
                }
                "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedNoApplicableRulesForActionParams
                }
                "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedNoApplicableRulesForTrigger
                }
                "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedNoRulesFound
                }
                "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedUnsupportedFileType
                }
                "SCAN_SKIPPED_CONSUMER" => MessageDlpScanOutcome::ScanSkippedConsumer,
                "SCAN_SKIPPED_EXPERIMENT_DISABLED" => {
                    MessageDlpScanOutcome::ScanSkippedExperimentDisabled
                }
                "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" => {
                    MessageDlpScanOutcome::ScanSkippedMessageFromUnsupportedOrigin
                }
                "SCAN_SKIPPED_NO_MESSAGE" => MessageDlpScanOutcome::ScanSkippedNoMessage,
                "SCAN_SKIPPED_NON_HUMAN_USER" => MessageDlpScanOutcome::ScanSkippedNonHumanUser,
                "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" => {
                    MessageDlpScanOutcome::ScanSkippedUserAcknowledgedWarning
                }
                "SCAN_SUCCEEDED_AUDIT_ONLY" => MessageDlpScanOutcome::ScanSucceededAuditOnly,
                "SCAN_SUCCEEDED_BLOCK" => MessageDlpScanOutcome::ScanSucceededBlock,
                "SCAN_SUCCEEDED_NO_VIOLATION" => MessageDlpScanOutcome::ScanSucceededNoViolation,
                "SCAN_SUCCEEDED_WARN" => MessageDlpScanOutcome::ScanSucceededWarn,
                "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" => {
                    MessageDlpScanOutcome::ScanSucceededWithFailuresAuditOnly
                }
                "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" => {
                    MessageDlpScanOutcome::ScanSucceededWithFailuresBlock
                }
                "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" => {
                    MessageDlpScanOutcome::ScanSucceededWithFailuresNoViolation
                }
                "SCAN_SUCCEEDED_WITH_FAILURES_WARN" => {
                    MessageDlpScanOutcome::ScanSucceededWithFailuresWarn
                }
                "SCAN_UNKNOWN_OUTCOME" => MessageDlpScanOutcome::ScanUnknownOutcome,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MessageDlpScanOutcome {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MessageDlpScanOutcome {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MessageDlpScanOutcome {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "SCAN_FAILURE_ALL_RULES_FAILED" => MessageDlpScanOutcome::ScanFailureAllRulesFailed,
                "SCAN_FAILURE_EXCEPTION" => MessageDlpScanOutcome::ScanFailureException,
                "SCAN_FAILURE_ILLEGAL_STATE_FOR_ATTACHMENTS" => {
                    MessageDlpScanOutcome::ScanFailureIllegalStateForAttachments
                }
                "SCAN_FAILURE_RULE_FETCH_FAILED" => {
                    MessageDlpScanOutcome::ScanFailureRuleFetchFailed
                }
                "SCAN_FAILURE_TIMEOUT" => MessageDlpScanOutcome::ScanFailureTimeout,
                "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_EMPTY_RESPONSE" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedChangelingEmptyResponse
                }
                "SCAN_RULE_EVALUATION_SKIPPED_CHANGELING_PERMANENT_ERROR" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedChangelingPermanentError
                }
                "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_ACTION_PARAMS" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedNoApplicableRulesForActionParams
                }
                "SCAN_RULE_EVALUATION_SKIPPED_NO_APPLICABLE_RULES_FOR_TRIGGER" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedNoApplicableRulesForTrigger
                }
                "SCAN_RULE_EVALUATION_SKIPPED_NO_RULES_FOUND" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedNoRulesFound
                }
                "SCAN_RULE_EVALUATION_SKIPPED_UNSUPPORTED_FILE_TYPE" => {
                    MessageDlpScanOutcome::ScanRuleEvaluationSkippedUnsupportedFileType
                }
                "SCAN_SKIPPED_CONSUMER" => MessageDlpScanOutcome::ScanSkippedConsumer,
                "SCAN_SKIPPED_EXPERIMENT_DISABLED" => {
                    MessageDlpScanOutcome::ScanSkippedExperimentDisabled
                }
                "SCAN_SKIPPED_MESSAGE_FROM_UNSUPPORTED_ORIGIN" => {
                    MessageDlpScanOutcome::ScanSkippedMessageFromUnsupportedOrigin
                }
                "SCAN_SKIPPED_NO_MESSAGE" => MessageDlpScanOutcome::ScanSkippedNoMessage,
                "SCAN_SKIPPED_NON_HUMAN_USER" => MessageDlpScanOutcome::ScanSkippedNonHumanUser,
                "SCAN_SKIPPED_USER_ACKNOWLEDGED_WARNING" => {
                    MessageDlpScanOutcome::ScanSkippedUserAcknowledgedWarning
                }
                "SCAN_SUCCEEDED_AUDIT_ONLY" => MessageDlpScanOutcome::ScanSucceededAuditOnly,
                "SCAN_SUCCEEDED_BLOCK" => MessageDlpScanOutcome::ScanSucceededBlock,
                "SCAN_SUCCEEDED_NO_VIOLATION" => MessageDlpScanOutcome::ScanSucceededNoViolation,
                "SCAN_SUCCEEDED_WARN" => MessageDlpScanOutcome::ScanSucceededWarn,
                "SCAN_SUCCEEDED_WITH_FAILURES_AUDIT_ONLY" => {
                    MessageDlpScanOutcome::ScanSucceededWithFailuresAuditOnly
                }
                "SCAN_SUCCEEDED_WITH_FAILURES_BLOCK" => {
                    MessageDlpScanOutcome::ScanSucceededWithFailuresBlock
                }
                "SCAN_SUCCEEDED_WITH_FAILURES_NO_VIOLATION" => {
                    MessageDlpScanOutcome::ScanSucceededWithFailuresNoViolation
                }
                "SCAN_SUCCEEDED_WITH_FAILURES_WARN" => {
                    MessageDlpScanOutcome::ScanSucceededWithFailuresWarn
                }
                "SCAN_UNKNOWN_OUTCOME" => MessageDlpScanOutcome::ScanUnknownOutcome,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MessageDlpScanOutcome {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageDlpScanOutcome {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MessageEditableBy {
        #[doc = "The message creator can mutate regardless of request origin. Use case: for messages created by human via Chat UI or Chat API. These messages can be mutated by the same human user via Chat UI or via any app on Chat API."]
        PermissionCreator,
        #[doc = "Every human member of a space or the creator can mutate the entity. This excludes app acting on behalf of human via Chat API. Use case: This is to enable humans to delete messages created by apps."]
        PermissionMember,
        #[doc = "No one except for the message creator/origin pair can mutate. This permission checks both gaia id and the request origin. Request origin can be Chat API or Chat UI. Mutation is allowed iff both attributes of the request match the original message creation. Use case: this allows historical 1P apps lock down message edit permission i.e. In Chat UI, humans cannot edit their messages created via these 1P apps. Do not use this for additional use cases."]
        PermissionNoOne,
        #[doc = "Default case, should never be used. If this data is encountered in the DB any request should throw an exception."]
        PermissionUnspecified,
    }
    impl MessageEditableBy {
        pub fn as_str(self) -> &'static str {
            match self {
                MessageEditableBy::PermissionCreator => "PERMISSION_CREATOR",
                MessageEditableBy::PermissionMember => "PERMISSION_MEMBER",
                MessageEditableBy::PermissionNoOne => "PERMISSION_NO_ONE",
                MessageEditableBy::PermissionUnspecified => "PERMISSION_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MessageEditableBy {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MessageEditableBy {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MessageEditableBy, ()> {
            Ok(match s {
                "PERMISSION_CREATOR" => MessageEditableBy::PermissionCreator,
                "PERMISSION_MEMBER" => MessageEditableBy::PermissionMember,
                "PERMISSION_NO_ONE" => MessageEditableBy::PermissionNoOne,
                "PERMISSION_UNSPECIFIED" => MessageEditableBy::PermissionUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MessageEditableBy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MessageEditableBy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MessageEditableBy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "PERMISSION_CREATOR" => MessageEditableBy::PermissionCreator,
                "PERMISSION_MEMBER" => MessageEditableBy::PermissionMember,
                "PERMISSION_NO_ONE" => MessageEditableBy::PermissionNoOne,
                "PERMISSION_UNSPECIFIED" => MessageEditableBy::PermissionUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MessageEditableBy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageEditableBy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MessageMessageOrigin {
        #[doc = "The message came directly from Babel as source-of-truth"]
        OriginBabel,
        #[doc = "The message came directly from Babel during dual-write"]
        OriginBabelDualWrite,
        #[doc = "The message came directly from Babel Manifold queue during dual write"]
        OriginBabelDualWriteRetry,
        #[doc = "The message is from Babel (Hangouts Classic) interop."]
        OriginBabelInteropLive,
        #[doc = "The message is from Babel interop retries from Manifold queue."]
        OriginBabelInteropRetry,
        OriginBackfillFromGmailArchive,
        #[doc = "The message was backfilled by go/dinnertrain as part of go/storage-consolidation. The backfill origin corresponds to the BackfillState in which the message was created."]
        OriginBackfillFromPapyrus,
        OriginDynamite,
        OriginNotSet,
    }
    impl MessageMessageOrigin {
        pub fn as_str(self) -> &'static str {
            match self {
                MessageMessageOrigin::OriginBabel => "ORIGIN_BABEL",
                MessageMessageOrigin::OriginBabelDualWrite => "ORIGIN_BABEL_DUAL_WRITE",
                MessageMessageOrigin::OriginBabelDualWriteRetry => "ORIGIN_BABEL_DUAL_WRITE_RETRY",
                MessageMessageOrigin::OriginBabelInteropLive => "ORIGIN_BABEL_INTEROP_LIVE",
                MessageMessageOrigin::OriginBabelInteropRetry => "ORIGIN_BABEL_INTEROP_RETRY",
                MessageMessageOrigin::OriginBackfillFromGmailArchive => {
                    "ORIGIN_BACKFILL_FROM_GMAIL_ARCHIVE"
                }
                MessageMessageOrigin::OriginBackfillFromPapyrus => "ORIGIN_BACKFILL_FROM_PAPYRUS",
                MessageMessageOrigin::OriginDynamite => "ORIGIN_DYNAMITE",
                MessageMessageOrigin::OriginNotSet => "ORIGIN_NOT_SET",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MessageMessageOrigin {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MessageMessageOrigin {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MessageMessageOrigin, ()> {
            Ok(match s {
                "ORIGIN_BABEL" => MessageMessageOrigin::OriginBabel,
                "ORIGIN_BABEL_DUAL_WRITE" => MessageMessageOrigin::OriginBabelDualWrite,
                "ORIGIN_BABEL_DUAL_WRITE_RETRY" => MessageMessageOrigin::OriginBabelDualWriteRetry,
                "ORIGIN_BABEL_INTEROP_LIVE" => MessageMessageOrigin::OriginBabelInteropLive,
                "ORIGIN_BABEL_INTEROP_RETRY" => MessageMessageOrigin::OriginBabelInteropRetry,
                "ORIGIN_BACKFILL_FROM_GMAIL_ARCHIVE" => {
                    MessageMessageOrigin::OriginBackfillFromGmailArchive
                }
                "ORIGIN_BACKFILL_FROM_PAPYRUS" => MessageMessageOrigin::OriginBackfillFromPapyrus,
                "ORIGIN_DYNAMITE" => MessageMessageOrigin::OriginDynamite,
                "ORIGIN_NOT_SET" => MessageMessageOrigin::OriginNotSet,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MessageMessageOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MessageMessageOrigin {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MessageMessageOrigin {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ORIGIN_BABEL" => MessageMessageOrigin::OriginBabel,
                "ORIGIN_BABEL_DUAL_WRITE" => MessageMessageOrigin::OriginBabelDualWrite,
                "ORIGIN_BABEL_DUAL_WRITE_RETRY" => MessageMessageOrigin::OriginBabelDualWriteRetry,
                "ORIGIN_BABEL_INTEROP_LIVE" => MessageMessageOrigin::OriginBabelInteropLive,
                "ORIGIN_BABEL_INTEROP_RETRY" => MessageMessageOrigin::OriginBabelInteropRetry,
                "ORIGIN_BACKFILL_FROM_GMAIL_ARCHIVE" => {
                    MessageMessageOrigin::OriginBackfillFromGmailArchive
                }
                "ORIGIN_BACKFILL_FROM_PAPYRUS" => MessageMessageOrigin::OriginBackfillFromPapyrus,
                "ORIGIN_DYNAMITE" => MessageMessageOrigin::OriginDynamite,
                "ORIGIN_NOT_SET" => MessageMessageOrigin::OriginNotSet,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MessageMessageOrigin {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageMessageOrigin {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MessageMessageState {
        #[doc = "Private state - only visible to the message creator, and the private_message_viewer if set."]
        Private,
        #[doc = "Default - visible to the room / DM."]
        Public,
    }
    impl MessageMessageState {
        pub fn as_str(self) -> &'static str {
            match self {
                MessageMessageState::Private => "PRIVATE",
                MessageMessageState::Public => "PUBLIC",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MessageMessageState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MessageMessageState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MessageMessageState, ()> {
            Ok(match s {
                "PRIVATE" => MessageMessageState::Private,
                "PUBLIC" => MessageMessageState::Public,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MessageMessageState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MessageMessageState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MessageMessageState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "PRIVATE" => MessageMessageState::Private,
                "PUBLIC" => MessageMessageState::Public,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MessageMessageState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageMessageState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MessageQuotedByState {
        #[doc = "State to indicate that this message is quoted by another message (excluding purged message)."]
        QuotedByStateHasBeenQuoted,
        #[doc = "State to indicate that this message are not quoted by another message."]
        QuotedByStateHasNotBeenQuoted,
        #[doc = "Unspecified state for QuotedByState."]
        QuotedByStateUnspecified,
    }
    impl MessageQuotedByState {
        pub fn as_str(self) -> &'static str {
            match self {
                MessageQuotedByState::QuotedByStateHasBeenQuoted => {
                    "QUOTED_BY_STATE_HAS_BEEN_QUOTED"
                }
                MessageQuotedByState::QuotedByStateHasNotBeenQuoted => {
                    "QUOTED_BY_STATE_HAS_NOT_BEEN_QUOTED"
                }
                MessageQuotedByState::QuotedByStateUnspecified => "QUOTED_BY_STATE_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MessageQuotedByState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MessageQuotedByState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MessageQuotedByState, ()> {
            Ok(match s {
                "QUOTED_BY_STATE_HAS_BEEN_QUOTED" => {
                    MessageQuotedByState::QuotedByStateHasBeenQuoted
                }
                "QUOTED_BY_STATE_HAS_NOT_BEEN_QUOTED" => {
                    MessageQuotedByState::QuotedByStateHasNotBeenQuoted
                }
                "QUOTED_BY_STATE_UNSPECIFIED" => MessageQuotedByState::QuotedByStateUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MessageQuotedByState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MessageQuotedByState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MessageQuotedByState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "QUOTED_BY_STATE_HAS_BEEN_QUOTED" => {
                    MessageQuotedByState::QuotedByStateHasBeenQuoted
                }
                "QUOTED_BY_STATE_HAS_NOT_BEEN_QUOTED" => {
                    MessageQuotedByState::QuotedByStateHasNotBeenQuoted
                }
                "QUOTED_BY_STATE_UNSPECIFIED" => MessageQuotedByState::QuotedByStateUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MessageQuotedByState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageQuotedByState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MessageRichTextFormattingType {
        #[doc = "The formatting was specified as {@link com.google.apps.dynamite.v1.shared.FormatMetadata} annotations."]
        FormatAnnotations,
        #[doc = "The client sent the format annotations, but didn’t set the accept_format_annotations field to true. This shouldn’t happen, but there might be some old clients that end up here."]
        FormatAnnotationsIgnored,
        #[doc = "A combination of MARKDOWN and FORMAT_ANNOTATIONS_IGNORED."]
        FormatAnnotationsIgnoredWithMarkdown,
        #[doc = "The formatting was specified as *markdown characters* in message text."]
        Markdown,
        None,
    }
    impl MessageRichTextFormattingType {
        pub fn as_str(self) -> &'static str {
            match self {
                MessageRichTextFormattingType::FormatAnnotations => "FORMAT_ANNOTATIONS",
                MessageRichTextFormattingType::FormatAnnotationsIgnored => {
                    "FORMAT_ANNOTATIONS_IGNORED"
                }
                MessageRichTextFormattingType::FormatAnnotationsIgnoredWithMarkdown => {
                    "FORMAT_ANNOTATIONS_IGNORED_WITH_MARKDOWN"
                }
                MessageRichTextFormattingType::Markdown => "MARKDOWN",
                MessageRichTextFormattingType::None => "NONE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MessageRichTextFormattingType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MessageRichTextFormattingType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MessageRichTextFormattingType, ()> {
            Ok(match s {
                "FORMAT_ANNOTATIONS" => MessageRichTextFormattingType::FormatAnnotations,
                "FORMAT_ANNOTATIONS_IGNORED" => {
                    MessageRichTextFormattingType::FormatAnnotationsIgnored
                }
                "FORMAT_ANNOTATIONS_IGNORED_WITH_MARKDOWN" => {
                    MessageRichTextFormattingType::FormatAnnotationsIgnoredWithMarkdown
                }
                "MARKDOWN" => MessageRichTextFormattingType::Markdown,
                "NONE" => MessageRichTextFormattingType::None,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MessageRichTextFormattingType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MessageRichTextFormattingType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MessageRichTextFormattingType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FORMAT_ANNOTATIONS" => MessageRichTextFormattingType::FormatAnnotations,
                "FORMAT_ANNOTATIONS_IGNORED" => {
                    MessageRichTextFormattingType::FormatAnnotationsIgnored
                }
                "FORMAT_ANNOTATIONS_IGNORED_WITH_MARKDOWN" => {
                    MessageRichTextFormattingType::FormatAnnotationsIgnoredWithMarkdown
                }
                "MARKDOWN" => MessageRichTextFormattingType::Markdown,
                "NONE" => MessageRichTextFormattingType::None,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MessageRichTextFormattingType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageRichTextFormattingType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MessageAdded {
        #[serde(
            rename = "attributeIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attribute_ids: ::std::option::Option<Vec<String>>,
        #[serde(
            rename = "labelIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_ids: ::std::option::Option<Vec<String>>,
        #[serde(
            rename = "messageKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_key: ::std::option::Option<crate::schemas::MultiKey>,
        #[doc = "Note that there can be fewer sync ids than label ids."]
        #[serde(
            rename = "syncIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sync_ids: ::std::option::Option<Vec<u32>>,
    }
    impl ::google_field_selector::FieldSelector for MessageAdded {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageAdded {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MessageAttributes {
        #[doc = "If true: message is a tombstone in the client. Default false."]
        #[serde(
            rename = "isTombstone",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_tombstone: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for MessageAttributes {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageAttributes {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MessageDeleted {
        #[doc = "Value of coproc’s message delete history record extension that exports /imapsync/folder attribute of deleted messages which have ^is label."]
        #[serde(
            rename = "imapSyncMappings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub imap_sync_mappings: ::std::option::Option<Vec<crate::schemas::ImapSyncDelete>>,
        #[serde(
            rename = "messageKeys",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_keys: ::std::option::Option<Vec<crate::schemas::MultiKey>>,
    }
    impl ::google_field_selector::FieldSelector for MessageDeleted {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageDeleted {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MessageId {
        #[doc = "Opaque, server-assigned ID of the Message. While this ID is guaranteed to be unique within the Space, it’s not guaranteed to be globally unique."]
        #[serde(
            rename = "messageId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_id: ::std::option::Option<String>,
        #[doc = "ID of the Message’s immediate parent."]
        #[serde(
            rename = "parentId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parent_id: ::std::option::Option<crate::schemas::MessageParentId>,
    }
    impl ::google_field_selector::FieldSelector for MessageId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct MessageInfo {
        #[doc = "The content of a matching message."]
        #[serde(
            rename = "message",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message: ::std::option::Option<crate::schemas::Message>,
        #[doc = "Searcher’s membership state in the space where the message is posted."]
        #[serde(
            rename = "searcherMembershipState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub searcher_membership_state:
            ::std::option::Option<crate::schemas::MessageInfoSearcherMembershipState>,
    }
    impl ::google_field_selector::FieldSelector for MessageInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MessageInfoSearcherMembershipState {
        #[doc = "This state should never be stored in Spanner. It is a state for responses to the clients to indicate that membership mutations have failed and the member is in its previous state."]
        MemberFailed,
        #[doc = "An invitation to the space has been sent"]
        MemberInvited,
        #[doc = "User has joined the space"]
        MemberJoined,
        #[doc = "User is not a member"]
        MemberNotAMember,
        #[doc = "Default state, do not use"]
        MemberUnknown,
    }
    impl MessageInfoSearcherMembershipState {
        pub fn as_str(self) -> &'static str {
            match self {
                MessageInfoSearcherMembershipState::MemberFailed => "MEMBER_FAILED",
                MessageInfoSearcherMembershipState::MemberInvited => "MEMBER_INVITED",
                MessageInfoSearcherMembershipState::MemberJoined => "MEMBER_JOINED",
                MessageInfoSearcherMembershipState::MemberNotAMember => "MEMBER_NOT_A_MEMBER",
                MessageInfoSearcherMembershipState::MemberUnknown => "MEMBER_UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for MessageInfoSearcherMembershipState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MessageInfoSearcherMembershipState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<MessageInfoSearcherMembershipState, ()> {
            Ok(match s {
                "MEMBER_FAILED" => MessageInfoSearcherMembershipState::MemberFailed,
                "MEMBER_INVITED" => MessageInfoSearcherMembershipState::MemberInvited,
                "MEMBER_JOINED" => MessageInfoSearcherMembershipState::MemberJoined,
                "MEMBER_NOT_A_MEMBER" => MessageInfoSearcherMembershipState::MemberNotAMember,
                "MEMBER_UNKNOWN" => MessageInfoSearcherMembershipState::MemberUnknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MessageInfoSearcherMembershipState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MessageInfoSearcherMembershipState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MessageInfoSearcherMembershipState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MEMBER_FAILED" => MessageInfoSearcherMembershipState::MemberFailed,
                "MEMBER_INVITED" => MessageInfoSearcherMembershipState::MemberInvited,
                "MEMBER_JOINED" => MessageInfoSearcherMembershipState::MemberJoined,
                "MEMBER_NOT_A_MEMBER" => MessageInfoSearcherMembershipState::MemberNotAMember,
                "MEMBER_UNKNOWN" => MessageInfoSearcherMembershipState::MemberUnknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MessageInfoSearcherMembershipState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageInfoSearcherMembershipState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MessageParentId {
        #[doc = "ID of the Topic this Message is posted to. NEXT TAG : 5"]
        #[serde(
            rename = "topicId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub topic_id: ::std::option::Option<crate::schemas::TopicId>,
    }
    impl ::google_field_selector::FieldSelector for MessageParentId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageParentId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MessageProps {
        #[serde(
            rename = "babelProps",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub babel_props: ::std::option::Option<crate::schemas::BabelMessageProps>,
    }
    impl ::google_field_selector::FieldSelector for MessageProps {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageProps {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MessageSet {}
    impl ::google_field_selector::FieldSelector for MessageSet {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MessageSet {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Metadata {
        #[doc = "The creation time for this document or object in the search result."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Options that specify how to display a structured data search result."]
        #[serde(
            rename = "displayOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_options: ::std::option::Option<crate::schemas::ResultDisplayMetadata>,
        #[doc = "Indexed fields in structured data, returned as a generic named property."]
        #[serde(
            rename = "fields",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fields: ::std::option::Option<Vec<crate::schemas::NamedProperty>>,
        #[doc = "Mime type of the search result."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Object type of the search result."]
        #[serde(
            rename = "objectType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_type: ::std::option::Option<String>,
        #[doc = "Owner (usually creator) of the document or object of the search result."]
        #[serde(
            rename = "owner",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub owner: ::std::option::Option<crate::schemas::Person>,
        #[doc = "The named source for the result, such as Gmail."]
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source: ::std::option::Option<crate::schemas::Source>,
        #[doc = "The thumbnail URL of the result."]
        #[serde(
            rename = "thumbnailUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thumbnail_url: ::std::option::Option<String>,
        #[doc = "The last modified date for the object in the search result. If not set in the item, the value returned here is empty. When `updateTime` is used for calculating freshness and is not set, this value defaults to 2 years from the current time."]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Metadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Metadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Metaline {
        #[doc = "The list of displayed properties for the metaline. The maximum number of properties is 5."]
        #[serde(
            rename = "properties",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub properties: ::std::option::Option<Vec<crate::schemas::DisplayedProperty>>,
    }
    impl ::google_field_selector::FieldSelector for Metaline {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Metaline {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MultiKey {
        #[doc = "A client-assigned string based key."]
        #[serde(
            rename = "clientAssignedPermId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_assigned_perm_id: ::std::option::Option<String>,
        #[doc = "A server-assigned ID. This ID must be used only by Gmail and is constructed using millesecond ts \\<\\< 20 + randomness. The ID affects the sort order of the index."]
        #[serde(
            rename = "serverId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub server_id: ::std::option::Option<u64>,
    }
    impl ::google_field_selector::FieldSelector for MultiKey {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MultiKey {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Name {
        #[doc = "The read-only display name formatted according to the locale specified by the viewer’s account or the `Accept-Language` HTTP header."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Name {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Name {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct NamedProperty {
        #[serde(
            rename = "booleanValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_value: ::std::option::Option<bool>,
        #[serde(
            rename = "dateValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date_values: ::std::option::Option<crate::schemas::DateValues>,
        #[serde(
            rename = "doubleValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_values: ::std::option::Option<crate::schemas::DoubleValues>,
        #[serde(
            rename = "enumValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enum_values: ::std::option::Option<crate::schemas::EnumValues>,
        #[serde(
            rename = "htmlValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub html_values: ::std::option::Option<crate::schemas::HtmlValues>,
        #[serde(
            rename = "integerValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integer_values: ::std::option::Option<crate::schemas::IntegerValues>,
        #[doc = "The name of the property. This name should correspond to the name of the property that was registered for object definition in the schema. The maximum allowable length for this property is 256 characters."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "objectValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_values: ::std::option::Option<crate::schemas::ObjectValues>,
        #[serde(
            rename = "textValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_values: ::std::option::Option<crate::schemas::TextValues>,
        #[serde(
            rename = "timestampValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub timestamp_values: ::std::option::Option<crate::schemas::TimestampValues>,
    }
    impl ::google_field_selector::FieldSelector for NamedProperty {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for NamedProperty {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct OauthConsumerProto {
        #[serde(
            rename = "domain",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub domain: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for OauthConsumerProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OauthConsumerProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ObjectDefinition {
        #[doc = "The name for the object, which then defines its type. Item indexing requests should set the objectType field equal to this value. For example, if *name* is *Document*, then indexing requests for items of type Document should set objectType equal to *Document*. Each object definition must be uniquely named within a schema. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The maximum length is 256 characters."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The optional object-specific options."]
        #[serde(
            rename = "options",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub options: ::std::option::Option<crate::schemas::ObjectOptions>,
        #[doc = "The property definitions for the object. The maximum number of elements is 1000."]
        #[serde(
            rename = "propertyDefinitions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub property_definitions: ::std::option::Option<Vec<crate::schemas::PropertyDefinition>>,
    }
    impl ::google_field_selector::FieldSelector for ObjectDefinition {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ObjectDefinition {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ObjectDisplayOptions {
        #[doc = "Defines the properties that are displayed in the metalines of the search results. The property values are displayed in the order given here. If a property holds multiple values, all of the values are displayed before the next properties. For this reason, it is a good practice to specify singular properties before repeated properties in this list. All of the properties must set is_returnable to true. The maximum number of metalines is 3."]
        #[serde(
            rename = "metalines",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metalines: ::std::option::Option<Vec<crate::schemas::Metaline>>,
        #[doc = "The user friendly label to display in the search result to indicate the type of the item. This is OPTIONAL; if not provided, an object label isn’t displayed on the context line of the search results. The maximum length is 64 characters."]
        #[serde(
            rename = "objectDisplayLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_display_label: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ObjectDisplayOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ObjectDisplayOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ObjectOptions {
        #[doc = "The options that determine how the object is displayed in the Cloud Search results page."]
        #[serde(
            rename = "displayOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_options: ::std::option::Option<crate::schemas::ObjectDisplayOptions>,
        #[doc = "The freshness options for an object."]
        #[serde(
            rename = "freshnessOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub freshness_options: ::std::option::Option<crate::schemas::FreshnessOptions>,
        #[doc = "Operators that can be used to filter suggestions. For Suggest API, only operators mentioned here will be honored in the FilterOptions. Only TEXT and ENUM operators are supported. NOTE: “objecttype”, “type” and “mimetype” are already supported. This property is to configure schema specific operators. Even though this is an array, only one operator can be specified. This is an array for future extensibility. Operators mapping to multiple properties within the same object are not supported. If the operator spans across different object types, this option has to be set once for each object definition."]
        #[serde(
            rename = "suggestionFilteringOperators",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suggestion_filtering_operators: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for ObjectOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ObjectOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ObjectPropertyOptions {
        #[doc = "The properties of the sub-object. These properties represent a nested object. For example, if this property represents a postal address, the subobjectProperties might be named *street*, *city*, and *state*. The maximum number of elements is 1000."]
        #[serde(
            rename = "subobjectProperties",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub subobject_properties: ::std::option::Option<Vec<crate::schemas::PropertyDefinition>>,
    }
    impl ::google_field_selector::FieldSelector for ObjectPropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ObjectPropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ObjectValues {
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<crate::schemas::StructuredDataObject>>,
    }
    impl ::google_field_selector::FieldSelector for ObjectValues {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ObjectValues {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct OnClick {
        #[serde(
            rename = "action",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action: ::std::option::Option<crate::schemas::FormAction>,
        #[doc = "This can be used as a short form for OpenLink with the default OpenAs and OnClose. It may be undeprecated if this proves to be handy for developers."]
        #[serde(
            rename = "link",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub link: ::std::option::Option<String>,
        #[serde(
            rename = "openLink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub open_link: ::std::option::Option<crate::schemas::OpenLink>,
        #[doc = "An add-on triggers this action when the form action needs to open a link. This differs from the open_link above in that this needs to talk to server to get the link. Thus some preparation work is required for web client to do before the open link action response comes back."]
        #[serde(
            rename = "openLinkAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub open_link_action: ::std::option::Option<crate::schemas::FormAction>,
    }
    impl ::google_field_selector::FieldSelector for OnClick {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OnClick {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct OpenCreatedDraftActionMarkup {
        #[doc = "The ID of the newly created draft in the form “r123”."]
        #[serde(
            rename = "draftId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub draft_id: ::std::option::Option<String>,
        #[doc = "The server storage ID in hex format, for example,“15e9fa622ce1029d”."]
        #[serde(
            rename = "draftStorageId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub draft_storage_id: ::std::option::Option<String>,
        #[doc = "The ID of the thread containing the newly created draft, for example, “15e9fa622ce1029d”."]
        #[serde(
            rename = "draftThreadId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub draft_thread_id: ::std::option::Option<String>,
        #[doc = "The server permanent ID for the draft’s thread. This field isn’t set anywhere, and it’s ignored when processing OpenCreatedDraftActionMarkup. Supply and use draftThreadStorageId instead."]
        #[serde(
            rename = "draftThreadServerPermId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub draft_thread_server_perm_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for OpenCreatedDraftActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OpenCreatedDraftActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct OpenLink {
        #[doc = "Next available ID: 5"]
        #[serde(
            rename = "loadIndicator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub load_indicator: ::std::option::Option<crate::schemas::OpenLinkLoadIndicator>,
        #[serde(
            rename = "onClose",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_close: ::std::option::Option<crate::schemas::OpenLinkOnClose>,
        #[serde(
            rename = "openAs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub open_as: ::std::option::Option<crate::schemas::OpenLinkOpenAs>,
        #[serde(
            rename = "url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for OpenLink {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OpenLink {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum OpenLinkLoadIndicator {
        None,
        Spinner,
    }
    impl OpenLinkLoadIndicator {
        pub fn as_str(self) -> &'static str {
            match self {
                OpenLinkLoadIndicator::None => "NONE",
                OpenLinkLoadIndicator::Spinner => "SPINNER",
            }
        }
    }
    impl ::std::convert::AsRef<str> for OpenLinkLoadIndicator {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for OpenLinkLoadIndicator {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<OpenLinkLoadIndicator, ()> {
            Ok(match s {
                "NONE" => OpenLinkLoadIndicator::None,
                "SPINNER" => OpenLinkLoadIndicator::Spinner,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for OpenLinkLoadIndicator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for OpenLinkLoadIndicator {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OpenLinkLoadIndicator {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NONE" => OpenLinkLoadIndicator::None,
                "SPINNER" => OpenLinkLoadIndicator::Spinner,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for OpenLinkLoadIndicator {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OpenLinkLoadIndicator {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum OpenLinkOnClose {
        Nothing,
        ReloadAddOn,
    }
    impl OpenLinkOnClose {
        pub fn as_str(self) -> &'static str {
            match self {
                OpenLinkOnClose::Nothing => "NOTHING",
                OpenLinkOnClose::ReloadAddOn => "RELOAD_ADD_ON",
            }
        }
    }
    impl ::std::convert::AsRef<str> for OpenLinkOnClose {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for OpenLinkOnClose {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<OpenLinkOnClose, ()> {
            Ok(match s {
                "NOTHING" => OpenLinkOnClose::Nothing,
                "RELOAD_ADD_ON" => OpenLinkOnClose::ReloadAddOn,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for OpenLinkOnClose {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for OpenLinkOnClose {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OpenLinkOnClose {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NOTHING" => OpenLinkOnClose::Nothing,
                "RELOAD_ADD_ON" => OpenLinkOnClose::ReloadAddOn,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for OpenLinkOnClose {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OpenLinkOnClose {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum OpenLinkOpenAs {
        FullSize,
        Overlay,
    }
    impl OpenLinkOpenAs {
        pub fn as_str(self) -> &'static str {
            match self {
                OpenLinkOpenAs::FullSize => "FULL_SIZE",
                OpenLinkOpenAs::Overlay => "OVERLAY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for OpenLinkOpenAs {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for OpenLinkOpenAs {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<OpenLinkOpenAs, ()> {
            Ok(match s {
                "FULL_SIZE" => OpenLinkOpenAs::FullSize,
                "OVERLAY" => OpenLinkOpenAs::Overlay,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for OpenLinkOpenAs {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for OpenLinkOpenAs {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OpenLinkOpenAs {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FULL_SIZE" => OpenLinkOpenAs::FullSize,
                "OVERLAY" => OpenLinkOpenAs::Overlay,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for OpenLinkOpenAs {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OpenLinkOpenAs {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct Operation {
        #[doc = "If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available."]
        #[serde(
            rename = "done",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub done: ::std::option::Option<bool>,
        #[doc = "The error result of the operation in case of failure or cancellation."]
        #[serde(
            rename = "error",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error: ::std::option::Option<crate::schemas::Status>,
        #[doc = "Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any."]
        #[serde(
            rename = "metadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metadata:
            ::std::option::Option<::std::collections::BTreeMap<String, ::serde_json::Value>>,
        #[doc = "The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."]
        #[serde(
            rename = "response",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub response:
            ::std::option::Option<::std::collections::BTreeMap<String, ::serde_json::Value>>,
    }
    impl ::google_field_selector::FieldSelector for Operation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Operation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct OsVersion {
        #[serde(
            rename = "majorVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub major_version: ::std::option::Option<i32>,
        #[serde(
            rename = "minorVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub minor_version: ::std::option::Option<i32>,
        #[serde(
            rename = "tertiaryVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tertiary_version: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for OsVersion {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OsVersion {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct OtrChatMessageEvent {
        #[serde(
            rename = "expirationTimestampUsec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub expiration_timestamp_usec: ::std::option::Option<i64>,
        #[serde(
            rename = "kansasRowId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kansas_row_id: ::std::option::Option<String>,
        #[serde(
            rename = "kansasVersionInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kansas_version_info: ::std::option::Option<String>,
        #[serde(
            rename = "messageOtrStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_otr_status:
            ::std::option::Option<crate::schemas::OtrChatMessageEventMessageOtrStatus>,
    }
    impl ::google_field_selector::FieldSelector for OtrChatMessageEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OtrChatMessageEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum OtrChatMessageEventMessageOtrStatus {
        #[doc = "The conversation is completely off the record."]
        OffTheRecord,
        #[doc = "The conversation is completely on the record."]
        OnTheRecord,
    }
    impl OtrChatMessageEventMessageOtrStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                OtrChatMessageEventMessageOtrStatus::OffTheRecord => "OFF_THE_RECORD",
                OtrChatMessageEventMessageOtrStatus::OnTheRecord => "ON_THE_RECORD",
            }
        }
    }
    impl ::std::convert::AsRef<str> for OtrChatMessageEventMessageOtrStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for OtrChatMessageEventMessageOtrStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<OtrChatMessageEventMessageOtrStatus, ()> {
            Ok(match s {
                "OFF_THE_RECORD" => OtrChatMessageEventMessageOtrStatus::OffTheRecord,
                "ON_THE_RECORD" => OtrChatMessageEventMessageOtrStatus::OnTheRecord,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for OtrChatMessageEventMessageOtrStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for OtrChatMessageEventMessageOtrStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OtrChatMessageEventMessageOtrStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "OFF_THE_RECORD" => OtrChatMessageEventMessageOtrStatus::OffTheRecord,
                "ON_THE_RECORD" => OtrChatMessageEventMessageOtrStatus::OnTheRecord,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for OtrChatMessageEventMessageOtrStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OtrChatMessageEventMessageOtrStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct OtrModificationEvent {
        #[serde(
            rename = "newOtrStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub new_otr_status: ::std::option::Option<crate::schemas::OtrModificationEventNewOtrStatus>,
        #[serde(
            rename = "newOtrToggle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub new_otr_toggle: ::std::option::Option<crate::schemas::OtrModificationEventNewOtrToggle>,
        #[serde(
            rename = "oldOtrStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub old_otr_status: ::std::option::Option<crate::schemas::OtrModificationEventOldOtrStatus>,
        #[serde(
            rename = "oldOtrToggle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub old_otr_toggle: ::std::option::Option<crate::schemas::OtrModificationEventOldOtrToggle>,
    }
    impl ::google_field_selector::FieldSelector for OtrModificationEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OtrModificationEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum OtrModificationEventNewOtrStatus {
        #[doc = "The conversation is completely off the record."]
        OffTheRecord,
        #[doc = "The conversation is completely on the record."]
        OnTheRecord,
    }
    impl OtrModificationEventNewOtrStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                OtrModificationEventNewOtrStatus::OffTheRecord => "OFF_THE_RECORD",
                OtrModificationEventNewOtrStatus::OnTheRecord => "ON_THE_RECORD",
            }
        }
    }
    impl ::std::convert::AsRef<str> for OtrModificationEventNewOtrStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for OtrModificationEventNewOtrStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<OtrModificationEventNewOtrStatus, ()> {
            Ok(match s {
                "OFF_THE_RECORD" => OtrModificationEventNewOtrStatus::OffTheRecord,
                "ON_THE_RECORD" => OtrModificationEventNewOtrStatus::OnTheRecord,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for OtrModificationEventNewOtrStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for OtrModificationEventNewOtrStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OtrModificationEventNewOtrStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "OFF_THE_RECORD" => OtrModificationEventNewOtrStatus::OffTheRecord,
                "ON_THE_RECORD" => OtrModificationEventNewOtrStatus::OnTheRecord,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for OtrModificationEventNewOtrStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OtrModificationEventNewOtrStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum OtrModificationEventNewOtrToggle {
        #[doc = "The conversation cannot be toggled"]
        Disabled,
        #[doc = "The conversation can be toggled"]
        Enabled,
    }
    impl OtrModificationEventNewOtrToggle {
        pub fn as_str(self) -> &'static str {
            match self {
                OtrModificationEventNewOtrToggle::Disabled => "DISABLED",
                OtrModificationEventNewOtrToggle::Enabled => "ENABLED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for OtrModificationEventNewOtrToggle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for OtrModificationEventNewOtrToggle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<OtrModificationEventNewOtrToggle, ()> {
            Ok(match s {
                "DISABLED" => OtrModificationEventNewOtrToggle::Disabled,
                "ENABLED" => OtrModificationEventNewOtrToggle::Enabled,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for OtrModificationEventNewOtrToggle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for OtrModificationEventNewOtrToggle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OtrModificationEventNewOtrToggle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DISABLED" => OtrModificationEventNewOtrToggle::Disabled,
                "ENABLED" => OtrModificationEventNewOtrToggle::Enabled,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for OtrModificationEventNewOtrToggle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OtrModificationEventNewOtrToggle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum OtrModificationEventOldOtrStatus {
        #[doc = "The conversation is completely off the record."]
        OffTheRecord,
        #[doc = "The conversation is completely on the record."]
        OnTheRecord,
    }
    impl OtrModificationEventOldOtrStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                OtrModificationEventOldOtrStatus::OffTheRecord => "OFF_THE_RECORD",
                OtrModificationEventOldOtrStatus::OnTheRecord => "ON_THE_RECORD",
            }
        }
    }
    impl ::std::convert::AsRef<str> for OtrModificationEventOldOtrStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for OtrModificationEventOldOtrStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<OtrModificationEventOldOtrStatus, ()> {
            Ok(match s {
                "OFF_THE_RECORD" => OtrModificationEventOldOtrStatus::OffTheRecord,
                "ON_THE_RECORD" => OtrModificationEventOldOtrStatus::OnTheRecord,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for OtrModificationEventOldOtrStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for OtrModificationEventOldOtrStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OtrModificationEventOldOtrStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "OFF_THE_RECORD" => OtrModificationEventOldOtrStatus::OffTheRecord,
                "ON_THE_RECORD" => OtrModificationEventOldOtrStatus::OnTheRecord,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for OtrModificationEventOldOtrStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OtrModificationEventOldOtrStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum OtrModificationEventOldOtrToggle {
        #[doc = "The conversation cannot be toggled"]
        Disabled,
        #[doc = "The conversation can be toggled"]
        Enabled,
    }
    impl OtrModificationEventOldOtrToggle {
        pub fn as_str(self) -> &'static str {
            match self {
                OtrModificationEventOldOtrToggle::Disabled => "DISABLED",
                OtrModificationEventOldOtrToggle::Enabled => "ENABLED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for OtrModificationEventOldOtrToggle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for OtrModificationEventOldOtrToggle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<OtrModificationEventOldOtrToggle, ()> {
            Ok(match s {
                "DISABLED" => OtrModificationEventOldOtrToggle::Disabled,
                "ENABLED" => OtrModificationEventOldOtrToggle::Enabled,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for OtrModificationEventOldOtrToggle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for OtrModificationEventOldOtrToggle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for OtrModificationEventOldOtrToggle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DISABLED" => OtrModificationEventOldOtrToggle::Disabled,
                "ENABLED" => OtrModificationEventOldOtrToggle::Enabled,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for OtrModificationEventOldOtrToggle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for OtrModificationEventOldOtrToggle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PackagingServiceClient {
        #[doc = "Android app’s package name to generate the deep-link URI."]
        #[serde(
            rename = "androidPackageName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub android_package_name: ::std::option::Option<String>,
        #[doc = "iOS app’s App Store ID to generate the App Store URL when app is not installed on device."]
        #[serde(
            rename = "iosAppStoreId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ios_app_store_id: ::std::option::Option<String>,
        #[doc = "iOS app’s bundle ID to generate the deep-link URI."]
        #[serde(
            rename = "iosBundleId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ios_bundle_id: ::std::option::Option<String>,
        #[doc = "Type of Google API Console client."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::PackagingServiceClientType>,
    }
    impl ::google_field_selector::FieldSelector for PackagingServiceClient {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PackagingServiceClient {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PackagingServiceClientType {
        #[doc = "Client for Android app."]
        Android,
        #[doc = "Client for iOS app."]
        Ios,
    }
    impl PackagingServiceClientType {
        pub fn as_str(self) -> &'static str {
            match self {
                PackagingServiceClientType::Android => "ANDROID",
                PackagingServiceClientType::Ios => "IOS",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PackagingServiceClientType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PackagingServiceClientType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PackagingServiceClientType, ()> {
            Ok(match s {
                "ANDROID" => PackagingServiceClientType::Android,
                "IOS" => PackagingServiceClientType::Ios,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PackagingServiceClientType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PackagingServiceClientType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PackagingServiceClientType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ANDROID" => PackagingServiceClientType::Android,
                "IOS" => PackagingServiceClientType::Ios,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PackagingServiceClientType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PackagingServiceClientType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PaygateInfo {
        #[doc = "Time when client should show message that the call is ending soon."]
        #[serde(
            rename = "callEndingSoonWarningTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub call_ending_soon_warning_time: ::std::option::Option<String>,
        #[doc = "Time when the call will end if the user does not upgrade (after in-call upgrade support check has been implemented)."]
        #[serde(
            rename = "callEndingTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub call_ending_time: ::std::option::Option<String>,
        #[doc = "This boolean is used by clients to decide whether the user should be shown promos to upgrade."]
        #[serde(
            rename = "showUpgradePromos",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub show_upgrade_promos: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for PaygateInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PaygateInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PeopleSuggestion {
        #[doc = "Suggested person. All fields of the person object might not be populated."]
        #[serde(
            rename = "person",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub person: ::std::option::Option<crate::schemas::Person>,
    }
    impl ::google_field_selector::FieldSelector for PeopleSuggestion {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PeopleSuggestion {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Person {
        #[doc = "The person’s email addresses"]
        #[serde(
            rename = "emailAddresses",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email_addresses: ::std::option::Option<Vec<crate::schemas::EmailAddress>>,
        #[doc = "The resource name of the person to provide information about. See [`People.get`](https://developers.google.com/people/api/rest/v1/people/get) from the Google People API."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Obfuscated ID of a person."]
        #[serde(
            rename = "obfuscatedId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub obfuscated_id: ::std::option::Option<String>,
        #[doc = "The person’s name"]
        #[serde(
            rename = "personNames",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub person_names: ::std::option::Option<Vec<crate::schemas::Name>>,
        #[doc = "The person’s phone numbers"]
        #[serde(
            rename = "phoneNumbers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub phone_numbers: ::std::option::Option<Vec<crate::schemas::PhoneNumber>>,
        #[doc = "A person’s read-only photo. A picture shown next to the person’s name to help others recognize the person in search results."]
        #[serde(
            rename = "photos",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub photos: ::std::option::Option<Vec<crate::schemas::Photo>>,
    }
    impl ::google_field_selector::FieldSelector for Person {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Person {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PersonalLabelTag {
        #[doc = "A string ID representing the label. Possible ID values are documented at go/chat-labels-howto:ids. Examples: “^t” for “Starred”, “^nu” for “Nudged”."]
        #[serde(
            rename = "labelId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for PersonalLabelTag {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PersonalLabelTag {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PhoneAccess {
        #[doc = "The phone number to dial for this meeting space in INTERNATIONAL format. Full phone number with a leading ‘+’ character and whitespace separations."]
        #[serde(
            rename = "formattedPhoneNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub formatted_phone_number: ::std::option::Option<String>,
        #[doc = "The BCP 47/LDML language code for the language associated with this phone access. To be parsed by the i18n LanguageCode utility. Examples: “es-419” for Latin American Spanish, “fr-CA” for Canadian French."]
        #[serde(
            rename = "languageCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_code: ::std::option::Option<String>,
        #[doc = "The phone number to dial for this meeting space in E.164 format. Full phone number with a leading ‘+’ character."]
        #[serde(
            rename = "phoneNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub phone_number: ::std::option::Option<String>,
        #[doc = "The PIN that users must enter after dialing the given number. The PIN consists of only decimal digits and the length may vary."]
        #[serde(
            rename = "pin",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pin: ::std::option::Option<String>,
        #[doc = "The CLDR/ISO 3166 region code for the country associated with this phone access. To be parsed by the i18n RegionCode utility. Example: “SE” for Sweden."]
        #[serde(
            rename = "regionCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub region_code: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for PhoneAccess {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PhoneAccess {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PhoneNumber {
        #[doc = "The phone number of the person."]
        #[serde(
            rename = "phoneNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub phone_number: ::std::option::Option<String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::PhoneNumberType>,
    }
    impl ::google_field_selector::FieldSelector for PhoneNumber {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PhoneNumber {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PhoneNumberType {
        Mobile,
        Office,
        Other,
    }
    impl PhoneNumberType {
        pub fn as_str(self) -> &'static str {
            match self {
                PhoneNumberType::Mobile => "MOBILE",
                PhoneNumberType::Office => "OFFICE",
                PhoneNumberType::Other => "OTHER",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PhoneNumberType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PhoneNumberType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PhoneNumberType, ()> {
            Ok(match s {
                "MOBILE" => PhoneNumberType::Mobile,
                "OFFICE" => PhoneNumberType::Office,
                "OTHER" => PhoneNumberType::Other,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PhoneNumberType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PhoneNumberType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PhoneNumberType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MOBILE" => PhoneNumberType::Mobile,
                "OFFICE" => PhoneNumberType::Office,
                "OTHER" => PhoneNumberType::Other,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PhoneNumberType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PhoneNumberType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Photo {
        #[doc = "The URL of the photo."]
        #[serde(
            rename = "url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Photo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Photo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PinnedItemId {
        #[doc = "Identifier for a Drive file (e.g. Docs, Sheets, Slides)."]
        #[serde(
            rename = "driveId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for PinnedItemId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PinnedItemId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PollItemsRequest {
        #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
        #[serde(
            rename = "connectorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connector_name: ::std::option::Option<String>,
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[doc = "Maximum number of items to return. The maximum value is 100 and the default value is 20."]
        #[serde(
            rename = "limit",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub limit: ::std::option::Option<i32>,
        #[doc = "Queue name to fetch items from. If unspecified, PollItems will fetch from ‘default’ queue. The maximum length is 100 characters."]
        #[serde(
            rename = "queue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub queue: ::std::option::Option<String>,
        #[doc = "Limit the items polled to the ones with these statuses."]
        #[serde(
            rename = "statusCodes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status_codes:
            ::std::option::Option<Vec<crate::schemas::PollItemsRequestStatusCodesItems>>,
    }
    impl ::google_field_selector::FieldSelector for PollItemsRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PollItemsRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PollItemsRequestStatusCodesItems {
        #[doc = "API has accepted the up-to-date data of this item."]
        Accepted,
        #[doc = "Input-only value. Used with Items.list to list all items in the queue, regardless of status."]
        CodeUnspecified,
        #[doc = "Error encountered by Cloud Search while processing this item. Details of the error are in repositoryError."]
        Error,
        #[doc = "Item has been modified in the repository, and is out of date with the version previously accepted into Cloud Search."]
        Modified,
        #[doc = "Item is known to exist in the repository, but is not yet accepted by Cloud Search. An item can be in this state when Items.push has been called for an item of this name that did not exist previously."]
        NewItem,
    }
    impl PollItemsRequestStatusCodesItems {
        pub fn as_str(self) -> &'static str {
            match self {
                PollItemsRequestStatusCodesItems::Accepted => "ACCEPTED",
                PollItemsRequestStatusCodesItems::CodeUnspecified => "CODE_UNSPECIFIED",
                PollItemsRequestStatusCodesItems::Error => "ERROR",
                PollItemsRequestStatusCodesItems::Modified => "MODIFIED",
                PollItemsRequestStatusCodesItems::NewItem => "NEW_ITEM",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PollItemsRequestStatusCodesItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PollItemsRequestStatusCodesItems {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PollItemsRequestStatusCodesItems, ()> {
            Ok(match s {
                "ACCEPTED" => PollItemsRequestStatusCodesItems::Accepted,
                "CODE_UNSPECIFIED" => PollItemsRequestStatusCodesItems::CodeUnspecified,
                "ERROR" => PollItemsRequestStatusCodesItems::Error,
                "MODIFIED" => PollItemsRequestStatusCodesItems::Modified,
                "NEW_ITEM" => PollItemsRequestStatusCodesItems::NewItem,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PollItemsRequestStatusCodesItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PollItemsRequestStatusCodesItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PollItemsRequestStatusCodesItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACCEPTED" => PollItemsRequestStatusCodesItems::Accepted,
                "CODE_UNSPECIFIED" => PollItemsRequestStatusCodesItems::CodeUnspecified,
                "ERROR" => PollItemsRequestStatusCodesItems::Error,
                "MODIFIED" => PollItemsRequestStatusCodesItems::Modified,
                "NEW_ITEM" => PollItemsRequestStatusCodesItems::NewItem,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PollItemsRequestStatusCodesItems {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PollItemsRequestStatusCodesItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct PollItemsResponse {
        #[doc = "Set of items from the queue available for connector to process. These items have the following subset of fields populated: version metadata.hash structured_data.hash content.hash payload status queue"]
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<Vec<crate::schemas::Item>>,
    }
    impl ::google_field_selector::FieldSelector for PollItemsResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PollItemsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PossiblyTrimmedModel {
        #[serde(
            rename = "isTrimmed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_trimmed: ::std::option::Option<bool>,
        #[serde(
            rename = "model",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub model: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for PossiblyTrimmedModel {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PossiblyTrimmedModel {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PostiniUserProto {
        #[serde(
            rename = "postiniUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub postini_user_id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for PostiniUserProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PostiniUserProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PreState {
        #[serde(
            rename = "labelIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_ids: ::std::option::Option<Vec<String>>,
        #[serde(
            rename = "messageKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_key: ::std::option::Option<crate::schemas::MultiKey>,
        #[doc = "Note that there can be fewer sync ids than label ids."]
        #[serde(
            rename = "syncIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sync_ids: ::std::option::Option<Vec<u32>>,
        #[serde(
            rename = "threadKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_key: ::std::option::Option<crate::schemas::MultiKey>,
    }
    impl ::google_field_selector::FieldSelector for PreState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PreState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PrefDeleted {}
    impl ::google_field_selector::FieldSelector for PrefDeleted {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PrefDeleted {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PrefUpdate {
        #[doc = "Name of the affected preference."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "preState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pre_state: ::std::option::Option<crate::schemas::FuseboxPrefUpdatePreState>,
        #[serde(
            rename = "prefDeleted",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pref_deleted: ::std::option::Option<crate::schemas::PrefDeleted>,
        #[serde(
            rename = "prefWritten",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pref_written: ::std::option::Option<crate::schemas::PrefWritten>,
    }
    impl ::google_field_selector::FieldSelector for PrefUpdate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PrefUpdate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PrefWritten {
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector for PrefWritten {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PrefWritten {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Presenter {
        #[doc = "The device resource name of the device which requested the current presenter to be set. This field can not be modified by clients."]
        #[serde(
            rename = "byDeviceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub by_device_id: ::std::option::Option<String>,
        #[doc = "The device resource names of other devices which can control the current presentation."]
        #[serde(
            rename = "copresenterDeviceIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub copresenter_device_ids: ::std::option::Option<Vec<String>>,
        #[doc = "The device resource name of the currently presenting device."]
        #[serde(
            rename = "presenterDeviceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub presenter_device_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Presenter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Presenter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Principal {
        #[doc = "This principal is a group identified using an external identity. The name field must specify the group resource name with this format: identitysources/{source_id}/groups/{ID}"]
        #[serde(
            rename = "groupResourceName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_resource_name: ::std::option::Option<String>,
        #[doc = "This principal is a Google Workspace user, group or domain."]
        #[serde(
            rename = "gsuitePrincipal",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gsuite_principal: ::std::option::Option<crate::schemas::GsuitePrincipal>,
        #[doc = "This principal is a user identified using an external identity. The name field must specify the user resource name with this format: identitysources/{source_id}/users/{ID}"]
        #[serde(
            rename = "userResourceName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_resource_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Principal {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Principal {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PrincipalProto {
        #[doc = "scope = ALL_AUTHENTICATED_USERS"]
        #[serde(
            rename = "allAuthenticatedUsers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub all_authenticated_users:
            ::std::option::Option<crate::schemas::AllAuthenticatedUsersProto>,
        #[doc = "scope = CAP_TOKEN_HOLDER"]
        #[serde(
            rename = "capTokenHolder",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cap_token_holder: ::std::option::Option<crate::schemas::CapTokenHolderProto>,
        #[doc = "scope = CHAT"]
        #[serde(
            rename = "chat",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub chat: ::std::option::Option<crate::schemas::ChatProto>,
        #[doc = "scope = CIRCLE"]
        #[serde(
            rename = "circle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub circle: ::std::option::Option<crate::schemas::CircleProto>,
        #[doc = "scope = CLOUD_PRINCIPAL"]
        #[serde(
            rename = "cloudPrincipal",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cloud_principal: ::std::option::Option<crate::schemas::CloudPrincipalProto>,
        #[doc = "scope = CONTACT_GROUP"]
        #[serde(
            rename = "contactGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contact_group: ::std::option::Option<crate::schemas::ContactGroupProto>,
        #[doc = "scope = EMAIL_OWNER"]
        #[serde(
            rename = "emailOwner",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email_owner: ::std::option::Option<crate::schemas::EmailOwnerProto>,
        #[doc = "scope = EVENT"]
        #[serde(
            rename = "event",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event: ::std::option::Option<crate::schemas::EventProto>,
        #[doc = "scope = GAIA_GROUP"]
        #[serde(
            rename = "gaiaGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gaia_group: ::std::option::Option<crate::schemas::GaiaGroupProto>,
        #[doc = "scope = GAIA_USER"]
        #[serde(
            rename = "gaiaUser",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gaia_user: ::std::option::Option<crate::schemas::GaiaUserProto>,
        #[doc = "scope = HOST"]
        #[serde(
            rename = "host",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub host: ::std::option::Option<crate::schemas::HostProto>,
        #[doc = "scope = LDAP_GROUP"]
        #[serde(
            rename = "ldapGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ldap_group: ::std::option::Option<crate::schemas::LdapGroupProto>,
        #[doc = "scope = LDAP_USER"]
        #[serde(
            rename = "ldapUser",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ldap_user: ::std::option::Option<crate::schemas::LdapUserProto>,
        #[doc = "scope = MDB_GROUP"]
        #[serde(
            rename = "mdbGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mdb_group: ::std::option::Option<crate::schemas::MdbGroupProto>,
        #[doc = "scope = MDB_USER"]
        #[serde(
            rename = "mdbUser",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mdb_user: ::std::option::Option<crate::schemas::MdbUserProto>,
        #[doc = "scope = OAUTH_CONSUMER;"]
        #[serde(
            rename = "oauthConsumer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oauth_consumer: ::std::option::Option<crate::schemas::OauthConsumerProto>,
        #[doc = "scope = POSTINI_USER"]
        #[serde(
            rename = "postiniUser",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub postini_user: ::std::option::Option<crate::schemas::PostiniUserProto>,
        #[doc = "scope = RBAC_ROLE"]
        #[serde(
            rename = "rbacRole",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rbac_role: ::std::option::Option<crate::schemas::RbacRoleProto>,
        #[doc = "scope = RBAC_SUBJECT"]
        #[serde(
            rename = "rbacSubject",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rbac_subject: ::std::option::Option<crate::schemas::RbacSubjectProto>,
        #[doc = "scope = RESOURCE_ROLE"]
        #[serde(
            rename = "resourceRole",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resource_role: ::std::option::Option<crate::schemas::ResourceRoleProto>,
        #[doc = "This is only optional because required enums cannot be extended. Currently required."]
        #[serde(
            rename = "scope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scope: ::std::option::Option<crate::schemas::PrincipalProtoScope>,
        #[doc = "scope = SIGNING_KEY_POSSESSOR"]
        #[serde(
            rename = "signingKeyPossessor",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub signing_key_possessor: ::std::option::Option<crate::schemas::SigningKeyPossessorProto>,
        #[doc = "scope = SIMPLE_SECRET_HOLDER"]
        #[serde(
            rename = "simpleSecretHolder",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub simple_secret_holder: ::std::option::Option<crate::schemas::SimpleSecretHolderProto>,
        #[doc = "scope = SOCIAL_GRAPH_NODE"]
        #[serde(
            rename = "socialGraphNode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub social_graph_node: ::std::option::Option<crate::schemas::SocialGraphNodeProto>,
        #[doc = "scope = SQUARE"]
        #[serde(
            rename = "square",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub square: ::std::option::Option<crate::schemas::SquareProto>,
        #[doc = "scope = YOUTUBE_USER"]
        #[serde(
            rename = "youtubeUser",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub youtube_user: ::std::option::Option<crate::schemas::YoutubeUserProto>,
        #[doc = "scope = ZWIEBACK_SESSION"]
        #[serde(
            rename = "zwiebackSession",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub zwieback_session: ::std::option::Option<crate::schemas::ZwiebackSessionProto>,
    }
    impl ::google_field_selector::FieldSelector for PrincipalProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PrincipalProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PrincipalProtoScope {
        AllAuthenticatedUsers,
        CapTokenHolder,
        Chat,
        Circle,
        #[doc = "next tag: 29"]
        CloudPrincipal,
        ContactGroup,
        EmailOwner,
        Event,
        GaiaGroup,
        GaiaUser,
        Host,
        Invalid,
        LdapGroup,
        LdapUser,
        MdbGroup,
        MdbUser,
        OauthConsumer,
        PostiniUser,
        RbacRole,
        RbacSubject,
        ResourceRole,
        SigningKeyPossessor,
        SimpleSecretHolder,
        SocialGraphNode,
        Square,
        UnusedZwiebackSession,
        YoutubeUser,
        ZwiebackSession,
    }
    impl PrincipalProtoScope {
        pub fn as_str(self) -> &'static str {
            match self {
                PrincipalProtoScope::AllAuthenticatedUsers => "ALL_AUTHENTICATED_USERS",
                PrincipalProtoScope::CapTokenHolder => "CAP_TOKEN_HOLDER",
                PrincipalProtoScope::Chat => "CHAT",
                PrincipalProtoScope::Circle => "CIRCLE",
                PrincipalProtoScope::CloudPrincipal => "CLOUD_PRINCIPAL",
                PrincipalProtoScope::ContactGroup => "CONTACT_GROUP",
                PrincipalProtoScope::EmailOwner => "EMAIL_OWNER",
                PrincipalProtoScope::Event => "EVENT",
                PrincipalProtoScope::GaiaGroup => "GAIA_GROUP",
                PrincipalProtoScope::GaiaUser => "GAIA_USER",
                PrincipalProtoScope::Host => "HOST",
                PrincipalProtoScope::Invalid => "INVALID",
                PrincipalProtoScope::LdapGroup => "LDAP_GROUP",
                PrincipalProtoScope::LdapUser => "LDAP_USER",
                PrincipalProtoScope::MdbGroup => "MDB_GROUP",
                PrincipalProtoScope::MdbUser => "MDB_USER",
                PrincipalProtoScope::OauthConsumer => "OAUTH_CONSUMER",
                PrincipalProtoScope::PostiniUser => "POSTINI_USER",
                PrincipalProtoScope::RbacRole => "RBAC_ROLE",
                PrincipalProtoScope::RbacSubject => "RBAC_SUBJECT",
                PrincipalProtoScope::ResourceRole => "RESOURCE_ROLE",
                PrincipalProtoScope::SigningKeyPossessor => "SIGNING_KEY_POSSESSOR",
                PrincipalProtoScope::SimpleSecretHolder => "SIMPLE_SECRET_HOLDER",
                PrincipalProtoScope::SocialGraphNode => "SOCIAL_GRAPH_NODE",
                PrincipalProtoScope::Square => "SQUARE",
                PrincipalProtoScope::UnusedZwiebackSession => "UNUSED_ZWIEBACK_SESSION",
                PrincipalProtoScope::YoutubeUser => "YOUTUBE_USER",
                PrincipalProtoScope::ZwiebackSession => "ZWIEBACK_SESSION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PrincipalProtoScope {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PrincipalProtoScope {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PrincipalProtoScope, ()> {
            Ok(match s {
                "ALL_AUTHENTICATED_USERS" => PrincipalProtoScope::AllAuthenticatedUsers,
                "CAP_TOKEN_HOLDER" => PrincipalProtoScope::CapTokenHolder,
                "CHAT" => PrincipalProtoScope::Chat,
                "CIRCLE" => PrincipalProtoScope::Circle,
                "CLOUD_PRINCIPAL" => PrincipalProtoScope::CloudPrincipal,
                "CONTACT_GROUP" => PrincipalProtoScope::ContactGroup,
                "EMAIL_OWNER" => PrincipalProtoScope::EmailOwner,
                "EVENT" => PrincipalProtoScope::Event,
                "GAIA_GROUP" => PrincipalProtoScope::GaiaGroup,
                "GAIA_USER" => PrincipalProtoScope::GaiaUser,
                "HOST" => PrincipalProtoScope::Host,
                "INVALID" => PrincipalProtoScope::Invalid,
                "LDAP_GROUP" => PrincipalProtoScope::LdapGroup,
                "LDAP_USER" => PrincipalProtoScope::LdapUser,
                "MDB_GROUP" => PrincipalProtoScope::MdbGroup,
                "MDB_USER" => PrincipalProtoScope::MdbUser,
                "OAUTH_CONSUMER" => PrincipalProtoScope::OauthConsumer,
                "POSTINI_USER" => PrincipalProtoScope::PostiniUser,
                "RBAC_ROLE" => PrincipalProtoScope::RbacRole,
                "RBAC_SUBJECT" => PrincipalProtoScope::RbacSubject,
                "RESOURCE_ROLE" => PrincipalProtoScope::ResourceRole,
                "SIGNING_KEY_POSSESSOR" => PrincipalProtoScope::SigningKeyPossessor,
                "SIMPLE_SECRET_HOLDER" => PrincipalProtoScope::SimpleSecretHolder,
                "SOCIAL_GRAPH_NODE" => PrincipalProtoScope::SocialGraphNode,
                "SQUARE" => PrincipalProtoScope::Square,
                "UNUSED_ZWIEBACK_SESSION" => PrincipalProtoScope::UnusedZwiebackSession,
                "YOUTUBE_USER" => PrincipalProtoScope::YoutubeUser,
                "ZWIEBACK_SESSION" => PrincipalProtoScope::ZwiebackSession,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PrincipalProtoScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PrincipalProtoScope {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PrincipalProtoScope {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ALL_AUTHENTICATED_USERS" => PrincipalProtoScope::AllAuthenticatedUsers,
                "CAP_TOKEN_HOLDER" => PrincipalProtoScope::CapTokenHolder,
                "CHAT" => PrincipalProtoScope::Chat,
                "CIRCLE" => PrincipalProtoScope::Circle,
                "CLOUD_PRINCIPAL" => PrincipalProtoScope::CloudPrincipal,
                "CONTACT_GROUP" => PrincipalProtoScope::ContactGroup,
                "EMAIL_OWNER" => PrincipalProtoScope::EmailOwner,
                "EVENT" => PrincipalProtoScope::Event,
                "GAIA_GROUP" => PrincipalProtoScope::GaiaGroup,
                "GAIA_USER" => PrincipalProtoScope::GaiaUser,
                "HOST" => PrincipalProtoScope::Host,
                "INVALID" => PrincipalProtoScope::Invalid,
                "LDAP_GROUP" => PrincipalProtoScope::LdapGroup,
                "LDAP_USER" => PrincipalProtoScope::LdapUser,
                "MDB_GROUP" => PrincipalProtoScope::MdbGroup,
                "MDB_USER" => PrincipalProtoScope::MdbUser,
                "OAUTH_CONSUMER" => PrincipalProtoScope::OauthConsumer,
                "POSTINI_USER" => PrincipalProtoScope::PostiniUser,
                "RBAC_ROLE" => PrincipalProtoScope::RbacRole,
                "RBAC_SUBJECT" => PrincipalProtoScope::RbacSubject,
                "RESOURCE_ROLE" => PrincipalProtoScope::ResourceRole,
                "SIGNING_KEY_POSSESSOR" => PrincipalProtoScope::SigningKeyPossessor,
                "SIMPLE_SECRET_HOLDER" => PrincipalProtoScope::SimpleSecretHolder,
                "SOCIAL_GRAPH_NODE" => PrincipalProtoScope::SocialGraphNode,
                "SQUARE" => PrincipalProtoScope::Square,
                "UNUSED_ZWIEBACK_SESSION" => PrincipalProtoScope::UnusedZwiebackSession,
                "YOUTUBE_USER" => PrincipalProtoScope::YoutubeUser,
                "ZWIEBACK_SESSION" => PrincipalProtoScope::ZwiebackSession,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PrincipalProtoScope {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PrincipalProtoScope {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct PrivateMessageInfo {
        #[doc = "Annotations private to {@code userId}."]
        #[serde(
            rename = "annotations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotations: ::std::option::Option<Vec<crate::schemas::Annotation>>,
        #[doc = "Attachments private to {@code userId}."]
        #[serde(
            rename = "attachments",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachments: ::std::option::Option<Vec<crate::schemas::Attachment>>,
        #[serde(
            rename = "contextualAddOnMarkup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contextual_add_on_markup:
            ::std::option::Option<Vec<crate::schemas::GoogleChatV1ContextualAddOnMarkup>>,
        #[serde(
            rename = "gsuiteIntegrationMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gsuite_integration_metadata:
            ::std::option::Option<Vec<crate::schemas::GsuiteIntegrationMetadata>>,
        #[doc = "Text private to {@code user_id}. Initial restriction: Only one of public text or private text is rendered on the client. So if public text is set, private text is ignored."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "Required. The elements in this struct are visible to this user."]
        #[serde(
            rename = "userId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_id: ::std::option::Option<crate::schemas::UserId>,
    }
    impl ::google_field_selector::FieldSelector for PrivateMessageInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PrivateMessageInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ProcessingError {
        #[doc = "Error code indicating the nature of the error."]
        #[serde(
            rename = "code",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub code: ::std::option::Option<crate::schemas::ProcessingErrorCode>,
        #[doc = "The description of the error."]
        #[serde(
            rename = "errorMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_message: ::std::option::Option<String>,
        #[doc = "In case the item fields are invalid, this field contains the details about the validation errors."]
        #[serde(
            rename = "fieldViolations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub field_violations: ::std::option::Option<Vec<crate::schemas::FieldViolation>>,
    }
    impl ::google_field_selector::FieldSelector for ProcessingError {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ProcessingError {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ProcessingErrorCode {
        #[doc = "ACL inheritance graph formed a cycle."]
        AclCycle,
        #[doc = "Items with incomplete ACL information due to inheriting other items with broken ACL or having groups with unmapped descendants."]
        IndirectBrokenAcl,
        #[doc = "Item’s ACL, metadata, or content is malformed or in invalid state. FieldViolations contains more details on where the problem is."]
        MalformedRequest,
        #[doc = "Input only value. Use this value in Items."]
        ProcessingErrorCodeUnspecified,
        #[doc = "Countent format is unsupported."]
        UnsupportedContentFormat,
    }
    impl ProcessingErrorCode {
        pub fn as_str(self) -> &'static str {
            match self {
                ProcessingErrorCode::AclCycle => "ACL_CYCLE",
                ProcessingErrorCode::IndirectBrokenAcl => "INDIRECT_BROKEN_ACL",
                ProcessingErrorCode::MalformedRequest => "MALFORMED_REQUEST",
                ProcessingErrorCode::ProcessingErrorCodeUnspecified => {
                    "PROCESSING_ERROR_CODE_UNSPECIFIED"
                }
                ProcessingErrorCode::UnsupportedContentFormat => "UNSUPPORTED_CONTENT_FORMAT",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ProcessingErrorCode {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ProcessingErrorCode {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ProcessingErrorCode, ()> {
            Ok(match s {
                "ACL_CYCLE" => ProcessingErrorCode::AclCycle,
                "INDIRECT_BROKEN_ACL" => ProcessingErrorCode::IndirectBrokenAcl,
                "MALFORMED_REQUEST" => ProcessingErrorCode::MalformedRequest,
                "PROCESSING_ERROR_CODE_UNSPECIFIED" => {
                    ProcessingErrorCode::ProcessingErrorCodeUnspecified
                }
                "UNSUPPORTED_CONTENT_FORMAT" => ProcessingErrorCode::UnsupportedContentFormat,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ProcessingErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ProcessingErrorCode {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ProcessingErrorCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACL_CYCLE" => ProcessingErrorCode::AclCycle,
                "INDIRECT_BROKEN_ACL" => ProcessingErrorCode::IndirectBrokenAcl,
                "MALFORMED_REQUEST" => ProcessingErrorCode::MalformedRequest,
                "PROCESSING_ERROR_CODE_UNSPECIFIED" => {
                    ProcessingErrorCode::ProcessingErrorCodeUnspecified
                }
                "UNSUPPORTED_CONTENT_FORMAT" => ProcessingErrorCode::UnsupportedContentFormat,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ProcessingErrorCode {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ProcessingErrorCode {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PropertyDefinition {
        #[serde(
            rename = "booleanPropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_property_options: ::std::option::Option<crate::schemas::BooleanPropertyOptions>,
        #[serde(
            rename = "datePropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date_property_options: ::std::option::Option<crate::schemas::DatePropertyOptions>,
        #[doc = "The options that determine how the property is displayed in the Cloud Search results page if it’s specified to be displayed in the object’s display options."]
        #[serde(
            rename = "displayOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_options: ::std::option::Option<crate::schemas::PropertyDisplayOptions>,
        #[serde(
            rename = "doublePropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_property_options: ::std::option::Option<crate::schemas::DoublePropertyOptions>,
        #[serde(
            rename = "enumPropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enum_property_options: ::std::option::Option<crate::schemas::EnumPropertyOptions>,
        #[serde(
            rename = "htmlPropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub html_property_options: ::std::option::Option<crate::schemas::HtmlPropertyOptions>,
        #[serde(
            rename = "integerPropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integer_property_options: ::std::option::Option<crate::schemas::IntegerPropertyOptions>,
        #[doc = "Indicates that the property can be used for generating facets. Cannot be true for properties whose type is object. IsReturnable must be true to set this option. Only supported for boolean, enum, integer, and text properties."]
        #[serde(
            rename = "isFacetable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_facetable: ::std::option::Option<bool>,
        #[doc = "Indicates that multiple values are allowed for the property. For example, a document only has one description but can have multiple comments. Cannot be true for properties whose type is a boolean. If set to false, properties that contain more than one value cause the indexing request for that item to be rejected."]
        #[serde(
            rename = "isRepeatable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_repeatable: ::std::option::Option<bool>,
        #[doc = "Indicates that the property identifies data that should be returned in search results via the Query API. If set to *true*, indicates that Query API users can use matching property fields in results. However, storing fields requires more space allocation and uses more bandwidth for search queries, which impacts performance over large datasets. Set to *true* here only if the field is needed for search results. Cannot be true for properties whose type is an object."]
        #[serde(
            rename = "isReturnable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_returnable: ::std::option::Option<bool>,
        #[doc = "Indicates that the property can be used for sorting. Cannot be true for properties that are repeatable. Cannot be true for properties whose type is object. IsReturnable must be true to set this option. Only supported for boolean, date, double, integer, and timestamp properties."]
        #[serde(
            rename = "isSortable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_sortable: ::std::option::Option<bool>,
        #[doc = "Indicates that the property can be used for generating query suggestions."]
        #[serde(
            rename = "isSuggestable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_suggestable: ::std::option::Option<bool>,
        #[doc = "Indicates that users can perform wildcard search for this property. Only supported for Text properties. IsReturnable must be true to set this option. In a given datasource maximum of 5 properties can be marked as is_wildcard_searchable. For more details, see [Define object properties](https://developers.google.com/cloud-search/docs/guides/schema-guide#properties)"]
        #[serde(
            rename = "isWildcardSearchable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_wildcard_searchable: ::std::option::Option<bool>,
        #[doc = "The name of the property. Item indexing requests sent to the Indexing API should set the property name equal to this value. For example, if name is *subject_line*, then indexing requests for document items with subject fields should set the name for that field equal to *subject_line*. Use the name as the identifier for the object property. Once registered as a property for an object, you cannot re-use this name for another property within that object. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The maximum length is 256 characters."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "objectPropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_property_options: ::std::option::Option<crate::schemas::ObjectPropertyOptions>,
        #[serde(
            rename = "textPropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_property_options: ::std::option::Option<crate::schemas::TextPropertyOptions>,
        #[serde(
            rename = "timestampPropertyOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub timestamp_property_options:
            ::std::option::Option<crate::schemas::TimestampPropertyOptions>,
    }
    impl ::google_field_selector::FieldSelector for PropertyDefinition {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PropertyDefinition {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PropertyDisplayOptions {
        #[doc = "The user friendly label for the property that is used if the property is specified to be displayed in ObjectDisplayOptions. If provided, the display label is shown in front of the property values when the property is part of the object display options. For example, if the property value is ‘1’, the value by itself may not be useful context for the user. If the display name given was ‘priority’, then the user sees ‘priority : 1’ in the search results which provides clear context to search users. This is OPTIONAL; if not given, only the property values are displayed. The maximum length is 64 characters."]
        #[serde(
            rename = "displayLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_label: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for PropertyDisplayOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PropertyDisplayOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Provenance {
        #[doc = "Annotation blob from Annotation Service."]
        #[serde(
            rename = "annotationBlob",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotation_blob: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "Canonical url of the retrieved_url, if one was resolved during retrieval, for example, if a rel=“canonical” link tag was provided in the retrieved web page."]
        #[serde(
            rename = "canonicalUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub canonical_url: ::std::option::Option<String>,
        #[doc = "The url originally passed in the PRS request, which should be used to re-discover the content. Note that this URL may be a forwarding service or link shortener (bit.ly), so it should not be assumed to be canonical, but should be used for navigation back to the original source of the itemscope."]
        #[serde(
            rename = "inputUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_url: ::std::option::Option<String>,
        #[doc = "Contains exact types as parsed, whether or not we recognized that type at parse time. If an itemscope is created by merging SchemaOrg markup and open graph markup then the first itemtype would be schemaorg type, the second would be open graph and so on. example: http://schema.org/VideoObject, og:video.movie Plain text; usually a URL"]
        #[serde(
            rename = "itemtype",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub itemtype: ::std::option::Option<Vec<String>>,
        #[doc = "The server retrieved timestamp (in msec)."]
        #[serde(
            rename = "retrievedTimestampMsec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub retrieved_timestamp_msec: ::std::option::Option<u64>,
        #[doc = "The final URL that was the actual source of the itemscope, after any redirects."]
        #[serde(
            rename = "retrievedUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retrieved_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Provenance {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Provenance {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PushItem {
        #[doc = "Content hash of the item according to the repository. If specified, this is used to determine how to modify this item’s status. Setting this field and the type field results in argument error. The maximum length is 2048 characters."]
        #[serde(
            rename = "contentHash",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_hash: ::std::option::Option<String>,
        #[doc = "The metadata hash of the item according to the repository. If specified, this is used to determine how to modify this item’s status. Setting this field and the type field results in argument error. The maximum length is 2048 characters."]
        #[serde(
            rename = "metadataHash",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metadata_hash: ::std::option::Option<String>,
        #[doc = "Provides additional document state information for the connector, such as an alternate repository ID and other metadata. The maximum length is 8192 bytes."]
        #[serde(
            rename = "payload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub payload: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "Queue to which this item belongs. The `default` queue is chosen if this field is not specified. The maximum length is 512 characters."]
        #[serde(
            rename = "queue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub queue: ::std::option::Option<String>,
        #[doc = "The type of the push operation that defines the push behavior."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::PushItemType>,
        #[doc = "Populate this field to store Connector or repository error details. This information is displayed in the Admin Console. This field may only be populated when the Type is REPOSITORY_ERROR."]
        #[serde(
            rename = "repositoryError",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub repository_error: ::std::option::Option<crate::schemas::RepositoryError>,
        #[doc = "Structured data hash of the item according to the repository. If specified, this is used to determine how to modify this item’s status. Setting this field and the type field results in argument error. The maximum length is 2048 characters."]
        #[serde(
            rename = "structuredDataHash",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub structured_data_hash: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for PushItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PushItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PushItemType {
        #[doc = "Indicates that the repository document has been modified or updated since the previous update call. This changes status to MODIFIED state for an existing item. If this is called on a non existing item, the status is changed to NEW_ITEM."]
        Modified,
        #[doc = "Item in the repository has not been modified since the last update call. This push operation will set status to ACCEPTED state."]
        NotModified,
        #[doc = "Connector is facing a repository error regarding this item. Change status to REPOSITORY_ERROR state. Item is unreserved and rescheduled at a future time determined by exponential backoff."]
        RepositoryError,
        #[doc = "Call push with REQUEUE only for items that have been reserved. This action unreserves the item and resets its available time to the wall clock time."]
        Requeue,
        #[doc = "Default UNSPECIFIED. Specifies that the push operation should not modify ItemStatus"]
        Unspecified,
    }
    impl PushItemType {
        pub fn as_str(self) -> &'static str {
            match self {
                PushItemType::Modified => "MODIFIED",
                PushItemType::NotModified => "NOT_MODIFIED",
                PushItemType::RepositoryError => "REPOSITORY_ERROR",
                PushItemType::Requeue => "REQUEUE",
                PushItemType::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PushItemType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PushItemType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PushItemType, ()> {
            Ok(match s {
                "MODIFIED" => PushItemType::Modified,
                "NOT_MODIFIED" => PushItemType::NotModified,
                "REPOSITORY_ERROR" => PushItemType::RepositoryError,
                "REQUEUE" => PushItemType::Requeue,
                "UNSPECIFIED" => PushItemType::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PushItemType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PushItemType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PushItemType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MODIFIED" => PushItemType::Modified,
                "NOT_MODIFIED" => PushItemType::NotModified,
                "REPOSITORY_ERROR" => PushItemType::RepositoryError,
                "REQUEUE" => PushItemType::Requeue,
                "UNSPECIFIED" => PushItemType::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PushItemType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PushItemType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PushItemRequest {
        #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
        #[serde(
            rename = "connectorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connector_name: ::std::option::Option<String>,
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[doc = "Item to push onto the queue."]
        #[serde(
            rename = "item",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item: ::std::option::Option<crate::schemas::PushItem>,
    }
    impl ::google_field_selector::FieldSelector for PushItemRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PushItemRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QueryCountByStatus {
        #[serde(
            rename = "count",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub count: ::std::option::Option<i64>,
        #[doc = "This represents the http status code."]
        #[serde(
            rename = "statusCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status_code: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for QueryCountByStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryCountByStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QueryInterpretation {
        #[serde(
            rename = "interpretationType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub interpretation_type:
            ::std::option::Option<crate::schemas::QueryInterpretationInterpretationType>,
        #[doc = "The interpretation of the query used in search. For example, queries with natural language intent like “email from john” will be interpreted as “from:john source:mail”. This field will not be filled when the reason is NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY."]
        #[serde(
            rename = "interpretedQuery",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub interpreted_query: ::std::option::Option<String>,
        #[doc = "The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE."]
        #[serde(
            rename = "reason",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reason: ::std::option::Option<crate::schemas::QueryInterpretationReason>,
    }
    impl ::google_field_selector::FieldSelector for QueryInterpretation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryInterpretation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum QueryInterpretationInterpretationType {
        #[doc = "The results from original query are blended with other results. The reason for blending these other results with the results from original query is populated in the ‘Reason’ field below."]
        Blend,
        #[doc = "Neither the natural language interpretation, nor a broader version of the query is used to fetch the search results."]
        None,
        #[doc = "The results from original query are replaced. The reason for replacing the results from original query is populated in the ‘Reason’ field below."]
        Replace,
    }
    impl QueryInterpretationInterpretationType {
        pub fn as_str(self) -> &'static str {
            match self {
                QueryInterpretationInterpretationType::Blend => "BLEND",
                QueryInterpretationInterpretationType::None => "NONE",
                QueryInterpretationInterpretationType::Replace => "REPLACE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for QueryInterpretationInterpretationType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for QueryInterpretationInterpretationType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<QueryInterpretationInterpretationType, ()> {
            Ok(match s {
                "BLEND" => QueryInterpretationInterpretationType::Blend,
                "NONE" => QueryInterpretationInterpretationType::None,
                "REPLACE" => QueryInterpretationInterpretationType::Replace,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for QueryInterpretationInterpretationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for QueryInterpretationInterpretationType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for QueryInterpretationInterpretationType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BLEND" => QueryInterpretationInterpretationType::Blend,
                "NONE" => QueryInterpretationInterpretationType::None,
                "REPLACE" => QueryInterpretationInterpretationType::Replace,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for QueryInterpretationInterpretationType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryInterpretationInterpretationType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum QueryInterpretationReason {
        #[doc = "Query and document terms similarity is used to selectively broaden the query to retrieve additional search results since enough results were not found for the user query. Interpreted query will be empty for this case."]
        NotEnoughResultsFoundForUserQuery,
        #[doc = "Natural language interpretation of the query is used to fetch the search results."]
        QueryHasNaturalLanguageIntent,
        Unspecified,
    }
    impl QueryInterpretationReason {
        pub fn as_str(self) -> &'static str {
            match self {
                QueryInterpretationReason::NotEnoughResultsFoundForUserQuery => {
                    "NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY"
                }
                QueryInterpretationReason::QueryHasNaturalLanguageIntent => {
                    "QUERY_HAS_NATURAL_LANGUAGE_INTENT"
                }
                QueryInterpretationReason::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for QueryInterpretationReason {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for QueryInterpretationReason {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<QueryInterpretationReason, ()> {
            Ok(match s {
                "NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY" => {
                    QueryInterpretationReason::NotEnoughResultsFoundForUserQuery
                }
                "QUERY_HAS_NATURAL_LANGUAGE_INTENT" => {
                    QueryInterpretationReason::QueryHasNaturalLanguageIntent
                }
                "UNSPECIFIED" => QueryInterpretationReason::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for QueryInterpretationReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for QueryInterpretationReason {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for QueryInterpretationReason {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY" => {
                    QueryInterpretationReason::NotEnoughResultsFoundForUserQuery
                }
                "QUERY_HAS_NATURAL_LANGUAGE_INTENT" => {
                    QueryInterpretationReason::QueryHasNaturalLanguageIntent
                }
                "UNSPECIFIED" => QueryInterpretationReason::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for QueryInterpretationReason {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryInterpretationReason {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QueryInterpretationConfig {
        #[doc = "Set this flag to disable supplemental results retrieval, setting a flag here will not retrieve supplemental results for queries associated with a given search application. If this flag is set to True, it will take precedence over the option set at Query level. For the default value of False, query level flag will set the correct interpretation for supplemental results."]
        #[serde(
            rename = "forceDisableSupplementalResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub force_disable_supplemental_results: ::std::option::Option<bool>,
        #[doc = "Enable this flag to turn off all internal optimizations like natural language (NL) interpretation of queries, supplemental results retrieval, and usage of synonyms including custom ones. If this flag is set to True, it will take precedence over the option set at Query level. For the default value of False, query level flag will set the correct interpretation for verbatim mode."]
        #[serde(
            rename = "forceVerbatimMode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub force_verbatim_mode: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for QueryInterpretationConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryInterpretationConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QueryInterpretationOptions {
        #[doc = "Flag to disable natural language (NL) interpretation of queries. Default is false, Set to true to disable natural language interpretation. NL interpretation only applies to predefined datasources."]
        #[serde(
            rename = "disableNlInterpretation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disable_nl_interpretation: ::std::option::Option<bool>,
        #[doc = "Use this flag to disable supplemental results for a query. Supplemental results setting chosen at SearchApplication level will take precedence if set to True."]
        #[serde(
            rename = "disableSupplementalResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disable_supplemental_results: ::std::option::Option<bool>,
        #[doc = "Enable this flag to turn off all internal optimizations like natural language (NL) interpretation of queries, supplemental result retrieval, and usage of synonyms including custom ones. Nl interpretation will be disabled if either one of the two flags is true."]
        #[serde(
            rename = "enableVerbatimMode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enable_verbatim_mode: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for QueryInterpretationOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryInterpretationOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QueryItem {
        #[doc = "True if the text was generated by means other than a previous user search."]
        #[serde(
            rename = "isSynthetic",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_synthetic: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for QueryItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QueryOperator {
        #[doc = "Display name of the operator"]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Potential list of values for the opeatror field. This field is only filled when we can safely enumerate all the possible values of this operator."]
        #[serde(
            rename = "enumValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enum_values: ::std::option::Option<Vec<String>>,
        #[doc = "Indicates the operator name that can be used to isolate the property using the greater-than operator."]
        #[serde(
            rename = "greaterThanOperatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub greater_than_operator_name: ::std::option::Option<String>,
        #[doc = "Can this operator be used to get facets."]
        #[serde(
            rename = "isFacetable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_facetable: ::std::option::Option<bool>,
        #[doc = "Indicates if multiple values can be set for this property."]
        #[serde(
            rename = "isRepeatable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_repeatable: ::std::option::Option<bool>,
        #[doc = "Will the property associated with this facet be returned as part of search results."]
        #[serde(
            rename = "isReturnable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_returnable: ::std::option::Option<bool>,
        #[doc = "Can this operator be used to sort results."]
        #[serde(
            rename = "isSortable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_sortable: ::std::option::Option<bool>,
        #[doc = "Can get suggestions for this field."]
        #[serde(
            rename = "isSuggestable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_suggestable: ::std::option::Option<bool>,
        #[doc = "Indicates the operator name that can be used to isolate the property using the less-than operator."]
        #[serde(
            rename = "lessThanOperatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub less_than_operator_name: ::std::option::Option<String>,
        #[doc = "The name of the object corresponding to the operator. This field is only filled for schema-specific operators, and is unset for common operators."]
        #[serde(
            rename = "objectType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_type: ::std::option::Option<String>,
        #[doc = "The name of the operator."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
        #[doc = "The type of the operator."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::QueryOperatorType>,
    }
    impl ::google_field_selector::FieldSelector for QueryOperator {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryOperator {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum QueryOperatorType {
        Boolean,
        Date,
        Double,
        Enum,
        Html,
        Integer,
        Text,
        Timestamp,
        #[doc = "Invalid value."]
        Unknown,
    }
    impl QueryOperatorType {
        pub fn as_str(self) -> &'static str {
            match self {
                QueryOperatorType::Boolean => "BOOLEAN",
                QueryOperatorType::Date => "DATE",
                QueryOperatorType::Double => "DOUBLE",
                QueryOperatorType::Enum => "ENUM",
                QueryOperatorType::Html => "HTML",
                QueryOperatorType::Integer => "INTEGER",
                QueryOperatorType::Text => "TEXT",
                QueryOperatorType::Timestamp => "TIMESTAMP",
                QueryOperatorType::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for QueryOperatorType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for QueryOperatorType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<QueryOperatorType, ()> {
            Ok(match s {
                "BOOLEAN" => QueryOperatorType::Boolean,
                "DATE" => QueryOperatorType::Date,
                "DOUBLE" => QueryOperatorType::Double,
                "ENUM" => QueryOperatorType::Enum,
                "HTML" => QueryOperatorType::Html,
                "INTEGER" => QueryOperatorType::Integer,
                "TEXT" => QueryOperatorType::Text,
                "TIMESTAMP" => QueryOperatorType::Timestamp,
                "UNKNOWN" => QueryOperatorType::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for QueryOperatorType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for QueryOperatorType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for QueryOperatorType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOOLEAN" => QueryOperatorType::Boolean,
                "DATE" => QueryOperatorType::Date,
                "DOUBLE" => QueryOperatorType::Double,
                "ENUM" => QueryOperatorType::Enum,
                "HTML" => QueryOperatorType::Html,
                "INTEGER" => QueryOperatorType::Integer,
                "TEXT" => QueryOperatorType::Text,
                "TIMESTAMP" => QueryOperatorType::Timestamp,
                "UNKNOWN" => QueryOperatorType::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for QueryOperatorType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QueryOperatorType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QuerySource {
        #[doc = "Display name of the data source."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "List of all operators applicable for this source."]
        #[serde(
            rename = "operators",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operators: ::std::option::Option<Vec<crate::schemas::QueryOperator>>,
        #[doc = "A short name or alias for the source. This value can be used with the ‘source’ operator."]
        #[serde(
            rename = "shortName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub short_name: ::std::option::Option<String>,
        #[doc = "The name of the source"]
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source: ::std::option::Option<crate::schemas::Source>,
    }
    impl ::google_field_selector::FieldSelector for QuerySource {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QuerySource {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QuerySuggestion {}
    impl ::google_field_selector::FieldSelector for QuerySuggestion {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QuerySuggestion {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct QuotedMessageMetadata {
        #[doc = "Output only. Snapshot of the annotations of the quoted message."]
        #[serde(
            rename = "annotations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub annotations: ::std::option::Option<Vec<crate::schemas::Annotation>>,
        #[doc = "Output only. Custom display profile info for apps. Will be empty for real users."]
        #[serde(
            rename = "appProfile",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub app_profile: ::std::option::Option<crate::schemas::AppsDynamiteSharedAppProfile>,
        #[doc = "Output only. The bot attachment state of the quoted message. Used by clients to display a bot attachment indicator in the UI."]
        #[serde(
            rename = "botAttachmentState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bot_attachment_state:
            ::std::option::Option<crate::schemas::QuotedMessageMetadataBotAttachmentState>,
        #[doc = "Output only. Time when the quoted message was posted in microseconds."]
        #[serde(
            rename = "createTimeMicros",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub create_time_micros: ::std::option::Option<i64>,
        #[doc = "Output only. ID of the User who posted the quoted message. This includes information to identify if the quoted message was posted by an App on behalf of a user."]
        #[serde(
            rename = "creatorId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub creator_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Output only. Time when the quoted message was last edited by a user at the time when quoting action happens. Time is in microseconds."]
        #[serde(
            rename = "lastEditTimeMicros",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_edit_time_micros: ::std::option::Option<i64>,
        #[doc = "The `last_update_time` of the original message when the client initiated the quote creation. This is derived from the request payload passed from clients. Used to fetch the quoted message contents at a specific time on the read path. This field is populated from storage directly."]
        #[serde(
            rename = "lastUpdateTimeWhenQuotedMicros",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_update_time_when_quoted_micros: ::std::option::Option<i64>,
        #[doc = "MessageId of the original message that is being quoted. This is derived from the request payload passed from clients. This field is populated from storage directly."]
        #[serde(
            rename = "messageId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_id: ::std::option::Option<crate::schemas::MessageId>,
        #[doc = "Output only. The state of the quoted message. Used by clients to display tombstones for quotes that reference a deleted message."]
        #[serde(
            rename = "messageState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_state: ::std::option::Option<crate::schemas::QuotedMessageMetadataMessageState>,
        #[doc = "Output only. The retention (OTR) settings of the quoted message."]
        #[serde(
            rename = "retentionSettings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retention_settings:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedRetentionSettings>,
        #[doc = "Output only. Snapshot of the text body of the quoted message."]
        #[serde(
            rename = "textBody",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_body: ::std::option::Option<String>,
        #[doc = "Output only. ID of the User who last updated (created/edited/deleted) the quoted message at the time when quoting action happens. This includes information to identify if the quoted message was posted by an App on behalf of a user."]
        #[serde(
            rename = "updaterId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub updater_id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Output only. Upload metadata of the quoted message."]
        #[serde(
            rename = "uploadMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub upload_metadata: ::std::option::Option<Vec<crate::schemas::UploadMetadata>>,
    }
    impl ::google_field_selector::FieldSelector for QuotedMessageMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QuotedMessageMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum QuotedMessageMetadataBotAttachmentState {
        BotAttachmentStateHasBotAttachment,
        BotAttachmentStateNoBotAttachment,
        BotAttachmentStateUnspecified,
    }
    impl QuotedMessageMetadataBotAttachmentState {
        pub fn as_str(self) -> &'static str {
            match self {
                QuotedMessageMetadataBotAttachmentState::BotAttachmentStateHasBotAttachment => {
                    "BOT_ATTACHMENT_STATE_HAS_BOT_ATTACHMENT"
                }
                QuotedMessageMetadataBotAttachmentState::BotAttachmentStateNoBotAttachment => {
                    "BOT_ATTACHMENT_STATE_NO_BOT_ATTACHMENT"
                }
                QuotedMessageMetadataBotAttachmentState::BotAttachmentStateUnspecified => {
                    "BOT_ATTACHMENT_STATE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for QuotedMessageMetadataBotAttachmentState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for QuotedMessageMetadataBotAttachmentState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<QuotedMessageMetadataBotAttachmentState, ()> {
            Ok(match s {
                "BOT_ATTACHMENT_STATE_HAS_BOT_ATTACHMENT" => {
                    QuotedMessageMetadataBotAttachmentState::BotAttachmentStateHasBotAttachment
                }
                "BOT_ATTACHMENT_STATE_NO_BOT_ATTACHMENT" => {
                    QuotedMessageMetadataBotAttachmentState::BotAttachmentStateNoBotAttachment
                }
                "BOT_ATTACHMENT_STATE_UNSPECIFIED" => {
                    QuotedMessageMetadataBotAttachmentState::BotAttachmentStateUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for QuotedMessageMetadataBotAttachmentState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for QuotedMessageMetadataBotAttachmentState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for QuotedMessageMetadataBotAttachmentState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOT_ATTACHMENT_STATE_HAS_BOT_ATTACHMENT" => {
                    QuotedMessageMetadataBotAttachmentState::BotAttachmentStateHasBotAttachment
                }
                "BOT_ATTACHMENT_STATE_NO_BOT_ATTACHMENT" => {
                    QuotedMessageMetadataBotAttachmentState::BotAttachmentStateNoBotAttachment
                }
                "BOT_ATTACHMENT_STATE_UNSPECIFIED" => {
                    QuotedMessageMetadataBotAttachmentState::BotAttachmentStateUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for QuotedMessageMetadataBotAttachmentState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QuotedMessageMetadataBotAttachmentState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum QuotedMessageMetadataMessageState {
        #[doc = "The original message is present in storage and not deleted; the message contents can be hydrated."]
        MessageStateActive,
        #[doc = "The original message has been deleted; the message contents cannot be hydrated."]
        MessageStateDeleted,
        #[doc = "The OTR original message was edited and therefore no longer retrievable from storage; the message contents cannot be hydrated. See go/message-quoting-otr-edits for more context."]
        MessageStateOtrEdited,
        MessageStateUnspecified,
    }
    impl QuotedMessageMetadataMessageState {
        pub fn as_str(self) -> &'static str {
            match self {
                QuotedMessageMetadataMessageState::MessageStateActive => "MESSAGE_STATE_ACTIVE",
                QuotedMessageMetadataMessageState::MessageStateDeleted => "MESSAGE_STATE_DELETED",
                QuotedMessageMetadataMessageState::MessageStateOtrEdited => {
                    "MESSAGE_STATE_OTR_EDITED"
                }
                QuotedMessageMetadataMessageState::MessageStateUnspecified => {
                    "MESSAGE_STATE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for QuotedMessageMetadataMessageState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for QuotedMessageMetadataMessageState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<QuotedMessageMetadataMessageState, ()> {
            Ok(match s {
                "MESSAGE_STATE_ACTIVE" => QuotedMessageMetadataMessageState::MessageStateActive,
                "MESSAGE_STATE_DELETED" => QuotedMessageMetadataMessageState::MessageStateDeleted,
                "MESSAGE_STATE_OTR_EDITED" => {
                    QuotedMessageMetadataMessageState::MessageStateOtrEdited
                }
                "MESSAGE_STATE_UNSPECIFIED" => {
                    QuotedMessageMetadataMessageState::MessageStateUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for QuotedMessageMetadataMessageState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for QuotedMessageMetadataMessageState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for QuotedMessageMetadataMessageState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MESSAGE_STATE_ACTIVE" => QuotedMessageMetadataMessageState::MessageStateActive,
                "MESSAGE_STATE_DELETED" => QuotedMessageMetadataMessageState::MessageStateDeleted,
                "MESSAGE_STATE_OTR_EDITED" => {
                    QuotedMessageMetadataMessageState::MessageStateOtrEdited
                }
                "MESSAGE_STATE_UNSPECIFIED" => {
                    QuotedMessageMetadataMessageState::MessageStateUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for QuotedMessageMetadataMessageState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for QuotedMessageMetadataMessageState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Rank {
        #[doc = "The primary rank is the most significant rank member. This rank element should always be present. Items with higher primary rank are always considered of higher rank than those of lower primary rank."]
        #[serde(
            rename = "primary",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub primary: ::std::option::Option<i64>,
        #[doc = "The secondary rank may be used to rank items of identical primary rank. This rank element should always be present."]
        #[serde(
            rename = "secondary",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub secondary: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for Rank {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Rank {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RbacRoleProto {
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "objectId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_id: ::std::option::Option<String>,
        #[doc = "DEPRECATED as of 01.11.2019"]
        #[serde(
            rename = "rbacNamespace",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rbac_namespace: ::std::option::Option<String>,
        #[doc = "Format: “role/z?” - “role” is the Sphinx globally unique name of the Sphinx role that provisions the RBAC role. - “/z?” suffix indicates which Zanzibar environment stores the role membership data (“/zd”: dev, “/zs”: staging, “/zp”: prod, “/zt”: local test instance). Example: “mysystem_myrole/zp”"]
        #[serde(
            rename = "rbacRoleName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rbac_role_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for RbacRoleProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RbacRoleProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RbacSubjectProto {
        #[doc = "Format “username” without “@domain”, e.g., “bogdand”."]
        #[serde(
            rename = "username",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub username: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for RbacSubjectProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RbacSubjectProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ReactionInfo {
        #[doc = "Unicode string representing a single emoji."]
        #[serde(
            rename = "emoji",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub emoji: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ReactionInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ReactionInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ReadReceiptsSettingsUpdatedMetadata {
        #[doc = "The new read receipts state."]
        #[serde(
            rename = "readReceiptsEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub read_receipts_enabled: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for ReadReceiptsSettingsUpdatedMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ReadReceiptsSettingsUpdatedMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Recipient {
        #[serde(
            rename = "email",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Recipient {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Recipient {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RecordingEvent {
        #[doc = "The initiator of the latest event of the recording. It will be set for all user events (`type` is 100-199) and unset for all server events (`type` is 200-299)."]
        #[serde(
            rename = "deviceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub device_id: ::std::option::Option<String>,
        #[doc = "The type of event."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::RecordingEventType>,
    }
    impl ::google_field_selector::FieldSelector for RecordingEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RecordingEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum RecordingEventType {
        #[doc = "Recording is about to be stopped by the server because the recording is about to reach the maximum duration."]
        ActiveAboutToStopTooLong,
        #[doc = "Recording was cancelled by a user."]
        CancelledByUser,
        #[doc = "Recording was cancelled by the server because of a failure during recording initialization."]
        CancelledInitializationFailed,
        #[doc = "Recording was cancelled by the server because the recording initiator left the conference during initialization. When the initiator leaves after the recording is started, no event is triggered."]
        CancelledInitiatorLeft,
        #[doc = "This is never used."]
        RecordingEventUnspecified,
        #[doc = "Recording was started or is being started by a user."]
        StartedByUser,
        #[doc = "Recording was stopped because there were no devices left in the conference."]
        StoppedAllDevicesLeft,
        #[doc = "Recording was stopped by a user."]
        StoppedByUser,
        #[doc = "Recording was stopped because of an internal error."]
        StoppedInternalFailures,
        #[doc = "Recording was stopped because the recording reached the maximum duration."]
        StoppedTooLong,
        #[doc = "Deprecated, use detailed user actions instead."]
        UserAction,
    }
    impl RecordingEventType {
        pub fn as_str(self) -> &'static str {
            match self {
                RecordingEventType::ActiveAboutToStopTooLong => "ACTIVE_ABOUT_TO_STOP_TOO_LONG",
                RecordingEventType::CancelledByUser => "CANCELLED_BY_USER",
                RecordingEventType::CancelledInitializationFailed => {
                    "CANCELLED_INITIALIZATION_FAILED"
                }
                RecordingEventType::CancelledInitiatorLeft => "CANCELLED_INITIATOR_LEFT",
                RecordingEventType::RecordingEventUnspecified => "RECORDING_EVENT_UNSPECIFIED",
                RecordingEventType::StartedByUser => "STARTED_BY_USER",
                RecordingEventType::StoppedAllDevicesLeft => "STOPPED_ALL_DEVICES_LEFT",
                RecordingEventType::StoppedByUser => "STOPPED_BY_USER",
                RecordingEventType::StoppedInternalFailures => "STOPPED_INTERNAL_FAILURES",
                RecordingEventType::StoppedTooLong => "STOPPED_TOO_LONG",
                RecordingEventType::UserAction => "USER_ACTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for RecordingEventType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for RecordingEventType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<RecordingEventType, ()> {
            Ok(match s {
                "ACTIVE_ABOUT_TO_STOP_TOO_LONG" => RecordingEventType::ActiveAboutToStopTooLong,
                "CANCELLED_BY_USER" => RecordingEventType::CancelledByUser,
                "CANCELLED_INITIALIZATION_FAILED" => {
                    RecordingEventType::CancelledInitializationFailed
                }
                "CANCELLED_INITIATOR_LEFT" => RecordingEventType::CancelledInitiatorLeft,
                "RECORDING_EVENT_UNSPECIFIED" => RecordingEventType::RecordingEventUnspecified,
                "STARTED_BY_USER" => RecordingEventType::StartedByUser,
                "STOPPED_ALL_DEVICES_LEFT" => RecordingEventType::StoppedAllDevicesLeft,
                "STOPPED_BY_USER" => RecordingEventType::StoppedByUser,
                "STOPPED_INTERNAL_FAILURES" => RecordingEventType::StoppedInternalFailures,
                "STOPPED_TOO_LONG" => RecordingEventType::StoppedTooLong,
                "USER_ACTION" => RecordingEventType::UserAction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for RecordingEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for RecordingEventType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RecordingEventType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVE_ABOUT_TO_STOP_TOO_LONG" => RecordingEventType::ActiveAboutToStopTooLong,
                "CANCELLED_BY_USER" => RecordingEventType::CancelledByUser,
                "CANCELLED_INITIALIZATION_FAILED" => {
                    RecordingEventType::CancelledInitializationFailed
                }
                "CANCELLED_INITIATOR_LEFT" => RecordingEventType::CancelledInitiatorLeft,
                "RECORDING_EVENT_UNSPECIFIED" => RecordingEventType::RecordingEventUnspecified,
                "STARTED_BY_USER" => RecordingEventType::StartedByUser,
                "STOPPED_ALL_DEVICES_LEFT" => RecordingEventType::StoppedAllDevicesLeft,
                "STOPPED_BY_USER" => RecordingEventType::StoppedByUser,
                "STOPPED_INTERNAL_FAILURES" => RecordingEventType::StoppedInternalFailures,
                "STOPPED_TOO_LONG" => RecordingEventType::StoppedTooLong,
                "USER_ACTION" => RecordingEventType::UserAction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for RecordingEventType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RecordingEventType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RecordingInfo {
        #[doc = "The latest recording event. This can be used by clients to help explain what is going on, why recording stopped, etc. This will always be set if there is or was an active recording, which means there can be latest event when recording is INACTIVE."]
        #[serde(
            rename = "latestRecordingEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub latest_recording_event: ::std::option::Option<crate::schemas::RecordingEvent>,
        #[doc = "The display name of the owner of the recording output. Email notifications about uploaded recordings will also be sent to this owner."]
        #[serde(
            rename = "ownerDisplayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub owner_display_name: ::std::option::Option<String>,
        #[doc = "The device resource name of the producer device for the currently active recording. Note that, after the producer drops/leaves the conference, this field will be cleaned up by the server after a delay."]
        #[serde(
            rename = "producerDeviceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub producer_device_id: ::std::option::Option<String>,
        #[doc = "The application type of the current active recording. `RECORDING_APPLICATION_TYPE_UNSPECIFIED` if `recording_status` is inactive."]
        #[serde(
            rename = "recordingApplicationType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recording_application_type:
            ::std::option::Option<crate::schemas::RecordingInfoRecordingApplicationType>,
        #[doc = "An identifier for the current recording, if any. This is returned whenever recording_status is either `RECORDING_STARTING` or `RECORDING_STARTED`."]
        #[serde(
            rename = "recordingId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recording_id: ::std::option::Option<String>,
        #[doc = "The current status of the recording. This can be used by clients to show a recording dot or similar to indicated to the user that a recording is taking place."]
        #[serde(
            rename = "recordingStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recording_status: ::std::option::Option<crate::schemas::RecordingInfoRecordingStatus>,
    }
    impl ::google_field_selector::FieldSelector for RecordingInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RecordingInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum RecordingInfoRecordingApplicationType {
        #[doc = "A meeting broadcast."]
        Broadcast,
        #[doc = "A *Google Live* managed stream."]
        GliveStream,
        #[doc = "A meeting recording saved to a video file in Google Drive."]
        Recording,
        #[doc = "This is never used."]
        RecordingApplicationTypeUnspecified,
    }
    impl RecordingInfoRecordingApplicationType {
        pub fn as_str(self) -> &'static str {
            match self {
                RecordingInfoRecordingApplicationType::Broadcast => "BROADCAST",
                RecordingInfoRecordingApplicationType::GliveStream => "GLIVE_STREAM",
                RecordingInfoRecordingApplicationType::Recording => "RECORDING",
                RecordingInfoRecordingApplicationType::RecordingApplicationTypeUnspecified => {
                    "RECORDING_APPLICATION_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for RecordingInfoRecordingApplicationType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for RecordingInfoRecordingApplicationType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<RecordingInfoRecordingApplicationType, ()> {
            Ok(match s {
                "BROADCAST" => RecordingInfoRecordingApplicationType::Broadcast,
                "GLIVE_STREAM" => RecordingInfoRecordingApplicationType::GliveStream,
                "RECORDING" => RecordingInfoRecordingApplicationType::Recording,
                "RECORDING_APPLICATION_TYPE_UNSPECIFIED" => {
                    RecordingInfoRecordingApplicationType::RecordingApplicationTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for RecordingInfoRecordingApplicationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for RecordingInfoRecordingApplicationType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RecordingInfoRecordingApplicationType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BROADCAST" => RecordingInfoRecordingApplicationType::Broadcast,
                "GLIVE_STREAM" => RecordingInfoRecordingApplicationType::GliveStream,
                "RECORDING" => RecordingInfoRecordingApplicationType::Recording,
                "RECORDING_APPLICATION_TYPE_UNSPECIFIED" => {
                    RecordingInfoRecordingApplicationType::RecordingApplicationTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for RecordingInfoRecordingApplicationType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RecordingInfoRecordingApplicationType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum RecordingInfoRecordingStatus {
        #[doc = "The conference is not being recorded. This can mean either that no recording has been started, or that a previous recording has stopped."]
        RecordingInactive,
        #[doc = "The recording is started. Any media sent to the conference may be included in the resulting recording."]
        RecordingStarted,
        #[doc = "Recording is about to begin. The status will be updated to RECORDING_STARTED when the recording actually starts, which happens when all the backend plumbing is set up."]
        RecordingStarting,
        #[doc = "This value is never used."]
        RecordingUnspecified,
    }
    impl RecordingInfoRecordingStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                RecordingInfoRecordingStatus::RecordingInactive => "RECORDING_INACTIVE",
                RecordingInfoRecordingStatus::RecordingStarted => "RECORDING_STARTED",
                RecordingInfoRecordingStatus::RecordingStarting => "RECORDING_STARTING",
                RecordingInfoRecordingStatus::RecordingUnspecified => "RECORDING_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for RecordingInfoRecordingStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for RecordingInfoRecordingStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<RecordingInfoRecordingStatus, ()> {
            Ok(match s {
                "RECORDING_INACTIVE" => RecordingInfoRecordingStatus::RecordingInactive,
                "RECORDING_STARTED" => RecordingInfoRecordingStatus::RecordingStarted,
                "RECORDING_STARTING" => RecordingInfoRecordingStatus::RecordingStarting,
                "RECORDING_UNSPECIFIED" => RecordingInfoRecordingStatus::RecordingUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for RecordingInfoRecordingStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for RecordingInfoRecordingStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RecordingInfoRecordingStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "RECORDING_INACTIVE" => RecordingInfoRecordingStatus::RecordingInactive,
                "RECORDING_STARTED" => RecordingInfoRecordingStatus::RecordingStarted,
                "RECORDING_STARTING" => RecordingInfoRecordingStatus::RecordingStarting,
                "RECORDING_UNSPECIFIED" => RecordingInfoRecordingStatus::RecordingUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for RecordingInfoRecordingStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RecordingInfoRecordingStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RecordingSessionInfo {
        #[doc = "Input only. Deprecated field, should not be used."]
        #[serde(
            rename = "ownerEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub owner_email: ::std::option::Option<String>,
        #[doc = "A unique server-generated ID for the recording session."]
        #[serde(
            rename = "recordingSessionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recording_session_id: ::std::option::Option<String>,
        #[doc = "Recording session’s state information."]
        #[serde(
            rename = "sessionStateInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_state_info: ::std::option::Option<crate::schemas::SessionStateInfo>,
    }
    impl ::google_field_selector::FieldSelector for RecordingSessionInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RecordingSessionInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Reference {
        #[serde(
            rename = "blobId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub blob_id: ::std::option::Option<String>,
        #[serde(
            rename = "contentType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_type: ::std::option::Option<String>,
        #[serde(
            rename = "hash",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hash: ::std::option::Option<String>,
        #[doc = "LINT.IfChange"]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "LINT.ThenChange(//depot/google3/storage/slice/production/gmail/ user_data_tables.pi)"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "size",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub size: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for Reference {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Reference {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct References {
        #[serde(
            rename = "references",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub references: ::std::option::Option<Vec<crate::schemas::Reference>>,
    }
    impl ::google_field_selector::FieldSelector for References {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for References {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RenameEvent {
        #[serde(
            rename = "newName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub new_name: ::std::option::Option<String>,
        #[serde(
            rename = "originalName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub original_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for RenameEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RenameEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RepositoryError {
        #[doc = "Message that describes the error. The maximum allowable length of the message is 8192 characters."]
        #[serde(
            rename = "errorMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_message: ::std::option::Option<String>,
        #[doc = "Error codes. Matches the definition of HTTP status codes."]
        #[serde(
            rename = "httpStatusCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub http_status_code: ::std::option::Option<i32>,
        #[doc = "The type of error."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::RepositoryErrorType>,
    }
    impl ::google_field_selector::FieldSelector for RepositoryError {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RepositoryError {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum RepositoryErrorType {
        #[doc = "Failed authentication due to incorrect credentials."]
        AuthenticationError,
        #[doc = "Service account is not authorized for the repository."]
        AuthorizationError,
        #[doc = "Client-related error, such as an invalid request from the connector to the repository server."]
        ClientError,
        #[doc = "Cannot connect to the repository server."]
        ConnectionError,
        #[doc = "DNS problem, such as the DNS server is not responding."]
        DnsError,
        #[doc = "Unknown or unreachable host."]
        NetworkError,
        #[doc = "Quota exceeded."]
        QuotaExceeded,
        #[doc = "Repository server error."]
        ServerError,
        #[doc = "Server temporarily unavailable."]
        ServiceUnavailable,
        #[doc = "Unknown error."]
        Unknown,
    }
    impl RepositoryErrorType {
        pub fn as_str(self) -> &'static str {
            match self {
                RepositoryErrorType::AuthenticationError => "AUTHENTICATION_ERROR",
                RepositoryErrorType::AuthorizationError => "AUTHORIZATION_ERROR",
                RepositoryErrorType::ClientError => "CLIENT_ERROR",
                RepositoryErrorType::ConnectionError => "CONNECTION_ERROR",
                RepositoryErrorType::DnsError => "DNS_ERROR",
                RepositoryErrorType::NetworkError => "NETWORK_ERROR",
                RepositoryErrorType::QuotaExceeded => "QUOTA_EXCEEDED",
                RepositoryErrorType::ServerError => "SERVER_ERROR",
                RepositoryErrorType::ServiceUnavailable => "SERVICE_UNAVAILABLE",
                RepositoryErrorType::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for RepositoryErrorType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for RepositoryErrorType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<RepositoryErrorType, ()> {
            Ok(match s {
                "AUTHENTICATION_ERROR" => RepositoryErrorType::AuthenticationError,
                "AUTHORIZATION_ERROR" => RepositoryErrorType::AuthorizationError,
                "CLIENT_ERROR" => RepositoryErrorType::ClientError,
                "CONNECTION_ERROR" => RepositoryErrorType::ConnectionError,
                "DNS_ERROR" => RepositoryErrorType::DnsError,
                "NETWORK_ERROR" => RepositoryErrorType::NetworkError,
                "QUOTA_EXCEEDED" => RepositoryErrorType::QuotaExceeded,
                "SERVER_ERROR" => RepositoryErrorType::ServerError,
                "SERVICE_UNAVAILABLE" => RepositoryErrorType::ServiceUnavailable,
                "UNKNOWN" => RepositoryErrorType::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for RepositoryErrorType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for RepositoryErrorType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RepositoryErrorType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AUTHENTICATION_ERROR" => RepositoryErrorType::AuthenticationError,
                "AUTHORIZATION_ERROR" => RepositoryErrorType::AuthorizationError,
                "CLIENT_ERROR" => RepositoryErrorType::ClientError,
                "CONNECTION_ERROR" => RepositoryErrorType::ConnectionError,
                "DNS_ERROR" => RepositoryErrorType::DnsError,
                "NETWORK_ERROR" => RepositoryErrorType::NetworkError,
                "QUOTA_EXCEEDED" => RepositoryErrorType::QuotaExceeded,
                "SERVER_ERROR" => RepositoryErrorType::ServerError,
                "SERVICE_UNAVAILABLE" => RepositoryErrorType::ServiceUnavailable,
                "UNKNOWN" => RepositoryErrorType::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for RepositoryErrorType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RepositoryErrorType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RequestFileScope {
        #[serde(
            rename = "itemId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub item_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for RequestFileScope {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RequestFileScope {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RequestFileScopeForActiveDocument {}
    impl ::google_field_selector::FieldSelector for RequestFileScopeForActiveDocument {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RequestFileScopeForActiveDocument {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RequestOptions {
        #[doc = "Debug options of the request"]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[doc = "The BCP-47 language code, such as “en-US” or “sr-Latn”. For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. For translations. Set this field using the language set in browser or for the page. In the event that the user’s language preference is known, set this field to the known user language. When specified, the documents in search results are biased towards the specified language. From Suggest API perspective, for 3p suggest this is used as a hint while making predictions to add language boosting."]
        #[serde(
            rename = "languageCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_code: ::std::option::Option<String>,
        #[doc = "The ID generated when you create a search application using the [admin console](https://support.google.com/a/answer/9043922)."]
        #[serde(
            rename = "searchApplicationId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub search_application_id: ::std::option::Option<String>,
        #[doc = "Current user’s time zone id, such as “America/Los_Angeles” or “Australia/Sydney”. These IDs are defined by [Unicode Common Locale Data Repository (CLDR)](http://cldr.unicode.org/) project, and currently available in the file [timezone.xml](http://unicode.org/repos/cldr/trunk/common/bcp47/timezone.xml). This field is used to correctly interpret date and time queries. If this field is not specified, the default time zone (UTC) is used."]
        #[serde(
            rename = "timeZone",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub time_zone: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for RequestOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RequestOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RequiredMessageFeaturesMetadata {
        #[serde(
            rename = "requiredFeatures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub required_features: ::std::option::Option<
            Vec<crate::schemas::RequiredMessageFeaturesMetadataRequiredFeaturesItems>,
        >,
    }
    impl ::google_field_selector::FieldSelector for RequiredMessageFeaturesMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RequiredMessageFeaturesMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum RequiredMessageFeaturesMetadataRequiredFeaturesItems {
        RequiredFeatureCustomHyperlink,
        RequiredFeatureMessageQuoting,
        RequiredFeatureTombstonesInDmsAndUfrs,
        RequiredFeatureUnspecified,
    }
    impl RequiredMessageFeaturesMetadataRequiredFeaturesItems {
        pub fn as_str(self) -> &'static str {
            match self { RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureCustomHyperlink => "REQUIRED_FEATURE_CUSTOM_HYPERLINK" , RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureMessageQuoting => "REQUIRED_FEATURE_MESSAGE_QUOTING" , RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureTombstonesInDmsAndUfrs => "REQUIRED_FEATURE_TOMBSTONES_IN_DMS_AND_UFRS" , RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureUnspecified => "REQUIRED_FEATURE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str> for RequiredMessageFeaturesMetadataRequiredFeaturesItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for RequiredMessageFeaturesMetadataRequiredFeaturesItems {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<RequiredMessageFeaturesMetadataRequiredFeaturesItems, ()>
        {
            Ok (match s { "REQUIRED_FEATURE_CUSTOM_HYPERLINK" => RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureCustomHyperlink , "REQUIRED_FEATURE_MESSAGE_QUOTING" => RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureMessageQuoting , "REQUIRED_FEATURE_TOMBSTONES_IN_DMS_AND_UFRS" => RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureTombstonesInDmsAndUfrs , "REQUIRED_FEATURE_UNSPECIFIED" => RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for RequiredMessageFeaturesMetadataRequiredFeaturesItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for RequiredMessageFeaturesMetadataRequiredFeaturesItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequiredMessageFeaturesMetadataRequiredFeaturesItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "REQUIRED_FEATURE_CUSTOM_HYPERLINK" => RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureCustomHyperlink , "REQUIRED_FEATURE_MESSAGE_QUOTING" => RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureMessageQuoting , "REQUIRED_FEATURE_TOMBSTONES_IN_DMS_AND_UFRS" => RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureTombstonesInDmsAndUfrs , "REQUIRED_FEATURE_UNSPECIFIED" => RequiredMessageFeaturesMetadataRequiredFeaturesItems :: RequiredFeatureUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for RequiredMessageFeaturesMetadataRequiredFeaturesItems
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RequiredMessageFeaturesMetadataRequiredFeaturesItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ResetSearchApplicationRequest {
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
    }
    impl ::google_field_selector::FieldSelector for ResetSearchApplicationRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ResetSearchApplicationRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ResourceRoleProto {
        #[serde(
            rename = "applicationId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub application_id: ::std::option::Option<String>,
        #[serde(
            rename = "objectId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_id: ::std::option::Option<String>,
        #[serde(
            rename = "objectPart",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_part: ::std::option::Option<String>,
        #[serde(
            rename = "roleId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub role_id: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for ResourceRoleProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ResourceRoleProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ResponseDebugInfo {
        #[doc = "General debug info formatted for display."]
        #[serde(
            rename = "formattedDebugInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub formatted_debug_info: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ResponseDebugInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ResponseDebugInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RestrictItem {
        #[serde(
            rename = "driveFollowUpRestrict",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_follow_up_restrict: ::std::option::Option<crate::schemas::DriveFollowUpRestrict>,
        #[serde(
            rename = "driveLocationRestrict",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_location_restrict: ::std::option::Option<crate::schemas::DriveLocationRestrict>,
        #[doc = "Drive Types."]
        #[serde(
            rename = "driveMimeTypeRestrict",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_mime_type_restrict: ::std::option::Option<crate::schemas::DriveMimeTypeRestrict>,
        #[serde(
            rename = "driveTimeSpanRestrict",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_time_span_restrict: ::std::option::Option<crate::schemas::DriveTimeSpanRestrict>,
        #[doc = "The search restrict (e.g. “after:2017-09-11 before:2017-09-12”)."]
        #[serde(
            rename = "searchOperator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub search_operator: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for RestrictItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RestrictItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ResultCounts {
        #[doc = "Result count information for each source with results."]
        #[serde(
            rename = "sourceResultCounts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source_result_counts: ::std::option::Option<Vec<crate::schemas::SourceResultCount>>,
    }
    impl ::google_field_selector::FieldSelector for ResultCounts {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ResultCounts {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ResultDebugInfo {
        #[doc = "General debug info formatted for display."]
        #[serde(
            rename = "formattedDebugInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub formatted_debug_info: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ResultDebugInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ResultDebugInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ResultDisplayField {
        #[doc = "The display label for the property."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "The operator name of the property."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
        #[doc = "The name value pair for the property."]
        #[serde(
            rename = "property",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub property: ::std::option::Option<crate::schemas::NamedProperty>,
    }
    impl ::google_field_selector::FieldSelector for ResultDisplayField {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ResultDisplayField {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ResultDisplayLine {
        #[serde(
            rename = "fields",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fields: ::std::option::Option<Vec<crate::schemas::ResultDisplayField>>,
    }
    impl ::google_field_selector::FieldSelector for ResultDisplayLine {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ResultDisplayLine {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ResultDisplayMetadata {
        #[doc = "The metalines content to be displayed with the result."]
        #[serde(
            rename = "metalines",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metalines: ::std::option::Option<Vec<crate::schemas::ResultDisplayLine>>,
        #[doc = "The display label for the object."]
        #[serde(
            rename = "objectTypeLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_type_label: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for ResultDisplayMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ResultDisplayMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RetrievalImportance {
        #[doc = "Indicates the ranking importance given to property when it is matched during retrieval. Once set, the token importance of a property cannot be changed."]
        #[serde(
            rename = "importance",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub importance: ::std::option::Option<crate::schemas::RetrievalImportanceImportance>,
    }
    impl ::google_field_selector::FieldSelector for RetrievalImportance {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RetrievalImportance {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum RetrievalImportanceImportance {
        #[doc = "Treat the match like a body text match."]
        Default,
        #[doc = "Treat the match with higher importance than body text."]
        High,
        #[doc = "Treat the match like a match against title of the item."]
        Highest,
        #[doc = "Treat the match with lower importance than body text."]
        Low,
        #[doc = "Do not match against this field during retrieval. The property can still be used for operator matching, faceting, and suggest if desired."]
        None,
    }
    impl RetrievalImportanceImportance {
        pub fn as_str(self) -> &'static str {
            match self {
                RetrievalImportanceImportance::Default => "DEFAULT",
                RetrievalImportanceImportance::High => "HIGH",
                RetrievalImportanceImportance::Highest => "HIGHEST",
                RetrievalImportanceImportance::Low => "LOW",
                RetrievalImportanceImportance::None => "NONE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for RetrievalImportanceImportance {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for RetrievalImportanceImportance {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<RetrievalImportanceImportance, ()> {
            Ok(match s {
                "DEFAULT" => RetrievalImportanceImportance::Default,
                "HIGH" => RetrievalImportanceImportance::High,
                "HIGHEST" => RetrievalImportanceImportance::Highest,
                "LOW" => RetrievalImportanceImportance::Low,
                "NONE" => RetrievalImportanceImportance::None,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for RetrievalImportanceImportance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for RetrievalImportanceImportance {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RetrievalImportanceImportance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEFAULT" => RetrievalImportanceImportance::Default,
                "HIGH" => RetrievalImportanceImportance::High,
                "HIGHEST" => RetrievalImportanceImportance::Highest,
                "LOW" => RetrievalImportanceImportance::Low,
                "NONE" => RetrievalImportanceImportance::None,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for RetrievalImportanceImportance {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RetrievalImportanceImportance {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RoomRenameMetadata {
        #[serde(
            rename = "newName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub new_name: ::std::option::Option<String>,
        #[doc = "NEXT_TAG: 3"]
        #[serde(
            rename = "prevName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub prev_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for RoomRenameMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RoomRenameMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RoomUpdatedMetadata {
        #[serde(
            rename = "groupDetailsMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_details_metadata:
            ::std::option::Option<crate::schemas::GroupDetailsUpdatedMetadata>,
        #[serde(
            rename = "groupLinkSharingEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_link_sharing_enabled: ::std::option::Option<bool>,
        #[doc = "The user who initiated this room update. Complete member profiles, when ListTopicsRequest FetchOptions.USER is set. Otherwise, only the id will be filled in."]
        #[serde(
            rename = "initiator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator: ::std::option::Option<crate::schemas::User>,
        #[doc = "The type of the user who initiated this room update."]
        #[serde(
            rename = "initiatorType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initiator_type: ::std::option::Option<crate::schemas::RoomUpdatedMetadataInitiatorType>,
        #[doc = "What was updated in the room."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "renameMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rename_metadata: ::std::option::Option<crate::schemas::RoomRenameMetadata>,
        #[doc = "DEPRECATED: See GroupVisibility proto definition."]
        #[serde(
            rename = "visibility",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub visibility: ::std::option::Option<crate::schemas::AppsDynamiteSharedGroupVisibility>,
    }
    impl ::google_field_selector::FieldSelector for RoomUpdatedMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RoomUpdatedMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum RoomUpdatedMetadataInitiatorType {
        InitiatorTypeAdmin,
        InitiatorTypeEndUser,
        InitiatorTypeUnspecified,
    }
    impl RoomUpdatedMetadataInitiatorType {
        pub fn as_str(self) -> &'static str {
            match self {
                RoomUpdatedMetadataInitiatorType::InitiatorTypeAdmin => "INITIATOR_TYPE_ADMIN",
                RoomUpdatedMetadataInitiatorType::InitiatorTypeEndUser => "INITIATOR_TYPE_END_USER",
                RoomUpdatedMetadataInitiatorType::InitiatorTypeUnspecified => {
                    "INITIATOR_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for RoomUpdatedMetadataInitiatorType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for RoomUpdatedMetadataInitiatorType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<RoomUpdatedMetadataInitiatorType, ()> {
            Ok(match s {
                "INITIATOR_TYPE_ADMIN" => RoomUpdatedMetadataInitiatorType::InitiatorTypeAdmin,
                "INITIATOR_TYPE_END_USER" => RoomUpdatedMetadataInitiatorType::InitiatorTypeEndUser,
                "INITIATOR_TYPE_UNSPECIFIED" => {
                    RoomUpdatedMetadataInitiatorType::InitiatorTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for RoomUpdatedMetadataInitiatorType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for RoomUpdatedMetadataInitiatorType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RoomUpdatedMetadataInitiatorType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "INITIATOR_TYPE_ADMIN" => RoomUpdatedMetadataInitiatorType::InitiatorTypeAdmin,
                "INITIATOR_TYPE_END_USER" => RoomUpdatedMetadataInitiatorType::InitiatorTypeEndUser,
                "INITIATOR_TYPE_UNSPECIFIED" => {
                    RoomUpdatedMetadataInitiatorType::InitiatorTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for RoomUpdatedMetadataInitiatorType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RoomUpdatedMetadataInitiatorType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Roster {
        #[serde(
            rename = "avatarUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub avatar_url: ::std::option::Option<String>,
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<crate::schemas::RosterId>,
        #[doc = "Whether caller has visibility into members of the roster."]
        #[serde(
            rename = "isMembershipVisibleToCaller",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_membership_visible_to_caller: ::std::option::Option<bool>,
        #[serde(
            rename = "membershipCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub membership_count: ::std::option::Option<i32>,
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Roster gaia key, usually an email address. Set in looking up rosters response."]
        #[serde(
            rename = "rosterGaiaKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub roster_gaia_key: ::std::option::Option<String>,
        #[doc = "Roster deletion state - considered active unless set to deleted"]
        #[serde(
            rename = "rosterState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub roster_state: ::std::option::Option<crate::schemas::RosterRosterState>,
        #[doc = "Roster membership count. May contain counts based on member type and membership state."]
        #[serde(
            rename = "segmentedMembershipCounts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub segmented_membership_counts:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedSegmentedMembershipCounts>,
    }
    impl ::google_field_selector::FieldSelector for Roster {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Roster {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum RosterRosterState {
        #[doc = "Roster is active"]
        RosterActive,
        #[doc = "Roster deleted"]
        RosterDeleted,
        RosterStateUnknown,
    }
    impl RosterRosterState {
        pub fn as_str(self) -> &'static str {
            match self {
                RosterRosterState::RosterActive => "ROSTER_ACTIVE",
                RosterRosterState::RosterDeleted => "ROSTER_DELETED",
                RosterRosterState::RosterStateUnknown => "ROSTER_STATE_UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for RosterRosterState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for RosterRosterState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<RosterRosterState, ()> {
            Ok(match s {
                "ROSTER_ACTIVE" => RosterRosterState::RosterActive,
                "ROSTER_DELETED" => RosterRosterState::RosterDeleted,
                "ROSTER_STATE_UNKNOWN" => RosterRosterState::RosterStateUnknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for RosterRosterState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for RosterRosterState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RosterRosterState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ROSTER_ACTIVE" => RosterRosterState::RosterActive,
                "ROSTER_DELETED" => RosterRosterState::RosterDeleted,
                "ROSTER_STATE_UNKNOWN" => RosterRosterState::RosterStateUnknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for RosterRosterState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RosterRosterState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RosterId {
        #[doc = "Opaque, server-assigned ID of the Roster."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for RosterId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RosterId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RpcOptions {
        #[doc = "The RPC’s request extensions (i.e. RPC::request_extensions(), a.k.a. the Stubby side channel) will be merged with the specified \\[request_extensions\\]. When Triggers are batched, the RPC’s request extensions will be merged with all of the \\[request_extensions\\] of the Triggers in the batch. Note that merging of request extensions follows standard protocol buffer semantics; values of singular fields override previous values, and values of repeated fields are appended (In the case of Triggers, Triggers with later fire times will be merged after Triggers with earlier fire times in the same batch). It is not advised to specify extensions with repeated fields on batchable Triggers."]
        #[serde(
            rename = "requestExtensions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_extensions: ::std::option::Option<crate::schemas::MessageSet>,
    }
    impl ::google_field_selector::FieldSelector for RpcOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for RpcOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SafeUrlProto {
        #[doc = "IMPORTANT: Never set or read this field, even from tests, it is private. See documentation at the top of .proto file for programming language packages with which to create or read this message."]
        #[serde(
            rename = "privateDoNotAccessOrElseSafeUrlWrappedValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_do_not_access_or_else_safe_url_wrapped_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SafeUrlProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SafeUrlProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Schema {
        #[doc = "The list of top-level objects for the data source. The maximum number of elements is 10."]
        #[serde(
            rename = "objectDefinitions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_definitions: ::std::option::Option<Vec<crate::schemas::ObjectDefinition>>,
        #[doc = "IDs of the Long Running Operations (LROs) currently running for this schema. After modifying the schema, wait for operations to complete before indexing additional content."]
        #[serde(
            rename = "operationIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operation_ids: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for Schema {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Schema {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ScoringConfig {
        #[doc = "Whether to use freshness as a ranking signal. By default, freshness is used as a ranking signal. Note that this setting is not available in the Admin UI."]
        #[serde(
            rename = "disableFreshness",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disable_freshness: ::std::option::Option<bool>,
        #[doc = "Whether to personalize the results. By default, personal signals will be used to boost results."]
        #[serde(
            rename = "disablePersonalization",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disable_personalization: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for ScoringConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ScoringConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct SearchApplication {
        #[doc = "Retrictions applied to the configurations. The maximum number of elements is 10."]
        #[serde(
            rename = "dataSourceRestrictions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_source_restrictions:
            ::std::option::Option<Vec<crate::schemas::DataSourceRestriction>>,
        #[doc = "The default fields for returning facet results. The sources specified here also have been included in data_source_restrictions above."]
        #[serde(
            rename = "defaultFacetOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_facet_options: ::std::option::Option<Vec<crate::schemas::FacetOptions>>,
        #[doc = "The default options for sorting the search results"]
        #[serde(
            rename = "defaultSortOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_sort_options: ::std::option::Option<crate::schemas::SortOptions>,
        #[doc = "Display name of the Search Application. The maximum length is 300 characters."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Indicates whether audit logging is on/off for requests made for the search application in query APIs."]
        #[serde(
            rename = "enableAuditLog",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enable_audit_log: ::std::option::Option<bool>,
        #[doc = "The name of the Search Application. Format: searchapplications/{application_id}."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Output only. IDs of the Long Running Operations (LROs) currently running for this schema. Output only field."]
        #[serde(
            rename = "operationIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operation_ids: ::std::option::Option<Vec<String>>,
        #[doc = "The default options for query interpretation"]
        #[serde(
            rename = "queryInterpretationConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query_interpretation_config:
            ::std::option::Option<crate::schemas::QueryInterpretationConfig>,
        #[doc = "With each result we should return the URI for its thumbnail (when applicable)"]
        #[serde(
            rename = "returnResultThumbnailUrls",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub return_result_thumbnail_urls: ::std::option::Option<bool>,
        #[doc = "Configuration for ranking results."]
        #[serde(
            rename = "scoringConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scoring_config: ::std::option::Option<crate::schemas::ScoringConfig>,
        #[doc = "Configuration for a sources specified in data_source_restrictions."]
        #[serde(
            rename = "sourceConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source_config: ::std::option::Option<Vec<crate::schemas::SourceConfig>>,
    }
    impl ::google_field_selector::FieldSelector for SearchApplication {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchApplication {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SearchApplicationQueryStats {
        #[doc = "The date for which query stats were calculated. Stats calculated on the next day close to midnight are returned."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[serde(
            rename = "queryCountByStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query_count_by_status: ::std::option::Option<Vec<crate::schemas::QueryCountByStatus>>,
    }
    impl ::google_field_selector::FieldSelector for SearchApplicationQueryStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchApplicationQueryStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SearchApplicationSessionStats {
        #[doc = "The date for which session stats were calculated. Stats are calculated on the following day, close to midnight PST, and then returned."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "The count of search sessions on the day"]
        #[serde(
            rename = "searchSessionsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub search_sessions_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for SearchApplicationSessionStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchApplicationSessionStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SearchApplicationUserStats {
        #[doc = "The date for which session stats were calculated. Stats calculated on the next day close to midnight are returned."]
        #[serde(
            rename = "date",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "The count of unique active users in the past one day"]
        #[serde(
            rename = "oneDayActiveUsersCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub one_day_active_users_count: ::std::option::Option<i64>,
        #[doc = "The count of unique active users in the past seven days"]
        #[serde(
            rename = "sevenDaysActiveUsersCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub seven_days_active_users_count: ::std::option::Option<i64>,
        #[doc = "The count of unique active users in the past thirty days"]
        #[serde(
            rename = "thirtyDaysActiveUsersCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub thirty_days_active_users_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for SearchApplicationUserStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchApplicationUserStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SearchItemsByViewUrlRequest {
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[doc = "The next_page_token value returned from a previous request, if any."]
        #[serde(
            rename = "pageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub page_token: ::std::option::Option<String>,
        #[doc = "Specify the full view URL to find the corresponding item. The maximum length is 2048 characters."]
        #[serde(
            rename = "viewUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub view_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SearchItemsByViewUrlRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchItemsByViewUrlRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct SearchItemsByViewUrlResponse {
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<Vec<crate::schemas::Item>>,
        #[doc = "Token to retrieve the next page of results, or empty if there are no more results in the list."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SearchItemsByViewUrlResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchItemsByViewUrlResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for SearchItemsByViewUrlResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct SearchQualityMetadata {
        #[doc = "An indication of the quality of the item, used to influence search quality. Value should be between 0.0 (lowest quality) and 1.0 (highest quality). The default value is 0.0."]
        #[serde(
            rename = "quality",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub quality: ::std::option::Option<f64>,
    }
    impl ::google_field_selector::FieldSelector for SearchQualityMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchQualityMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct SearchRequest {
        #[doc = "Context attributes for the request which will be used to adjust ranking of search results. The maximum number of elements is 10."]
        #[serde(
            rename = "contextAttributes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub context_attributes: ::std::option::Option<Vec<crate::schemas::ContextAttribute>>,
        #[doc = "The sources to use for querying. If not specified, all data sources from the current search application are used."]
        #[serde(
            rename = "dataSourceRestrictions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_source_restrictions:
            ::std::option::Option<Vec<crate::schemas::DataSourceRestriction>>,
        #[serde(
            rename = "facetOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub facet_options: ::std::option::Option<Vec<crate::schemas::FacetOptions>>,
        #[doc = "Maximum number of search results to return in one page. Valid values are between 1 and 100, inclusive. Default value is 10. Minimum value is 50 when results beyond 2000 are requested."]
        #[serde(
            rename = "pageSize",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub page_size: ::std::option::Option<i32>,
        #[doc = "The raw query string. See supported search operators in the [Narrow your search with operators](https://support.google.com/cloudsearch/answer/6172299)"]
        #[serde(
            rename = "query",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query: ::std::option::Option<String>,
        #[doc = "Options to interpret the user query."]
        #[serde(
            rename = "queryInterpretationOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query_interpretation_options:
            ::std::option::Option<crate::schemas::QueryInterpretationOptions>,
        #[doc = "Request options, such as the search application and user timezone."]
        #[serde(
            rename = "requestOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_options: ::std::option::Option<crate::schemas::RequestOptions>,
        #[doc = "The options for sorting the search results"]
        #[serde(
            rename = "sortOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sort_options: ::std::option::Option<crate::schemas::SortOptions>,
        #[doc = "Starting index of the results."]
        #[serde(
            rename = "start",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for SearchRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct SearchResponse {
        #[doc = "Debugging information about the response."]
        #[serde(
            rename = "debugInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_info: ::std::option::Option<crate::schemas::ResponseDebugInfo>,
        #[doc = "Error information about the response."]
        #[serde(
            rename = "errorInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_info: ::std::option::Option<crate::schemas::ErrorInfo>,
        #[doc = "Repeated facet results."]
        #[serde(
            rename = "facetResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub facet_results: ::std::option::Option<Vec<crate::schemas::FacetResult>>,
        #[doc = "Whether there are more search results matching the query."]
        #[serde(
            rename = "hasMoreResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub has_more_results: ::std::option::Option<bool>,
        #[doc = "Query interpretation result for user query. Empty if query interpretation is disabled."]
        #[serde(
            rename = "queryInterpretation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query_interpretation: ::std::option::Option<crate::schemas::QueryInterpretation>,
        #[doc = "The estimated result count for this query."]
        #[serde(
            rename = "resultCountEstimate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub result_count_estimate: ::std::option::Option<i64>,
        #[doc = "The exact result count for this query."]
        #[serde(
            rename = "resultCountExact",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub result_count_exact: ::std::option::Option<i64>,
        #[doc = "Expanded result count information."]
        #[serde(
            rename = "resultCounts",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub result_counts: ::std::option::Option<crate::schemas::ResultCounts>,
        #[doc = "Results from a search query."]
        #[serde(
            rename = "results",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub results: ::std::option::Option<Vec<crate::schemas::SearchResult>>,
        #[doc = "Suggested spelling for the query."]
        #[serde(
            rename = "spellResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub spell_results: ::std::option::Option<Vec<crate::schemas::SpellResult>>,
        #[doc = "Structured results for the user query. These results are not counted against the page_size."]
        #[serde(
            rename = "structuredResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub structured_results: ::std::option::Option<Vec<crate::schemas::StructuredResult>>,
    }
    impl ::google_field_selector::FieldSelector for SearchResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct SearchResult {
        #[doc = "If source is clustered, provide list of clustered results. There will only be one level of clustered results. If current source is not enabled for clustering, this field will be empty."]
        #[serde(
            rename = "clusteredResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub clustered_results: ::std::option::Option<Vec<crate::schemas::SearchResult>>,
        #[doc = "Debugging information about this search result."]
        #[serde(
            rename = "debugInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_info: ::std::option::Option<crate::schemas::ResultDebugInfo>,
        #[doc = "Metadata of the search result."]
        #[serde(
            rename = "metadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metadata: ::std::option::Option<crate::schemas::Metadata>,
        #[doc = "The concatenation of all snippets (summaries) available for this result."]
        #[serde(
            rename = "snippet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snippet: ::std::option::Option<crate::schemas::Snippet>,
        #[doc = "Title of the search result."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
        #[doc = "The URL of the search result. The URL contains a Google redirect to the actual item. This URL is signed and shouldn’t be changed."]
        #[serde(
            rename = "url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SearchResult {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SearchResult {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Section {
        #[doc = "Indicating whether this section is collapsable. If a section is collapsable, the description must be given."]
        #[serde(
            rename = "collapsable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub collapsable: ::std::option::Option<bool>,
        #[doc = "The header of the section, text formatted supported."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "The number of uncollapsable widgets. For example, when a section contains 5 widgets and the num_uncollapsable_widget are set to be 2, The first 2 widgets will always shown and the last 3 is collapsed as default. Only when collapsable is set to be true, the num_uncollapsable_widget will be taken into account."]
        #[serde(
            rename = "numUncollapsableWidgets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_uncollapsable_widgets: ::std::option::Option<i32>,
        #[doc = "A section must contain at least 1 widget."]
        #[serde(
            rename = "widgets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub widgets: ::std::option::Option<Vec<crate::schemas::WidgetMarkup>>,
    }
    impl ::google_field_selector::FieldSelector for Section {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Section {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Segment {
        #[doc = "Formatting to be applied when rendering the Segment. For all segment types, this is the standard way of representing that the Segment should be rendered in bold, italics, etc."]
        #[serde(
            rename = "formatting",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub formatting: ::std::option::Option<crate::schemas::Formatting>,
        #[doc = "For HASHTAG type:"]
        #[serde(
            rename = "hashtagData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hashtag_data: ::std::option::Option<crate::schemas::HashtagData>,
        #[doc = "Type-specific metadata. At most one of these should be populated, and the one that is populated should correspond to the type of the Segment. For LINK type:"]
        #[serde(
            rename = "linkData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub link_data: ::std::option::Option<crate::schemas::LinkData>,
        #[doc = "Type of Segment."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::SegmentType>,
        #[doc = "Text content of the Segment. As a general rule, this field should contain the actual text that should be rendered in the UI. Thus, for a hashtag, it should be “\\#Foo”, and for a link, it should be the display text. Clients that do not understand a particular segment type may use this text, along with the Formatting info below, as a fallback for display. The field is not required – if all relevant information is carried in other metadata fields and there is no need for a fallback, or it is not practical for a fallback to be provided for any other reason, the field may be left blank. A standard example would be a user reference being transmitted between server layers, where a gaia-ID representation may be sufficient and there is no need for a textual fallback. In such a case, it would be valid and useful - though not required - for servers to compute and populate a fallback on the serving path."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "For USER_MENTION type:"]
        #[serde(
            rename = "userMentionData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_mention_data: ::std::option::Option<crate::schemas::UserMentionData>,
    }
    impl ::google_field_selector::FieldSelector for Segment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Segment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SegmentType {
        #[doc = "An ALL_USER_MENTION segment represents a reference to all users in the context, that is, the conversation, discussion, or other context containing the segment. For example, an ALL_USER_MENTION segment (“@all”) can be useful to ping all participants in a conversation if the notification setting of the conversation is not set to ping on normal messages. An ALL_USER_MENTION should be treated as a USER_MENTION for all users who receives the segment."]
        AllUserMention,
        #[doc = "A HASHTAG segment represents a structured reference to a topic. The “text” field should represent display text (e.g. “\\#Google”), and additional metadata should be put in the Segment’s hashtag_data field."]
        Hashtag,
        #[doc = "A LINE_BREAK segment is simply a placeholder to represent a line break between other segments. The “text” variable may be set to a newline as a fallback, but clients that understand this segment type should simply insert a line break without needing to reference any fields."]
        LineBreak,
        #[doc = "A LINK segment represents a link to a web entity. The “text” field should be used for anchor text. Additional link data should be put in the link_data protobuf."]
        Link,
        #[doc = "A TEXT segment represents plain-text subject to particular formatting constraints (as represented in the “formatting” field of the Segment)."]
        Text,
        #[doc = "A USER_MENTION segment represents a reference to a (possibly non-Gaia, possibly off-network) user. The “text” field may be populated as a fallback, but information identifying the user should be contained in the user_mention_data protobuf. (The set of fields that are populated in user_mention_data may differ depending on the context in which the segment is viewed, but the interpretation of the fields is uniform. See comments over UserMentionData)."]
        UserMention,
    }
    impl SegmentType {
        pub fn as_str(self) -> &'static str {
            match self {
                SegmentType::AllUserMention => "ALL_USER_MENTION",
                SegmentType::Hashtag => "HASHTAG",
                SegmentType::LineBreak => "LINE_BREAK",
                SegmentType::Link => "LINK",
                SegmentType::Text => "TEXT",
                SegmentType::UserMention => "USER_MENTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SegmentType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SegmentType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SegmentType, ()> {
            Ok(match s {
                "ALL_USER_MENTION" => SegmentType::AllUserMention,
                "HASHTAG" => SegmentType::Hashtag,
                "LINE_BREAK" => SegmentType::LineBreak,
                "LINK" => SegmentType::Link,
                "TEXT" => SegmentType::Text,
                "USER_MENTION" => SegmentType::UserMention,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SegmentType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SegmentType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SegmentType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ALL_USER_MENTION" => SegmentType::AllUserMention,
                "HASHTAG" => SegmentType::Hashtag,
                "LINE_BREAK" => SegmentType::LineBreak,
                "LINK" => SegmentType::Link,
                "TEXT" => SegmentType::Text,
                "USER_MENTION" => SegmentType::UserMention,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SegmentType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SegmentType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SelectionControl {
        #[doc = "For radio button, at most one of the items will be selected."]
        #[serde(
            rename = "items",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub items: ::std::option::Option<Vec<crate::schemas::SelectionItem>>,
        #[doc = "Label used to be displayed ahead of the selection control. It is optional."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "The name of the text field which is will be used in FormInput."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "If specified, form is submitted when selection changed. If not specified, developer will need to specify a separate button."]
        #[serde(
            rename = "onChange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change: ::std::option::Option<crate::schemas::FormAction>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::SelectionControlType>,
    }
    impl ::google_field_selector::FieldSelector for SelectionControl {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SelectionControl {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SelectionControlType {
        CheckBox,
        Dropdown,
        RadioButton,
        Switch,
    }
    impl SelectionControlType {
        pub fn as_str(self) -> &'static str {
            match self {
                SelectionControlType::CheckBox => "CHECK_BOX",
                SelectionControlType::Dropdown => "DROPDOWN",
                SelectionControlType::RadioButton => "RADIO_BUTTON",
                SelectionControlType::Switch => "SWITCH",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SelectionControlType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SelectionControlType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SelectionControlType, ()> {
            Ok(match s {
                "CHECK_BOX" => SelectionControlType::CheckBox,
                "DROPDOWN" => SelectionControlType::Dropdown,
                "RADIO_BUTTON" => SelectionControlType::RadioButton,
                "SWITCH" => SelectionControlType::Switch,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SelectionControlType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SelectionControlType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SelectionControlType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CHECK_BOX" => SelectionControlType::CheckBox,
                "DROPDOWN" => SelectionControlType::Dropdown,
                "RADIO_BUTTON" => SelectionControlType::RadioButton,
                "SWITCH" => SelectionControlType::Switch,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SelectionControlType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SelectionControlType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SelectionItem {
        #[doc = "If more than one items are selected for RADIO_BUTTON and DROPDOWN, the first selected item is treated as sElected and the after ones are all ignored."]
        #[serde(
            rename = "selected",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub selected: ::std::option::Option<bool>,
        #[doc = "The text to be displayed."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
        #[doc = "The value associated with this item which will be sent back to app scripts. Client should use as a form input value."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SelectionItem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SelectionItem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SessionContext {
        #[doc = "Time at which this activity’s session was authenticated, in seconds since the epoch."]
        #[serde(
            rename = "authTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub auth_time: ::std::option::Option<i64>,
        #[doc = "Gaia ID of the authenticated user when delegate access is active. In such sessions the main gaia ID is that of the delegator, i.e. the account being accessed."]
        #[serde(
            rename = "delegateUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub delegate_user_id: ::std::option::Option<i64>,
        #[doc = "Device User Session ID, see go/dusi."]
        #[serde(
            rename = "dusi",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dusi: ::std::option::Option<String>,
        #[doc = "Imap session context for Bond/Gmail integration"]
        #[serde(
            rename = "imapSessionContext",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub imap_session_context: ::std::option::Option<crate::schemas::ImapSessionContext>,
        #[doc = "OAuth login ID."]
        #[serde(
            rename = "oauthLoginId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oauth_login_id: ::std::option::Option<i32>,
        #[doc = "The devconsole project ID of the developer who authenticated with OAuth."]
        #[serde(
            rename = "oauthProjectId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub oauth_project_id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for SessionContext {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SessionContext {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SessionEvent {
        #[doc = "The initiator of the latest event of the streaming session. It will be set for all user events (`type` is 100-199) and unset for all server events(`type` is 200-299)."]
        #[serde(
            rename = "deviceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub device_id: ::std::option::Option<String>,
        #[doc = "The type of event."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::SessionEventType>,
    }
    impl ::google_field_selector::FieldSelector for SessionEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SessionEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SessionEventType {
        #[doc = "Streaming session is about to be stopped by the server because the session is about to reach the maximum duration."]
        ActiveAboutToStopTooLong,
        #[doc = "Streaming session was cancelled by a user."]
        CancelledByUser,
        #[doc = "Streaming session was cancelled by the server because of a failure during session initialization."]
        CancelledInitializationFailed,
        #[doc = "Streaming session was cancelled by the server because the session initiator left the conference during initialization. When the initiator leaves after the session is started, no event is triggered."]
        CancelledInitiatorLeft,
        #[doc = "This is never used."]
        EventUnspecified,
        #[doc = "Streaming session was started or is being started by a user."]
        StartedByUser,
        #[doc = "Streaming session was stopped because there were no devices left in the conference."]
        StoppedAllDevicesLeft,
        #[doc = "Streaming session was stopped by a user."]
        StoppedByUser,
        #[doc = "Streaming session was stopped because of an internal error."]
        StoppedInternalFailures,
        #[doc = "Streaming session was stopped because the session reached the maximum duration."]
        StoppedTooLong,
    }
    impl SessionEventType {
        pub fn as_str(self) -> &'static str {
            match self {
                SessionEventType::ActiveAboutToStopTooLong => "ACTIVE_ABOUT_TO_STOP_TOO_LONG",
                SessionEventType::CancelledByUser => "CANCELLED_BY_USER",
                SessionEventType::CancelledInitializationFailed => {
                    "CANCELLED_INITIALIZATION_FAILED"
                }
                SessionEventType::CancelledInitiatorLeft => "CANCELLED_INITIATOR_LEFT",
                SessionEventType::EventUnspecified => "EVENT_UNSPECIFIED",
                SessionEventType::StartedByUser => "STARTED_BY_USER",
                SessionEventType::StoppedAllDevicesLeft => "STOPPED_ALL_DEVICES_LEFT",
                SessionEventType::StoppedByUser => "STOPPED_BY_USER",
                SessionEventType::StoppedInternalFailures => "STOPPED_INTERNAL_FAILURES",
                SessionEventType::StoppedTooLong => "STOPPED_TOO_LONG",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SessionEventType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SessionEventType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SessionEventType, ()> {
            Ok(match s {
                "ACTIVE_ABOUT_TO_STOP_TOO_LONG" => SessionEventType::ActiveAboutToStopTooLong,
                "CANCELLED_BY_USER" => SessionEventType::CancelledByUser,
                "CANCELLED_INITIALIZATION_FAILED" => {
                    SessionEventType::CancelledInitializationFailed
                }
                "CANCELLED_INITIATOR_LEFT" => SessionEventType::CancelledInitiatorLeft,
                "EVENT_UNSPECIFIED" => SessionEventType::EventUnspecified,
                "STARTED_BY_USER" => SessionEventType::StartedByUser,
                "STOPPED_ALL_DEVICES_LEFT" => SessionEventType::StoppedAllDevicesLeft,
                "STOPPED_BY_USER" => SessionEventType::StoppedByUser,
                "STOPPED_INTERNAL_FAILURES" => SessionEventType::StoppedInternalFailures,
                "STOPPED_TOO_LONG" => SessionEventType::StoppedTooLong,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SessionEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SessionEventType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SessionEventType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVE_ABOUT_TO_STOP_TOO_LONG" => SessionEventType::ActiveAboutToStopTooLong,
                "CANCELLED_BY_USER" => SessionEventType::CancelledByUser,
                "CANCELLED_INITIALIZATION_FAILED" => {
                    SessionEventType::CancelledInitializationFailed
                }
                "CANCELLED_INITIATOR_LEFT" => SessionEventType::CancelledInitiatorLeft,
                "EVENT_UNSPECIFIED" => SessionEventType::EventUnspecified,
                "STARTED_BY_USER" => SessionEventType::StartedByUser,
                "STOPPED_ALL_DEVICES_LEFT" => SessionEventType::StoppedAllDevicesLeft,
                "STOPPED_BY_USER" => SessionEventType::StoppedByUser,
                "STOPPED_INTERNAL_FAILURES" => SessionEventType::StoppedInternalFailures,
                "STOPPED_TOO_LONG" => SessionEventType::StoppedTooLong,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SessionEventType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SessionEventType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SessionStateInfo {
        #[doc = "Output only. The ack info of the session."]
        #[serde(
            rename = "ackInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ack_info: ::std::option::Option<crate::schemas::AckInfo>,
        #[doc = "Immutable. The language configuration used by this session. When empty, captions will be disabled. It’s a required field for transcription sessions."]
        #[serde(
            rename = "languageConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_config: ::std::option::Option<crate::schemas::LanguageConfig>,
        #[doc = "Output only. The device id of the actor is set if the current state is a result of a user action, is empty otherwise."]
        #[serde(
            rename = "lastActorDeviceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_actor_device_id: ::std::option::Option<String>,
        #[doc = "Output only. The max end time of the session, at this time the session will be force stopped/terminated. Clients are expected to use this timestamp to warn users about the force stop."]
        #[serde(
            rename = "maxEndTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_end_time: ::std::option::Option<String>,
        #[doc = "State of the session."]
        #[serde(
            rename = "sessionState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_state: ::std::option::Option<crate::schemas::SessionStateInfoSessionState>,
        #[doc = "Output only. The reason the session was transitioned to STOPPED state."]
        #[serde(
            rename = "sessionStopReason",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_stop_reason:
            ::std::option::Option<crate::schemas::SessionStateInfoSessionStopReason>,
    }
    impl ::google_field_selector::FieldSelector for SessionStateInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SessionStateInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SessionStateInfoSessionState {
        #[doc = "The session is active/ongoing."]
        Active,
        #[doc = "Unspecified session state."]
        SessionStateUnspecified,
        #[doc = "The session is starting."]
        Starting,
        #[doc = "The session has stopped."]
        Stopped,
    }
    impl SessionStateInfoSessionState {
        pub fn as_str(self) -> &'static str {
            match self {
                SessionStateInfoSessionState::Active => "ACTIVE",
                SessionStateInfoSessionState::SessionStateUnspecified => {
                    "SESSION_STATE_UNSPECIFIED"
                }
                SessionStateInfoSessionState::Starting => "STARTING",
                SessionStateInfoSessionState::Stopped => "STOPPED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SessionStateInfoSessionState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SessionStateInfoSessionState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SessionStateInfoSessionState, ()> {
            Ok(match s {
                "ACTIVE" => SessionStateInfoSessionState::Active,
                "SESSION_STATE_UNSPECIFIED" => {
                    SessionStateInfoSessionState::SessionStateUnspecified
                }
                "STARTING" => SessionStateInfoSessionState::Starting,
                "STOPPED" => SessionStateInfoSessionState::Stopped,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SessionStateInfoSessionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SessionStateInfoSessionState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SessionStateInfoSessionState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVE" => SessionStateInfoSessionState::Active,
                "SESSION_STATE_UNSPECIFIED" => {
                    SessionStateInfoSessionState::SessionStateUnspecified
                }
                "STARTING" => SessionStateInfoSessionState::Starting,
                "STOPPED" => SessionStateInfoSessionState::Stopped,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SessionStateInfoSessionState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SessionStateInfoSessionState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SessionStateInfoSessionStopReason {
        #[doc = "Session stop reason unspecified."]
        SessionStopReasonUnspecified,
        #[doc = "Stopped because there were no devices left in the conference."]
        StoppedAllDevicesLeft,
        #[doc = "Stopped by the server because of an initialization failure."]
        StoppedInitializationFailed,
        #[doc = "Stopped because of an internal error."]
        StoppedInternalFailures,
        #[doc = "Stopped because the session reached the maximum duration."]
        StoppedTooLong,
        #[doc = "Stopped because the broadcast event ended on YouTube."]
        StoppedYouTubeLiveEventEnded,
        #[doc = "Stopped by user action."]
        UserAction,
    }
    impl SessionStateInfoSessionStopReason {
        pub fn as_str(self) -> &'static str {
            match self {
                SessionStateInfoSessionStopReason::SessionStopReasonUnspecified => {
                    "SESSION_STOP_REASON_UNSPECIFIED"
                }
                SessionStateInfoSessionStopReason::StoppedAllDevicesLeft => {
                    "STOPPED_ALL_DEVICES_LEFT"
                }
                SessionStateInfoSessionStopReason::StoppedInitializationFailed => {
                    "STOPPED_INITIALIZATION_FAILED"
                }
                SessionStateInfoSessionStopReason::StoppedInternalFailures => {
                    "STOPPED_INTERNAL_FAILURES"
                }
                SessionStateInfoSessionStopReason::StoppedTooLong => "STOPPED_TOO_LONG",
                SessionStateInfoSessionStopReason::StoppedYouTubeLiveEventEnded => {
                    "STOPPED_YOU_TUBE_LIVE_EVENT_ENDED"
                }
                SessionStateInfoSessionStopReason::UserAction => "USER_ACTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SessionStateInfoSessionStopReason {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SessionStateInfoSessionStopReason {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SessionStateInfoSessionStopReason, ()> {
            Ok(match s {
                "SESSION_STOP_REASON_UNSPECIFIED" => {
                    SessionStateInfoSessionStopReason::SessionStopReasonUnspecified
                }
                "STOPPED_ALL_DEVICES_LEFT" => {
                    SessionStateInfoSessionStopReason::StoppedAllDevicesLeft
                }
                "STOPPED_INITIALIZATION_FAILED" => {
                    SessionStateInfoSessionStopReason::StoppedInitializationFailed
                }
                "STOPPED_INTERNAL_FAILURES" => {
                    SessionStateInfoSessionStopReason::StoppedInternalFailures
                }
                "STOPPED_TOO_LONG" => SessionStateInfoSessionStopReason::StoppedTooLong,
                "STOPPED_YOU_TUBE_LIVE_EVENT_ENDED" => {
                    SessionStateInfoSessionStopReason::StoppedYouTubeLiveEventEnded
                }
                "USER_ACTION" => SessionStateInfoSessionStopReason::UserAction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SessionStateInfoSessionStopReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SessionStateInfoSessionStopReason {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SessionStateInfoSessionStopReason {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "SESSION_STOP_REASON_UNSPECIFIED" => {
                    SessionStateInfoSessionStopReason::SessionStopReasonUnspecified
                }
                "STOPPED_ALL_DEVICES_LEFT" => {
                    SessionStateInfoSessionStopReason::StoppedAllDevicesLeft
                }
                "STOPPED_INITIALIZATION_FAILED" => {
                    SessionStateInfoSessionStopReason::StoppedInitializationFailed
                }
                "STOPPED_INTERNAL_FAILURES" => {
                    SessionStateInfoSessionStopReason::StoppedInternalFailures
                }
                "STOPPED_TOO_LONG" => SessionStateInfoSessionStopReason::StoppedTooLong,
                "STOPPED_YOU_TUBE_LIVE_EVENT_ENDED" => {
                    SessionStateInfoSessionStopReason::StoppedYouTubeLiveEventEnded
                }
                "USER_ACTION" => SessionStateInfoSessionStopReason::UserAction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SessionStateInfoSessionStopReason {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SessionStateInfoSessionStopReason {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Settings {
        #[doc = "The access lock of the meeting space that lets hosts control who can join the meeting."]
        #[serde(
            rename = "accessLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_lock: ::std::option::Option<bool>,
        #[doc = "The access type of the meeting space."]
        #[serde(
            rename = "accessType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_type: ::std::option::Option<crate::schemas::SettingsAccessType>,
        #[doc = "Whether users can join before host in the conferences of this meeting space."]
        #[serde(
            rename = "allowJoiningBeforeHost",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub allow_joining_before_host: ::std::option::Option<bool>,
        #[doc = "Whether attendance report is enabled for the meeting space."]
        #[serde(
            rename = "attendanceReportEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attendance_report_enabled: ::std::option::Option<bool>,
        #[doc = "The chat lock of the meeting space that lets owner control whether the participants can send chat messages."]
        #[serde(
            rename = "chatLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub chat_lock: ::std::option::Option<bool>,
        #[doc = "Whether meeting artifacts will be shared with cohosts."]
        #[serde(
            rename = "cohostArtifactSharingEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cohost_artifact_sharing_enabled: ::std::option::Option<bool>,
        #[doc = "Whether Client-side Encryption is enabled for the meeting space."]
        #[serde(
            rename = "cseEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cse_enabled: ::std::option::Option<bool>,
        #[doc = "Whether the default role is viewer or not."]
        #[serde(
            rename = "defaultAsViewer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_as_viewer: ::std::option::Option<bool>,
        #[doc = "Indicates whether the meeting space is moderated."]
        #[serde(
            rename = "moderationEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub moderation_enabled: ::std::option::Option<bool>,
        #[doc = "The present lock of the meeting space that lets owner control whether the participants can present their screen."]
        #[serde(
            rename = "presentLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub present_lock: ::std::option::Option<bool>,
        #[doc = "The reactions lock of the meeting space that lets owner control whether the participants can send reactions."]
        #[serde(
            rename = "reactionsLock",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reactions_lock: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for Settings {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Settings {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SettingsAccessType {
        #[doc = "Anyone with meeting join information (url, phone access…) can join, no knocking required. (Subject to organization policies)"]
        AccessTypeOpen,
        #[doc = "Only participants invited by a host can automatically join, everyone else must knock and be admitted. (Subject to organization policies) Participants cannot dial out from the meeting. And only hosts can accept knocks."]
        AccessTypeRestricted,
        #[doc = "Members of the Host’s organization, invited external users, and dial-in users can join without knocking, everyone else must knock. (Subject to organization policies)"]
        AccessTypeTrusted,
        #[doc = "Default value. This value is unused."]
        AccessTypeUnspecified,
    }
    impl SettingsAccessType {
        pub fn as_str(self) -> &'static str {
            match self {
                SettingsAccessType::AccessTypeOpen => "ACCESS_TYPE_OPEN",
                SettingsAccessType::AccessTypeRestricted => "ACCESS_TYPE_RESTRICTED",
                SettingsAccessType::AccessTypeTrusted => "ACCESS_TYPE_TRUSTED",
                SettingsAccessType::AccessTypeUnspecified => "ACCESS_TYPE_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SettingsAccessType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SettingsAccessType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SettingsAccessType, ()> {
            Ok(match s {
                "ACCESS_TYPE_OPEN" => SettingsAccessType::AccessTypeOpen,
                "ACCESS_TYPE_RESTRICTED" => SettingsAccessType::AccessTypeRestricted,
                "ACCESS_TYPE_TRUSTED" => SettingsAccessType::AccessTypeTrusted,
                "ACCESS_TYPE_UNSPECIFIED" => SettingsAccessType::AccessTypeUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SettingsAccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SettingsAccessType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SettingsAccessType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACCESS_TYPE_OPEN" => SettingsAccessType::AccessTypeOpen,
                "ACCESS_TYPE_RESTRICTED" => SettingsAccessType::AccessTypeRestricted,
                "ACCESS_TYPE_TRUSTED" => SettingsAccessType::AccessTypeTrusted,
                "ACCESS_TYPE_UNSPECIFIED" => SettingsAccessType::AccessTypeUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SettingsAccessType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SettingsAccessType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ShareScope {
        #[doc = "If scope is DOMAIN, this field contains the dasher domain, for example “google.com”."]
        #[serde(
            rename = "domain",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub domain: ::std::option::Option<String>,
        #[doc = "The scope to which the content was shared."]
        #[serde(
            rename = "scope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scope: ::std::option::Option<crate::schemas::ShareScopeScope>,
    }
    impl ::google_field_selector::FieldSelector for ShareScope {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ShareScope {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ShareScopeScope {
        DasherDomain,
        #[doc = "Viewable by extended circles."]
        Extended,
        #[doc = "Viewable only by a set of people."]
        Limited,
        #[doc = "Only the author can view the post."]
        Private,
        Public,
        Unknown,
    }
    impl ShareScopeScope {
        pub fn as_str(self) -> &'static str {
            match self {
                ShareScopeScope::DasherDomain => "DASHER_DOMAIN",
                ShareScopeScope::Extended => "EXTENDED",
                ShareScopeScope::Limited => "LIMITED",
                ShareScopeScope::Private => "PRIVATE",
                ShareScopeScope::Public => "PUBLIC",
                ShareScopeScope::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ShareScopeScope {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ShareScopeScope {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ShareScopeScope, ()> {
            Ok(match s {
                "DASHER_DOMAIN" => ShareScopeScope::DasherDomain,
                "EXTENDED" => ShareScopeScope::Extended,
                "LIMITED" => ShareScopeScope::Limited,
                "PRIVATE" => ShareScopeScope::Private,
                "PUBLIC" => ShareScopeScope::Public,
                "UNKNOWN" => ShareScopeScope::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ShareScopeScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ShareScopeScope {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ShareScopeScope {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DASHER_DOMAIN" => ShareScopeScope::DasherDomain,
                "EXTENDED" => ShareScopeScope::Extended,
                "LIMITED" => ShareScopeScope::Limited,
                "PRIVATE" => ShareScopeScope::Private,
                "PUBLIC" => ShareScopeScope::Public,
                "UNKNOWN" => ShareScopeScope::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ShareScopeScope {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ShareScopeScope {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct SheetsClientActionMarkup {
        #[serde(
            rename = "customFunctionReturnValueMarkup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub custom_function_return_value_markup:
            ::std::option::Option<crate::schemas::CustomFunctionReturnValueMarkup>,
    }
    impl ::google_field_selector::FieldSelector for SheetsClientActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SheetsClientActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SigningKeyPossessorProto {
        #[doc = "This value must be from the KeyMetadata.Type enum in keymaster.proto."]
        #[serde(
            rename = "keymasterKeyType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub keymaster_key_type: ::std::option::Option<i32>,
        #[doc = "The actual verification key bytes corresponding to the above type."]
        #[serde(
            rename = "serializedVerificationKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub serialized_verification_key: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "The binary serialized Keymaster SerializedReader of a public keyset. The keyset must contain exactly one key. N.B.: If this field is populated, serialized_verification_key should be set to the empty string and keymaster_key_type should be set to zero."]
        #[serde(
            rename = "serializedVerificationKeyset",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub serialized_verification_keyset: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector for SigningKeyPossessorProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SigningKeyPossessorProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SimpleSecretHolderProto {
        #[doc = "A descriptive label to help identify a relevant ACL entry or otherwise disambiguate this instance."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<crate::schemas::SimpleSecretLabelProto>,
    }
    impl ::google_field_selector::FieldSelector for SimpleSecretHolderProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SimpleSecretHolderProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SimpleSecretLabelProto {
        #[doc = "\\*\\*\\*DEPRECATED (3-Oct-2011) *** This field should be deleted when code stops using CAP_TOKEN labels. Used when type = CAP_TOKEN. When a CAP_TOKEN label appears in a SimpleSecretHolder Principal, |capability_id| must be filled in to identify one of the capabilities on the ACL. When a CAP_TOKEN label appears in a SimpleSecret Authenticator, it is NOT necessary to fill in |capability_id| – ACL Service will find the ID by searching all capabilities on the ACL for one associated with the token given by the SimpleSecret’s secret data. If |capability_id| is specified, though, then the Authenticator will only be accepted if it actually matches that particular token ID."]
        #[serde(
            rename = "capabilityId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub capability_id: ::std::option::Option<i32>,
        #[doc = "Used when type = GENERIC_SECRET"]
        #[serde(
            rename = "genericLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub generic_label: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "Used when type == INVITE."]
        #[serde(
            rename = "inviteId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub invite_id: ::std::option::Option<i64>,
        #[doc = "This is optional because required enums cannot be extended."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::SimpleSecretLabelProtoType>,
    }
    impl ::google_field_selector::FieldSelector for SimpleSecretLabelProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SimpleSecretLabelProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SimpleSecretLabelProtoType {
        #[doc = "The singleton auth key for a common-sharing ACL. No other fields of SimpleSecretLabelProto need to be filled in, since there is only one of these per ACL. The corresponding secret is the auth key encoded in 64-bit big-endian."]
        AuthKey,
        #[doc = "***DEPRECATED (3-Oct-2011)*** Use the new CapTokenProto and CapTokenHolderProto instead. A capability token. The corresponding secret is an arbitrary-length random byte string (recommended: 128 bits). |capability_id| may be filled in (see below). See CapTokenMetadata in acl.proto."]
        CapToken,
        #[doc = "A generic secret value. Do not use this if any more specific type is appropriate."]
        GenericSecret,
        #[doc = "Used as a default value."]
        Invalid,
        #[doc = "A common-sharing invite token. |invite_id| (below) must be set to identify the invite. The corresponding secret is the SecretMaterial, as defined by InviteToken.SecretMaterial in acl.proto, encoded in 64-bit big-endian. If there is no SecretMaterial, the secret should be omitted; in this case the invite ID itself is the secret, which is less secure."]
        Invite,
        #[doc = "Identifies a principal that can perform a successful REKE handshake. The holder is not authenticated by presenting a SimpleSecretProto, but rather by knowing either the REKE resumption ticket secret or the private key corresponding to a public key specified outside the PrincipalProto. For more information, see: http://goto.google.com/loas2cert"]
        Reke,
    }
    impl SimpleSecretLabelProtoType {
        pub fn as_str(self) -> &'static str {
            match self {
                SimpleSecretLabelProtoType::AuthKey => "AUTH_KEY",
                SimpleSecretLabelProtoType::CapToken => "CAP_TOKEN",
                SimpleSecretLabelProtoType::GenericSecret => "GENERIC_SECRET",
                SimpleSecretLabelProtoType::Invalid => "INVALID",
                SimpleSecretLabelProtoType::Invite => "INVITE",
                SimpleSecretLabelProtoType::Reke => "REKE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SimpleSecretLabelProtoType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SimpleSecretLabelProtoType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SimpleSecretLabelProtoType, ()> {
            Ok(match s {
                "AUTH_KEY" => SimpleSecretLabelProtoType::AuthKey,
                "CAP_TOKEN" => SimpleSecretLabelProtoType::CapToken,
                "GENERIC_SECRET" => SimpleSecretLabelProtoType::GenericSecret,
                "INVALID" => SimpleSecretLabelProtoType::Invalid,
                "INVITE" => SimpleSecretLabelProtoType::Invite,
                "REKE" => SimpleSecretLabelProtoType::Reke,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SimpleSecretLabelProtoType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SimpleSecretLabelProtoType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SimpleSecretLabelProtoType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AUTH_KEY" => SimpleSecretLabelProtoType::AuthKey,
                "CAP_TOKEN" => SimpleSecretLabelProtoType::CapToken,
                "GENERIC_SECRET" => SimpleSecretLabelProtoType::GenericSecret,
                "INVALID" => SimpleSecretLabelProtoType::Invalid,
                "INVITE" => SimpleSecretLabelProtoType::Invite,
                "REKE" => SimpleSecretLabelProtoType::Reke,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SimpleSecretLabelProtoType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SimpleSecretLabelProtoType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SlashCommandMetadata {
        #[doc = "Hint string for the arguments expected by the slash command."]
        #[serde(
            rename = "argumentsHint",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub arguments_hint: ::std::option::Option<String>,
        #[doc = "Unique id for the slash command."]
        #[serde(
            rename = "commandId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub command_id: ::std::option::Option<i64>,
        #[doc = "Name of the slash command."]
        #[serde(
            rename = "commandName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub command_name: ::std::option::Option<String>,
        #[doc = "ID of the bot which owns the slash command."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<crate::schemas::UserId>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::SlashCommandMetadataType>,
        #[doc = "Whether or not this slash command should trigger a dialog."]
        #[serde(
            rename = "triggersDialog",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub triggers_dialog: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for SlashCommandMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SlashCommandMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SlashCommandMetadataType {
        #[doc = "If a bot is added by a Slash Command, it means the bot was invoked by the user but hasn’t yet been added to the group. Attaching an ADD annotation both add and invoke the bot."]
        Add,
        #[doc = "Server-generated slash command metadata, for clients to strikethrough."]
        FailedToAdd,
        Invoke,
        #[doc = "Default value for the enum. DO NOT USE."]
        TypeUnspecified,
    }
    impl SlashCommandMetadataType {
        pub fn as_str(self) -> &'static str {
            match self {
                SlashCommandMetadataType::Add => "ADD",
                SlashCommandMetadataType::FailedToAdd => "FAILED_TO_ADD",
                SlashCommandMetadataType::Invoke => "INVOKE",
                SlashCommandMetadataType::TypeUnspecified => "TYPE_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SlashCommandMetadataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SlashCommandMetadataType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SlashCommandMetadataType, ()> {
            Ok(match s {
                "ADD" => SlashCommandMetadataType::Add,
                "FAILED_TO_ADD" => SlashCommandMetadataType::FailedToAdd,
                "INVOKE" => SlashCommandMetadataType::Invoke,
                "TYPE_UNSPECIFIED" => SlashCommandMetadataType::TypeUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SlashCommandMetadataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SlashCommandMetadataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SlashCommandMetadataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADD" => SlashCommandMetadataType::Add,
                "FAILED_TO_ADD" => SlashCommandMetadataType::FailedToAdd,
                "INVOKE" => SlashCommandMetadataType::Invoke,
                "TYPE_UNSPECIFIED" => SlashCommandMetadataType::TypeUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SlashCommandMetadataType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SlashCommandMetadataType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Snippet {
        #[doc = "The matched ranges in the snippet."]
        #[serde(
            rename = "matchRanges",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub match_ranges: ::std::option::Option<Vec<crate::schemas::MatchRange>>,
        #[doc = "The snippet of the document. The snippet of the document. May contain escaped HTML character that should be unescaped prior to rendering."]
        #[serde(
            rename = "snippet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snippet: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Snippet {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Snippet {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SocialCommonAttachmentAttachment {
        #[doc = "An embed represents an external entity. See go/es-embeds."]
        #[serde(
            rename = "embedItem",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub embed_item: ::std::option::Option<crate::schemas::EmbedClientItem>,
        #[doc = "An id to uniquely identify an attachment when several attachments are in a collection."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SocialCommonAttachmentAttachment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SocialCommonAttachmentAttachment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SocialGraphNodeProto {
        #[doc = "The fields from ccc/socialgraph/socialgraphnode.proto:SgnNode that uniquely identify a social graph node. The ‘ident’ field is not included here because its value can be changed."]
        #[serde(
            rename = "sgnDomain",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sgn_domain: ::std::option::Option<String>,
        #[serde(
            rename = "sgnPk",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sgn_pk: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SocialGraphNodeProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SocialGraphNodeProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SortOptions {
        #[doc = "The name of the operator corresponding to the field to sort on. The corresponding property must be marked as sortable."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
        #[doc = "Ascending is the default sort order"]
        #[serde(
            rename = "sortOrder",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sort_order: ::std::option::Option<crate::schemas::SortOptionsSortOrder>,
    }
    impl ::google_field_selector::FieldSelector for SortOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SortOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SortOptionsSortOrder {
        Ascending,
        Descending,
    }
    impl SortOptionsSortOrder {
        pub fn as_str(self) -> &'static str {
            match self {
                SortOptionsSortOrder::Ascending => "ASCENDING",
                SortOptionsSortOrder::Descending => "DESCENDING",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SortOptionsSortOrder {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SortOptionsSortOrder {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SortOptionsSortOrder, ()> {
            Ok(match s {
                "ASCENDING" => SortOptionsSortOrder::Ascending,
                "DESCENDING" => SortOptionsSortOrder::Descending,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SortOptionsSortOrder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SortOptionsSortOrder {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SortOptionsSortOrder {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ASCENDING" => SortOptionsSortOrder::Ascending,
                "DESCENDING" => SortOptionsSortOrder::Descending,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SortOptionsSortOrder {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SortOptionsSortOrder {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Source {
        #[doc = "Source name for content indexed by the Indexing API."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Predefined content source for Google Apps."]
        #[serde(
            rename = "predefinedSource",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub predefined_source: ::std::option::Option<crate::schemas::SourcePredefinedSource>,
    }
    impl ::google_field_selector::FieldSelector for Source {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Source {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SourcePredefinedSource {
        GoogleCalendar,
        GoogleDrive,
        GoogleGmail,
        GoogleGroups,
        GoogleKeep,
        GoogleSites,
        None,
        #[doc = "Suggests people in the organization. Only valid when used with the suggest API. Results in an error when used in the query API."]
        Person,
        #[doc = "Suggests queries issued by the user in the past. Only valid when used with the suggest API. Ignored when used in the query API."]
        QueryHistory,
    }
    impl SourcePredefinedSource {
        pub fn as_str(self) -> &'static str {
            match self {
                SourcePredefinedSource::GoogleCalendar => "GOOGLE_CALENDAR",
                SourcePredefinedSource::GoogleDrive => "GOOGLE_DRIVE",
                SourcePredefinedSource::GoogleGmail => "GOOGLE_GMAIL",
                SourcePredefinedSource::GoogleGroups => "GOOGLE_GROUPS",
                SourcePredefinedSource::GoogleKeep => "GOOGLE_KEEP",
                SourcePredefinedSource::GoogleSites => "GOOGLE_SITES",
                SourcePredefinedSource::None => "NONE",
                SourcePredefinedSource::Person => "PERSON",
                SourcePredefinedSource::QueryHistory => "QUERY_HISTORY",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SourcePredefinedSource {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SourcePredefinedSource {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SourcePredefinedSource, ()> {
            Ok(match s {
                "GOOGLE_CALENDAR" => SourcePredefinedSource::GoogleCalendar,
                "GOOGLE_DRIVE" => SourcePredefinedSource::GoogleDrive,
                "GOOGLE_GMAIL" => SourcePredefinedSource::GoogleGmail,
                "GOOGLE_GROUPS" => SourcePredefinedSource::GoogleGroups,
                "GOOGLE_KEEP" => SourcePredefinedSource::GoogleKeep,
                "GOOGLE_SITES" => SourcePredefinedSource::GoogleSites,
                "NONE" => SourcePredefinedSource::None,
                "PERSON" => SourcePredefinedSource::Person,
                "QUERY_HISTORY" => SourcePredefinedSource::QueryHistory,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SourcePredefinedSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SourcePredefinedSource {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SourcePredefinedSource {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "GOOGLE_CALENDAR" => SourcePredefinedSource::GoogleCalendar,
                "GOOGLE_DRIVE" => SourcePredefinedSource::GoogleDrive,
                "GOOGLE_GMAIL" => SourcePredefinedSource::GoogleGmail,
                "GOOGLE_GROUPS" => SourcePredefinedSource::GoogleGroups,
                "GOOGLE_KEEP" => SourcePredefinedSource::GoogleKeep,
                "GOOGLE_SITES" => SourcePredefinedSource::GoogleSites,
                "NONE" => SourcePredefinedSource::None,
                "PERSON" => SourcePredefinedSource::Person,
                "QUERY_HISTORY" => SourcePredefinedSource::QueryHistory,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SourcePredefinedSource {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SourcePredefinedSource {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SourceConfig {
        #[doc = "The crowding configuration for the source."]
        #[serde(
            rename = "crowdingConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub crowding_config: ::std::option::Option<crate::schemas::SourceCrowdingConfig>,
        #[doc = "The scoring configuration for the source."]
        #[serde(
            rename = "scoringConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scoring_config: ::std::option::Option<crate::schemas::SourceScoringConfig>,
        #[doc = "The source for which this configuration is to be used."]
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source: ::std::option::Option<crate::schemas::Source>,
    }
    impl ::google_field_selector::FieldSelector for SourceConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SourceConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SourceCrowdingConfig {
        #[doc = "Maximum number of results allowed from a datasource in a result page as long as results from other sources are not exhausted. Value specified must not be negative. A default value is used if this value is equal to 0. To disable crowding, set the value greater than 100."]
        #[serde(
            rename = "numResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_results: ::std::option::Option<i32>,
        #[doc = "Maximum number of suggestions allowed from a source. No limits will be set on results if this value is less than or equal to 0."]
        #[serde(
            rename = "numSuggestions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_suggestions: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for SourceCrowdingConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SourceCrowdingConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SourceResultCount {
        #[doc = "Whether there are more search results for this source."]
        #[serde(
            rename = "hasMoreResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub has_more_results: ::std::option::Option<bool>,
        #[doc = "The estimated result count for this source."]
        #[serde(
            rename = "resultCountEstimate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub result_count_estimate: ::std::option::Option<i64>,
        #[doc = "The exact result count for this source."]
        #[serde(
            rename = "resultCountExact",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub result_count_exact: ::std::option::Option<i64>,
        #[doc = "The source the result count information is associated with."]
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source: ::std::option::Option<crate::schemas::Source>,
    }
    impl ::google_field_selector::FieldSelector for SourceResultCount {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SourceResultCount {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SourceScoringConfig {
        #[doc = "Importance of the source."]
        #[serde(
            rename = "sourceImportance",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source_importance:
            ::std::option::Option<crate::schemas::SourceScoringConfigSourceImportance>,
    }
    impl ::google_field_selector::FieldSelector for SourceScoringConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SourceScoringConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SourceScoringConfigSourceImportance {
        Default,
        High,
        Low,
    }
    impl SourceScoringConfigSourceImportance {
        pub fn as_str(self) -> &'static str {
            match self {
                SourceScoringConfigSourceImportance::Default => "DEFAULT",
                SourceScoringConfigSourceImportance::High => "HIGH",
                SourceScoringConfigSourceImportance::Low => "LOW",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SourceScoringConfigSourceImportance {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SourceScoringConfigSourceImportance {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SourceScoringConfigSourceImportance, ()> {
            Ok(match s {
                "DEFAULT" => SourceScoringConfigSourceImportance::Default,
                "HIGH" => SourceScoringConfigSourceImportance::High,
                "LOW" => SourceScoringConfigSourceImportance::Low,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SourceScoringConfigSourceImportance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SourceScoringConfigSourceImportance {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SourceScoringConfigSourceImportance {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEFAULT" => SourceScoringConfigSourceImportance::Default,
                "HIGH" => SourceScoringConfigSourceImportance::High,
                "LOW" => SourceScoringConfigSourceImportance::Low,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SourceScoringConfigSourceImportance {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SourceScoringConfigSourceImportance {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SpaceId {
        #[doc = "Unique, immutable ID of the Space"]
        #[serde(
            rename = "spaceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub space_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SpaceId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SpaceId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SpellResult {
        #[doc = "The suggested spelling of the query."]
        #[serde(
            rename = "suggestedQuery",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suggested_query: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SpellResult {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SpellResult {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SquareProto {
        #[doc = "The type of Square members to consider, e.g. “all members” vs. “owners” vs. “admins”. These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See square.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with square. Currently required."]
        #[serde(
            rename = "memberType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub member_type: ::std::option::Option<i32>,
        #[doc = "Currently required."]
        #[serde(
            rename = "squareId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub square_id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for SquareProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SquareProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct StartUploadItemRequest {
        #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
        #[serde(
            rename = "connectorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connector_name: ::std::option::Option<String>,
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
    }
    impl ::google_field_selector::FieldSelector for StartUploadItemRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StartUploadItemRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct Status {
        #[doc = "The status code, which should be an enum value of google.rpc.Code."]
        #[serde(
            rename = "code",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub code: ::std::option::Option<i32>,
        #[doc = "A list of messages that carry the error details. There is a common set of message types for APIs to use."]
        #[serde(
            rename = "details",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub details:
            ::std::option::Option<Vec<::std::collections::BTreeMap<String, ::serde_json::Value>>>,
        #[doc = "A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."]
        #[serde(
            rename = "message",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Status {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Status {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct StoredParticipantId {
        #[serde(
            rename = "gaiaId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub gaia_id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for StoredParticipantId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StoredParticipantId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct StreamViewerStats {
        #[doc = "The estimate of the current viewer count."]
        #[serde(
            rename = "estimatedViewerCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub estimated_viewer_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for StreamViewerStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StreamViewerStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct StreamingSessionInfo {
        #[doc = "The application type of the current streaming session."]
        #[serde(
            rename = "applicationType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub application_type:
            ::std::option::Option<crate::schemas::StreamingSessionInfoApplicationType>,
        #[doc = "The latest streaming session event. This can be used by clients to help explain what is going on, why recording stopped, etc. This will always be set to a valid event and consistent with the status. It can be set when current session is inactive to indicate latest event that makes current session to become inactive."]
        #[serde(
            rename = "latestSessionEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub latest_session_event: ::std::option::Option<crate::schemas::SessionEvent>,
        #[doc = "The display name of the owner of the recording output. It’s only set when there will be uploaded recordings. Currently, it’s only set when application type is RECORDING or GLIVE_STREAM."]
        #[serde(
            rename = "ownerDisplayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub owner_display_name: ::std::option::Option<String>,
        #[doc = "This is the REST name and unique identifier of this streaming session and has the form `spaces//recordings/` This is returned whenever status is either `STARTING` or `STARTED`."]
        #[serde(
            rename = "sessionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_id: ::std::option::Option<String>,
        #[doc = "The current status of this streaming session. This can be used by clients to show session status indicator and/or notification."]
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status: ::std::option::Option<crate::schemas::StreamingSessionInfoStatus>,
        #[doc = "When true, this recording may be used for training new transcription models."]
        #[serde(
            rename = "trainingEnabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub training_enabled: ::std::option::Option<bool>,
        #[doc = "The policy that controls who can view the broadcast. This setting applies for broadcast session."]
        #[serde(
            rename = "viewerAccessPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub viewer_access_policy:
            ::std::option::Option<crate::schemas::StreamingSessionInfoViewerAccessPolicy>,
        #[doc = "Contains information about viewers of the livestream. It is only set when application type is BROADCAST."]
        #[serde(
            rename = "viewerStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub viewer_stats: ::std::option::Option<crate::schemas::StreamViewerStats>,
    }
    impl ::google_field_selector::FieldSelector for StreamingSessionInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StreamingSessionInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum StreamingSessionInfoApplicationType {
        #[doc = "A meeting broadcast."]
        Broadcast,
        #[doc = "A *Google Live* managed stream."]
        GliveStream,
        #[doc = "A meeting recording saved to a video file in Google Drive."]
        Recording,
        #[doc = "This is never used."]
        RecordingApplicationTypeUnspecified,
    }
    impl StreamingSessionInfoApplicationType {
        pub fn as_str(self) -> &'static str {
            match self {
                StreamingSessionInfoApplicationType::Broadcast => "BROADCAST",
                StreamingSessionInfoApplicationType::GliveStream => "GLIVE_STREAM",
                StreamingSessionInfoApplicationType::Recording => "RECORDING",
                StreamingSessionInfoApplicationType::RecordingApplicationTypeUnspecified => {
                    "RECORDING_APPLICATION_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for StreamingSessionInfoApplicationType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for StreamingSessionInfoApplicationType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<StreamingSessionInfoApplicationType, ()> {
            Ok(match s {
                "BROADCAST" => StreamingSessionInfoApplicationType::Broadcast,
                "GLIVE_STREAM" => StreamingSessionInfoApplicationType::GliveStream,
                "RECORDING" => StreamingSessionInfoApplicationType::Recording,
                "RECORDING_APPLICATION_TYPE_UNSPECIFIED" => {
                    StreamingSessionInfoApplicationType::RecordingApplicationTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for StreamingSessionInfoApplicationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for StreamingSessionInfoApplicationType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StreamingSessionInfoApplicationType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BROADCAST" => StreamingSessionInfoApplicationType::Broadcast,
                "GLIVE_STREAM" => StreamingSessionInfoApplicationType::GliveStream,
                "RECORDING" => StreamingSessionInfoApplicationType::Recording,
                "RECORDING_APPLICATION_TYPE_UNSPECIFIED" => {
                    StreamingSessionInfoApplicationType::RecordingApplicationTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for StreamingSessionInfoApplicationType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StreamingSessionInfoApplicationType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum StreamingSessionInfoStatus {
        #[doc = "The streaming session is inactive. This means either it’s not started yet or it’s already stopped."]
        Inactive,
        #[doc = "The streaming session is live. Any media sent to the conference may be included in the resulting recording/broadcast."]
        Live,
        #[doc = "The streaming session is about to begin. The status will be updated to LIVE when the streaming session actually starts, which happens when all the backend plumbing is set up."]
        Starting,
        #[doc = "This value is never used."]
        StatusUnspecified,
    }
    impl StreamingSessionInfoStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                StreamingSessionInfoStatus::Inactive => "INACTIVE",
                StreamingSessionInfoStatus::Live => "LIVE",
                StreamingSessionInfoStatus::Starting => "STARTING",
                StreamingSessionInfoStatus::StatusUnspecified => "STATUS_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for StreamingSessionInfoStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for StreamingSessionInfoStatus {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<StreamingSessionInfoStatus, ()> {
            Ok(match s {
                "INACTIVE" => StreamingSessionInfoStatus::Inactive,
                "LIVE" => StreamingSessionInfoStatus::Live,
                "STARTING" => StreamingSessionInfoStatus::Starting,
                "STATUS_UNSPECIFIED" => StreamingSessionInfoStatus::StatusUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for StreamingSessionInfoStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for StreamingSessionInfoStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StreamingSessionInfoStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "INACTIVE" => StreamingSessionInfoStatus::Inactive,
                "LIVE" => StreamingSessionInfoStatus::Live,
                "STARTING" => StreamingSessionInfoStatus::Starting,
                "STATUS_UNSPECIFIED" => StreamingSessionInfoStatus::StatusUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for StreamingSessionInfoStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StreamingSessionInfoStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum StreamingSessionInfoViewerAccessPolicy {
        #[doc = "Used only when broadcast is not enabled, or an unknown enum value is used."]
        BroadcastingAccessPolicyUnspecified,
        #[doc = "Only authenticated Google accounts belonging to the same organization as the meeting organizer can access the broadcast."]
        Organization,
        #[doc = "Anyone with the broadcast view URL can access the broadcast."]
        Public,
    }
    impl StreamingSessionInfoViewerAccessPolicy {
        pub fn as_str(self) -> &'static str {
            match self {
                StreamingSessionInfoViewerAccessPolicy::BroadcastingAccessPolicyUnspecified => {
                    "BROADCASTING_ACCESS_POLICY_UNSPECIFIED"
                }
                StreamingSessionInfoViewerAccessPolicy::Organization => "ORGANIZATION",
                StreamingSessionInfoViewerAccessPolicy::Public => "PUBLIC",
            }
        }
    }
    impl ::std::convert::AsRef<str> for StreamingSessionInfoViewerAccessPolicy {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for StreamingSessionInfoViewerAccessPolicy {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<StreamingSessionInfoViewerAccessPolicy, ()> {
            Ok(match s {
                "BROADCASTING_ACCESS_POLICY_UNSPECIFIED" => {
                    StreamingSessionInfoViewerAccessPolicy::BroadcastingAccessPolicyUnspecified
                }
                "ORGANIZATION" => StreamingSessionInfoViewerAccessPolicy::Organization,
                "PUBLIC" => StreamingSessionInfoViewerAccessPolicy::Public,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for StreamingSessionInfoViewerAccessPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for StreamingSessionInfoViewerAccessPolicy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StreamingSessionInfoViewerAccessPolicy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BROADCASTING_ACCESS_POLICY_UNSPECIFIED" => {
                    StreamingSessionInfoViewerAccessPolicy::BroadcastingAccessPolicyUnspecified
                }
                "ORGANIZATION" => StreamingSessionInfoViewerAccessPolicy::Organization,
                "PUBLIC" => StreamingSessionInfoViewerAccessPolicy::Public,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for StreamingSessionInfoViewerAccessPolicy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StreamingSessionInfoViewerAccessPolicy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct StructuredDataObject {
        #[doc = "The properties for the object. The maximum number of elements is 1000."]
        #[serde(
            rename = "properties",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub properties: ::std::option::Option<Vec<crate::schemas::NamedProperty>>,
    }
    impl ::google_field_selector::FieldSelector for StructuredDataObject {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StructuredDataObject {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct StructuredResult {
        #[doc = "Representation of a person"]
        #[serde(
            rename = "person",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub person: ::std::option::Option<crate::schemas::Person>,
    }
    impl ::google_field_selector::FieldSelector for StructuredResult {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for StructuredResult {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct SuggestRequest {
        #[doc = "The sources to use for suggestions. If not specified, the data sources are taken from the current search application. NOTE: Suggestions are only supported for the following sources: * Third-party data sources * PredefinedSource.PERSON * PredefinedSource.GOOGLE_DRIVE"]
        #[serde(
            rename = "dataSourceRestrictions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_source_restrictions:
            ::std::option::Option<Vec<crate::schemas::DataSourceRestriction>>,
        #[doc = "Partial query for which autocomplete suggestions will be shown. For example, if the query is “sea”, then the server might return “season”, “search”, “seagull” and so on."]
        #[serde(
            rename = "query",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query: ::std::option::Option<String>,
        #[doc = "Request options, such as the search application and user timezone."]
        #[serde(
            rename = "requestOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_options: ::std::option::Option<crate::schemas::RequestOptions>,
    }
    impl ::google_field_selector::FieldSelector for SuggestRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SuggestRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SuggestResponse {
        #[doc = "List of suggestions."]
        #[serde(
            rename = "suggestResults",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suggest_results: ::std::option::Option<Vec<crate::schemas::SuggestResult>>,
    }
    impl ::google_field_selector::FieldSelector for SuggestResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SuggestResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SuggestResult {
        #[doc = "This is present when the suggestion indicates a person. It contains more information about the person - like their email ID, name etc."]
        #[serde(
            rename = "peopleSuggestion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub people_suggestion: ::std::option::Option<crate::schemas::PeopleSuggestion>,
        #[doc = "This field will be present if the suggested query is a word/phrase completion."]
        #[serde(
            rename = "querySuggestion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub query_suggestion: ::std::option::Option<crate::schemas::QuerySuggestion>,
        #[doc = "The source of the suggestion."]
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source: ::std::option::Option<crate::schemas::Source>,
        #[doc = "The suggested query that will be used for search, when the user clicks on the suggestion"]
        #[serde(
            rename = "suggestedQuery",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suggested_query: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SuggestResult {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SuggestResult {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SupportUrls {
        #[doc = "Link to the admin configuration webpage for the bot. Configured by Pantheon, may be empty."]
        #[serde(
            rename = "adminConfigUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub admin_config_url: ::std::option::Option<String>,
        #[doc = "Link to the deletion policy webpage for the bot. Configured by Pantheon, may be empty."]
        #[serde(
            rename = "deletionPolicyUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deletion_policy_url: ::std::option::Option<String>,
        #[doc = "Link to GWM page of the app. May be empty."]
        #[serde(
            rename = "gwmUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gwm_url: ::std::option::Option<String>,
        #[doc = "Link to the privacy policy webpage for the bot. May be empty."]
        #[serde(
            rename = "privacyPolicyUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub privacy_policy_url: ::std::option::Option<String>,
        #[doc = "Link to the setup webpage for the bot. Configured by Pantheon, may be empty."]
        #[serde(
            rename = "setupUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub setup_url: ::std::option::Option<String>,
        #[doc = "Link to the support webpage for the developer of the bot. May be empty."]
        #[serde(
            rename = "supportUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub support_url: ::std::option::Option<String>,
        #[doc = "Link to the terms of service webpage for the bot. May be empty."]
        #[serde(
            rename = "tosUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tos_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SupportUrls {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SupportUrls {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SwitchWidget {
        #[serde(
            rename = "controlType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub control_type: ::std::option::Option<crate::schemas::SwitchWidgetControlType>,
        #[doc = "The name of the switch widget which is will be used in FormInput."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "onChange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change: ::std::option::Option<crate::schemas::FormAction>,
        #[serde(
            rename = "selected",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub selected: ::std::option::Option<bool>,
        #[doc = "The value is what is passed back in apps script callback."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for SwitchWidget {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SwitchWidget {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SwitchWidgetControlType {
        Checkbox,
        Switch,
        Unspecified,
    }
    impl SwitchWidgetControlType {
        pub fn as_str(self) -> &'static str {
            match self {
                SwitchWidgetControlType::Checkbox => "CHECKBOX",
                SwitchWidgetControlType::Switch => "SWITCH",
                SwitchWidgetControlType::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SwitchWidgetControlType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SwitchWidgetControlType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SwitchWidgetControlType, ()> {
            Ok(match s {
                "CHECKBOX" => SwitchWidgetControlType::Checkbox,
                "SWITCH" => SwitchWidgetControlType::Switch,
                "UNSPECIFIED" => SwitchWidgetControlType::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SwitchWidgetControlType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SwitchWidgetControlType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SwitchWidgetControlType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CHECKBOX" => SwitchWidgetControlType::Checkbox,
                "SWITCH" => SwitchWidgetControlType::Switch,
                "UNSPECIFIED" => SwitchWidgetControlType::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SwitchWidgetControlType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SwitchWidgetControlType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TaskActionMarkup {
        #[serde(
            rename = "reloadTasks",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reload_tasks: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for TaskActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TaskActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TextButton {
        #[doc = "The alternative text used for accessibility Next field number: 7."]
        #[serde(
            rename = "altText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alt_text: ::std::option::Option<String>,
        #[doc = "Optional color of the button’s background in RAISE mode. The default is the secondary color from addon’s manifest."]
        #[serde(
            rename = "backgroundColor",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub background_color: ::std::option::Option<String>,
        #[serde(
            rename = "disabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disabled: ::std::option::Option<bool>,
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::OnClick>,
        #[serde(
            rename = "style",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub style: ::std::option::Option<crate::schemas::TextButtonStyle>,
        #[doc = "Text color can be set via HTML markup."]
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TextButton {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextButton {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TextButtonStyle {
        #[doc = "Button with solid background."]
        Filled,
        #[doc = "Simple text button with ripple touch feedback."]
        Text,
        Unspecified,
    }
    impl TextButtonStyle {
        pub fn as_str(self) -> &'static str {
            match self {
                TextButtonStyle::Filled => "FILLED",
                TextButtonStyle::Text => "TEXT",
                TextButtonStyle::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TextButtonStyle {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TextButtonStyle {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<TextButtonStyle, ()> {
            Ok(match s {
                "FILLED" => TextButtonStyle::Filled,
                "TEXT" => TextButtonStyle::Text,
                "UNSPECIFIED" => TextButtonStyle::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TextButtonStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TextButtonStyle {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TextButtonStyle {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FILLED" => TextButtonStyle::Filled,
                "TEXT" => TextButtonStyle::Text,
                "UNSPECIFIED" => TextButtonStyle::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TextButtonStyle {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextButtonStyle {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TextField {
        #[doc = "The initial set of auto complete items without any user input."]
        #[serde(
            rename = "autoComplete",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auto_complete: ::std::option::Option<crate::schemas::AutoComplete>,
        #[doc = "The refresh function which returns AutoComplete based on the user’s input text. If the callback is not specified, auto complete will be purely done in client side based on the auto_complete items."]
        #[serde(
            rename = "autoCompleteCallback",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auto_complete_callback: ::std::option::Option<crate::schemas::FormAction>,
        #[doc = "When set to true, a user can input multiple auto-complet items."]
        #[serde(
            rename = "autoCompleteMultipleSelections",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auto_complete_multiple_selections: ::std::option::Option<bool>,
        #[serde(
            rename = "hintText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hint_text: ::std::option::Option<String>,
        #[doc = "One of label or hint_text is required to be specified by the developers."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[serde(
            rename = "maxLines",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_lines: ::std::option::Option<i32>,
        #[doc = "The name of the text field which is will be used in FormInput."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "onChange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_change: ::std::option::Option<crate::schemas::FormAction>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::TextFieldType>,
        #[doc = "The default value when no input from user."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TextField {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextField {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TextFieldType {
        MultipleLine,
        SingleLine,
    }
    impl TextFieldType {
        pub fn as_str(self) -> &'static str {
            match self {
                TextFieldType::MultipleLine => "MULTIPLE_LINE",
                TextFieldType::SingleLine => "SINGLE_LINE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TextFieldType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TextFieldType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<TextFieldType, ()> {
            Ok(match s {
                "MULTIPLE_LINE" => TextFieldType::MultipleLine,
                "SINGLE_LINE" => TextFieldType::SingleLine,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TextFieldType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TextFieldType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TextFieldType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "MULTIPLE_LINE" => TextFieldType::MultipleLine,
                "SINGLE_LINE" => TextFieldType::SingleLine,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TextFieldType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextFieldType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TextKeyValue {
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[serde(
            rename = "onClick",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub on_click: ::std::option::Option<crate::schemas::OnClick>,
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TextKeyValue {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextKeyValue {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TextOperatorOptions {
        #[doc = "If true, the text value is tokenized as one atomic value in operator searches and facet matches. For example, if the operator name is “genre” and the value is “science-fiction” the query restrictions “genre:science” and “genre:fiction” doesn’t match the item; “genre:science-fiction” does. Text value matching is case-sensitive and does not remove special characters. If false, the text is tokenized. For example, if the value is “science-fiction” the queries “genre:science” and “genre:fiction” matches the item."]
        #[serde(
            rename = "exactMatchWithOperator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub exact_match_with_operator: ::std::option::Option<bool>,
        #[doc = "Indicates the operator name required in the query in order to isolate the text property. For example, if operatorName is *subject* and the property’s name is *subjectLine*, then queries like *subject:<value>* show results only where the value of the property named *subjectLine* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any text properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TextOperatorOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextOperatorOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TextParagraph {
        #[serde(
            rename = "text",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TextParagraph {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextParagraph {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TextPropertyOptions {
        #[doc = "If set, describes how the property should be used as a search operator."]
        #[serde(
            rename = "operatorOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_options: ::std::option::Option<crate::schemas::TextOperatorOptions>,
        #[doc = "Indicates the search quality importance of the tokens within the field when used for retrieval."]
        #[serde(
            rename = "retrievalImportance",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retrieval_importance: ::std::option::Option<crate::schemas::RetrievalImportance>,
    }
    impl ::google_field_selector::FieldSelector for TextPropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextPropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TextValues {
        #[doc = "The maximum allowable length for text values is 2048 characters."]
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for TextValues {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TextValues {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ThreadKeySet {
        #[doc = "Messages on which the thread_key was changed."]
        #[serde(
            rename = "messageKeys",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_keys: ::std::option::Option<Vec<crate::schemas::MultiKey>>,
        #[doc = "The new thread_key for this thread"]
        #[serde(
            rename = "newThreadKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub new_thread_key: ::std::option::Option<crate::schemas::MultiKey>,
    }
    impl ::google_field_selector::FieldSelector for ThreadKeySet {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ThreadKeySet {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ThreadUpdate {
        #[serde(
            rename = "attributeRemoved",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attribute_removed: ::std::option::Option<crate::schemas::AttributeRemoved>,
        #[serde(
            rename = "attributeSet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attribute_set: ::std::option::Option<crate::schemas::AttributeSet>,
        #[serde(
            rename = "labelAdded",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_added: ::std::option::Option<crate::schemas::LabelAdded>,
        #[serde(
            rename = "labelRemoved",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_removed: ::std::option::Option<crate::schemas::LabelRemoved>,
        #[doc = "Indicates the record id of the last operation that modified this thread."]
        #[serde(
            rename = "lastHistoryRecordId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_history_record_id: ::std::option::Option<u64>,
        #[serde(
            rename = "messageAdded",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_added: ::std::option::Option<crate::schemas::MessageAdded>,
        #[serde(
            rename = "messageDeleted",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message_deleted: ::std::option::Option<crate::schemas::MessageDeleted>,
        #[doc = "The first non-empty thread-key on any message in the thread (including deleted messages). This field has been introduced to maintain backward compatibility for clients that are not subthread aware."]
        #[serde(
            rename = "originalThreadKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub original_thread_key: ::std::option::Option<crate::schemas::MultiKey>,
        #[doc = "The PreStates of all messages before the transaction. These are suppressed if the client requested that prestates not be included in the output of the GetHistoryRequest."]
        #[serde(
            rename = "preState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pre_state: ::std::option::Option<Vec<crate::schemas::PreState>>,
        #[doc = "Affected thread"]
        #[serde(
            rename = "threadKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_key: ::std::option::Option<crate::schemas::MultiKey>,
        #[serde(
            rename = "threadKeySet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_key_set: ::std::option::Option<crate::schemas::ThreadKeySet>,
        #[doc = "Thread PLID"]
        #[serde(
            rename = "threadLocator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub thread_locator: ::std::option::Option<String>,
        #[serde(
            rename = "topicStateUpdate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub topic_state_update: ::std::option::Option<crate::schemas::TopicStateUpdate>,
    }
    impl ::google_field_selector::FieldSelector for ThreadUpdate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ThreadUpdate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TimestampOperatorOptions {
        #[doc = "Indicates the operator name required in the query in order to isolate the timestamp property using the greater-than operator. For example, if greaterThanOperatorName is *closedafter* and the property’s name is *closeDate*, then queries like *closedafter:<value>* show results only where the value of the property named *closeDate* is later than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "greaterThanOperatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub greater_than_operator_name: ::std::option::Option<String>,
        #[doc = "Indicates the operator name required in the query in order to isolate the timestamp property using the less-than operator. For example, if lessThanOperatorName is *closedbefore* and the property’s name is *closeDate*, then queries like *closedbefore:<value>* show results only where the value of the property named *closeDate* is earlier than *<value>*. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "lessThanOperatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub less_than_operator_name: ::std::option::Option<String>,
        #[doc = "Indicates the operator name required in the query in order to isolate the timestamp property. For example, if operatorName is *closedon* and the property’s name is *closeDate*, then queries like *closedon:<value>* show results only where the value of the property named *closeDate* matches *<value>*. By contrast, a search that uses the same *<value>* without an operator returns all items where *<value>* matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TimestampOperatorOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TimestampOperatorOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TimestampPropertyOptions {
        #[doc = "If set, describes how the timestamp should be used as a search operator."]
        #[serde(
            rename = "operatorOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_options: ::std::option::Option<crate::schemas::TimestampOperatorOptions>,
    }
    impl ::google_field_selector::FieldSelector for TimestampPropertyOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TimestampPropertyOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TimestampValues {
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for TimestampValues {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TimestampValues {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TombstoneMetadata {
        #[doc = "Indicates the type of Tombstone."]
        #[serde(
            rename = "tombstoneType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tombstone_type: ::std::option::Option<crate::schemas::TombstoneMetadataTombstoneType>,
    }
    impl ::google_field_selector::FieldSelector for TombstoneMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TombstoneMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TombstoneMetadataTombstoneType {
        #[doc = "The customer admin deleted a message in a space or DM owned by the customer. (go/chat-customer-owned-data)"]
        Admin,
        #[doc = "App scheduled deletion of their own message. See go/bme-dd."]
        AppMessageExpiry,
        #[doc = "User deleted their own message."]
        Creator,
        #[doc = "User deleted their own message via an app. See go/chat-api-delete-message."]
        CreatorViaApp,
        #[doc = "The space owner deleted a message in their space."]
        RoomOwner,
        #[doc = "The space owner deleted a message in their space via an app. See go/chat-api-delete-message."]
        RoomOwnerViaApp,
        #[doc = "This should not be used."]
        TombstoneUnspecified,
    }
    impl TombstoneMetadataTombstoneType {
        pub fn as_str(self) -> &'static str {
            match self {
                TombstoneMetadataTombstoneType::Admin => "ADMIN",
                TombstoneMetadataTombstoneType::AppMessageExpiry => "APP_MESSAGE_EXPIRY",
                TombstoneMetadataTombstoneType::Creator => "CREATOR",
                TombstoneMetadataTombstoneType::CreatorViaApp => "CREATOR_VIA_APP",
                TombstoneMetadataTombstoneType::RoomOwner => "ROOM_OWNER",
                TombstoneMetadataTombstoneType::RoomOwnerViaApp => "ROOM_OWNER_VIA_APP",
                TombstoneMetadataTombstoneType::TombstoneUnspecified => "TOMBSTONE_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TombstoneMetadataTombstoneType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TombstoneMetadataTombstoneType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<TombstoneMetadataTombstoneType, ()> {
            Ok(match s {
                "ADMIN" => TombstoneMetadataTombstoneType::Admin,
                "APP_MESSAGE_EXPIRY" => TombstoneMetadataTombstoneType::AppMessageExpiry,
                "CREATOR" => TombstoneMetadataTombstoneType::Creator,
                "CREATOR_VIA_APP" => TombstoneMetadataTombstoneType::CreatorViaApp,
                "ROOM_OWNER" => TombstoneMetadataTombstoneType::RoomOwner,
                "ROOM_OWNER_VIA_APP" => TombstoneMetadataTombstoneType::RoomOwnerViaApp,
                "TOMBSTONE_UNSPECIFIED" => TombstoneMetadataTombstoneType::TombstoneUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TombstoneMetadataTombstoneType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TombstoneMetadataTombstoneType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TombstoneMetadataTombstoneType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADMIN" => TombstoneMetadataTombstoneType::Admin,
                "APP_MESSAGE_EXPIRY" => TombstoneMetadataTombstoneType::AppMessageExpiry,
                "CREATOR" => TombstoneMetadataTombstoneType::Creator,
                "CREATOR_VIA_APP" => TombstoneMetadataTombstoneType::CreatorViaApp,
                "ROOM_OWNER" => TombstoneMetadataTombstoneType::RoomOwner,
                "ROOM_OWNER_VIA_APP" => TombstoneMetadataTombstoneType::RoomOwnerViaApp,
                "TOMBSTONE_UNSPECIFIED" => TombstoneMetadataTombstoneType::TombstoneUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TombstoneMetadataTombstoneType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TombstoneMetadataTombstoneType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Toolbar {
        #[doc = "Background color of the toolbar in RBG hex representation."]
        #[serde(
            rename = "color",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub color: ::std::option::Option<String>,
        #[serde(
            rename = "iconUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_url: ::std::option::Option<String>,
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Toolbar {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Toolbar {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TopicId {
        #[doc = "The Space or DM that the topic belongs to."]
        #[serde(
            rename = "groupId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub group_id: ::std::option::Option<crate::schemas::GroupId>,
        #[doc = "Opaque, server-assigned ID of the Topic. While this ID is guaranteed to be unique within the Space, it’s not guaranteed to be globally unique. Internal usage: this field can be empty in the following cases: 1. To create the first message in a topic. 2. To list last N messages of a Space (regardless of topic)."]
        #[serde(
            rename = "topicId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub topic_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TopicId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TopicId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TopicState {
        #[doc = "Map of label => count of topic constituent messages with label These only contain counts of labels that are relevant for topic normalization/denormalization. Eg. If a topic thread has 5 constituents, 4 of which are in inbox, this will contain ^i => 4. Some labels of interest are archive, inbox, trash, spam, etc."]
        #[serde(
            rename = "labelIdMessageCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label_id_message_count:
            ::std::option::Option<::std::collections::BTreeMap<String, i32>>,
        #[doc = "Number of constituents for this entity."]
        #[serde(
            rename = "numConstituents",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_constituents: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for TopicState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TopicState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TopicStateUpdate {
        #[serde(
            rename = "topicState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub topic_state: ::std::option::Option<crate::schemas::TopicState>,
    }
    impl ::google_field_selector::FieldSelector for TopicStateUpdate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TopicStateUpdate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TransactionContext {
        #[doc = "The last HistoryRecord of the transaction. Note that this may correspond to a record that is filtered by Tingle (and thus not returned to the client). See http://b/9513464."]
        #[serde(
            rename = "endingRecordId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub ending_record_id: ::std::option::Option<u64>,
        #[doc = "The first HistoryRecord of the transaction. Note that this may be a record of type INTERNAL."]
        #[serde(
            rename = "startingRecordId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub starting_record_id: ::std::option::Option<u64>,
        #[doc = "The microsecond timestamp of the transaction."]
        #[serde(
            rename = "writeTimestampUs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub write_timestamp_us: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for TransactionContext {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransactionContext {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TransactionDebugInfo {}
    impl ::google_field_selector::FieldSelector for TransactionDebugInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransactionDebugInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TranscriptionSessionInfo {
        #[doc = "Transcription session’s state information."]
        #[serde(
            rename = "sessionStateInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_state_info: ::std::option::Option<crate::schemas::SessionStateInfo>,
        #[doc = "A unique server-generated ID for the transcription session."]
        #[serde(
            rename = "transcriptionSessionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transcription_session_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TranscriptionSessionInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TranscriptionSessionInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TransientData {}
    impl ::google_field_selector::FieldSelector for TransientData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransientData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Trigger {
        #[doc = "Each dispatcher should use an enum to for the actions that it supports. If a dispatcher has only one action, this does not need to be set. (It can be expanded later, defining the default behaviour as type 0.) For purposes such as batching, the type of a trigger is (dispatcher, action_type)."]
        #[serde(
            rename = "actionType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action_type: ::std::option::Option<u32>,
        #[doc = "Maximum possible delay in micros that can be tolerated so triggers can be batched, which makes processing more efficient compared to firing triggers individually. Note that the actual fire time will be somewhere in the timerange interval \\[fire_time_us, fire_time_us + batch_time_us)."]
        #[serde(
            rename = "batchTimeUs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub batch_time_us: ::std::option::Option<i64>,
        #[doc = "Must be set for DISPATCHER_STUBBY_DISPATCHER."]
        #[serde(
            rename = "dispatchId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dispatch_id: ::std::option::Option<u32>,
        #[doc = "Which server should interpret action_type."]
        #[serde(
            rename = "dispatcher",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dispatcher: ::std::option::Option<crate::schemas::TriggerDispatcher>,
        #[doc = "Earliest time to fire at in microseconds. The actual time that the trigger will fire will be in the timerange: \\[fire_time_us, fire_time_us + batch_time_us)."]
        #[serde(
            rename = "fireTimeUs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub fire_time_us: ::std::option::Option<i64>,
        #[doc = "Must be set for DISPATCHER_JOBSETTED_PRIMARY."]
        #[serde(
            rename = "jobsettedServerSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub jobsetted_server_spec: ::std::option::Option<crate::schemas::JobsettedServerSpec>,
        #[doc = "The trigger key, if applicable."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[serde(
            rename = "rpcOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rpc_options: ::std::option::Option<crate::schemas::RpcOptions>,
        #[doc = "The slice_fire_time_us is automatically computed and stored as part of the trigger write. It represents the exact fire time at which the trigger will be queued to fire and will satisfy fire_time_us \\< slice_fire_time_us \\<= fire_time_us + batch_time_us Triggers have an index row in the slice trigger index with the row prefix matching this time. Note that this field is internal to gmail_cp and is ignored if set by external clients when adding / updating triggers."]
        #[serde(
            rename = "sliceFireTimeUs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub slice_fire_time_us: ::std::option::Option<i64>,
        #[doc = "Trigger action to perform. This should always be set."]
        #[serde(
            rename = "triggerAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_action: ::std::option::Option<crate::schemas::TriggerAction>,
        #[doc = "The TriggerKey will uniquely determine a trigger within a given context. A context is a single message for message triggers or a single account for account triggers."]
        #[serde(
            rename = "triggerKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_key: ::std::option::Option<crate::schemas::TriggerKey>,
    }
    impl ::google_field_selector::FieldSelector for Trigger {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Trigger {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TriggerDispatcher {
        #[doc = "Replace ACTION_INVOKE_X; the CS and Stratus are no longer limited to a single type of action. Each additional remote client should be defined here."]
        DispatcherCoproc,
        DispatcherCs,
        DispatcherJobsettedPrimary,
        DispatcherStratus,
        DispatcherStubbyDispatcher,
        DispatcherTasksServer,
    }
    impl TriggerDispatcher {
        pub fn as_str(self) -> &'static str {
            match self {
                TriggerDispatcher::DispatcherCoproc => "DISPATCHER_COPROC",
                TriggerDispatcher::DispatcherCs => "DISPATCHER_CS",
                TriggerDispatcher::DispatcherJobsettedPrimary => "DISPATCHER_JOBSETTED_PRIMARY",
                TriggerDispatcher::DispatcherStratus => "DISPATCHER_STRATUS",
                TriggerDispatcher::DispatcherStubbyDispatcher => "DISPATCHER_STUBBY_DISPATCHER",
                TriggerDispatcher::DispatcherTasksServer => "DISPATCHER_TASKS_SERVER",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TriggerDispatcher {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TriggerDispatcher {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<TriggerDispatcher, ()> {
            Ok(match s {
                "DISPATCHER_COPROC" => TriggerDispatcher::DispatcherCoproc,
                "DISPATCHER_CS" => TriggerDispatcher::DispatcherCs,
                "DISPATCHER_JOBSETTED_PRIMARY" => TriggerDispatcher::DispatcherJobsettedPrimary,
                "DISPATCHER_STRATUS" => TriggerDispatcher::DispatcherStratus,
                "DISPATCHER_STUBBY_DISPATCHER" => TriggerDispatcher::DispatcherStubbyDispatcher,
                "DISPATCHER_TASKS_SERVER" => TriggerDispatcher::DispatcherTasksServer,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TriggerDispatcher {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TriggerDispatcher {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TriggerDispatcher {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DISPATCHER_COPROC" => TriggerDispatcher::DispatcherCoproc,
                "DISPATCHER_CS" => TriggerDispatcher::DispatcherCs,
                "DISPATCHER_JOBSETTED_PRIMARY" => TriggerDispatcher::DispatcherJobsettedPrimary,
                "DISPATCHER_STRATUS" => TriggerDispatcher::DispatcherStratus,
                "DISPATCHER_STUBBY_DISPATCHER" => TriggerDispatcher::DispatcherStubbyDispatcher,
                "DISPATCHER_TASKS_SERVER" => TriggerDispatcher::DispatcherTasksServer,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TriggerDispatcher {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TriggerDispatcher {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TriggerAction {
        #[serde(
            rename = "action",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action: ::std::option::Option<crate::schemas::TriggerActionAction>,
        #[doc = "Clients should use extensions on the Trigger message instead."]
        #[serde(
            rename = "data",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data: ::std::option::Option<::google_api_bytes::Bytes>,
        #[serde(
            rename = "dataInt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub data_int: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for TriggerAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TriggerAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TriggerActionAction {
        #[doc = "This trigger will be executed once per newly created account. It will be created as part of the first transaction written to the account. The trigger can also be written as part of an SVF in case we want to re-initialize every account."]
        ActionAccountInitialization,
        #[doc = "Begins the message expunge similar to ACTION_MESSAGE_EXPUNGE but fires within one day. To be used ONLY for auto save drafts. See go/faster-auto-save-draft-deletion for more details."]
        ActionAutoSaveDraftExpunge,
        #[doc = "Similar to ACTION_QUERY_RETENTION but uses the MessageRetention policies to trash/delete the messages: cs/caribou/base/lib/proto/data_retention.proto ."]
        ActionCaribouDataRetention,
        #[doc = "Trigger for executing comparison logic between the output of ApplyDataRetention idle task and CaribouDataRetention trigger."]
        ActionCaribouDataRetentionDiff,
        #[doc = "No-op"]
        ActionCreateNewTrigger,
        #[doc = "No-op"]
        ActionDelete,
        #[doc = "Sends RPC to everclear for the message expunge."]
        ActionEverclearExpunge,
        #[doc = "The retention trigger that will be written to implement Groups retention."]
        ActionGroupsQueryRetention,
        #[doc = "This trigger deletes expired HistoryRecords. See go/history-record-cleanup for more details."]
        ActionHistoryCleanup,
        #[doc = "Sends the trigger to the master Caribou server via the Stubby TriggerHandlerService interface (defined in caribou/coproc/proto/trigger_handler.proto). The trigger is handled at fire time in the account’s primary replica, and only in non-primary replicas after a delay."]
        ActionInvokeCs,
        #[doc = "Process the debug log trigger by adding message body before dispatching to the Caribou Server through Stubby Dispatcher."]
        ActionInvokeDebugLog,
        #[doc = "Send the trigger to a groups server that implements the TriggerHandlerService. Dispatched via GSLB target specified by FLAGS_triggers_groups_server_address."]
        ActionInvokeGroups,
        #[doc = "Similar to ACTION_INVOKE_CS, but instead of sending the trigger to the master Caribou server, sends it to a jobsetted server in the user’s master jobset using the consistent-hash homing algorithm. The jobsetted_server_spec must be specified when using this TriggerAction."]
        ActionInvokeJobsettedPrimary,
        #[doc = "Send the trigger to an Observer server that implements the TriggerHandlerService. Dispatched via GSLB target specified by FLAGS_triggers_observer_server_address."]
        ActionInvokeObserver,
        #[doc = "Send the trigger to an Observer server that implements the TriggerHandlerService for wipeout purpose. Dispatched via GSLB target specified by FLAGS_triggers_observer_server_address. It behaves differently from the invoke observer trigger (ACTION_INVOKE_OBSERVER) and should be batched separately. Tingle always fires this kind of action trigger for ^deleted messages."]
        ActionInvokeObserverWipeout,
        #[doc = "Send the trigger to a SmartMail Publisher server that implements the TriggerHandlerService. Dispatched via GSLB target specified by FLAGS_triggers_publisher_server_address."]
        ActionInvokePublisher,
        #[doc = "Dispatches the permanent backup trigger to Satellite through Stubby dispatcher."]
        ActionInvokeSatelliteBackup,
        #[doc = "Dispatches the image processing trigger to Satellite through Stubby dispatcher. See go/gmail-photo-sharing for details."]
        ActionInvokeSatelliteImageProcessing,
        #[doc = "Send the trigger to the S/MIME certificate issuer server. Dispatched via the GSLB target specified by FLAGS_triggers_smime_certificate_issuer_server_address."]
        ActionInvokeSmimeCertificateIssuer,
        #[doc = "Similar to ACTION_INVOKE_CS, but instead of sending the trigger to the master Caribou server, sends it to a Stratus server that also implements the TriggerHandlerService. This Stratus server is specified via FLAGS_triggers_stratus_server_address. The trigger is handled at fire time in the account’s primary replica, and only in non-primary replicas after a delay."]
        ActionInvokeStratus,
        #[doc = "Send the trigger to the stubby dispatcher, which routes the RPC using the value of Trigger.dispatch_id as the RoutingInfo.extension_tag field. Dispatched via the GSLB target specified by FLAGS_triggers_stubby_dispatcher_address."]
        ActionInvokeStubbyDispatcher,
        #[doc = "Send the trigger to a Tasks server that implements the TriggerHandlerService. Dispatched via GSLB target specified by FLAGS_triggers_tasks_server_address."]
        ActionInvokeTasksServer,
        #[doc = "This trigger relabels messages asynchronously. See go/fusebox-bulk-api for more details."]
        ActionItemBulkRelabel,
        #[doc = "This action begins the message expunge process. It will trigger a purge attempt for all messages that have this trigger."]
        ActionMessageExpunge,
        #[doc = "Move messages from ^deleted to ^all. This trigger will only undelete messages that were deleted before the fire time of the trigger. Also, messages whose blobs are already deleted will not be undeleted. This is an account trigger."]
        ActionMessageUndelete,
        ActionNone,
        #[doc = "Backfills a set of records from an account and pushes them to PDH."]
        ActionPdhBackfill,
        #[doc = "This action begins the message’s PDH expunge. It will trigger a expunge (from pdh) attempt for all messages that have this trigger."]
        ActionPdhExpunge,
        #[doc = "Trigger to backfill gaps left by pdh pushed via push notification. see go/tingle-moonshine-push-v2"]
        ActionPdhPushNotificationBackfill,
        #[doc = "This trigger deletes expired temporary preferences. See go/tingle-temp-prefs for more details."]
        ActionPreferenceCleanup,
        #[doc = "Push a set of history records to PDH."]
        ActionPushHistoryToPdh,
        #[doc = "When this trigger fires, based on the latest retention policy: 1. messages that need to be deleted will be deleted through the CS trigger handler 2. ^deleted messages that need to be expunged will be expunged"]
        ActionQueryRetention,
        #[doc = "Trigger for backfill relevancy score. see go/gmail-relevancy-scoring-write for detail."]
        ActionRelevancyScoreBackfill,
        #[doc = "When this trigger fires, the current retention policy will be loaded from the policy management system and stored into the preference cache (if necessary). This will also create new expunge triggers if necessary."]
        ActionRetentionPolicyUpdate,
        #[doc = "Begins the message expunge similar to ACTION_MESSAGE_EXPUNGE but doesn’t check if the message was deleted at least 30 days back. To be used ONLY for service removal. See go/gmail-service-removal for more details."]
        ActionServiceRemovedMessageExpunge,
        #[doc = "When this trigger fires, the message should be used to update the user’s importance model. See http://go/io-tingle for more details."]
        ActionUpdateIceboxModel,
        #[doc = "This trigger will undelete messages that were ^deleted arbitrarily long in the past and a trash label will be applied to these undeleted messages. This is an account trigger that will be written when the Vault admin enables end user access for the Vault customer. This trigger shares its implementation with the ACTION_MESSAGE_UNDELETE trigger."]
        ActionVaultEndUserAccess,
    }
    impl TriggerActionAction {
        pub fn as_str(self) -> &'static str {
            match self {
                TriggerActionAction::ActionAccountInitialization => "ACTION_ACCOUNT_INITIALIZATION",
                TriggerActionAction::ActionAutoSaveDraftExpunge => "ACTION_AUTO_SAVE_DRAFT_EXPUNGE",
                TriggerActionAction::ActionCaribouDataRetention => "ACTION_CARIBOU_DATA_RETENTION",
                TriggerActionAction::ActionCaribouDataRetentionDiff => {
                    "ACTION_CARIBOU_DATA_RETENTION_DIFF"
                }
                TriggerActionAction::ActionCreateNewTrigger => "ACTION_CREATE_NEW_TRIGGER",
                TriggerActionAction::ActionDelete => "ACTION_DELETE",
                TriggerActionAction::ActionEverclearExpunge => "ACTION_EVERCLEAR_EXPUNGE",
                TriggerActionAction::ActionGroupsQueryRetention => "ACTION_GROUPS_QUERY_RETENTION",
                TriggerActionAction::ActionHistoryCleanup => "ACTION_HISTORY_CLEANUP",
                TriggerActionAction::ActionInvokeCs => "ACTION_INVOKE_CS",
                TriggerActionAction::ActionInvokeDebugLog => "ACTION_INVOKE_DEBUG_LOG",
                TriggerActionAction::ActionInvokeGroups => "ACTION_INVOKE_GROUPS",
                TriggerActionAction::ActionInvokeJobsettedPrimary => {
                    "ACTION_INVOKE_JOBSETTED_PRIMARY"
                }
                TriggerActionAction::ActionInvokeObserver => "ACTION_INVOKE_OBSERVER",
                TriggerActionAction::ActionInvokeObserverWipeout => {
                    "ACTION_INVOKE_OBSERVER_WIPEOUT"
                }
                TriggerActionAction::ActionInvokePublisher => "ACTION_INVOKE_PUBLISHER",
                TriggerActionAction::ActionInvokeSatelliteBackup => {
                    "ACTION_INVOKE_SATELLITE_BACKUP"
                }
                TriggerActionAction::ActionInvokeSatelliteImageProcessing => {
                    "ACTION_INVOKE_SATELLITE_IMAGE_PROCESSING"
                }
                TriggerActionAction::ActionInvokeSmimeCertificateIssuer => {
                    "ACTION_INVOKE_SMIME_CERTIFICATE_ISSUER"
                }
                TriggerActionAction::ActionInvokeStratus => "ACTION_INVOKE_STRATUS",
                TriggerActionAction::ActionInvokeStubbyDispatcher => {
                    "ACTION_INVOKE_STUBBY_DISPATCHER"
                }
                TriggerActionAction::ActionInvokeTasksServer => "ACTION_INVOKE_TASKS_SERVER",
                TriggerActionAction::ActionItemBulkRelabel => "ACTION_ITEM_BULK_RELABEL",
                TriggerActionAction::ActionMessageExpunge => "ACTION_MESSAGE_EXPUNGE",
                TriggerActionAction::ActionMessageUndelete => "ACTION_MESSAGE_UNDELETE",
                TriggerActionAction::ActionNone => "ACTION_NONE",
                TriggerActionAction::ActionPdhBackfill => "ACTION_PDH_BACKFILL",
                TriggerActionAction::ActionPdhExpunge => "ACTION_PDH_EXPUNGE",
                TriggerActionAction::ActionPdhPushNotificationBackfill => {
                    "ACTION_PDH_PUSH_NOTIFICATION_BACKFILL"
                }
                TriggerActionAction::ActionPreferenceCleanup => "ACTION_PREFERENCE_CLEANUP",
                TriggerActionAction::ActionPushHistoryToPdh => "ACTION_PUSH_HISTORY_TO_PDH",
                TriggerActionAction::ActionQueryRetention => "ACTION_QUERY_RETENTION",
                TriggerActionAction::ActionRelevancyScoreBackfill => {
                    "ACTION_RELEVANCY_SCORE_BACKFILL"
                }
                TriggerActionAction::ActionRetentionPolicyUpdate => {
                    "ACTION_RETENTION_POLICY_UPDATE"
                }
                TriggerActionAction::ActionServiceRemovedMessageExpunge => {
                    "ACTION_SERVICE_REMOVED_MESSAGE_EXPUNGE"
                }
                TriggerActionAction::ActionUpdateIceboxModel => "ACTION_UPDATE_ICEBOX_MODEL",
                TriggerActionAction::ActionVaultEndUserAccess => "ACTION_VAULT_END_USER_ACCESS",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TriggerActionAction {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TriggerActionAction {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<TriggerActionAction, ()> {
            Ok(match s {
                "ACTION_ACCOUNT_INITIALIZATION" => TriggerActionAction::ActionAccountInitialization,
                "ACTION_AUTO_SAVE_DRAFT_EXPUNGE" => TriggerActionAction::ActionAutoSaveDraftExpunge,
                "ACTION_CARIBOU_DATA_RETENTION" => TriggerActionAction::ActionCaribouDataRetention,
                "ACTION_CARIBOU_DATA_RETENTION_DIFF" => {
                    TriggerActionAction::ActionCaribouDataRetentionDiff
                }
                "ACTION_CREATE_NEW_TRIGGER" => TriggerActionAction::ActionCreateNewTrigger,
                "ACTION_DELETE" => TriggerActionAction::ActionDelete,
                "ACTION_EVERCLEAR_EXPUNGE" => TriggerActionAction::ActionEverclearExpunge,
                "ACTION_GROUPS_QUERY_RETENTION" => TriggerActionAction::ActionGroupsQueryRetention,
                "ACTION_HISTORY_CLEANUP" => TriggerActionAction::ActionHistoryCleanup,
                "ACTION_INVOKE_CS" => TriggerActionAction::ActionInvokeCs,
                "ACTION_INVOKE_DEBUG_LOG" => TriggerActionAction::ActionInvokeDebugLog,
                "ACTION_INVOKE_GROUPS" => TriggerActionAction::ActionInvokeGroups,
                "ACTION_INVOKE_JOBSETTED_PRIMARY" => {
                    TriggerActionAction::ActionInvokeJobsettedPrimary
                }
                "ACTION_INVOKE_OBSERVER" => TriggerActionAction::ActionInvokeObserver,
                "ACTION_INVOKE_OBSERVER_WIPEOUT" => {
                    TriggerActionAction::ActionInvokeObserverWipeout
                }
                "ACTION_INVOKE_PUBLISHER" => TriggerActionAction::ActionInvokePublisher,
                "ACTION_INVOKE_SATELLITE_BACKUP" => {
                    TriggerActionAction::ActionInvokeSatelliteBackup
                }
                "ACTION_INVOKE_SATELLITE_IMAGE_PROCESSING" => {
                    TriggerActionAction::ActionInvokeSatelliteImageProcessing
                }
                "ACTION_INVOKE_SMIME_CERTIFICATE_ISSUER" => {
                    TriggerActionAction::ActionInvokeSmimeCertificateIssuer
                }
                "ACTION_INVOKE_STRATUS" => TriggerActionAction::ActionInvokeStratus,
                "ACTION_INVOKE_STUBBY_DISPATCHER" => {
                    TriggerActionAction::ActionInvokeStubbyDispatcher
                }
                "ACTION_INVOKE_TASKS_SERVER" => TriggerActionAction::ActionInvokeTasksServer,
                "ACTION_ITEM_BULK_RELABEL" => TriggerActionAction::ActionItemBulkRelabel,
                "ACTION_MESSAGE_EXPUNGE" => TriggerActionAction::ActionMessageExpunge,
                "ACTION_MESSAGE_UNDELETE" => TriggerActionAction::ActionMessageUndelete,
                "ACTION_NONE" => TriggerActionAction::ActionNone,
                "ACTION_PDH_BACKFILL" => TriggerActionAction::ActionPdhBackfill,
                "ACTION_PDH_EXPUNGE" => TriggerActionAction::ActionPdhExpunge,
                "ACTION_PDH_PUSH_NOTIFICATION_BACKFILL" => {
                    TriggerActionAction::ActionPdhPushNotificationBackfill
                }
                "ACTION_PREFERENCE_CLEANUP" => TriggerActionAction::ActionPreferenceCleanup,
                "ACTION_PUSH_HISTORY_TO_PDH" => TriggerActionAction::ActionPushHistoryToPdh,
                "ACTION_QUERY_RETENTION" => TriggerActionAction::ActionQueryRetention,
                "ACTION_RELEVANCY_SCORE_BACKFILL" => {
                    TriggerActionAction::ActionRelevancyScoreBackfill
                }
                "ACTION_RETENTION_POLICY_UPDATE" => {
                    TriggerActionAction::ActionRetentionPolicyUpdate
                }
                "ACTION_SERVICE_REMOVED_MESSAGE_EXPUNGE" => {
                    TriggerActionAction::ActionServiceRemovedMessageExpunge
                }
                "ACTION_UPDATE_ICEBOX_MODEL" => TriggerActionAction::ActionUpdateIceboxModel,
                "ACTION_VAULT_END_USER_ACCESS" => TriggerActionAction::ActionVaultEndUserAccess,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TriggerActionAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TriggerActionAction {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TriggerActionAction {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTION_ACCOUNT_INITIALIZATION" => TriggerActionAction::ActionAccountInitialization,
                "ACTION_AUTO_SAVE_DRAFT_EXPUNGE" => TriggerActionAction::ActionAutoSaveDraftExpunge,
                "ACTION_CARIBOU_DATA_RETENTION" => TriggerActionAction::ActionCaribouDataRetention,
                "ACTION_CARIBOU_DATA_RETENTION_DIFF" => {
                    TriggerActionAction::ActionCaribouDataRetentionDiff
                }
                "ACTION_CREATE_NEW_TRIGGER" => TriggerActionAction::ActionCreateNewTrigger,
                "ACTION_DELETE" => TriggerActionAction::ActionDelete,
                "ACTION_EVERCLEAR_EXPUNGE" => TriggerActionAction::ActionEverclearExpunge,
                "ACTION_GROUPS_QUERY_RETENTION" => TriggerActionAction::ActionGroupsQueryRetention,
                "ACTION_HISTORY_CLEANUP" => TriggerActionAction::ActionHistoryCleanup,
                "ACTION_INVOKE_CS" => TriggerActionAction::ActionInvokeCs,
                "ACTION_INVOKE_DEBUG_LOG" => TriggerActionAction::ActionInvokeDebugLog,
                "ACTION_INVOKE_GROUPS" => TriggerActionAction::ActionInvokeGroups,
                "ACTION_INVOKE_JOBSETTED_PRIMARY" => {
                    TriggerActionAction::ActionInvokeJobsettedPrimary
                }
                "ACTION_INVOKE_OBSERVER" => TriggerActionAction::ActionInvokeObserver,
                "ACTION_INVOKE_OBSERVER_WIPEOUT" => {
                    TriggerActionAction::ActionInvokeObserverWipeout
                }
                "ACTION_INVOKE_PUBLISHER" => TriggerActionAction::ActionInvokePublisher,
                "ACTION_INVOKE_SATELLITE_BACKUP" => {
                    TriggerActionAction::ActionInvokeSatelliteBackup
                }
                "ACTION_INVOKE_SATELLITE_IMAGE_PROCESSING" => {
                    TriggerActionAction::ActionInvokeSatelliteImageProcessing
                }
                "ACTION_INVOKE_SMIME_CERTIFICATE_ISSUER" => {
                    TriggerActionAction::ActionInvokeSmimeCertificateIssuer
                }
                "ACTION_INVOKE_STRATUS" => TriggerActionAction::ActionInvokeStratus,
                "ACTION_INVOKE_STUBBY_DISPATCHER" => {
                    TriggerActionAction::ActionInvokeStubbyDispatcher
                }
                "ACTION_INVOKE_TASKS_SERVER" => TriggerActionAction::ActionInvokeTasksServer,
                "ACTION_ITEM_BULK_RELABEL" => TriggerActionAction::ActionItemBulkRelabel,
                "ACTION_MESSAGE_EXPUNGE" => TriggerActionAction::ActionMessageExpunge,
                "ACTION_MESSAGE_UNDELETE" => TriggerActionAction::ActionMessageUndelete,
                "ACTION_NONE" => TriggerActionAction::ActionNone,
                "ACTION_PDH_BACKFILL" => TriggerActionAction::ActionPdhBackfill,
                "ACTION_PDH_EXPUNGE" => TriggerActionAction::ActionPdhExpunge,
                "ACTION_PDH_PUSH_NOTIFICATION_BACKFILL" => {
                    TriggerActionAction::ActionPdhPushNotificationBackfill
                }
                "ACTION_PREFERENCE_CLEANUP" => TriggerActionAction::ActionPreferenceCleanup,
                "ACTION_PUSH_HISTORY_TO_PDH" => TriggerActionAction::ActionPushHistoryToPdh,
                "ACTION_QUERY_RETENTION" => TriggerActionAction::ActionQueryRetention,
                "ACTION_RELEVANCY_SCORE_BACKFILL" => {
                    TriggerActionAction::ActionRelevancyScoreBackfill
                }
                "ACTION_RETENTION_POLICY_UPDATE" => {
                    TriggerActionAction::ActionRetentionPolicyUpdate
                }
                "ACTION_SERVICE_REMOVED_MESSAGE_EXPUNGE" => {
                    TriggerActionAction::ActionServiceRemovedMessageExpunge
                }
                "ACTION_UPDATE_ICEBOX_MODEL" => TriggerActionAction::ActionUpdateIceboxModel,
                "ACTION_VAULT_END_USER_ACCESS" => TriggerActionAction::ActionVaultEndUserAccess,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TriggerActionAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TriggerActionAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TriggerKey {
        #[doc = "Identifier to distinguish multiple Triggers of the same type (per message or per account)."]
        #[serde(
            rename = "instanceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub instance_id: ::std::option::Option<String>,
        #[doc = "A non-empty string that identifies the type of Trigger. Triggers of the same type may be batched together. The universe of values for the type field should be finite as it is used as a stats key."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TriggerKey {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TriggerKey {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Triggers {
        #[doc = "A list of triggers."]
        #[serde(
            rename = "triggers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub triggers: ::std::option::Option<Vec<crate::schemas::Trigger>>,
    }
    impl ::google_field_selector::FieldSelector for Triggers {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Triggers {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TrustedResourceUrlProto {
        #[doc = "IMPORTANT: Never set or read this field, even from tests, it is private. See documentation at the top of .proto file for programming language packages with which to create or read this message."]
        #[serde(
            rename = "privateDoNotAccessOrElseTrustedResourceUrlWrappedValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_do_not_access_or_else_trusted_resource_url_wrapped_value:
            ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for TrustedResourceUrlProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TrustedResourceUrlProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TypeInfo {
        #[doc = "Contains additional video information only if document_type is VIDEO."]
        #[serde(
            rename = "videoInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_info: ::std::option::Option<crate::schemas::VideoInfo>,
    }
    impl ::google_field_selector::FieldSelector for TypeInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TypeInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UniversalPhoneAccess {
        #[doc = "The PIN that users must enter after dialing a universal number. The pin consists of only decimal digits and the length may vary, though it generally is longer than a PhoneAccess.pin."]
        #[serde(
            rename = "pin",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pin: ::std::option::Option<String>,
        #[doc = "This field has the same contents as the MeetingSpace.more_join_url field, and is included for compatibility reasons. Clients should use the other field instead. This field is deprecated and will be removed."]
        #[serde(
            rename = "pstnInfoUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pstn_info_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for UniversalPhoneAccess {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UniversalPhoneAccess {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UnmappedIdentity {
        #[doc = "The resource name for an external user."]
        #[serde(
            rename = "externalIdentity",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub external_identity: ::std::option::Option<crate::schemas::Principal>,
        #[doc = "The resolution status for the external identity."]
        #[serde(
            rename = "resolutionStatusCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resolution_status_code:
            ::std::option::Option<crate::schemas::UnmappedIdentityResolutionStatusCode>,
    }
    impl ::google_field_selector::FieldSelector for UnmappedIdentity {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UnmappedIdentity {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UnmappedIdentityResolutionStatusCode {
        #[doc = "Input-only value. Used to list all unmapped identities regardless of status."]
        CodeUnspecified,
        #[doc = "IDaaS does not understand the identity source, probably because the schema was modified in a non compatible way."]
        IdentitySourceMisconfigured,
        #[doc = "The identity source associated with the identity was either not found or deleted."]
        IdentitySourceNotFound,
        #[doc = "Internal error."]
        InternalError,
        #[doc = "The unmapped identity was not found in IDaaS, and needs to be provided by the user."]
        NotFound,
        #[doc = "The number of users associated with the external identity is too large."]
        TooManyMappingsFound,
    }
    impl UnmappedIdentityResolutionStatusCode {
        pub fn as_str(self) -> &'static str {
            match self {
                UnmappedIdentityResolutionStatusCode::CodeUnspecified => "CODE_UNSPECIFIED",
                UnmappedIdentityResolutionStatusCode::IdentitySourceMisconfigured => {
                    "IDENTITY_SOURCE_MISCONFIGURED"
                }
                UnmappedIdentityResolutionStatusCode::IdentitySourceNotFound => {
                    "IDENTITY_SOURCE_NOT_FOUND"
                }
                UnmappedIdentityResolutionStatusCode::InternalError => "INTERNAL_ERROR",
                UnmappedIdentityResolutionStatusCode::NotFound => "NOT_FOUND",
                UnmappedIdentityResolutionStatusCode::TooManyMappingsFound => {
                    "TOO_MANY_MAPPINGS_FOUND"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for UnmappedIdentityResolutionStatusCode {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UnmappedIdentityResolutionStatusCode {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UnmappedIdentityResolutionStatusCode, ()> {
            Ok(match s {
                "CODE_UNSPECIFIED" => UnmappedIdentityResolutionStatusCode::CodeUnspecified,
                "IDENTITY_SOURCE_MISCONFIGURED" => {
                    UnmappedIdentityResolutionStatusCode::IdentitySourceMisconfigured
                }
                "IDENTITY_SOURCE_NOT_FOUND" => {
                    UnmappedIdentityResolutionStatusCode::IdentitySourceNotFound
                }
                "INTERNAL_ERROR" => UnmappedIdentityResolutionStatusCode::InternalError,
                "NOT_FOUND" => UnmappedIdentityResolutionStatusCode::NotFound,
                "TOO_MANY_MAPPINGS_FOUND" => {
                    UnmappedIdentityResolutionStatusCode::TooManyMappingsFound
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UnmappedIdentityResolutionStatusCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UnmappedIdentityResolutionStatusCode {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UnmappedIdentityResolutionStatusCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CODE_UNSPECIFIED" => UnmappedIdentityResolutionStatusCode::CodeUnspecified,
                "IDENTITY_SOURCE_MISCONFIGURED" => {
                    UnmappedIdentityResolutionStatusCode::IdentitySourceMisconfigured
                }
                "IDENTITY_SOURCE_NOT_FOUND" => {
                    UnmappedIdentityResolutionStatusCode::IdentitySourceNotFound
                }
                "INTERNAL_ERROR" => UnmappedIdentityResolutionStatusCode::InternalError,
                "NOT_FOUND" => UnmappedIdentityResolutionStatusCode::NotFound,
                "TOO_MANY_MAPPINGS_FOUND" => {
                    UnmappedIdentityResolutionStatusCode::TooManyMappingsFound
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UnmappedIdentityResolutionStatusCode {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UnmappedIdentityResolutionStatusCode {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UnreserveItemsRequest {
        #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
        #[serde(
            rename = "connectorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connector_name: ::std::option::Option<String>,
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[doc = "The name of a queue to unreserve items from."]
        #[serde(
            rename = "queue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub queue: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for UnreserveItemsRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UnreserveItemsRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateBccRecipients {
        #[serde(
            rename = "bccRecipients",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bcc_recipients: ::std::option::Option<Vec<crate::schemas::Recipient>>,
    }
    impl ::google_field_selector::FieldSelector for UpdateBccRecipients {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateBccRecipients {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateBody {
        #[doc = "A repeated field that contains a series of content to insert into the draft that the user is currently editing. The content can contain HTML content or plain text content."]
        #[serde(
            rename = "insertContents",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub insert_contents: ::std::option::Option<Vec<crate::schemas::InsertContent>>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::UpdateBodyType>,
    }
    impl ::google_field_selector::FieldSelector for UpdateBody {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateBody {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UpdateBodyType {
        #[doc = "Indicates this action is to perform an in-place insertion. By default the content is inserted at the current cursor position, if there is selected content, it replaces the selected content."]
        InPlaceInsert,
        #[doc = "Indicates this action is to perform insert at the end of the message body."]
        InsertAtEnd,
        #[doc = "Indicates this action is to perform insert at the start of the message body."]
        InsertAtStart,
        #[doc = "Indicates this action is to replace the message body."]
        Replace,
        #[doc = "Default value when nothing is set for Type."]
        UnspecifiedActionType,
    }
    impl UpdateBodyType {
        pub fn as_str(self) -> &'static str {
            match self {
                UpdateBodyType::InPlaceInsert => "IN_PLACE_INSERT",
                UpdateBodyType::InsertAtEnd => "INSERT_AT_END",
                UpdateBodyType::InsertAtStart => "INSERT_AT_START",
                UpdateBodyType::Replace => "REPLACE",
                UpdateBodyType::UnspecifiedActionType => "UNSPECIFIED_ACTION_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for UpdateBodyType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UpdateBodyType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UpdateBodyType, ()> {
            Ok(match s {
                "IN_PLACE_INSERT" => UpdateBodyType::InPlaceInsert,
                "INSERT_AT_END" => UpdateBodyType::InsertAtEnd,
                "INSERT_AT_START" => UpdateBodyType::InsertAtStart,
                "REPLACE" => UpdateBodyType::Replace,
                "UNSPECIFIED_ACTION_TYPE" => UpdateBodyType::UnspecifiedActionType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UpdateBodyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UpdateBodyType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateBodyType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "IN_PLACE_INSERT" => UpdateBodyType::InPlaceInsert,
                "INSERT_AT_END" => UpdateBodyType::InsertAtEnd,
                "INSERT_AT_START" => UpdateBodyType::InsertAtStart,
                "REPLACE" => UpdateBodyType::Replace,
                "UNSPECIFIED_ACTION_TYPE" => UpdateBodyType::UnspecifiedActionType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UpdateBodyType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateBodyType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateCcRecipients {
        #[serde(
            rename = "ccRecipients",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cc_recipients: ::std::option::Option<Vec<crate::schemas::Recipient>>,
    }
    impl ::google_field_selector::FieldSelector for UpdateCcRecipients {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateCcRecipients {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateDataSourceRequest {
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source: ::std::option::Option<crate::schemas::DataSource>,
        #[doc = "Only applies to [`settings.datasources.patch`](https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.datasources/patch). Update mask to control which fields to update. Example field paths: `name`, `displayName`. * If `update_mask` is non-empty, then only the fields specified in the `update_mask` are updated. * If you specify a field in the `update_mask`, but don’t specify its value in the source, that field is cleared. * If the `update_mask` is not present or empty or has the value `*`, then all fields are updated."]
        #[serde(
            rename = "updateMask",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_mask: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for UpdateDataSourceRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateDataSourceRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateDraftActionMarkup {
        #[doc = "If set, replaces the existing Bcc recipients of the draft the user is currently editing."]
        #[serde(
            rename = "updateBccRecipients",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_bcc_recipients: ::std::option::Option<crate::schemas::UpdateBccRecipients>,
        #[doc = "A field that contains a series of update actions to perform on the draft body that the user is currently editing."]
        #[serde(
            rename = "updateBody",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_body: ::std::option::Option<crate::schemas::UpdateBody>,
        #[doc = "If set, replaces the existing Cc recipients of the draft the user is currently editing."]
        #[serde(
            rename = "updateCcRecipients",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_cc_recipients: ::std::option::Option<crate::schemas::UpdateCcRecipients>,
        #[doc = "If set, replaces the existing subject of the draft the user is currently editing."]
        #[serde(
            rename = "updateSubject",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_subject: ::std::option::Option<crate::schemas::UpdateSubject>,
        #[doc = "If set, replaces the existing To recipients of the draft the user is currently editing."]
        #[serde(
            rename = "updateToRecipients",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_to_recipients: ::std::option::Option<crate::schemas::UpdateToRecipients>,
    }
    impl ::google_field_selector::FieldSelector for UpdateDraftActionMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateDraftActionMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateSchemaRequest {
        #[doc = "Common debug options."]
        #[serde(
            rename = "debugOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debug_options: ::std::option::Option<crate::schemas::DebugOptions>,
        #[doc = "The new schema for the source."]
        #[serde(
            rename = "schema",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub schema: ::std::option::Option<crate::schemas::Schema>,
        #[doc = "If true, the schema will be checked for validity, but will not be registered with the data source, even if valid."]
        #[serde(
            rename = "validateOnly",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub validate_only: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for UpdateSchemaRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateSchemaRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateSubject {
        #[serde(
            rename = "subject",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub subject: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for UpdateSubject {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateSubject {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateToRecipients {
        #[serde(
            rename = "toRecipients",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub to_recipients: ::std::option::Option<Vec<crate::schemas::Recipient>>,
    }
    impl ::google_field_selector::FieldSelector for UpdateToRecipients {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UpdateToRecipients {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UploadItemRef {
        #[doc = "The name of the content reference. The maximum length is 2048 characters."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for UploadItemRef {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UploadItemRef {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UploadMetadata {
        #[doc = "Opaque token. Clients shall simply pass it back to the Backend. This field will NOT be saved into storage."]
        #[serde(
            rename = "attachmentToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attachment_token: ::std::option::Option<String>,
        #[doc = "Information about the uploaded attachment that is only used in Backend. This field will NOT be sent out of Google."]
        #[serde(
            rename = "backendUploadMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub backend_upload_metadata:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedBackendUploadMetadata>,
        #[doc = "The “new” secure identifier for Drive files. Should be used instead of the deprecated string drive_id field above. This should only be set if the upload file has been added to Drive. Note that older Drive files that do not have a ResourceKey should still use this field, with the resource_key field unset."]
        #[serde(
            rename = "clonedAuthorizedItemId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cloned_authorized_item_id: ::std::option::Option<crate::schemas::AuthorizedItemId>,
        #[doc = "DriveAction for organizing the cloned version of this upload in Drive, if the file has been added to Drive. This field is not set if the file has not been added to Drive. Additionally, this field is only set when part of a FileResult in a ListFilesResponse."]
        #[serde(
            rename = "clonedDriveAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cloned_drive_action:
            ::std::option::Option<crate::schemas::UploadMetadataClonedDriveAction>,
        #[doc = "Reference to a Drive ID, if this upload file has been previously cloned to Drive. Note: this is deprecated in favor of the AuthorizedItemId below."]
        #[serde(
            rename = "clonedDriveId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cloned_drive_id: ::std::option::Option<String>,
        #[doc = "The original file name for the content, not the full path."]
        #[serde(
            rename = "contentName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_name: ::std::option::Option<String>,
        #[doc = "Type is from Scotty’s best_guess by default: http://google3/uploader/agent/scotty_agent.proto?l=51&rcl=140889785"]
        #[serde(
            rename = "contentType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content_type: ::std::option::Option<String>,
        #[doc = "The metrics metadata of the Data Loss Prevention attachment scan."]
        #[serde(
            rename = "dlpMetricsMetadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dlp_metrics_metadata:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedDlpMetricsMetadata>,
        #[doc = "The timestamp of the most recent virus scan completed (in microseconds)."]
        #[serde(
            rename = "latestVirusScanTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub latest_virus_scan_timestamp: ::std::option::Option<i64>,
        #[doc = "A copy of the LocalId in Annotation. This field is supposed to be filled by server only."]
        #[serde(
            rename = "localId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub local_id: ::std::option::Option<String>,
        #[doc = "Original dimension of the content. Only set for image attachments."]
        #[serde(
            rename = "originalDimension",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub original_dimension: ::std::option::Option<crate::schemas::AppsDynamiteSharedDimension>,
        #[doc = "Reference to a transcoded video attachment. Only set for video attachments."]
        #[serde(
            rename = "videoReference",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub video_reference:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedVideoReference>,
        #[doc = "Result for a virus scan. It’s duplicated in the above field apps.dynamite.shared.BackendUploadMetadata"]
        #[serde(
            rename = "virusScanResult",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub virus_scan_result: ::std::option::Option<crate::schemas::UploadMetadataVirusScanResult>,
    }
    impl ::google_field_selector::FieldSelector for UploadMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UploadMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UploadMetadataClonedDriveAction {
        #[doc = "Show “Add another shortcut” button, for Drive files the user has already created a shortcut to."]
        AddAnotherShortcut,
        #[doc = "Show “Add shortcut” button, for adding a shortcut to a Drive file the user does not have permission to move."]
        AddShortcut,
        #[doc = "Show “Add to Drive” button, for adding file that doesn’t exist in Drive to Drive. Note that deleted Drive files that still exist (i.e. in your Trash) will still be ORGANIZE (this is consistent with Gmail Drive attachments)."]
        AddToDrive,
        #[doc = "No organize action should be shown."]
        DriveActionUnspecified,
        #[doc = "Show “Move” button, for organizing a Drive file the user has permission to move."]
        Organize,
    }
    impl UploadMetadataClonedDriveAction {
        pub fn as_str(self) -> &'static str {
            match self {
                UploadMetadataClonedDriveAction::AddAnotherShortcut => "ADD_ANOTHER_SHORTCUT",
                UploadMetadataClonedDriveAction::AddShortcut => "ADD_SHORTCUT",
                UploadMetadataClonedDriveAction::AddToDrive => "ADD_TO_DRIVE",
                UploadMetadataClonedDriveAction::DriveActionUnspecified => {
                    "DRIVE_ACTION_UNSPECIFIED"
                }
                UploadMetadataClonedDriveAction::Organize => "ORGANIZE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for UploadMetadataClonedDriveAction {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UploadMetadataClonedDriveAction {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UploadMetadataClonedDriveAction, ()> {
            Ok(match s {
                "ADD_ANOTHER_SHORTCUT" => UploadMetadataClonedDriveAction::AddAnotherShortcut,
                "ADD_SHORTCUT" => UploadMetadataClonedDriveAction::AddShortcut,
                "ADD_TO_DRIVE" => UploadMetadataClonedDriveAction::AddToDrive,
                "DRIVE_ACTION_UNSPECIFIED" => {
                    UploadMetadataClonedDriveAction::DriveActionUnspecified
                }
                "ORGANIZE" => UploadMetadataClonedDriveAction::Organize,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UploadMetadataClonedDriveAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UploadMetadataClonedDriveAction {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UploadMetadataClonedDriveAction {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADD_ANOTHER_SHORTCUT" => UploadMetadataClonedDriveAction::AddAnotherShortcut,
                "ADD_SHORTCUT" => UploadMetadataClonedDriveAction::AddShortcut,
                "ADD_TO_DRIVE" => UploadMetadataClonedDriveAction::AddToDrive,
                "DRIVE_ACTION_UNSPECIFIED" => {
                    UploadMetadataClonedDriveAction::DriveActionUnspecified
                }
                "ORGANIZE" => UploadMetadataClonedDriveAction::Organize,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UploadMetadataClonedDriveAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UploadMetadataClonedDriveAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UploadMetadataVirusScanResult {
        Clean,
        Error,
        Infected,
        #[doc = "The document violates Google’s policy for executables and archives."]
        PolicyViolation,
        UnknownVirusScanResult,
    }
    impl UploadMetadataVirusScanResult {
        pub fn as_str(self) -> &'static str {
            match self {
                UploadMetadataVirusScanResult::Clean => "CLEAN",
                UploadMetadataVirusScanResult::Error => "ERROR",
                UploadMetadataVirusScanResult::Infected => "INFECTED",
                UploadMetadataVirusScanResult::PolicyViolation => "POLICY_VIOLATION",
                UploadMetadataVirusScanResult::UnknownVirusScanResult => {
                    "UNKNOWN_VIRUS_SCAN_RESULT"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for UploadMetadataVirusScanResult {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UploadMetadataVirusScanResult {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UploadMetadataVirusScanResult, ()> {
            Ok(match s {
                "CLEAN" => UploadMetadataVirusScanResult::Clean,
                "ERROR" => UploadMetadataVirusScanResult::Error,
                "INFECTED" => UploadMetadataVirusScanResult::Infected,
                "POLICY_VIOLATION" => UploadMetadataVirusScanResult::PolicyViolation,
                "UNKNOWN_VIRUS_SCAN_RESULT" => {
                    UploadMetadataVirusScanResult::UnknownVirusScanResult
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UploadMetadataVirusScanResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UploadMetadataVirusScanResult {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UploadMetadataVirusScanResult {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CLEAN" => UploadMetadataVirusScanResult::Clean,
                "ERROR" => UploadMetadataVirusScanResult::Error,
                "INFECTED" => UploadMetadataVirusScanResult::Infected,
                "POLICY_VIOLATION" => UploadMetadataVirusScanResult::PolicyViolation,
                "UNKNOWN_VIRUS_SCAN_RESULT" => {
                    UploadMetadataVirusScanResult::UnknownVirusScanResult
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UploadMetadataVirusScanResult {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UploadMetadataVirusScanResult {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UrlMetadata {
        #[doc = "Domain for this url. If it’s an IP address the address is returned."]
        #[serde(
            rename = "domain",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub domain: ::std::option::Option<String>,
        #[doc = "The signed GWS URL."]
        #[serde(
            rename = "gwsUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gws_url: ::std::option::Option<crate::schemas::SafeUrlProto>,
        #[doc = "The expiration timestamp for GWS URL, only set when gws_url is set."]
        #[serde(
            rename = "gwsUrlExpirationTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub gws_url_expiration_timestamp: ::std::option::Option<i64>,
        #[doc = "Dimensions of the image: height. This field is string to match with page render service response. Deprecated. Use int_image_height instead."]
        #[serde(
            rename = "imageHeight",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_height: ::std::option::Option<String>,
        #[doc = "Representative image of the website."]
        #[serde(
            rename = "imageUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_url: ::std::option::Option<String>,
        #[doc = "Dimensions of the image: width. This field is string to match with page render service response. Deprecated. Use int_image_height instead."]
        #[serde(
            rename = "imageWidth",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_width: ::std::option::Option<String>,
        #[doc = "Dimensions of the image: height."]
        #[serde(
            rename = "intImageHeight",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_image_height: ::std::option::Option<i32>,
        #[doc = "Dimensions of the image: width."]
        #[serde(
            rename = "intImageWidth",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_image_width: ::std::option::Option<i32>,
        #[doc = "Mime type of the content (Currently mapped from Page Render Service ItemType) Note that this is not necessarily the mime type of the http resource. For example a text/html from youtube or vimeo may actually be classified as a video type. Then we shall mark it as video/\\* since we don’t know exactly what type of video it is."]
        #[serde(
            rename = "mimeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "The stable redirect URL pointing to frontend server."]
        #[serde(
            rename = "redirectUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub redirect_url: ::std::option::Option<crate::schemas::SafeUrlProto>,
        #[doc = "If the UrlMetadata is missing data for rendering a chip. Deprecated. Use Annotation.ChipRenderType instead."]
        #[serde(
            rename = "shouldNotRender",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub should_not_render: ::std::option::Option<bool>,
        #[doc = "Snippet/small description of the weblink."]
        #[serde(
            rename = "snippet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snippet: ::std::option::Option<String>,
        #[doc = "Title of the Weblink."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
        #[doc = "The original URL."]
        #[serde(
            rename = "url",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url: ::std::option::Option<crate::schemas::SafeUrlProto>,
        #[serde(
            rename = "urlSource",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub url_source: ::std::option::Option<crate::schemas::UrlMetadataUrlSource>,
    }
    impl ::google_field_selector::FieldSelector for UrlMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UrlMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UrlMetadataUrlSource {
        #[doc = "Set by the server, when it detects a URL in the message text"]
        AutoDetectedPlainText,
        #[doc = "Set by the client, when the user adds a link as a custom hyperlink. Validated by the server and persisted in storage."]
        RichText,
        ServerSuppliedPolicyViolation,
        UrlSourceUnknown,
    }
    impl UrlMetadataUrlSource {
        pub fn as_str(self) -> &'static str {
            match self {
                UrlMetadataUrlSource::AutoDetectedPlainText => "AUTO_DETECTED_PLAIN_TEXT",
                UrlMetadataUrlSource::RichText => "RICH_TEXT",
                UrlMetadataUrlSource::ServerSuppliedPolicyViolation => {
                    "SERVER_SUPPLIED_POLICY_VIOLATION"
                }
                UrlMetadataUrlSource::UrlSourceUnknown => "URL_SOURCE_UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for UrlMetadataUrlSource {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UrlMetadataUrlSource {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UrlMetadataUrlSource, ()> {
            Ok(match s {
                "AUTO_DETECTED_PLAIN_TEXT" => UrlMetadataUrlSource::AutoDetectedPlainText,
                "RICH_TEXT" => UrlMetadataUrlSource::RichText,
                "SERVER_SUPPLIED_POLICY_VIOLATION" => {
                    UrlMetadataUrlSource::ServerSuppliedPolicyViolation
                }
                "URL_SOURCE_UNKNOWN" => UrlMetadataUrlSource::UrlSourceUnknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UrlMetadataUrlSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UrlMetadataUrlSource {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UrlMetadataUrlSource {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AUTO_DETECTED_PLAIN_TEXT" => UrlMetadataUrlSource::AutoDetectedPlainText,
                "RICH_TEXT" => UrlMetadataUrlSource::RichText,
                "SERVER_SUPPLIED_POLICY_VIOLATION" => {
                    UrlMetadataUrlSource::ServerSuppliedPolicyViolation
                }
                "URL_SOURCE_UNKNOWN" => UrlMetadataUrlSource::UrlSourceUnknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UrlMetadataUrlSource {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UrlMetadataUrlSource {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct User {
        #[doc = "URL for the avatar picture of the User in dynamite"]
        #[serde(
            rename = "avatarUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub avatar_url: ::std::option::Option<String>,
        #[doc = "Information about whether the user is blocked by requester and/or has blocked requester."]
        #[serde(
            rename = "blockRelationship",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub block_relationship:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedUserBlockRelationship>,
        #[doc = "Bot-specific profile information. Leave it empty for human users."]
        #[serde(
            rename = "botInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bot_info: ::std::option::Option<crate::schemas::BotInfo>,
        #[doc = "Deleted flag, if true, means User has been soft-deleted/purged Deprecated. Use user_account_state field instead."]
        #[serde(
            rename = "deleted",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub deleted: ::std::option::Option<bool>,
        #[doc = "Email ID of the user"]
        #[serde(
            rename = "email",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email: ::std::option::Option<String>,
        #[doc = "First or given name of the user"]
        #[serde(
            rename = "firstName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub first_name: ::std::option::Option<String>,
        #[doc = "Gender of the user"]
        #[serde(
            rename = "gender",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gender: ::std::option::Option<String>,
        #[doc = "UserId"]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Set to true if none of the depending services (Gaia, PeopleApi) returns any info for this user."]
        #[serde(
            rename = "isAnonymous",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_anonymous: ::std::option::Option<bool>,
        #[doc = "Last or family name of the user"]
        #[serde(
            rename = "lastName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_name: ::std::option::Option<String>,
        #[doc = "Non-unique, user-defined display name of the User"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Information about whether the user is a consumer user, or the GSuite customer that they belong to."]
        #[serde(
            rename = "organizationInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub organization_info:
            ::std::option::Option<crate::schemas::AppsDynamiteSharedOrganizationInfo>,
        #[doc = "Phone number(s) of the user"]
        #[serde(
            rename = "phoneNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub phone_number: ::std::option::Option<Vec<crate::schemas::AppsDynamiteSharedPhoneNumber>>,
        #[doc = "State of user’s Gaia Account"]
        #[serde(
            rename = "userAccountState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_account_state: ::std::option::Option<crate::schemas::UserUserAccountState>,
        #[doc = "Visibility of user’s Profile"]
        #[serde(
            rename = "userProfileVisibility",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_profile_visibility:
            ::std::option::Option<crate::schemas::UserUserProfileVisibility>,
    }
    impl ::google_field_selector::FieldSelector for User {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for User {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UserUserAccountState {
        #[doc = "User account is deleted"]
        Deleted,
        #[doc = "User doesn’t have Dynamite enabled. This includes service disabled by admin, or user’s account is suspended"]
        Disabled,
        #[doc = "User has Dynamite enabled."]
        Enabled,
        #[doc = "Failed to retrieve user’s info. Will use user’s email address as name and first_name."]
        TemporaryUnavailable,
        UnknownUserAccountState,
    }
    impl UserUserAccountState {
        pub fn as_str(self) -> &'static str {
            match self {
                UserUserAccountState::Deleted => "DELETED",
                UserUserAccountState::Disabled => "DISABLED",
                UserUserAccountState::Enabled => "ENABLED",
                UserUserAccountState::TemporaryUnavailable => "TEMPORARY_UNAVAILABLE",
                UserUserAccountState::UnknownUserAccountState => "UNKNOWN_USER_ACCOUNT_STATE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for UserUserAccountState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UserUserAccountState {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UserUserAccountState, ()> {
            Ok(match s {
                "DELETED" => UserUserAccountState::Deleted,
                "DISABLED" => UserUserAccountState::Disabled,
                "ENABLED" => UserUserAccountState::Enabled,
                "TEMPORARY_UNAVAILABLE" => UserUserAccountState::TemporaryUnavailable,
                "UNKNOWN_USER_ACCOUNT_STATE" => UserUserAccountState::UnknownUserAccountState,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UserUserAccountState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UserUserAccountState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UserUserAccountState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DELETED" => UserUserAccountState::Deleted,
                "DISABLED" => UserUserAccountState::Disabled,
                "ENABLED" => UserUserAccountState::Enabled,
                "TEMPORARY_UNAVAILABLE" => UserUserAccountState::TemporaryUnavailable,
                "UNKNOWN_USER_ACCOUNT_STATE" => UserUserAccountState::UnknownUserAccountState,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UserUserAccountState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserUserAccountState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UserUserProfileVisibility {
        #[doc = "Caller can only see the target user as a deleted user. Email is empty. Names are redacted as “Deleted User”."]
        DeletedUser,
        #[doc = "Stubby failed. Clients should always retry ASAP"]
        Failure,
        #[doc = "Caller has full visibility."]
        FullProfile,
        #[doc = "Caller can only see the email used to invite the target user"]
        InviteeEmail,
        #[doc = "Caller can only see target user’s primary email from Gaia"]
        PrimaryMail,
        #[doc = "Caller has no visibility to the target user at all. Email is empty. Names are redacted as “Unknown User”."]
        UnknownUser,
        UnknownUserProfileVisibility,
    }
    impl UserUserProfileVisibility {
        pub fn as_str(self) -> &'static str {
            match self {
                UserUserProfileVisibility::DeletedUser => "DELETED_USER",
                UserUserProfileVisibility::Failure => "FAILURE",
                UserUserProfileVisibility::FullProfile => "FULL_PROFILE",
                UserUserProfileVisibility::InviteeEmail => "INVITEE_EMAIL",
                UserUserProfileVisibility::PrimaryMail => "PRIMARY_MAIL",
                UserUserProfileVisibility::UnknownUser => "UNKNOWN_USER",
                UserUserProfileVisibility::UnknownUserProfileVisibility => {
                    "UNKNOWN_USER_PROFILE_VISIBILITY"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for UserUserProfileVisibility {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UserUserProfileVisibility {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UserUserProfileVisibility, ()> {
            Ok(match s {
                "DELETED_USER" => UserUserProfileVisibility::DeletedUser,
                "FAILURE" => UserUserProfileVisibility::Failure,
                "FULL_PROFILE" => UserUserProfileVisibility::FullProfile,
                "INVITEE_EMAIL" => UserUserProfileVisibility::InviteeEmail,
                "PRIMARY_MAIL" => UserUserProfileVisibility::PrimaryMail,
                "UNKNOWN_USER" => UserUserProfileVisibility::UnknownUser,
                "UNKNOWN_USER_PROFILE_VISIBILITY" => {
                    UserUserProfileVisibility::UnknownUserProfileVisibility
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UserUserProfileVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UserUserProfileVisibility {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UserUserProfileVisibility {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DELETED_USER" => UserUserProfileVisibility::DeletedUser,
                "FAILURE" => UserUserProfileVisibility::Failure,
                "FULL_PROFILE" => UserUserProfileVisibility::FullProfile,
                "INVITEE_EMAIL" => UserUserProfileVisibility::InviteeEmail,
                "PRIMARY_MAIL" => UserUserProfileVisibility::PrimaryMail,
                "UNKNOWN_USER" => UserUserProfileVisibility::UnknownUser,
                "UNKNOWN_USER_PROFILE_VISIBILITY" => {
                    UserUserProfileVisibility::UnknownUserProfileVisibility
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UserUserProfileVisibility {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserUserProfileVisibility {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UserDisplayInfo {
        #[doc = "The avatar to show for this user"]
        #[serde(
            rename = "avatarUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub avatar_url: ::std::option::Option<String>,
        #[doc = "The name to show for this user"]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for UserDisplayInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserDisplayInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UserId {
        #[doc = "Optional. Opaque, server-assigned ID of the user profile associated with App/user acting on behalf of the human user. This is currently only set when a 3P application is acting on the user’s behalf."]
        #[serde(
            rename = "actingUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub acting_user_id: ::std::option::Option<String>,
        #[doc = "Opaque, server-assigned ID of the User."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
        #[doc = "Optional. Identifier of the App involved (directly or on behalf of a human creator) in creating this message. This is not set if the user posted a message directly, but is used in the case of, for example, a message being generated by a 1P integration based on a user action (creating an event, creating a task etc). This should only be used on the BE. For clients, please use the field in the FE message proto instead (google3/apps/dynamite/v1/frontend/api/message.proto?q=origin_app_id)."]
        #[serde(
            rename = "originAppId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub origin_app_id: ::std::option::Option<crate::schemas::AppId>,
        #[doc = "Clients do not need to send UserType to Backend, but Backend will always send this field to clients per the following rule: 1. For HUMAN Ids, the field is empty but by default .getType() will return HUMAN. 2. For BOT Ids, the field is ALWAYS set to BOT."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::UserIdType>,
    }
    impl ::google_field_selector::FieldSelector for UserId {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UserIdType {
        Bot,
        #[doc = "Notes on HUMAN type: 1) Leaving UserId.UserType field empty will return HUMAN as default value. This is expected because all the existing UserIds are without explicitly setting UserType, most of which are HUMAN Ids. For Bot Ids we will always set BOT in UserType field. 2) DO NOT explicitly set HUMAN as type. This is a proto2 issue, that a UserId with explicitly set default value HUMAN as type is NOT equal to an id without setting the field. aka. UserId id1 = UserId.newBuilder() .setId(“dummy”).setType(UserType.HUMAN).build(); UserId id2 = UserId.newBuilder().setId(“dummy”).build(); AssertThat(id1).isNotEqual(id2); AssertThat(id2.getType()).isEqualTo(UserType.HUMAN);"]
        Human,
    }
    impl UserIdType {
        pub fn as_str(self) -> &'static str {
            match self {
                UserIdType::Bot => "BOT",
                UserIdType::Human => "HUMAN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for UserIdType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UserIdType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UserIdType, ()> {
            Ok(match s {
                "BOT" => UserIdType::Bot,
                "HUMAN" => UserIdType::Human,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UserIdType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UserIdType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UserIdType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOT" => UserIdType::Bot,
                "HUMAN" => UserIdType::Human,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UserIdType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserIdType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UserInfo {
        #[doc = "Avatar url of the user who triggered the Drive Notification email. This field will be populated if we can extract such information from the Drive Notification email. This should only be used to fetch user avatars when updater_to_show_email is not populated. This field is not set for non-Drive Notification items."]
        #[serde(
            rename = "driveNotificationAvatarUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub drive_notification_avatar_url: ::std::option::Option<String>,
        #[doc = "Describes how updater_count_to_show should be used."]
        #[serde(
            rename = "updaterCountDisplayType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub updater_count_display_type:
            ::std::option::Option<crate::schemas::UserInfoUpdaterCountDisplayType>,
        #[doc = "The number of updaters for clients to show depending on UpdaterCountDisplayType."]
        #[serde(
            rename = "updaterCountToShow",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub updater_count_to_show: ::std::option::Option<i32>,
        #[doc = "The email of the updater for clients to show used for Gmail items. For Drive Notifications, this is the email of the user who triggered the Drive Notification email. This field will be populated if we can extract such information from the Drive Notification email. This is not the actual sender of the email, as the sender is always comments-noreply@docs.google.com."]
        #[serde(
            rename = "updaterToShowEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub updater_to_show_email: ::std::option::Option<String>,
        #[doc = "The gaia id of the updater for clients to show used for Gmail items. If the updater is an external user, the email field below should be populated."]
        #[serde(
            rename = "updaterToShowGaiaId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub updater_to_show_gaia_id: ::std::option::Option<i64>,
        #[doc = "The display name of the updater for clients to show used for Gmail items. For non-Drive Notification items, this field will always be populated. If the display name cannot be found for the user, the fallback string will be the email address. For Drive Notification items, this is the name of the user who triggered the Drive notification email. This field will be populated if we can extract such information from the Drive Notification email. If the name cannot be extracted, then the email will be the fallback string, which is used as the display name text in the UI when needed. This is not the actual sender of the email, as the sender is always comments-noreply@docs.google.com."]
        #[serde(
            rename = "updaterToShowName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub updater_to_show_name: ::std::option::Option<String>,
        #[doc = "The updater for clients to show used for Dynamite Chat items."]
        #[serde(
            rename = "updaterToShowUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub updater_to_show_user_id: ::std::option::Option<crate::schemas::UserId>,
    }
    impl ::google_field_selector::FieldSelector for UserInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UserInfoUpdaterCountDisplayType {
        #[doc = "A precise updater count is known and the value set in updater_count_to_show should be used. If set, updater_count_to_show is set to the total number of updaters minus the one set in updater_to_show. Shows up in clients as “$USERNAME and $NUM others replied”."]
        ExactCount,
        #[doc = "No additional updaters where involved. Shows up in clients as “$USERNAME replied”."]
        NoDisplayCount,
        #[doc = "A precise updater count could not be calculated, but there is at least one. Any value set in updater_count_to_show should NOT be used. Shows up in clients as “$USERNAME and others replied”."]
        NonzeroCount,
        UpdaterCountDisplayTypeUnspecified,
    }
    impl UserInfoUpdaterCountDisplayType {
        pub fn as_str(self) -> &'static str {
            match self {
                UserInfoUpdaterCountDisplayType::ExactCount => "EXACT_COUNT",
                UserInfoUpdaterCountDisplayType::NoDisplayCount => "NO_DISPLAY_COUNT",
                UserInfoUpdaterCountDisplayType::NonzeroCount => "NONZERO_COUNT",
                UserInfoUpdaterCountDisplayType::UpdaterCountDisplayTypeUnspecified => {
                    "UPDATER_COUNT_DISPLAY_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for UserInfoUpdaterCountDisplayType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UserInfoUpdaterCountDisplayType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UserInfoUpdaterCountDisplayType, ()> {
            Ok(match s {
                "EXACT_COUNT" => UserInfoUpdaterCountDisplayType::ExactCount,
                "NO_DISPLAY_COUNT" => UserInfoUpdaterCountDisplayType::NoDisplayCount,
                "NONZERO_COUNT" => UserInfoUpdaterCountDisplayType::NonzeroCount,
                "UPDATER_COUNT_DISPLAY_TYPE_UNSPECIFIED" => {
                    UserInfoUpdaterCountDisplayType::UpdaterCountDisplayTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UserInfoUpdaterCountDisplayType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UserInfoUpdaterCountDisplayType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UserInfoUpdaterCountDisplayType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EXACT_COUNT" => UserInfoUpdaterCountDisplayType::ExactCount,
                "NO_DISPLAY_COUNT" => UserInfoUpdaterCountDisplayType::NoDisplayCount,
                "NONZERO_COUNT" => UserInfoUpdaterCountDisplayType::NonzeroCount,
                "UPDATER_COUNT_DISPLAY_TYPE_UNSPECIFIED" => {
                    UserInfoUpdaterCountDisplayType::UpdaterCountDisplayTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UserInfoUpdaterCountDisplayType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserInfoUpdaterCountDisplayType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UserMentionData {
        #[serde(
            rename = "email",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email: ::std::option::Option<String>,
        #[doc = "If the principal is backed by a gaia id, DO NOT use this field. Use user_gaia_id/user_id fields instead."]
        #[serde(
            rename = "user",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user: ::std::option::Option<crate::schemas::PrincipalProto>,
        #[doc = "An unobfuscated gaia ID:"]
        #[serde(
            rename = "userGaiaId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub user_gaia_id: ::std::option::Option<i64>,
        #[doc = "An obfuscated gaia ID:"]
        #[serde(
            rename = "userId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for UserMentionData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserMentionData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UserMentionMetadata {
        #[doc = "Display name of the mentioned user. This field should remain empty when clients resolve a UserMention annotation. It will be filled in when a UserMention is generated by the Integration Server."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Gender of the mentioned user. One of “female”, “male” or “other”. Used for choosing accurate translations for strings that contain the UserMention, when these need to be constructed (e.g. task assignment update message). This field should remain empty when clients resolve a UserMention. It will be filled in when a UserMention is generated by the Integration Server."]
        #[serde(
            rename = "gender",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gender: ::std::option::Option<String>,
        #[doc = "To be deprecated. Use invitee_info field instead. ID of the User mentioned. This field should remain empty when type == MENTION_ALL."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<crate::schemas::UserId>,
        #[doc = "Invitee UserId and email used when mentioned. This field should remain empty when type == MENTION_ALL. Invitee_info.email is only used when a user is @-mentioned with an email address, and it will be empty when clients get messages from Backend."]
        #[serde(
            rename = "inviteeInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub invitee_info: ::std::option::Option<crate::schemas::InviteeInfo>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<crate::schemas::UserMentionMetadataType>,
    }
    impl ::google_field_selector::FieldSelector for UserMentionMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserMentionMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum UserMentionMetadataType {
        #[doc = "Server-generated user mention, for clients to strikethrough."]
        FailedToAdd,
        Invite,
        Mention,
        MentionAll,
        #[doc = "Default value for the enum. DO NOT USE."]
        TypeUnspecified,
        Uninvite,
    }
    impl UserMentionMetadataType {
        pub fn as_str(self) -> &'static str {
            match self {
                UserMentionMetadataType::FailedToAdd => "FAILED_TO_ADD",
                UserMentionMetadataType::Invite => "INVITE",
                UserMentionMetadataType::Mention => "MENTION",
                UserMentionMetadataType::MentionAll => "MENTION_ALL",
                UserMentionMetadataType::TypeUnspecified => "TYPE_UNSPECIFIED",
                UserMentionMetadataType::Uninvite => "UNINVITE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for UserMentionMetadataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for UserMentionMetadataType {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<UserMentionMetadataType, ()> {
            Ok(match s {
                "FAILED_TO_ADD" => UserMentionMetadataType::FailedToAdd,
                "INVITE" => UserMentionMetadataType::Invite,
                "MENTION" => UserMentionMetadataType::Mention,
                "MENTION_ALL" => UserMentionMetadataType::MentionAll,
                "TYPE_UNSPECIFIED" => UserMentionMetadataType::TypeUnspecified,
                "UNINVITE" => UserMentionMetadataType::Uninvite,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for UserMentionMetadataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for UserMentionMetadataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UserMentionMetadataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FAILED_TO_ADD" => UserMentionMetadataType::FailedToAdd,
                "INVITE" => UserMentionMetadataType::Invite,
                "MENTION" => UserMentionMetadataType::Mention,
                "MENTION_ALL" => UserMentionMetadataType::MentionAll,
                "TYPE_UNSPECIFIED" => UserMentionMetadataType::TypeUnspecified,
                "UNINVITE" => UserMentionMetadataType::Uninvite,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for UserMentionMetadataType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for UserMentionMetadataType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Value {
        #[serde(
            rename = "booleanValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_value: ::std::option::Option<bool>,
        #[serde(
            rename = "dateValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date_value: ::std::option::Option<crate::schemas::Date>,
        #[serde(
            rename = "doubleValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_value: ::std::option::Option<f64>,
        #[serde(
            rename = "integerValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub integer_value: ::std::option::Option<i64>,
        #[serde(
            rename = "stringValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_value: ::std::option::Option<String>,
        #[serde(
            rename = "timestampValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub timestamp_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Value {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Value {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct ValueFilter {
        #[doc = "The `operator_name` applied to the query, such as *price_greater_than*. The filter can work against both types of filters defined in the schema for your data source: 1. `operator_name`, where the query filters results by the property that matches the value. 2. `greater_than_operator_name` or `less_than_operator_name` in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query."]
        #[serde(
            rename = "operatorName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator_name: ::std::option::Option<String>,
        #[doc = "The value to be compared with."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<crate::schemas::Value>,
    }
    impl ::google_field_selector::FieldSelector for ValueFilter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ValueFilter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct VideoCallMetadata {
        #[doc = "Thor meeting space."]
        #[serde(
            rename = "meetingSpace",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_space: ::std::option::Option<crate::schemas::MeetingSpace>,
        #[doc = "If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip."]
        #[serde(
            rename = "shouldNotRender",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub should_not_render: ::std::option::Option<bool>,
        #[doc = "Whether this meeting space was created via Dynamite in this Dynamite group."]
        #[serde(
            rename = "wasCreatedInCurrentGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub was_created_in_current_group: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for VideoCallMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for VideoCallMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct VideoInfo {
        #[doc = "Duration of the video in milliseconds. This field can be absent for recently uploaded video or inaccurate sometimes."]
        #[serde(
            rename = "duration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub duration: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for VideoInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for VideoInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct VoicePhoneNumber {
        #[doc = "E.164 formatted full phone number with leading +. This field also represents encoded form of short telephone numbers in E.164 format. e.g. “911” is encoded as “+1911”."]
        #[serde(
            rename = "e164",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub e_164: ::std::option::Option<String>,
        #[doc = "Additional data that could be added using the libphonenumber API."]
        #[serde(
            rename = "i18nData",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub i_1_8n_data: ::std::option::Option<crate::schemas::VoicePhoneNumberI18NData>,
    }
    impl ::google_field_selector::FieldSelector for VoicePhoneNumber {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for VoicePhoneNumber {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct VoicePhoneNumberI18NData {
        #[doc = "The country calling code for this number, as defined by the ITU. For example, this would be 1 for NANPA countries, and 33 for France (for more info see i18n.phonenumbers.PhoneNumber.country_code)."]
        #[serde(
            rename = "countryCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub country_code: ::std::option::Option<i32>,
        #[doc = "Display number formatted using the INTERNATIONAL format."]
        #[serde(
            rename = "internationalNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub international_number: ::std::option::Option<String>,
        #[doc = "When present, indicates the number is valid according to the libphonenumber’s isValidNumber API (see https://code.google.com/p/libphonenumber/)."]
        #[serde(
            rename = "isValid",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_valid: ::std::option::Option<bool>,
        #[doc = "Display number formatted using the NATIONAL format."]
        #[serde(
            rename = "nationalNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub national_number: ::std::option::Option<String>,
        #[doc = "A region (country, territory, continent, etc), as defined by Unicode’s “CLDR”, itself based on ISO 3166 (UN country codes). For details, see https://www.corp.google.com/~engdocs/java/com/google/i18n/identifiers/RegionCode.html"]
        #[serde(
            rename = "regionCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub region_code: ::std::option::Option<String>,
        #[doc = "When set to a non-default value, indicates the validation reason that is set when phone number is invalid (is_valid is false)."]
        #[serde(
            rename = "validationResult",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub validation_result:
            ::std::option::Option<crate::schemas::VoicePhoneNumberI18NDataValidationResult>,
    }
    impl ::google_field_selector::FieldSelector for VoicePhoneNumberI18NData {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for VoicePhoneNumberI18NData {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum VoicePhoneNumberI18NDataValidationResult {
        InvalidCountryCode,
        InvalidLength,
        IsPossible,
        IsPossibleLocalOnly,
        TooLong,
        TooShort,
        Unknown,
    }
    impl VoicePhoneNumberI18NDataValidationResult {
        pub fn as_str(self) -> &'static str {
            match self {
                VoicePhoneNumberI18NDataValidationResult::InvalidCountryCode => {
                    "INVALID_COUNTRY_CODE"
                }
                VoicePhoneNumberI18NDataValidationResult::InvalidLength => "INVALID_LENGTH",
                VoicePhoneNumberI18NDataValidationResult::IsPossible => "IS_POSSIBLE",
                VoicePhoneNumberI18NDataValidationResult::IsPossibleLocalOnly => {
                    "IS_POSSIBLE_LOCAL_ONLY"
                }
                VoicePhoneNumberI18NDataValidationResult::TooLong => "TOO_LONG",
                VoicePhoneNumberI18NDataValidationResult::TooShort => "TOO_SHORT",
                VoicePhoneNumberI18NDataValidationResult::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for VoicePhoneNumberI18NDataValidationResult {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for VoicePhoneNumberI18NDataValidationResult {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<VoicePhoneNumberI18NDataValidationResult, ()> {
            Ok(match s {
                "INVALID_COUNTRY_CODE" => {
                    VoicePhoneNumberI18NDataValidationResult::InvalidCountryCode
                }
                "INVALID_LENGTH" => VoicePhoneNumberI18NDataValidationResult::InvalidLength,
                "IS_POSSIBLE" => VoicePhoneNumberI18NDataValidationResult::IsPossible,
                "IS_POSSIBLE_LOCAL_ONLY" => {
                    VoicePhoneNumberI18NDataValidationResult::IsPossibleLocalOnly
                }
                "TOO_LONG" => VoicePhoneNumberI18NDataValidationResult::TooLong,
                "TOO_SHORT" => VoicePhoneNumberI18NDataValidationResult::TooShort,
                "UNKNOWN" => VoicePhoneNumberI18NDataValidationResult::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for VoicePhoneNumberI18NDataValidationResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for VoicePhoneNumberI18NDataValidationResult {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for VoicePhoneNumberI18NDataValidationResult {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "INVALID_COUNTRY_CODE" => {
                    VoicePhoneNumberI18NDataValidationResult::InvalidCountryCode
                }
                "INVALID_LENGTH" => VoicePhoneNumberI18NDataValidationResult::InvalidLength,
                "IS_POSSIBLE" => VoicePhoneNumberI18NDataValidationResult::IsPossible,
                "IS_POSSIBLE_LOCAL_ONLY" => {
                    VoicePhoneNumberI18NDataValidationResult::IsPossibleLocalOnly
                }
                "TOO_LONG" => VoicePhoneNumberI18NDataValidationResult::TooLong,
                "TOO_SHORT" => VoicePhoneNumberI18NDataValidationResult::TooShort,
                "UNKNOWN" => VoicePhoneNumberI18NDataValidationResult::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for VoicePhoneNumberI18NDataValidationResult {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for VoicePhoneNumberI18NDataValidationResult {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Vpcsettings {
        #[doc = "The resource name of the GCP Project to be used for VPC SC policy check. VPC security settings on this project will be honored for Cloud Search APIs after project_name has been updated through CustomerService. Format: projects/{project_id}"]
        #[serde(
            rename = "project",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub project: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for Vpcsettings {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Vpcsettings {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct WhiteboardInfo {
        #[doc = "The Cosmo Id of the whiteboard document (Jam)."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
        #[doc = "Title of the whiteboard document."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
        #[doc = "The uri for whiteboard document."]
        #[serde(
            rename = "uri",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub uri: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for WhiteboardInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WhiteboardInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct WidgetMarkup {
        #[doc = "buttons is also oneof data and only one of these fields should be set."]
        #[serde(
            rename = "buttons",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub buttons: ::std::option::Option<Vec<crate::schemas::Button>>,
        #[serde(
            rename = "dateTimePicker",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub date_time_picker: ::std::option::Option<crate::schemas::DateTimePicker>,
        #[serde(
            rename = "divider",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub divider: ::std::option::Option<crate::schemas::Divider>,
        #[serde(
            rename = "grid",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub grid: ::std::option::Option<crate::schemas::Grid>,
        #[doc = "The horizontal alignment of this widget."]
        #[serde(
            rename = "horizontalAlignment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub horizontal_alignment:
            ::std::option::Option<crate::schemas::WidgetMarkupHorizontalAlignment>,
        #[serde(
            rename = "image",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image: ::std::option::Option<crate::schemas::Image>,
        #[serde(
            rename = "imageKeyValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_key_value: ::std::option::Option<crate::schemas::ImageKeyValue>,
        #[serde(
            rename = "keyValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key_value: ::std::option::Option<crate::schemas::KeyValue>,
        #[doc = "Input Widgets"]
        #[serde(
            rename = "menu",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub menu: ::std::option::Option<crate::schemas::Menu>,
        #[serde(
            rename = "selectionControl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub selection_control: ::std::option::Option<crate::schemas::SelectionControl>,
        #[serde(
            rename = "textField",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_field: ::std::option::Option<crate::schemas::TextField>,
        #[serde(
            rename = "textKeyValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_key_value: ::std::option::Option<crate::schemas::TextKeyValue>,
        #[doc = "Read-only Widgets"]
        #[serde(
            rename = "textParagraph",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub text_paragraph: ::std::option::Option<crate::schemas::TextParagraph>,
    }
    impl ::google_field_selector::FieldSelector for WidgetMarkup {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WidgetMarkup {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WidgetMarkupHorizontalAlignment {
        Center,
        End,
        HorizontalAlignmentUnspecified,
        Start,
    }
    impl WidgetMarkupHorizontalAlignment {
        pub fn as_str(self) -> &'static str {
            match self {
                WidgetMarkupHorizontalAlignment::Center => "CENTER",
                WidgetMarkupHorizontalAlignment::End => "END",
                WidgetMarkupHorizontalAlignment::HorizontalAlignmentUnspecified => {
                    "HORIZONTAL_ALIGNMENT_UNSPECIFIED"
                }
                WidgetMarkupHorizontalAlignment::Start => "START",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WidgetMarkupHorizontalAlignment {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WidgetMarkupHorizontalAlignment {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WidgetMarkupHorizontalAlignment, ()> {
            Ok(match s {
                "CENTER" => WidgetMarkupHorizontalAlignment::Center,
                "END" => WidgetMarkupHorizontalAlignment::End,
                "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                    WidgetMarkupHorizontalAlignment::HorizontalAlignmentUnspecified
                }
                "START" => WidgetMarkupHorizontalAlignment::Start,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WidgetMarkupHorizontalAlignment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WidgetMarkupHorizontalAlignment {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WidgetMarkupHorizontalAlignment {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CENTER" => WidgetMarkupHorizontalAlignment::Center,
                "END" => WidgetMarkupHorizontalAlignment::End,
                "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => {
                    WidgetMarkupHorizontalAlignment::HorizontalAlignmentUnspecified
                }
                "START" => WidgetMarkupHorizontalAlignment::Start,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WidgetMarkupHorizontalAlignment {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WidgetMarkupHorizontalAlignment {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct WrappedResourceKey {
        #[doc = "Resource key of the Drive item. This field should be unset if, depending on the context, the item does not have a resource key, or if none was specified. This must never be logged."]
        #[serde(
            rename = "resourceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resource_key: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for WrappedResourceKey {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WrappedResourceKey {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct YouTubeBroadcastSessionInfo {
        #[doc = "Current broadcast session’s statistics."]
        #[serde(
            rename = "broadcastStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub broadcast_stats: ::std::option::Option<crate::schemas::YouTubeBroadcastStats>,
        #[doc = "YouTube broadcast session’s state information."]
        #[serde(
            rename = "sessionStateInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub session_state_info: ::std::option::Option<crate::schemas::SessionStateInfo>,
        #[doc = "A unique server-generated ID for the broadcast session."]
        #[serde(
            rename = "youTubeBroadcastSessionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub you_tube_broadcast_session_id: ::std::option::Option<String>,
        #[doc = "The YouTube Live broadcast event that is being streamed to."]
        #[serde(
            rename = "youTubeLiveBroadcastEvent",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub you_tube_live_broadcast_event:
            ::std::option::Option<crate::schemas::YouTubeLiveBroadcastEvent>,
    }
    impl ::google_field_selector::FieldSelector for YouTubeBroadcastSessionInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for YouTubeBroadcastSessionInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct YouTubeBroadcastStats {
        #[doc = "Estimated concurrent viewer count."]
        #[serde(
            rename = "estimatedViewerCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub estimated_viewer_count: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for YouTubeBroadcastStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for YouTubeBroadcastStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct YouTubeLiveBroadcastEvent {
        #[doc = "Input only. If the channel_id is for a YouTube Channel owned by a Brand Account, client is required to populate this field with the obfuscated gaia id of the Brand account when starting the broadcast."]
        #[serde(
            rename = "brandAccountGaiaId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub brand_account_gaia_id: ::std::option::Option<String>,
        #[doc = "Input only. The broadcast id, used to control the lifecycle of the event on YouTube"]
        #[serde(
            rename = "broadcastId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub broadcast_id: ::std::option::Option<String>,
        #[doc = "YouTube Channel associated with the broadcast."]
        #[serde(
            rename = "channelId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub channel_id: ::std::option::Option<String>,
        #[doc = "Output only. A URL that can be used to watch the meeting broadcast. Will be populated by the backend."]
        #[serde(
            rename = "viewUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub view_url: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for YouTubeLiveBroadcastEvent {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for YouTubeLiveBroadcastEvent {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct YoutubeMetadata {
        #[doc = "YouTube resource ID of the artifact."]
        #[serde(
            rename = "id",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub id: ::std::option::Option<String>,
        #[doc = "If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip."]
        #[serde(
            rename = "shouldNotRender",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub should_not_render: ::std::option::Option<bool>,
        #[doc = "YouTube query parameter for timestamp. YouTube specific flag that allows users to embed time token when sharing a link. This property contains parsed time token in seconds."]
        #[serde(
            rename = "startTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_time: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for YoutubeMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for YoutubeMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct YoutubeUserProto {
        #[serde(
            rename = "youtubeUserId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub youtube_user_id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector for YoutubeUserProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for YoutubeUserProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ZwiebackSessionProto {
        #[serde(
            rename = "zwiebackSessionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub zwieback_session_id: ::std::option::Option<u64>,
    }
    impl ::google_field_selector::FieldSelector for ZwiebackSessionProto {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ZwiebackSessionProto {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
}
pub mod params {
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Alt {
        #[doc = "Responses with Content-Type of application/json"]
        Json,
        #[doc = "Media download with context-dependent Content-Type"]
        Media,
        #[doc = "Responses with Content-Type of application/x-protobuf"]
        Proto,
    }
    impl Alt {
        pub fn as_str(self) -> &'static str {
            match self {
                Alt::Json => "json",
                Alt::Media => "media",
                Alt::Proto => "proto",
            }
        }
    }
    impl ::std::convert::AsRef<str> for Alt {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for Alt {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<Alt, ()> {
            Ok(match s {
                "json" => Alt::Json,
                "media" => Alt::Media,
                "proto" => Alt::Proto,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for Alt {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Alt {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Alt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "json" => Alt::Json,
                "media" => Alt::Media,
                "proto" => Alt::Proto,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for Alt {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Alt {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Xgafv {
        #[doc = "v1 error format"]
        _1,
        #[doc = "v2 error format"]
        _2,
    }
    impl Xgafv {
        pub fn as_str(self) -> &'static str {
            match self {
                Xgafv::_1 => "1",
                Xgafv::_2 => "2",
            }
        }
    }
    impl ::std::convert::AsRef<str> for Xgafv {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for Xgafv {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<Xgafv, ()> {
            Ok(match s {
                "1" => Xgafv::_1,
                "2" => Xgafv::_2,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for Xgafv {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Xgafv {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Xgafv {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "1" => Xgafv::_1,
                "2" => Xgafv::_2,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for Xgafv {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Xgafv {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
}
pub struct Client {
    reqwest: ::reqwest::Client,
    auth: Box<dyn ::google_api_auth::GetAccessToken>,
}
impl Client {
    pub fn new<A>(auth: A) -> Self
    where
        A: ::google_api_auth::GetAccessToken + 'static,
    {
        Client::with_reqwest_client(auth, ::reqwest::Client::builder().build().unwrap())
    }
    pub fn with_reqwest_client<A>(auth: A, reqwest: ::reqwest::Client) -> Self
    where
        A: ::google_api_auth::GetAccessToken + 'static,
    {
        Client {
            reqwest,
            auth: Box::new(auth),
        }
    }
    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
        self.auth.as_ref()
    }
    #[doc = "Actions that can be performed on the debug resource"]
    pub fn debug(&self) -> crate::resources::debug::DebugActions {
        crate::resources::debug::DebugActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the indexing resource"]
    pub fn indexing(&self) -> crate::resources::indexing::IndexingActions {
        crate::resources::indexing::IndexingActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the media resource"]
    pub fn media(&self) -> crate::resources::media::MediaActions {
        crate::resources::media::MediaActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the operations resource"]
    pub fn operations(&self) -> crate::resources::operations::OperationsActions {
        crate::resources::operations::OperationsActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the query resource"]
    pub fn query(&self) -> crate::resources::query::QueryActions {
        crate::resources::query::QueryActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the settings resource"]
    pub fn settings(&self) -> crate::resources::settings::SettingsActions {
        crate::resources::settings::SettingsActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the stats resource"]
    pub fn stats(&self) -> crate::resources::stats::StatsActions {
        crate::resources::stats::StatsActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the v_1 resource"]
    pub fn v_1(&self) -> crate::resources::v_1::V1Actions {
        crate::resources::v_1::V1Actions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
}
pub mod resources {
    pub mod debug {
        pub mod params {}
        pub struct DebugActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> DebugActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Actions that can be performed on the datasources resource"]
            pub fn datasources(&self) -> crate::resources::debug::datasources::DatasourcesActions {
                crate::resources::debug::datasources::DatasourcesActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the identitysources resource"]
            pub fn identitysources(
                &self,
            ) -> crate::resources::debug::identitysources::IdentitysourcesActions {
                crate::resources::debug::identitysources::IdentitysourcesActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        pub mod datasources {
            pub mod params {}
            pub struct DatasourcesActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> DatasourcesActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Actions that can be performed on the items resource"]
                pub fn items(&self) -> crate::resources::debug::datasources::items::ItemsActions {
                    crate::resources::debug::datasources::items::ItemsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
            }
            pub mod items {
                pub mod params {}
                pub struct ItemsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> ItemsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Checks whether an item is accessible by specified principal. Principal must be a user; groups and domain values aren’t supported. **Note:** This API requires an admin account to execute."]
                    pub fn check_access(
                        &self,
                        request: crate::schemas::Principal,
                        name: impl Into<String>,
                    ) -> CheckAccessRequestBuilder {
                        CheckAccessRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            debug_options_enable_debugging: None,
                        }
                    }
                    #[doc = "Fetches the item whose viewUrl exactly matches that of the URL provided in the request. **Note:** This API requires an admin account to execute."]
                    pub fn search_by_view_url(
                        &self,
                        request: crate::schemas::SearchItemsByViewUrlRequest,
                        name: impl Into<String>,
                    ) -> SearchByViewUrlRequestBuilder {
                        SearchByViewUrlRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Actions that can be performed on the unmappedids resource"]
                    pub fn unmappedids(
                        &self,
                    ) -> crate::resources::debug::datasources::items::unmappedids::UnmappedidsActions
                    {
                        crate :: resources :: debug :: datasources :: items :: unmappedids :: UnmappedidsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                }
                #[doc = "Created via [ItemsActions::check_access()](struct.ItemsActions.html#method.check_access)"]
                #[derive(Debug, Clone)]
                pub struct CheckAccessRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::Principal,
                    name: String,
                    debug_options_enable_debugging: ::std::option::Option<bool>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> CheckAccessRequestBuilder<'a> {
                    #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                    pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                        self.debug_options_enable_debugging = Some(value);
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::CheckAccessResponse, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::CheckAccessResponse, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/debug/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str(":checkAccess");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[(
                            "debugOptions.enableDebugging",
                            &self.debug_options_enable_debugging,
                        )]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ItemsActions::search_by_view_url()](struct.ItemsActions.html#method.search_by_view_url)"]
                #[derive(Debug, Clone)]
                pub struct SearchByViewUrlRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::SearchItemsByViewUrlRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> SearchByViewUrlRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::SearchItemsByViewUrlResponse, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::SearchItemsByViewUrlResponse, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/debug/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/items:searchByViewUrl");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                pub mod unmappedids {
                    pub mod params {}
                    pub struct UnmappedidsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> UnmappedidsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "List all unmapped identities for a specific item. **Note:** This API requires an admin account to execute."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                debug_options_enable_debugging: None,
                                page_size: None,
                                page_token: None,
                            }
                        }
                    }
                    #[doc = "Created via [UnmappedidsActions::list()](struct.UnmappedidsActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        debug_options_enable_debugging: ::std::option::Option<bool>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                        pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                            self.debug_options_enable_debugging = Some(value);
                            self
                        }
                        #[doc = "Maximum number of items to fetch in a request. Defaults to 100."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "The next_page_token value returned from a previous List request, if any."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `unmappedIdentities` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_unmapped_identities<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_unmapped_identities_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `unmappedIdentities` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_unmapped_identities_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<crate::schemas::UnmappedIdentity, crate::Error>,
                        > + 'a {
                            self.stream_unmapped_identities_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `unmappedIdentities` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_unmapped_identities_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<crate::schemas::UnmappedIdentity, crate::Error>,
                        > + 'a {
                            self.stream_unmapped_identities_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `unmappedIdentities` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_unmapped_identities_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "unmappedIdentities")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "unmappedIdentities").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]
                        pub fn stream_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::ListUnmappedIdentitiesResponse,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]
                        pub fn stream_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::ListUnmappedIdentitiesResponse,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<crate::schemas::ListUnmappedIdentitiesResponse, crate::Error>
                        {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<crate::schemas::ListUnmappedIdentitiesResponse, crate::Error>
                        {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                            output.push_str("v1/debug/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/unmappedids");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[(
                                "debugOptions.enableDebugging",
                                &self.debug_options_enable_debugging,
                            )]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                }
            }
        }
        pub mod identitysources {
            pub mod params {}
            pub struct IdentitysourcesActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> IdentitysourcesActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Actions that can be performed on the items resource"]
                pub fn items(
                    &self,
                ) -> crate::resources::debug::identitysources::items::ItemsActions {
                    crate::resources::debug::identitysources::items::ItemsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the unmappedids resource"]
                pub fn unmappedids(
                    &self,
                ) -> crate::resources::debug::identitysources::unmappedids::UnmappedidsActions
                {
                    crate::resources::debug::identitysources::unmappedids::UnmappedidsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
            }
            pub mod items {
                pub mod params {}
                pub struct ItemsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> ItemsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Lists names of items associated with an unmapped identity. **Note:** This API requires an admin account to execute."]
                    pub fn list_forunmappedidentity(
                        &self,
                        parent: impl Into<String>,
                    ) -> ListForunmappedidentityRequestBuilder {
                        ListForunmappedidentityRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            debug_options_enable_debugging: None,
                            group_resource_name: None,
                            page_size: None,
                            page_token: None,
                            user_resource_name: None,
                        }
                    }
                }
                #[doc = "Created via [ItemsActions::list_forunmappedidentity()](struct.ItemsActions.html#method.list_forunmappedidentity)"]
                #[derive(Debug, Clone)]
                pub struct ListForunmappedidentityRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    parent: String,
                    debug_options_enable_debugging: ::std::option::Option<bool>,
                    group_resource_name: ::std::option::Option<String>,
                    page_size: ::std::option::Option<i32>,
                    page_token: ::std::option::Option<String>,
                    user_resource_name: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> ListForunmappedidentityRequestBuilder<'a> {
                    #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                    pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                        self.debug_options_enable_debugging = Some(value);
                        self
                    }
                    #[doc = ""]
                    pub fn group_resource_name(mut self, value: impl Into<String>) -> Self {
                        self.group_resource_name = Some(value.into());
                        self
                    }
                    #[doc = "Maximum number of items to fetch in a request. Defaults to 100."]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "The next_page_token value returned from a previous List request, if any."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = ""]
                    pub fn user_resource_name(mut self, value: impl Into<String>) -> Self {
                        self.user_resource_name = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = "\nExecute the request and yield each item in the `itemNames` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                    pub fn stream_item_names<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_item_names_with_fields(fields)
                    }
                    #[doc = "\nExecute the request and yield each item in the `itemNames` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                    pub fn stream_item_names_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<String, crate::Error>> + 'a
                    {
                        self.stream_item_names_with_fields(None::<String>)
                    }
                    #[doc = "\nExecute the request and yield each item in the `itemNames` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                    pub fn stream_item_names_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<String, crate::Error>> + 'a
                    {
                        self.stream_item_names_with_fields(Some("*"))
                    }
                    #[doc = "\nExecute the request and yield each item in the `itemNames` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                    pub fn stream_item_names_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                        struct Page<T> {
                            #[serde(rename = "nextPageToken")]
                            pub next_page_token: ::std::option::Option<String>,
                            #[serde(rename = "itemNames")]
                            pub items: Vec<T>,
                        }
                        impl<T> crate::GetNextPageToken<String> for Page<T> {
                            fn next_page_token(&self) -> ::std::option::Option<String> {
                                self.next_page_token.to_owned()
                            }
                        }
                        impl<T> crate::stream::IntoPageItems for Page<T> {
                            type Items = Vec<T>;
                            fn into_page_items(self) -> Self::Items {
                                self.items
                            }
                        }
                        self.fields = Some({
                            let mut selector = concat!("nextPageToken,", "itemNames").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::stream::page_item_stream::<_, Page<T>>(self)
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                    pub fn stream<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String>
                            + ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_with_fields(fields)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the default set of fields from the server."]
                    pub fn stream_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::ListItemNamesForUnmappedIdentityResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests all fields from the server."]
                    pub fn stream_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::ListItemNamesForUnmappedIdentityResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                    #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    pub fn stream_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::stream::page_stream(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::ListItemNamesForUnmappedIdentityResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::ListItemNamesForUnmappedIdentityResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/debug/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/items:forunmappedidentity");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[(
                            "debugOptions.enableDebugging",
                            &self.debug_options_enable_debugging,
                        )]);
                        req = req.query(&[("groupResourceName", &self.group_resource_name)]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("userResourceName", &self.user_resource_name)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[async_trait::async_trait]
                impl<'a> crate::stream::StreamableMethod for ListForunmappedidentityRequestBuilder<'a> {
                    type PageToken = String;
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    async fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                    {
                        self._execute().await
                    }
                }
            }
            pub mod unmappedids {
                pub mod params {
                    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
                    pub enum ListResolutionStatusCode {
                        #[doc = "Input-only value. Used to list all unmapped identities regardless of status."]
                        CodeUnspecified,
                        #[doc = "IDaaS does not understand the identity source, probably because the schema was modified in a non compatible way."]
                        IdentitySourceMisconfigured,
                        #[doc = "The identity source associated with the identity was either not found or deleted."]
                        IdentitySourceNotFound,
                        #[doc = "Internal error."]
                        InternalError,
                        #[doc = "The unmapped identity was not found in IDaaS, and needs to be provided by the user."]
                        NotFound,
                        #[doc = "The number of users associated with the external identity is too large."]
                        TooManyMappingsFound,
                    }
                    impl ListResolutionStatusCode {
                        pub fn as_str(self) -> &'static str {
                            match self {
                                ListResolutionStatusCode::CodeUnspecified => "CODE_UNSPECIFIED",
                                ListResolutionStatusCode::IdentitySourceMisconfigured => {
                                    "IDENTITY_SOURCE_MISCONFIGURED"
                                }
                                ListResolutionStatusCode::IdentitySourceNotFound => {
                                    "IDENTITY_SOURCE_NOT_FOUND"
                                }
                                ListResolutionStatusCode::InternalError => "INTERNAL_ERROR",
                                ListResolutionStatusCode::NotFound => "NOT_FOUND",
                                ListResolutionStatusCode::TooManyMappingsFound => {
                                    "TOO_MANY_MAPPINGS_FOUND"
                                }
                            }
                        }
                    }
                    impl ::std::convert::AsRef<str> for ListResolutionStatusCode {
                        fn as_ref(&self) -> &str {
                            self.as_str()
                        }
                    }
                    impl ::std::str::FromStr for ListResolutionStatusCode {
                        type Err = ();
                        fn from_str(
                            s: &str,
                        ) -> ::std::result::Result<ListResolutionStatusCode, ()>
                        {
                            Ok(match s {
                                "CODE_UNSPECIFIED" => ListResolutionStatusCode::CodeUnspecified,
                                "IDENTITY_SOURCE_MISCONFIGURED" => {
                                    ListResolutionStatusCode::IdentitySourceMisconfigured
                                }
                                "IDENTITY_SOURCE_NOT_FOUND" => {
                                    ListResolutionStatusCode::IdentitySourceNotFound
                                }
                                "INTERNAL_ERROR" => ListResolutionStatusCode::InternalError,
                                "NOT_FOUND" => ListResolutionStatusCode::NotFound,
                                "TOO_MANY_MAPPINGS_FOUND" => {
                                    ListResolutionStatusCode::TooManyMappingsFound
                                }
                                _ => return Err(()),
                            })
                        }
                    }
                    impl ::std::fmt::Display for ListResolutionStatusCode {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                            f.write_str(self.as_str())
                        }
                    }
                    impl ::serde::Serialize for ListResolutionStatusCode {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> ::std::result::Result<S::Ok, S::Error>
                        where
                            S: ::serde::ser::Serializer,
                        {
                            serializer.serialize_str(self.as_str())
                        }
                    }
                    impl<'de> ::serde::Deserialize<'de> for ListResolutionStatusCode {
                        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                        where
                            D: ::serde::de::Deserializer<'de>,
                        {
                            let value: &'de str = <&str>::deserialize(deserializer)?;
                            Ok(match value {
                                "CODE_UNSPECIFIED" => ListResolutionStatusCode::CodeUnspecified,
                                "IDENTITY_SOURCE_MISCONFIGURED" => {
                                    ListResolutionStatusCode::IdentitySourceMisconfigured
                                }
                                "IDENTITY_SOURCE_NOT_FOUND" => {
                                    ListResolutionStatusCode::IdentitySourceNotFound
                                }
                                "INTERNAL_ERROR" => ListResolutionStatusCode::InternalError,
                                "NOT_FOUND" => ListResolutionStatusCode::NotFound,
                                "TOO_MANY_MAPPINGS_FOUND" => {
                                    ListResolutionStatusCode::TooManyMappingsFound
                                }
                                _ => {
                                    return Err(::serde::de::Error::custom(format!(
                                        "invalid enum for #name: {}",
                                        value
                                    )))
                                }
                            })
                        }
                    }
                    impl ::google_field_selector::FieldSelector for ListResolutionStatusCode {
                        fn fields() -> Vec<::google_field_selector::Field> {
                            Vec::new()
                        }
                    }
                    impl ::google_field_selector::ToFieldType for ListResolutionStatusCode {
                        fn field_type() -> ::google_field_selector::FieldType {
                            ::google_field_selector::FieldType::Leaf
                        }
                    }
                }
                pub struct UnmappedidsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> UnmappedidsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Lists unmapped user identities for an identity source. **Note:** This API requires an admin account to execute."]
                    pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                        ListRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            debug_options_enable_debugging: None,
                            page_size: None,
                            page_token: None,
                            resolution_status_code: None,
                        }
                    }
                }
                #[doc = "Created via [UnmappedidsActions::list()](struct.UnmappedidsActions.html#method.list)"]
                #[derive(Debug, Clone)]
                pub struct ListRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , parent : String , debug_options_enable_debugging : :: std :: option :: Option < bool > , page_size : :: std :: option :: Option < i32 > , page_token : :: std :: option :: Option < String > , resolution_status_code : :: std :: option :: Option < crate :: resources :: debug :: identitysources :: unmappedids :: params :: ListResolutionStatusCode > , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                impl<'a> ListRequestBuilder<'a> {
                    #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                    pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                        self.debug_options_enable_debugging = Some(value);
                        self
                    }
                    #[doc = "Maximum number of items to fetch in a request. Defaults to 100."]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "The next_page_token value returned from a previous List request, if any."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = "Limit users selection to this status."]
                    pub fn resolution_status_code(
                        mut self,
                        value : crate :: resources :: debug :: identitysources :: unmappedids :: params :: ListResolutionStatusCode,
                    ) -> Self {
                        self.resolution_status_code = Some(value);
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = "\nExecute the request and yield each item in the `unmappedIdentities` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                    pub fn stream_unmapped_identities<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_unmapped_identities_with_fields(fields)
                    }
                    #[doc = "\nExecute the request and yield each item in the `unmappedIdentities` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                    pub fn stream_unmapped_identities_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<crate::schemas::UnmappedIdentity, crate::Error>,
                    > + 'a {
                        self.stream_unmapped_identities_with_fields(None::<String>)
                    }
                    #[doc = "\nExecute the request and yield each item in the `unmappedIdentities` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                    pub fn stream_unmapped_identities_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<crate::schemas::UnmappedIdentity, crate::Error>,
                    > + 'a {
                        self.stream_unmapped_identities_with_fields(Some("*"))
                    }
                    #[doc = "\nExecute the request and yield each item in the `unmappedIdentities` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                    pub fn stream_unmapped_identities_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                        struct Page<T> {
                            #[serde(rename = "nextPageToken")]
                            pub next_page_token: ::std::option::Option<String>,
                            #[serde(rename = "unmappedIdentities")]
                            pub items: Vec<T>,
                        }
                        impl<T> crate::GetNextPageToken<String> for Page<T> {
                            fn next_page_token(&self) -> ::std::option::Option<String> {
                                self.next_page_token.to_owned()
                            }
                        }
                        impl<T> crate::stream::IntoPageItems for Page<T> {
                            type Items = Vec<T>;
                            fn into_page_items(self) -> Self::Items {
                                self.items
                            }
                        }
                        self.fields = Some({
                            let mut selector =
                                concat!("nextPageToken,", "unmappedIdentities").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::stream::page_item_stream::<_, Page<T>>(self)
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                    pub fn stream<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String>
                            + ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_with_fields(fields)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the default set of fields from the server."]
                    pub fn stream_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<crate::schemas::ListUnmappedIdentitiesResponse, crate::Error>,
                    > + 'a {
                        self.stream_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests all fields from the server."]
                    pub fn stream_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<crate::schemas::ListUnmappedIdentitiesResponse, crate::Error>,
                    > + 'a {
                        self.stream_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                    #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    pub fn stream_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::stream::page_stream(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::ListUnmappedIdentitiesResponse, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::ListUnmappedIdentitiesResponse, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/debug/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/unmappedids");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[(
                            "debugOptions.enableDebugging",
                            &self.debug_options_enable_debugging,
                        )]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("resolutionStatusCode", &self.resolution_status_code)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[async_trait::async_trait]
                impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                    type PageToken = String;
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    async fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                    {
                        self._execute().await
                    }
                }
            }
        }
    }
    pub mod indexing {
        pub mod params {}
        pub struct IndexingActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> IndexingActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Actions that can be performed on the datasources resource"]
            pub fn datasources(
                &self,
            ) -> crate::resources::indexing::datasources::DatasourcesActions {
                crate::resources::indexing::datasources::DatasourcesActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        pub mod datasources {
            pub mod params {}
            pub struct DatasourcesActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> DatasourcesActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Deletes the schema of a data source. **Note:** This API requires an admin or service account to execute."]
                pub fn delete_schema(&self, name: impl Into<String>) -> DeleteSchemaRequestBuilder {
                    DeleteSchemaRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        debug_options_enable_debugging: None,
                    }
                }
                #[doc = "Gets the schema of a data source. **Note:** This API requires an admin or service account to execute."]
                pub fn get_schema(&self, name: impl Into<String>) -> GetSchemaRequestBuilder {
                    GetSchemaRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        debug_options_enable_debugging: None,
                    }
                }
                #[doc = "Updates the schema of a data source. This method does not perform incremental updates to the schema. Instead, this method updates the schema by overwriting the entire schema. **Note:** This API requires an admin or service account to execute."]
                pub fn update_schema(
                    &self,
                    request: crate::schemas::UpdateSchemaRequest,
                    name: impl Into<String>,
                ) -> UpdateSchemaRequestBuilder {
                    UpdateSchemaRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Actions that can be performed on the items resource"]
                pub fn items(
                    &self,
                ) -> crate::resources::indexing::datasources::items::ItemsActions {
                    crate::resources::indexing::datasources::items::ItemsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
            }
            #[doc = "Created via [DatasourcesActions::delete_schema()](struct.DatasourcesActions.html#method.delete_schema)"]
            #[derive(Debug, Clone)]
            pub struct DeleteSchemaRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> DeleteSchemaRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/indexing/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/schema");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasourcesActions::get_schema()](struct.DatasourcesActions.html#method.get_schema)"]
            #[derive(Debug, Clone)]
            pub struct GetSchemaRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> GetSchemaRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Schema, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Schema, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/indexing/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/schema");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasourcesActions::update_schema()](struct.DatasourcesActions.html#method.update_schema)"]
            #[derive(Debug, Clone)]
            pub struct UpdateSchemaRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::UpdateSchemaRequest,
                name: String,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> UpdateSchemaRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    let req = req.json(&self.request);
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/indexing/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/schema");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::PUT, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            pub mod items {
                pub mod params {
                    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
                    pub enum DeleteMode {
                        #[doc = "For changes that are executed after the response is sent back to the caller."]
                        Asynchronous,
                        #[doc = "For real-time updates."]
                        Synchronous,
                        #[doc = "The priority is not specified in the update request. Leaving priority unspecified results in an update failure."]
                        Unspecified,
                    }
                    impl DeleteMode {
                        pub fn as_str(self) -> &'static str {
                            match self {
                                DeleteMode::Asynchronous => "ASYNCHRONOUS",
                                DeleteMode::Synchronous => "SYNCHRONOUS",
                                DeleteMode::Unspecified => "UNSPECIFIED",
                            }
                        }
                    }
                    impl ::std::convert::AsRef<str> for DeleteMode {
                        fn as_ref(&self) -> &str {
                            self.as_str()
                        }
                    }
                    impl ::std::str::FromStr for DeleteMode {
                        type Err = ();
                        fn from_str(s: &str) -> ::std::result::Result<DeleteMode, ()> {
                            Ok(match s {
                                "ASYNCHRONOUS" => DeleteMode::Asynchronous,
                                "SYNCHRONOUS" => DeleteMode::Synchronous,
                                "UNSPECIFIED" => DeleteMode::Unspecified,
                                _ => return Err(()),
                            })
                        }
                    }
                    impl ::std::fmt::Display for DeleteMode {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                            f.write_str(self.as_str())
                        }
                    }
                    impl ::serde::Serialize for DeleteMode {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> ::std::result::Result<S::Ok, S::Error>
                        where
                            S: ::serde::ser::Serializer,
                        {
                            serializer.serialize_str(self.as_str())
                        }
                    }
                    impl<'de> ::serde::Deserialize<'de> for DeleteMode {
                        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                        where
                            D: ::serde::de::Deserializer<'de>,
                        {
                            let value: &'de str = <&str>::deserialize(deserializer)?;
                            Ok(match value {
                                "ASYNCHRONOUS" => DeleteMode::Asynchronous,
                                "SYNCHRONOUS" => DeleteMode::Synchronous,
                                "UNSPECIFIED" => DeleteMode::Unspecified,
                                _ => {
                                    return Err(::serde::de::Error::custom(format!(
                                        "invalid enum for #name: {}",
                                        value
                                    )))
                                }
                            })
                        }
                    }
                    impl ::google_field_selector::FieldSelector for DeleteMode {
                        fn fields() -> Vec<::google_field_selector::Field> {
                            Vec::new()
                        }
                    }
                    impl ::google_field_selector::ToFieldType for DeleteMode {
                        fn field_type() -> ::google_field_selector::FieldType {
                            ::google_field_selector::FieldType::Leaf
                        }
                    }
                }
                pub struct ItemsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> ItemsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Deletes Item resource for the specified resource name. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                        DeleteRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            connector_name: None,
                            debug_options_enable_debugging: None,
                            mode: None,
                            version: None,
                        }
                    }
                    #[doc = "Deletes all items in a queue. This method is useful for deleting stale items. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn delete_queue_items(
                        &self,
                        request: crate::schemas::DeleteQueueItemsRequest,
                        name: impl Into<String>,
                    ) -> DeleteQueueItemsRequestBuilder {
                        DeleteQueueItemsRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Gets Item resource by item name. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            connector_name: None,
                            debug_options_enable_debugging: None,
                        }
                    }
                    #[doc = "Updates Item ACL, metadata, and content. It will insert the Item if it does not exist. This method does not support partial updates. Fields with no provided values are cleared out in the Cloud Search index. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn index(
                        &self,
                        request: crate::schemas::IndexItemRequest,
                        name: impl Into<String>,
                    ) -> IndexRequestBuilder {
                        IndexRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Lists all or a subset of Item resources. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn list(&self, name: impl Into<String>) -> ListRequestBuilder {
                        ListRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            brief: None,
                            connector_name: None,
                            debug_options_enable_debugging: None,
                            page_size: None,
                            page_token: None,
                        }
                    }
                    #[doc = "Polls for unreserved items from the indexing queue and marks a set as reserved, starting with items that have the oldest timestamp from the highest priority ItemStatus. The priority order is as follows: ERROR MODIFIED NEW_ITEM ACCEPTED Reserving items ensures that polling from other threads cannot create overlapping sets. After handling the reserved items, the client should put items back into the unreserved state, either by calling index, or by calling push with the type REQUEUE. Items automatically become available (unreserved) after 4 hours even if no update or push method is called. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn poll(
                        &self,
                        request: crate::schemas::PollItemsRequest,
                        name: impl Into<String>,
                    ) -> PollRequestBuilder {
                        PollRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Pushes an item onto a queue for later polling and updating. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn push(
                        &self,
                        request: crate::schemas::PushItemRequest,
                        name: impl Into<String>,
                    ) -> PushRequestBuilder {
                        PushRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Unreserves all items from a queue, making them all eligible to be polled. This method is useful for resetting the indexing queue after a connector has been restarted. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn unreserve(
                        &self,
                        request: crate::schemas::UnreserveItemsRequest,
                        name: impl Into<String>,
                    ) -> UnreserveRequestBuilder {
                        UnreserveRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Creates an upload session for uploading item content. For items smaller than 100 KB, it’s easier to embed the content inline within an index request. This API requires an admin or service account to execute. The service account used is the one whitelisted in the corresponding data source."]
                    pub fn upload(
                        &self,
                        request: crate::schemas::StartUploadItemRequest,
                        name: impl Into<String>,
                    ) -> UploadRequestBuilder {
                        UploadRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                }
                #[doc = "Created via [ItemsActions::delete()](struct.ItemsActions.html#method.delete)"]
                #[derive(Debug, Clone)]
                pub struct DeleteRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    connector_name: ::std::option::Option<String>,
                    debug_options_enable_debugging: ::std::option::Option<bool>,
                    mode: ::std::option::Option<
                        crate::resources::indexing::datasources::items::params::DeleteMode,
                    >,
                    version: ::std::option::Option<::google_api_bytes::Bytes>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> DeleteRequestBuilder<'a> {
                    #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
                    pub fn connector_name(mut self, value: impl Into<String>) -> Self {
                        self.connector_name = Some(value.into());
                        self
                    }
                    #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                    pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                        self.debug_options_enable_debugging = Some(value);
                        self
                    }
                    #[doc = "Required. The RequestMode for this request."]
                    pub fn mode(
                        mut self,
                        value: crate::resources::indexing::datasources::items::params::DeleteMode,
                    ) -> Self {
                        self.mode = Some(value);
                        self
                    }
                    #[doc = "Required. The incremented version of the item to delete from the index. The indexing system stores the version from the datasource as a byte string and compares the Item version in the index to the version of the queued Item using lexical ordering. Cloud Search Indexing won’t delete any queued item with a version value that is less than or equal to the version of the currently indexed item. The maximum length for this field is 1024 bytes. For information on how item version affects the deletion process, refer to [Handle revisions after manual deletes](https://developers.google.com/cloud-search/docs/guides/operations)."]
                    pub fn version(mut self, value: impl Into<Vec<u8>>) -> Self {
                        let v: Vec<u8> = value.into();
                        self.version = Some(v.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::Operation, crate::Error> {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::Operation, crate::Error> {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                        req = req.query(&[("connectorName", &self.connector_name)]);
                        req = req.query(&[(
                            "debugOptions.enableDebugging",
                            &self.debug_options_enable_debugging,
                        )]);
                        req = req.query(&[("mode", &self.mode)]);
                        req = req.query(&[("version", &self.version)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ItemsActions::delete_queue_items()](struct.ItemsActions.html#method.delete_queue_items)"]
                #[derive(Debug, Clone)]
                pub struct DeleteQueueItemsRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::DeleteQueueItemsRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> DeleteQueueItemsRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::Operation, crate::Error> {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::Operation, crate::Error> {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/items:deleteQueueItems");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ItemsActions::get()](struct.ItemsActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    connector_name: ::std::option::Option<String>,
                    debug_options_enable_debugging: ::std::option::Option<bool>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
                    pub fn connector_name(mut self, value: impl Into<String>) -> Self {
                        self.connector_name = Some(value.into());
                        self
                    }
                    #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                    pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                        self.debug_options_enable_debugging = Some(value);
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::Item, crate::Error> {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::Item, crate::Error> {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("connectorName", &self.connector_name)]);
                        req = req.query(&[(
                            "debugOptions.enableDebugging",
                            &self.debug_options_enable_debugging,
                        )]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ItemsActions::index()](struct.ItemsActions.html#method.index)"]
                #[derive(Debug, Clone)]
                pub struct IndexRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::IndexItemRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> IndexRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::Operation, crate::Error> {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::Operation, crate::Error> {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str(":index");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ItemsActions::list()](struct.ItemsActions.html#method.list)"]
                #[derive(Debug, Clone)]
                pub struct ListRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    brief: ::std::option::Option<bool>,
                    connector_name: ::std::option::Option<String>,
                    debug_options_enable_debugging: ::std::option::Option<bool>,
                    page_size: ::std::option::Option<i32>,
                    page_token: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> ListRequestBuilder<'a> {
                    #[doc = "When set to true, the indexing system only populates the following fields: name, version, queue. metadata.hash, metadata.title, metadata.sourceRepositoryURL, metadata.objectType, metadata.createTime, metadata.updateTime, metadata.contentLanguage, metadata.mimeType, structured_data.hash, content.hash, itemType, itemStatus.code, itemStatus.processingError.code, itemStatus.repositoryError.type, If this value is false, then all the fields are populated in Item."]
                    pub fn brief(mut self, value: bool) -> Self {
                        self.brief = Some(value);
                        self
                    }
                    #[doc = "The name of connector making this call. Format: datasources/{source_id}/connectors/{ID}"]
                    pub fn connector_name(mut self, value: impl Into<String>) -> Self {
                        self.connector_name = Some(value.into());
                        self
                    }
                    #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                    pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                        self.debug_options_enable_debugging = Some(value);
                        self
                    }
                    #[doc = "Maximum number of items to fetch in a request. The max value is 1000 when brief is true. The max value is 10 if brief is false. The default value is 10"]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "The next_page_token value returned from a previous List request, if any."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = "\nExecute the request and yield each item in the `items` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                    pub fn stream_items<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_items_with_fields(fields)
                    }
                    #[doc = "\nExecute the request and yield each item in the `items` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                    pub fn stream_items_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<crate::schemas::Item, crate::Error>> + 'a
                    {
                        self.stream_items_with_fields(None::<String>)
                    }
                    #[doc = "\nExecute the request and yield each item in the `items` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                    pub fn stream_items_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<crate::schemas::Item, crate::Error>> + 'a
                    {
                        self.stream_items_with_fields(Some("*"))
                    }
                    #[doc = "\nExecute the request and yield each item in the `items` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                    pub fn stream_items_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                        struct Page<T> {
                            #[serde(rename = "nextPageToken")]
                            pub next_page_token: ::std::option::Option<String>,
                            #[serde(rename = "items")]
                            pub items: Vec<T>,
                        }
                        impl<T> crate::GetNextPageToken<String> for Page<T> {
                            fn next_page_token(&self) -> ::std::option::Option<String> {
                                self.next_page_token.to_owned()
                            }
                        }
                        impl<T> crate::stream::IntoPageItems for Page<T> {
                            type Items = Vec<T>;
                            fn into_page_items(self) -> Self::Items {
                                self.items
                            }
                        }
                        self.fields = Some({
                            let mut selector = concat!("nextPageToken,", "items").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::stream::page_item_stream::<_, Page<T>>(self)
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                    pub fn stream<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String>
                            + ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_with_fields(fields)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the default set of fields from the server."]
                    pub fn stream_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<crate::schemas::ListItemsResponse, crate::Error>,
                    > + 'a {
                        self.stream_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests all fields from the server."]
                    pub fn stream_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<crate::schemas::ListItemsResponse, crate::Error>,
                    > + 'a {
                        self.stream_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                    #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    pub fn stream_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::stream::page_stream(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::ListItemsResponse, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::ListItemsResponse, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/items");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("brief", &self.brief)]);
                        req = req.query(&[("connectorName", &self.connector_name)]);
                        req = req.query(&[(
                            "debugOptions.enableDebugging",
                            &self.debug_options_enable_debugging,
                        )]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[async_trait::async_trait]
                impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                    type PageToken = String;
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    async fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                    {
                        self._execute().await
                    }
                }
                #[doc = "Created via [ItemsActions::poll()](struct.ItemsActions.html#method.poll)"]
                #[derive(Debug, Clone)]
                pub struct PollRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::PollItemsRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> PollRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::PollItemsResponse, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::PollItemsResponse, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/items:poll");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ItemsActions::push()](struct.ItemsActions.html#method.push)"]
                #[derive(Debug, Clone)]
                pub struct PushRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::PushItemRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> PushRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::Item, crate::Error> {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::Item, crate::Error> {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str(":push");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ItemsActions::unreserve()](struct.ItemsActions.html#method.unreserve)"]
                #[derive(Debug, Clone)]
                pub struct UnreserveRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::UnreserveItemsRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> UnreserveRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::Operation, crate::Error> {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::Operation, crate::Error> {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/items:unreserve");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ItemsActions::upload()](struct.ItemsActions.html#method.upload)"]
                #[derive(Debug, Clone)]
                pub struct UploadRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::StartUploadItemRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> UploadRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::UploadItemRef, crate::Error> {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::UploadItemRef, crate::Error> {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/indexing/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str(":upload");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
            }
        }
    }
    pub mod media {
        pub mod params {}
        pub struct MediaActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> MediaActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Uploads media for indexing. The upload endpoint supports direct and resumable upload protocols and is intended for large items that can not be [inlined during index requests](https://developers.google.com/cloud-search/docs/reference/rest/v1/indexing.datasources.items#itemcontent). To index large content: 1. Call indexing.datasources.items.upload with the item name to begin an upload session and retrieve the UploadItemRef. 1. Call media.upload to upload the content, as a streaming request, using the same resource name from the UploadItemRef from step 1. 1. Call indexing.datasources.items.index to index the item. Populate the [ItemContent](/cloud-search/docs/reference/rest/v1/indexing.datasources.items#ItemContent) with the UploadItemRef from step 1. For additional information, see [Create a content connector using the REST API](https://developers.google.com/cloud-search/docs/guides/content-connector#rest). **Note:** This API requires a service account to execute."]
            pub fn upload(
                &self,
                request: crate::schemas::Media,
                resource_name: impl Into<String>,
            ) -> UploadRequestBuilder {
                UploadRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    request,
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    resource_name: resource_name.into(),
                }
            }
        }
        #[doc = "Created via [MediaActions::upload()](struct.MediaActions.html#method.upload)"]
        #[derive(Debug, Clone)]
        pub struct UploadRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            request: crate::schemas::Media,
            resource_name: String,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> UploadRequestBuilder<'a> {
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            fn _simple_upload_path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("upload/v1/media/");
                {
                    let var_as_str = &self.resource_name;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::RESERVED,
                    ));
                }
                output
            }
            pub async fn upload<T, R>(
                mut self,
                content: R,
                mime_type: ::mime::Mime,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                R: futures::io::AsyncRead + std::marker::Unpin + Send + 'static,
            {
                use crate::multipart::{Part, RelatedMultiPart};
                use futures::io::AsyncReadExt;
                let fields = ::google_field_selector::to_string::<T>();
                self.fields = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                let req = self._request(&self._simple_upload_path()).await?;
                let req = req.query(&[("uploadType", "multipart")]);
                let mut multipart = RelatedMultiPart::new();
                let request_json = ::serde_json::to_vec(&self.request)?;
                multipart.new_part(Part::new(
                    ::mime::APPLICATION_JSON,
                    Box::new(futures::io::Cursor::new(request_json)),
                ));
                multipart.new_part(Part::new(mime_type, Box::new(content)));
                let req = req.header(
                    ::reqwest::header::CONTENT_TYPE,
                    format!("multipart/related; boundary={}", multipart.boundary()),
                );
                let mut body: Vec<u8> = vec![];
                let mut reader = multipart.into_reader();
                let _num_bytes = reader.read_to_end(&mut body).await?;
                let req = req.body(body);
                let response = req.send().await?.error_for_status()?;
                Ok(response.json().await?)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::Media, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::Media, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                let req = req.json(&self.request);
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/media/");
                {
                    let var_as_str = &self.resource_name;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::RESERVED,
                    ));
                }
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
    }
    pub mod operations {
        pub mod params {}
        pub struct OperationsActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> OperationsActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service."]
            pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    name: name.into(),
                }
            }
            #[doc = "Actions that can be performed on the lro resource"]
            pub fn lro(&self) -> crate::resources::operations::lro::LroActions {
                crate::resources::operations::lro::LroActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        #[doc = "Created via [OperationsActions::get()](struct.OperationsActions.html#method.get)"]
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            name: String,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GetRequestBuilder<'a> {
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::Operation, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::Operation, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/");
                {
                    let var_as_str = &self.name;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::RESERVED,
                    ));
                }
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        pub mod lro {
            pub mod params {}
            pub struct LroActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> LroActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Lists operations that match the specified filter in the request. If the server doesn’t support this method, it returns `UNIMPLEMENTED`. NOTE: the `name` binding allows API services to override the binding to use different resource name schemes, such as `users/*/operations`. To override the binding, API services can add a binding such as `\"/v1/{name=users/*}/operations\"` to their service configuration. For backwards compatibility, the default name includes the operations collection id, however overriding users must ensure the name binding is the parent resource, without the operations collection id."]
                pub fn list(&self, name: impl Into<String>) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        filter: None,
                        page_size: None,
                        page_token: None,
                    }
                }
            }
            #[doc = "Created via [LroActions::list()](struct.LroActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                filter: ::std::option::Option<String>,
                page_size: ::std::option::Option<i32>,
                page_token: ::std::option::Option<String>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "The standard list filter."]
                pub fn filter(mut self, value: impl Into<String>) -> Self {
                    self.filter = Some(value.into());
                    self
                }
                #[doc = "The standard list page size."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "The standard list page token."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = "\nExecute the request and yield each item in the `operations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                pub fn stream_operations<T>(
                    self,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector + 'a,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.stream_operations_with_fields(fields)
                }
                #[doc = "\nExecute the request and yield each item in the `operations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                pub fn stream_operations_with_default_fields(
                    self,
                ) -> impl ::futures::Stream<Item = Result<crate::schemas::Operation, crate::Error>> + 'a
                {
                    self.stream_operations_with_fields(None::<String>)
                }
                #[doc = "\nExecute the request and yield each item in the `operations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                pub fn stream_operations_with_all_fields(
                    self,
                ) -> impl ::futures::Stream<Item = Result<crate::schemas::Operation, crate::Error>> + 'a
                {
                    self.stream_operations_with_fields(Some("*"))
                }
                #[doc = "\nExecute the request and yield each item in the `operations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                pub fn stream_operations_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: ::serde::de::DeserializeOwned + 'a,
                    F: AsRef<str>,
                {
                    #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                    struct Page<T> {
                        #[serde(rename = "nextPageToken")]
                        pub next_page_token: ::std::option::Option<String>,
                        #[serde(rename = "operations")]
                        pub items: Vec<T>,
                    }
                    impl<T> crate::GetNextPageToken<String> for Page<T> {
                        fn next_page_token(&self) -> ::std::option::Option<String> {
                            self.next_page_token.to_owned()
                        }
                    }
                    impl<T> crate::stream::IntoPageItems for Page<T> {
                        type Items = Vec<T>;
                        fn into_page_items(self) -> Self::Items {
                            self.items
                        }
                    }
                    self.fields = Some({
                        let mut selector = concat!("nextPageToken,", "operations").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::stream::page_item_stream::<_, Page<T>>(self)
                }
                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                #[doc = r" token is returned."]
                #[doc = r""]
                #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                #[doc = r""]
                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                pub fn stream<T>(
                    self,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: crate::GetNextPageToken<String>
                        + ::serde::de::DeserializeOwned
                        + ::google_field_selector::FieldSelector
                        + 'a,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.stream_with_fields(fields)
                }
                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                #[doc = r" repeated until no page token is returned."]
                #[doc = r""]
                #[doc = r" Requests the default set of fields from the server."]
                pub fn stream_with_default_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::ListOperationsResponse, crate::Error>,
                > + 'a {
                    self.stream_with_fields(None::<&str>)
                }
                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                #[doc = r" repeated until no page token is returned."]
                #[doc = r""]
                #[doc = r" Requests all fields from the server."]
                pub fn stream_with_all_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::ListOperationsResponse, crate::Error>,
                > + 'a {
                    self.stream_with_fields(Some("*"))
                }
                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                #[doc = r" token is returned."]
                #[doc = r""]
                #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                #[doc = r""]
                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                pub fn stream_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::stream::page_stream(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::ListOperationsResponse, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::ListOperationsResponse, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str("/lro");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("filter", &self.filter)]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[async_trait::async_trait]
            impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                type PageToken = String;
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                async fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                {
                    self._execute().await
                }
            }
        }
    }
    pub mod query {
        pub mod params {}
        pub struct QueryActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> QueryActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "The Cloud Search Query API provides the search method, which returns the most relevant results from a user query. The results can come from Google Workspace apps, such as Gmail or Google Drive, or they can come from data that you have indexed from a third party. **Note:** This API requires a standard end user account to execute. A service account can’t perform Query API requests directly; to use a service account to perform queries, set up [Google Workspace domain-wide delegation of authority](https://developers.google.com/cloud-search/docs/guides/delegation/)."]
            pub fn search(&self, request: crate::schemas::SearchRequest) -> SearchRequestBuilder {
                SearchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    request,
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                }
            }
            #[doc = "Provides suggestions for autocompleting the query. **Note:** This API requires a standard end user account to execute. A service account can’t perform Query API requests directly; to use a service account to perform queries, set up [Google Workspace domain-wide delegation of authority](https://developers.google.com/cloud-search/docs/guides/delegation/)."]
            pub fn suggest(
                &self,
                request: crate::schemas::SuggestRequest,
            ) -> SuggestRequestBuilder {
                SuggestRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    request,
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                }
            }
            #[doc = "Actions that can be performed on the sources resource"]
            pub fn sources(&self) -> crate::resources::query::sources::SourcesActions {
                crate::resources::query::sources::SourcesActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        #[doc = "Created via [QueryActions::search()](struct.QueryActions.html#method.search)"]
        #[derive(Debug, Clone)]
        pub struct SearchRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            request: crate::schemas::SearchRequest,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> SearchRequestBuilder<'a> {
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::SearchResponse, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::SearchResponse, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                let req = req.json(&self.request);
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/query/search");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        #[doc = "Created via [QueryActions::suggest()](struct.QueryActions.html#method.suggest)"]
        #[derive(Debug, Clone)]
        pub struct SuggestRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            request: crate::schemas::SuggestRequest,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> SuggestRequestBuilder<'a> {
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::SuggestResponse, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::SuggestResponse, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                let req = req.json(&self.request);
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/query/suggest");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        pub mod sources {
            pub mod params {}
            pub struct SourcesActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> SourcesActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Returns list of sources that user can use for Search and Suggest APIs. **Note:** This API requires a standard end user account to execute. A service account can’t perform Query API requests directly; to use a service account to perform queries, set up [Google Workspace domain-wide delegation of authority](https://developers.google.com/cloud-search/docs/guides/delegation/)."]
                pub fn list(&self) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        page_token: None,
                        request_options_debug_options_enable_debugging: None,
                        request_options_language_code: None,
                        request_options_search_application_id: None,
                        request_options_time_zone: None,
                    }
                }
            }
            #[doc = "Created via [SourcesActions::list()](struct.SourcesActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                page_token: ::std::option::Option<String>,
                request_options_debug_options_enable_debugging: ::std::option::Option<bool>,
                request_options_language_code: ::std::option::Option<String>,
                request_options_search_application_id: ::std::option::Option<String>,
                request_options_time_zone: ::std::option::Option<String>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "Number of sources to return in the response."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn request_options_debug_options_enable_debugging(
                    mut self,
                    value: bool,
                ) -> Self {
                    self.request_options_debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "The BCP-47 language code, such as “en-US” or “sr-Latn”. For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. For translations. Set this field using the language set in browser or for the page. In the event that the user’s language preference is known, set this field to the known user language. When specified, the documents in search results are biased towards the specified language. From Suggest API perspective, for 3p suggest this is used as a hint while making predictions to add language boosting."]
                pub fn request_options_language_code(mut self, value: impl Into<String>) -> Self {
                    self.request_options_language_code = Some(value.into());
                    self
                }
                #[doc = "The ID generated when you create a search application using the [admin console](https://support.google.com/a/answer/9043922)."]
                pub fn request_options_search_application_id(
                    mut self,
                    value: impl Into<String>,
                ) -> Self {
                    self.request_options_search_application_id = Some(value.into());
                    self
                }
                #[doc = "Current user’s time zone id, such as “America/Los_Angeles” or “Australia/Sydney”. These IDs are defined by [Unicode Common Locale Data Repository (CLDR)](http://cldr.unicode.org/) project, and currently available in the file [timezone.xml](http://unicode.org/repos/cldr/trunk/common/bcp47/timezone.xml). This field is used to correctly interpret date and time queries. If this field is not specified, the default time zone (UTC) is used."]
                pub fn request_options_time_zone(mut self, value: impl Into<String>) -> Self {
                    self.request_options_time_zone = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = "\nExecute the request and yield each item in the `sources` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                pub fn stream_sources<T>(
                    self,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector + 'a,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.stream_sources_with_fields(fields)
                }
                #[doc = "\nExecute the request and yield each item in the `sources` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                pub fn stream_sources_with_default_fields(
                    self,
                ) -> impl ::futures::Stream<Item = Result<crate::schemas::QuerySource, crate::Error>> + 'a
                {
                    self.stream_sources_with_fields(None::<String>)
                }
                #[doc = "\nExecute the request and yield each item in the `sources` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                pub fn stream_sources_with_all_fields(
                    self,
                ) -> impl ::futures::Stream<Item = Result<crate::schemas::QuerySource, crate::Error>> + 'a
                {
                    self.stream_sources_with_fields(Some("*"))
                }
                #[doc = "\nExecute the request and yield each item in the `sources` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                pub fn stream_sources_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: ::serde::de::DeserializeOwned + 'a,
                    F: AsRef<str>,
                {
                    #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                    struct Page<T> {
                        #[serde(rename = "nextPageToken")]
                        pub next_page_token: ::std::option::Option<String>,
                        #[serde(rename = "sources")]
                        pub items: Vec<T>,
                    }
                    impl<T> crate::GetNextPageToken<String> for Page<T> {
                        fn next_page_token(&self) -> ::std::option::Option<String> {
                            self.next_page_token.to_owned()
                        }
                    }
                    impl<T> crate::stream::IntoPageItems for Page<T> {
                        type Items = Vec<T>;
                        fn into_page_items(self) -> Self::Items {
                            self.items
                        }
                    }
                    self.fields = Some({
                        let mut selector = concat!("nextPageToken,", "sources").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::stream::page_item_stream::<_, Page<T>>(self)
                }
                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                #[doc = r" token is returned."]
                #[doc = r""]
                #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                #[doc = r""]
                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                pub fn stream<T>(
                    self,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: crate::GetNextPageToken<String>
                        + ::serde::de::DeserializeOwned
                        + ::google_field_selector::FieldSelector
                        + 'a,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.stream_with_fields(fields)
                }
                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                #[doc = r" repeated until no page token is returned."]
                #[doc = r""]
                #[doc = r" Requests the default set of fields from the server."]
                pub fn stream_with_default_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::ListQuerySourcesResponse, crate::Error>,
                > + 'a {
                    self.stream_with_fields(None::<&str>)
                }
                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                #[doc = r" repeated until no page token is returned."]
                #[doc = r""]
                #[doc = r" Requests all fields from the server."]
                pub fn stream_with_all_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::ListQuerySourcesResponse, crate::Error>,
                > + 'a {
                    self.stream_with_fields(Some("*"))
                }
                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                #[doc = r" token is returned."]
                #[doc = r""]
                #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                #[doc = r""]
                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                pub fn stream_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::stream::page_stream(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::ListQuerySourcesResponse, crate::Error>
                {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::ListQuerySourcesResponse, crate::Error>
                {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/query/sources");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[(
                        "requestOptions.debugOptions.enableDebugging",
                        &self.request_options_debug_options_enable_debugging,
                    )]);
                    req = req.query(&[(
                        "requestOptions.languageCode",
                        &self.request_options_language_code,
                    )]);
                    req = req.query(&[(
                        "requestOptions.searchApplicationId",
                        &self.request_options_search_application_id,
                    )]);
                    req =
                        req.query(&[("requestOptions.timeZone", &self.request_options_time_zone)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[async_trait::async_trait]
            impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                type PageToken = String;
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                async fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                {
                    self._execute().await
                }
            }
        }
    }
    pub mod settings {
        pub mod params {}
        pub struct SettingsActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> SettingsActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Get customer settings. **Note:** This API requires an admin account to execute."]
            pub fn get_customer(&self) -> GetCustomerRequestBuilder {
                GetCustomerRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                }
            }
            #[doc = "Update customer settings. **Note:** This API requires an admin account to execute."]
            pub fn update_customer(
                &self,
                request: crate::schemas::CustomerSettings,
            ) -> UpdateCustomerRequestBuilder {
                UpdateCustomerRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    request,
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    update_mask: None,
                }
            }
            #[doc = "Actions that can be performed on the datasources resource"]
            pub fn datasources(
                &self,
            ) -> crate::resources::settings::datasources::DatasourcesActions {
                crate::resources::settings::datasources::DatasourcesActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the searchapplications resource"]
            pub fn searchapplications(
                &self,
            ) -> crate::resources::settings::searchapplications::SearchapplicationsActions
            {
                crate::resources::settings::searchapplications::SearchapplicationsActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        #[doc = "Created via [SettingsActions::get_customer()](struct.SettingsActions.html#method.get_customer)"]
        #[derive(Debug, Clone)]
        pub struct GetCustomerRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GetCustomerRequestBuilder<'a> {
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::CustomerSettings, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::CustomerSettings, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/settings/customer");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        #[doc = "Created via [SettingsActions::update_customer()](struct.SettingsActions.html#method.update_customer)"]
        #[derive(Debug, Clone)]
        pub struct UpdateCustomerRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            request: crate::schemas::CustomerSettings,
            update_mask: ::std::option::Option<String>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> UpdateCustomerRequestBuilder<'a> {
            #[doc = "Update mask to control which fields get updated. If you specify a field in the update_mask but don’t specify its value here, that field will be cleared. If the mask is not present or empty, all fields will be updated. Currently supported field paths: vpc_settings and audit_logging_settings"]
            pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                self.update_mask = Some(value.into());
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::Operation, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::Operation, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                let req = req.json(&self.request);
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/settings/customer");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                req = req.query(&[("updateMask", &self.update_mask)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        pub mod datasources {
            pub mod params {}
            pub struct DatasourcesActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> DatasourcesActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Creates a datasource. **Note:** This API requires an admin account to execute."]
                pub fn create(&self, request: crate::schemas::DataSource) -> CreateRequestBuilder {
                    CreateRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                    }
                }
                #[doc = "Deletes a datasource. **Note:** This API requires an admin account to execute."]
                pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                    DeleteRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        debug_options_enable_debugging: None,
                    }
                }
                #[doc = "Gets a datasource. **Note:** This API requires an admin account to execute."]
                pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                    GetRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        debug_options_enable_debugging: None,
                    }
                }
                #[doc = "Lists datasources. **Note:** This API requires an admin account to execute."]
                pub fn list(&self) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        debug_options_enable_debugging: None,
                        page_size: None,
                        page_token: None,
                    }
                }
                #[doc = "Updates a datasource. **Note:** This API requires an admin account to execute."]
                pub fn patch(
                    &self,
                    request: crate::schemas::DataSource,
                    name: impl Into<String>,
                ) -> PatchRequestBuilder {
                    PatchRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        debug_options_enable_debugging: None,
                        update_mask: None,
                    }
                }
                #[doc = "Updates a datasource. **Note:** This API requires an admin account to execute."]
                pub fn update(
                    &self,
                    request: crate::schemas::UpdateDataSourceRequest,
                    name: impl Into<String>,
                ) -> UpdateRequestBuilder {
                    UpdateRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
            }
            #[doc = "Created via [DatasourcesActions::create()](struct.DatasourcesActions.html#method.create)"]
            #[derive(Debug, Clone)]
            pub struct CreateRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::DataSource,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> CreateRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    let req = req.json(&self.request);
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/datasources");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasourcesActions::delete()](struct.DatasourcesActions.html#method.delete)"]
            #[derive(Debug, Clone)]
            pub struct DeleteRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> DeleteRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasourcesActions::get()](struct.DatasourcesActions.html#method.get)"]
            #[derive(Debug, Clone)]
            pub struct GetRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> GetRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::DataSource, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::DataSource, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasourcesActions::list()](struct.DatasourcesActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                page_size: ::std::option::Option<i32>,
                page_token: ::std::option::Option<String>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "Maximum number of datasources to fetch in a request. The max value is 1000. The default value is 1000."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "Starting index of the results."]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = "\nExecute the request and yield each item in the `sources` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                pub fn stream_sources<T>(
                    self,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector + 'a,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.stream_sources_with_fields(fields)
                }
                #[doc = "\nExecute the request and yield each item in the `sources` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                pub fn stream_sources_with_default_fields(
                    self,
                ) -> impl ::futures::Stream<Item = Result<crate::schemas::DataSource, crate::Error>> + 'a
                {
                    self.stream_sources_with_fields(None::<String>)
                }
                #[doc = "\nExecute the request and yield each item in the `sources` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                pub fn stream_sources_with_all_fields(
                    self,
                ) -> impl ::futures::Stream<Item = Result<crate::schemas::DataSource, crate::Error>> + 'a
                {
                    self.stream_sources_with_fields(Some("*"))
                }
                #[doc = "\nExecute the request and yield each item in the `sources` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                pub fn stream_sources_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: ::serde::de::DeserializeOwned + 'a,
                    F: AsRef<str>,
                {
                    #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                    struct Page<T> {
                        #[serde(rename = "nextPageToken")]
                        pub next_page_token: ::std::option::Option<String>,
                        #[serde(rename = "sources")]
                        pub items: Vec<T>,
                    }
                    impl<T> crate::GetNextPageToken<String> for Page<T> {
                        fn next_page_token(&self) -> ::std::option::Option<String> {
                            self.next_page_token.to_owned()
                        }
                    }
                    impl<T> crate::stream::IntoPageItems for Page<T> {
                        type Items = Vec<T>;
                        fn into_page_items(self) -> Self::Items {
                            self.items
                        }
                    }
                    self.fields = Some({
                        let mut selector = concat!("nextPageToken,", "sources").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::stream::page_item_stream::<_, Page<T>>(self)
                }
                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                #[doc = r" token is returned."]
                #[doc = r""]
                #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                #[doc = r""]
                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                pub fn stream<T>(
                    self,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: crate::GetNextPageToken<String>
                        + ::serde::de::DeserializeOwned
                        + ::google_field_selector::FieldSelector
                        + 'a,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.stream_with_fields(fields)
                }
                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                #[doc = r" repeated until no page token is returned."]
                #[doc = r""]
                #[doc = r" Requests the default set of fields from the server."]
                pub fn stream_with_default_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::ListDataSourceResponse, crate::Error>,
                > + 'a {
                    self.stream_with_fields(None::<&str>)
                }
                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                #[doc = r" repeated until no page token is returned."]
                #[doc = r""]
                #[doc = r" Requests all fields from the server."]
                pub fn stream_with_all_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::ListDataSourceResponse, crate::Error>,
                > + 'a {
                    self.stream_with_fields(Some("*"))
                }
                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                #[doc = r" token is returned."]
                #[doc = r""]
                #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                #[doc = r""]
                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                pub fn stream_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::stream::page_stream(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::ListDataSourceResponse, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::ListDataSourceResponse, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/datasources");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[async_trait::async_trait]
            impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                type PageToken = String;
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                async fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                {
                    self._execute().await
                }
            }
            #[doc = "Created via [DatasourcesActions::patch()](struct.DatasourcesActions.html#method.patch)"]
            #[derive(Debug, Clone)]
            pub struct PatchRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::DataSource,
                name: String,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                update_mask: ::std::option::Option<String>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> PatchRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "Only applies to [`settings.datasources.patch`](https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.datasources/patch). Update mask to control which fields to update. Example field paths: `name`, `displayName`. * If `update_mask` is non-empty, then only the fields specified in the `update_mask` are updated. * If you specify a field in the `update_mask`, but don’t specify its value in the source, that field is cleared. * If the `update_mask` is not present or empty or has the value `*`, then all fields are updated."]
                pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                    self.update_mask = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    let req = req.json(&self.request);
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("updateMask", &self.update_mask)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [DatasourcesActions::update()](struct.DatasourcesActions.html#method.update)"]
            #[derive(Debug, Clone)]
            pub struct UpdateRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::UpdateDataSourceRequest,
                name: String,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> UpdateRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    let req = req.json(&self.request);
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::PUT, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
        }
        pub mod searchapplications {
            pub mod params {}
            pub struct SearchapplicationsActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> SearchapplicationsActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Creates a search application. **Note:** This API requires an admin account to execute."]
                pub fn create(
                    &self,
                    request: crate::schemas::SearchApplication,
                ) -> CreateRequestBuilder {
                    CreateRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                    }
                }
                #[doc = "Deletes a search application. **Note:** This API requires an admin account to execute."]
                pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                    DeleteRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        debug_options_enable_debugging: None,
                    }
                }
                #[doc = "Gets the specified search application. **Note:** This API requires an admin account to execute."]
                pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                    GetRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        debug_options_enable_debugging: None,
                    }
                }
                #[doc = "Lists all search applications. **Note:** This API requires an admin account to execute."]
                pub fn list(&self) -> ListRequestBuilder {
                    ListRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        debug_options_enable_debugging: None,
                        page_size: None,
                        page_token: None,
                    }
                }
                #[doc = "Updates a search application. **Note:** This API requires an admin account to execute."]
                pub fn patch(
                    &self,
                    request: crate::schemas::SearchApplication,
                    name: impl Into<String>,
                ) -> PatchRequestBuilder {
                    PatchRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        update_mask: None,
                    }
                }
                #[doc = "Resets a search application to default settings. This will return an empty response. **Note:** This API requires an admin account to execute."]
                pub fn reset(
                    &self,
                    request: crate::schemas::ResetSearchApplicationRequest,
                    name: impl Into<String>,
                ) -> ResetRequestBuilder {
                    ResetRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                    }
                }
                #[doc = "Updates a search application. **Note:** This API requires an admin account to execute."]
                pub fn update(
                    &self,
                    request: crate::schemas::SearchApplication,
                    name: impl Into<String>,
                ) -> UpdateRequestBuilder {
                    UpdateRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        request,
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        update_mask: None,
                    }
                }
            }
            #[doc = "Created via [SearchapplicationsActions::create()](struct.SearchapplicationsActions.html#method.create)"]
            #[derive(Debug, Clone)]
            pub struct CreateRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::SearchApplication,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> CreateRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    let req = req.json(&self.request);
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/searchapplications");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [SearchapplicationsActions::delete()](struct.SearchapplicationsActions.html#method.delete)"]
            #[derive(Debug, Clone)]
            pub struct DeleteRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> DeleteRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [SearchapplicationsActions::get()](struct.SearchapplicationsActions.html#method.get)"]
            #[derive(Debug, Clone)]
            pub struct GetRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> GetRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::SearchApplication, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::SearchApplication, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [SearchapplicationsActions::list()](struct.SearchapplicationsActions.html#method.list)"]
            #[derive(Debug, Clone)]
            pub struct ListRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                debug_options_enable_debugging: ::std::option::Option<bool>,
                page_size: ::std::option::Option<i32>,
                page_token: ::std::option::Option<String>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> ListRequestBuilder<'a> {
                #[doc = "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field."]
                pub fn debug_options_enable_debugging(mut self, value: bool) -> Self {
                    self.debug_options_enable_debugging = Some(value);
                    self
                }
                #[doc = "The maximum number of items to return."]
                pub fn page_size(mut self, value: i32) -> Self {
                    self.page_size = Some(value);
                    self
                }
                #[doc = "The next_page_token value returned from a previous List request, if any. The default value is 10"]
                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                    self.page_token = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = "\nExecute the request and yield each item in the `searchApplications` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                pub fn stream_search_applications<T>(
                    self,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector + 'a,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.stream_search_applications_with_fields(fields)
                }
                #[doc = "\nExecute the request and yield each item in the `searchApplications` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                pub fn stream_search_applications_with_default_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::SearchApplication, crate::Error>,
                > + 'a {
                    self.stream_search_applications_with_fields(None::<String>)
                }
                #[doc = "\nExecute the request and yield each item in the `searchApplications` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                pub fn stream_search_applications_with_all_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::SearchApplication, crate::Error>,
                > + 'a {
                    self.stream_search_applications_with_fields(Some("*"))
                }
                #[doc = "\nExecute the request and yield each item in the `searchApplications` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                pub fn stream_search_applications_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: ::serde::de::DeserializeOwned + 'a,
                    F: AsRef<str>,
                {
                    #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                    struct Page<T> {
                        #[serde(rename = "nextPageToken")]
                        pub next_page_token: ::std::option::Option<String>,
                        #[serde(rename = "searchApplications")]
                        pub items: Vec<T>,
                    }
                    impl<T> crate::GetNextPageToken<String> for Page<T> {
                        fn next_page_token(&self) -> ::std::option::Option<String> {
                            self.next_page_token.to_owned()
                        }
                    }
                    impl<T> crate::stream::IntoPageItems for Page<T> {
                        type Items = Vec<T>;
                        fn into_page_items(self) -> Self::Items {
                            self.items
                        }
                    }
                    self.fields = Some({
                        let mut selector =
                            concat!("nextPageToken,", "searchApplications").to_owned();
                        let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                        if !items_fields.is_empty() {
                            selector.push_str("(");
                            selector.push_str(items_fields);
                            selector.push_str(")");
                        }
                        selector
                    });
                    crate::stream::page_item_stream::<_, Page<T>>(self)
                }
                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                #[doc = r" token is returned."]
                #[doc = r""]
                #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                #[doc = r""]
                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                pub fn stream<T>(
                    self,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: crate::GetNextPageToken<String>
                        + ::serde::de::DeserializeOwned
                        + ::google_field_selector::FieldSelector
                        + 'a,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.stream_with_fields(fields)
                }
                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                #[doc = r" repeated until no page token is returned."]
                #[doc = r""]
                #[doc = r" Requests the default set of fields from the server."]
                pub fn stream_with_default_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::ListSearchApplicationsResponse, crate::Error>,
                > + 'a {
                    self.stream_with_fields(None::<&str>)
                }
                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                #[doc = r" repeated until no page token is returned."]
                #[doc = r""]
                #[doc = r" Requests all fields from the server."]
                pub fn stream_with_all_fields(
                    self,
                ) -> impl ::futures::Stream<
                    Item = Result<crate::schemas::ListSearchApplicationsResponse, crate::Error>,
                > + 'a {
                    self.stream_with_fields(Some("*"))
                }
                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                #[doc = r" token is returned."]
                #[doc = r""]
                #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                #[doc = r""]
                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                pub fn stream_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                where
                    T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                    F: AsRef<str>,
                {
                    let mut fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                    if !fields.is_empty() {
                        match fields.chars().rev().nth(0) {
                            Some(',') | None => {}
                            _ => fields.push_str(","),
                        }
                        fields.push_str("nextPageToken");
                        self.fields = Some(fields);
                    }
                    crate::stream::page_stream(self)
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::ListSearchApplicationsResponse, crate::Error>
                {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::ListSearchApplicationsResponse, crate::Error>
                {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/searchapplications");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[(
                        "debugOptions.enableDebugging",
                        &self.debug_options_enable_debugging,
                    )]);
                    req = req.query(&[("pageSize", &self.page_size)]);
                    req = req.query(&[("pageToken", &self.page_token)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[async_trait::async_trait]
            impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                type PageToken = String;
                fn set_page_token(&mut self, value: String) {
                    self.page_token = value.into();
                }
                async fn execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                {
                    self._execute().await
                }
            }
            #[doc = "Created via [SearchapplicationsActions::patch()](struct.SearchapplicationsActions.html#method.patch)"]
            #[derive(Debug, Clone)]
            pub struct PatchRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::SearchApplication,
                name: String,
                update_mask: ::std::option::Option<String>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> PatchRequestBuilder<'a> {
                #[doc = "Only applies to [`settings.searchapplications.patch`](https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.searchapplications/patch). Update mask to control which fields to update. Example field paths: `search_application.name`, `search_application.displayName`. * If `update_mask` is non-empty, then only the fields specified in the `update_mask` are updated. * If you specify a field in the `update_mask`, but don’t specify its value in the `search_application`, then that field is cleared. * If the `update_mask` is not present or empty or has the value `*`, then all fields are updated."]
                pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                    self.update_mask = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    let req = req.json(&self.request);
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                    req = req.query(&[("updateMask", &self.update_mask)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [SearchapplicationsActions::reset()](struct.SearchapplicationsActions.html#method.reset)"]
            #[derive(Debug, Clone)]
            pub struct ResetRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::ResetSearchApplicationRequest,
                name: String,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> ResetRequestBuilder<'a> {
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    let req = req.json(&self.request);
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str(":reset");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
            #[doc = "Created via [SearchapplicationsActions::update()](struct.SearchapplicationsActions.html#method.update)"]
            #[derive(Debug, Clone)]
            pub struct UpdateRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                request: crate::schemas::SearchApplication,
                name: String,
                update_mask: ::std::option::Option<String>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> UpdateRequestBuilder<'a> {
                #[doc = "Only applies to [`settings.searchapplications.patch`](https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.searchapplications/patch). Update mask to control which fields to update. Example field paths: `search_application.name`, `search_application.displayName`. * If `update_mask` is non-empty, then only the fields specified in the `update_mask` are updated. * If you specify a field in the `update_mask`, but don’t specify its value in the `search_application`, then that field is cleared. * If the `update_mask` is not present or empty or has the value `*`, then all fields are updated."]
                pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                    self.update_mask = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::Operation, crate::Error> {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    let req = req.json(&self.request);
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                    output.push_str("v1/settings/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::PUT, path);
                    req = req.query(&[("updateMask", &self.update_mask)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
        }
    }
    pub mod stats {
        pub mod params {}
        pub struct StatsActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> StatsActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Gets indexed item statistics aggreggated across all data sources. This API only returns statistics for previous dates; it doesn’t return statistics for the current day. **Note:** This API requires a standard end user account to execute."]
            pub fn get_index(&self) -> GetIndexRequestBuilder {
                GetIndexRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    from_date_day: None,
                    from_date_month: None,
                    from_date_year: None,
                    to_date_day: None,
                    to_date_month: None,
                    to_date_year: None,
                }
            }
            #[doc = "Get the query statistics for customer. **Note:** This API requires a standard end user account to execute."]
            pub fn get_query(&self) -> GetQueryRequestBuilder {
                GetQueryRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    from_date_day: None,
                    from_date_month: None,
                    from_date_year: None,
                    to_date_day: None,
                    to_date_month: None,
                    to_date_year: None,
                }
            }
            #[doc = "Get search application stats for customer. **Note:** This API requires a standard end user account to execute."]
            pub fn get_searchapplication(&self) -> GetSearchapplicationRequestBuilder {
                GetSearchapplicationRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    end_date_day: None,
                    end_date_month: None,
                    end_date_year: None,
                    start_date_day: None,
                    start_date_month: None,
                    start_date_year: None,
                }
            }
            #[doc = "Get the # of search sessions, % of successful sessions with a click query statistics for customer. **Note:** This API requires a standard end user account to execute."]
            pub fn get_session(&self) -> GetSessionRequestBuilder {
                GetSessionRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    from_date_day: None,
                    from_date_month: None,
                    from_date_year: None,
                    to_date_day: None,
                    to_date_month: None,
                    to_date_year: None,
                }
            }
            #[doc = "Get the users statistics for customer. **Note:** This API requires a standard end user account to execute."]
            pub fn get_user(&self) -> GetUserRequestBuilder {
                GetUserRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    from_date_day: None,
                    from_date_month: None,
                    from_date_year: None,
                    to_date_day: None,
                    to_date_month: None,
                    to_date_year: None,
                }
            }
            #[doc = "Actions that can be performed on the index resource"]
            pub fn index(&self) -> crate::resources::stats::index::IndexActions {
                crate::resources::stats::index::IndexActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the query resource"]
            pub fn query(&self) -> crate::resources::stats::query::QueryActions {
                crate::resources::stats::query::QueryActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the session resource"]
            pub fn session(&self) -> crate::resources::stats::session::SessionActions {
                crate::resources::stats::session::SessionActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
            #[doc = "Actions that can be performed on the user resource"]
            pub fn user(&self) -> crate::resources::stats::user::UserActions {
                crate::resources::stats::user::UserActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        #[doc = "Created via [StatsActions::get_index()](struct.StatsActions.html#method.get_index)"]
        #[derive(Debug, Clone)]
        pub struct GetIndexRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            from_date_day: ::std::option::Option<i32>,
            from_date_month: ::std::option::Option<i32>,
            from_date_year: ::std::option::Option<i32>,
            to_date_day: ::std::option::Option<i32>,
            to_date_month: ::std::option::Option<i32>,
            to_date_year: ::std::option::Option<i32>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GetIndexRequestBuilder<'a> {
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn from_date_day(mut self, value: i32) -> Self {
                self.from_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn from_date_month(mut self, value: i32) -> Self {
                self.from_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn from_date_year(mut self, value: i32) -> Self {
                self.from_date_year = Some(value);
                self
            }
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn to_date_day(mut self, value: i32) -> Self {
                self.to_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn to_date_month(mut self, value: i32) -> Self {
                self.to_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn to_date_year(mut self, value: i32) -> Self {
                self.to_date_year = Some(value);
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerIndexStatsResponse, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerIndexStatsResponse, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/stats/index");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("fromDate.day", &self.from_date_day)]);
                req = req.query(&[("fromDate.month", &self.from_date_month)]);
                req = req.query(&[("fromDate.year", &self.from_date_year)]);
                req = req.query(&[("toDate.day", &self.to_date_day)]);
                req = req.query(&[("toDate.month", &self.to_date_month)]);
                req = req.query(&[("toDate.year", &self.to_date_year)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        #[doc = "Created via [StatsActions::get_query()](struct.StatsActions.html#method.get_query)"]
        #[derive(Debug, Clone)]
        pub struct GetQueryRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            from_date_day: ::std::option::Option<i32>,
            from_date_month: ::std::option::Option<i32>,
            from_date_year: ::std::option::Option<i32>,
            to_date_day: ::std::option::Option<i32>,
            to_date_month: ::std::option::Option<i32>,
            to_date_year: ::std::option::Option<i32>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GetQueryRequestBuilder<'a> {
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn from_date_day(mut self, value: i32) -> Self {
                self.from_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn from_date_month(mut self, value: i32) -> Self {
                self.from_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn from_date_year(mut self, value: i32) -> Self {
                self.from_date_year = Some(value);
                self
            }
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn to_date_day(mut self, value: i32) -> Self {
                self.to_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn to_date_month(mut self, value: i32) -> Self {
                self.to_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn to_date_year(mut self, value: i32) -> Self {
                self.to_date_year = Some(value);
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerQueryStatsResponse, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerQueryStatsResponse, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/stats/query");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("fromDate.day", &self.from_date_day)]);
                req = req.query(&[("fromDate.month", &self.from_date_month)]);
                req = req.query(&[("fromDate.year", &self.from_date_year)]);
                req = req.query(&[("toDate.day", &self.to_date_day)]);
                req = req.query(&[("toDate.month", &self.to_date_month)]);
                req = req.query(&[("toDate.year", &self.to_date_year)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        #[doc = "Created via [StatsActions::get_searchapplication()](struct.StatsActions.html#method.get_searchapplication)"]
        #[derive(Debug, Clone)]
        pub struct GetSearchapplicationRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            end_date_day: ::std::option::Option<i32>,
            end_date_month: ::std::option::Option<i32>,
            end_date_year: ::std::option::Option<i32>,
            start_date_day: ::std::option::Option<i32>,
            start_date_month: ::std::option::Option<i32>,
            start_date_year: ::std::option::Option<i32>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GetSearchapplicationRequestBuilder<'a> {
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn end_date_day(mut self, value: i32) -> Self {
                self.end_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn end_date_month(mut self, value: i32) -> Self {
                self.end_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn end_date_year(mut self, value: i32) -> Self {
                self.end_date_year = Some(value);
                self
            }
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn start_date_day(mut self, value: i32) -> Self {
                self.start_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn start_date_month(mut self, value: i32) -> Self {
                self.start_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn start_date_year(mut self, value: i32) -> Self {
                self.start_date_year = Some(value);
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerSearchApplicationStatsResponse, crate::Error>
            {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerSearchApplicationStatsResponse, crate::Error>
            {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/stats/searchapplication");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("endDate.day", &self.end_date_day)]);
                req = req.query(&[("endDate.month", &self.end_date_month)]);
                req = req.query(&[("endDate.year", &self.end_date_year)]);
                req = req.query(&[("startDate.day", &self.start_date_day)]);
                req = req.query(&[("startDate.month", &self.start_date_month)]);
                req = req.query(&[("startDate.year", &self.start_date_year)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        #[doc = "Created via [StatsActions::get_session()](struct.StatsActions.html#method.get_session)"]
        #[derive(Debug, Clone)]
        pub struct GetSessionRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            from_date_day: ::std::option::Option<i32>,
            from_date_month: ::std::option::Option<i32>,
            from_date_year: ::std::option::Option<i32>,
            to_date_day: ::std::option::Option<i32>,
            to_date_month: ::std::option::Option<i32>,
            to_date_year: ::std::option::Option<i32>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GetSessionRequestBuilder<'a> {
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn from_date_day(mut self, value: i32) -> Self {
                self.from_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn from_date_month(mut self, value: i32) -> Self {
                self.from_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn from_date_year(mut self, value: i32) -> Self {
                self.from_date_year = Some(value);
                self
            }
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn to_date_day(mut self, value: i32) -> Self {
                self.to_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn to_date_month(mut self, value: i32) -> Self {
                self.to_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn to_date_year(mut self, value: i32) -> Self {
                self.to_date_year = Some(value);
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerSessionStatsResponse, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerSessionStatsResponse, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/stats/session");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("fromDate.day", &self.from_date_day)]);
                req = req.query(&[("fromDate.month", &self.from_date_month)]);
                req = req.query(&[("fromDate.year", &self.from_date_year)]);
                req = req.query(&[("toDate.day", &self.to_date_day)]);
                req = req.query(&[("toDate.month", &self.to_date_month)]);
                req = req.query(&[("toDate.year", &self.to_date_year)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        #[doc = "Created via [StatsActions::get_user()](struct.StatsActions.html#method.get_user)"]
        #[derive(Debug, Clone)]
        pub struct GetUserRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            from_date_day: ::std::option::Option<i32>,
            from_date_month: ::std::option::Option<i32>,
            from_date_year: ::std::option::Option<i32>,
            to_date_day: ::std::option::Option<i32>,
            to_date_month: ::std::option::Option<i32>,
            to_date_year: ::std::option::Option<i32>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GetUserRequestBuilder<'a> {
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn from_date_day(mut self, value: i32) -> Self {
                self.from_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn from_date_month(mut self, value: i32) -> Self {
                self.from_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn from_date_year(mut self, value: i32) -> Self {
                self.from_date_year = Some(value);
                self
            }
            #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
            pub fn to_date_day(mut self, value: i32) -> Self {
                self.to_date_day = Some(value);
                self
            }
            #[doc = "Month of date. Must be from 1 to 12."]
            pub fn to_date_month(mut self, value: i32) -> Self {
                self.to_date_month = Some(value);
                self
            }
            #[doc = "Year of date. Must be from 1 to 9999."]
            pub fn to_date_year(mut self, value: i32) -> Self {
                self.to_date_year = Some(value);
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerUserStatsResponse, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::GetCustomerUserStatsResponse, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1/stats/user");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("fromDate.day", &self.from_date_day)]);
                req = req.query(&[("fromDate.month", &self.from_date_month)]);
                req = req.query(&[("fromDate.year", &self.from_date_year)]);
                req = req.query(&[("toDate.day", &self.to_date_day)]);
                req = req.query(&[("toDate.month", &self.to_date_month)]);
                req = req.query(&[("toDate.year", &self.to_date_year)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        pub mod index {
            pub mod params {}
            pub struct IndexActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> IndexActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Actions that can be performed on the datasources resource"]
                pub fn datasources(
                    &self,
                ) -> crate::resources::stats::index::datasources::DatasourcesActions
                {
                    crate::resources::stats::index::datasources::DatasourcesActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
            }
            pub mod datasources {
                pub mod params {}
                pub struct DatasourcesActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> DatasourcesActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Gets indexed item statistics for a single data source. **Note:** This API requires a standard end user account to execute."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            from_date_day: None,
                            from_date_month: None,
                            from_date_year: None,
                            to_date_day: None,
                            to_date_month: None,
                            to_date_year: None,
                        }
                    }
                }
                #[doc = "Created via [DatasourcesActions::get()](struct.DatasourcesActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    from_date_day: ::std::option::Option<i32>,
                    from_date_month: ::std::option::Option<i32>,
                    from_date_year: ::std::option::Option<i32>,
                    to_date_day: ::std::option::Option<i32>,
                    to_date_month: ::std::option::Option<i32>,
                    to_date_year: ::std::option::Option<i32>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
                    pub fn from_date_day(mut self, value: i32) -> Self {
                        self.from_date_day = Some(value);
                        self
                    }
                    #[doc = "Month of date. Must be from 1 to 12."]
                    pub fn from_date_month(mut self, value: i32) -> Self {
                        self.from_date_month = Some(value);
                        self
                    }
                    #[doc = "Year of date. Must be from 1 to 9999."]
                    pub fn from_date_year(mut self, value: i32) -> Self {
                        self.from_date_year = Some(value);
                        self
                    }
                    #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
                    pub fn to_date_day(mut self, value: i32) -> Self {
                        self.to_date_day = Some(value);
                        self
                    }
                    #[doc = "Month of date. Must be from 1 to 12."]
                    pub fn to_date_month(mut self, value: i32) -> Self {
                        self.to_date_month = Some(value);
                        self
                    }
                    #[doc = "Year of date. Must be from 1 to 9999."]
                    pub fn to_date_year(mut self, value: i32) -> Self {
                        self.to_date_year = Some(value);
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GetDataSourceIndexStatsResponse, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GetDataSourceIndexStatsResponse, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/stats/index/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("fromDate.day", &self.from_date_day)]);
                        req = req.query(&[("fromDate.month", &self.from_date_month)]);
                        req = req.query(&[("fromDate.year", &self.from_date_year)]);
                        req = req.query(&[("toDate.day", &self.to_date_day)]);
                        req = req.query(&[("toDate.month", &self.to_date_month)]);
                        req = req.query(&[("toDate.year", &self.to_date_year)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
            }
        }
        pub mod query {
            pub mod params {}
            pub struct QueryActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> QueryActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Actions that can be performed on the searchapplications resource"]
                pub fn searchapplications(
                    &self,
                ) -> crate::resources::stats::query::searchapplications::SearchapplicationsActions
                {
                    crate::resources::stats::query::searchapplications::SearchapplicationsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
            }
            pub mod searchapplications {
                pub mod params {}
                pub struct SearchapplicationsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> SearchapplicationsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Get the query statistics for search application. **Note:** This API requires a standard end user account to execute."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            from_date_day: None,
                            from_date_month: None,
                            from_date_year: None,
                            to_date_day: None,
                            to_date_month: None,
                            to_date_year: None,
                        }
                    }
                }
                #[doc = "Created via [SearchapplicationsActions::get()](struct.SearchapplicationsActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    from_date_day: ::std::option::Option<i32>,
                    from_date_month: ::std::option::Option<i32>,
                    from_date_year: ::std::option::Option<i32>,
                    to_date_day: ::std::option::Option<i32>,
                    to_date_month: ::std::option::Option<i32>,
                    to_date_year: ::std::option::Option<i32>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
                    pub fn from_date_day(mut self, value: i32) -> Self {
                        self.from_date_day = Some(value);
                        self
                    }
                    #[doc = "Month of date. Must be from 1 to 12."]
                    pub fn from_date_month(mut self, value: i32) -> Self {
                        self.from_date_month = Some(value);
                        self
                    }
                    #[doc = "Year of date. Must be from 1 to 9999."]
                    pub fn from_date_year(mut self, value: i32) -> Self {
                        self.from_date_year = Some(value);
                        self
                    }
                    #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
                    pub fn to_date_day(mut self, value: i32) -> Self {
                        self.to_date_day = Some(value);
                        self
                    }
                    #[doc = "Month of date. Must be from 1 to 12."]
                    pub fn to_date_month(mut self, value: i32) -> Self {
                        self.to_date_month = Some(value);
                        self
                    }
                    #[doc = "Year of date. Must be from 1 to 9999."]
                    pub fn to_date_year(mut self, value: i32) -> Self {
                        self.to_date_year = Some(value);
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GetSearchApplicationQueryStatsResponse, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GetSearchApplicationQueryStatsResponse, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/stats/query/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("fromDate.day", &self.from_date_day)]);
                        req = req.query(&[("fromDate.month", &self.from_date_month)]);
                        req = req.query(&[("fromDate.year", &self.from_date_year)]);
                        req = req.query(&[("toDate.day", &self.to_date_day)]);
                        req = req.query(&[("toDate.month", &self.to_date_month)]);
                        req = req.query(&[("toDate.year", &self.to_date_year)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
            }
        }
        pub mod session {
            pub mod params {}
            pub struct SessionActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> SessionActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Actions that can be performed on the searchapplications resource"]
                pub fn searchapplications(
                    &self,
                ) -> crate::resources::stats::session::searchapplications::SearchapplicationsActions
                {
                    crate :: resources :: stats :: session :: searchapplications :: SearchapplicationsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                }
            }
            pub mod searchapplications {
                pub mod params {}
                pub struct SearchapplicationsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> SearchapplicationsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Get the # of search sessions, % of successful sessions with a click query statistics for search application. **Note:** This API requires a standard end user account to execute."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            from_date_day: None,
                            from_date_month: None,
                            from_date_year: None,
                            to_date_day: None,
                            to_date_month: None,
                            to_date_year: None,
                        }
                    }
                }
                #[doc = "Created via [SearchapplicationsActions::get()](struct.SearchapplicationsActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    from_date_day: ::std::option::Option<i32>,
                    from_date_month: ::std::option::Option<i32>,
                    from_date_year: ::std::option::Option<i32>,
                    to_date_day: ::std::option::Option<i32>,
                    to_date_month: ::std::option::Option<i32>,
                    to_date_year: ::std::option::Option<i32>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
                    pub fn from_date_day(mut self, value: i32) -> Self {
                        self.from_date_day = Some(value);
                        self
                    }
                    #[doc = "Month of date. Must be from 1 to 12."]
                    pub fn from_date_month(mut self, value: i32) -> Self {
                        self.from_date_month = Some(value);
                        self
                    }
                    #[doc = "Year of date. Must be from 1 to 9999."]
                    pub fn from_date_year(mut self, value: i32) -> Self {
                        self.from_date_year = Some(value);
                        self
                    }
                    #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
                    pub fn to_date_day(mut self, value: i32) -> Self {
                        self.to_date_day = Some(value);
                        self
                    }
                    #[doc = "Month of date. Must be from 1 to 12."]
                    pub fn to_date_month(mut self, value: i32) -> Self {
                        self.to_date_month = Some(value);
                        self
                    }
                    #[doc = "Year of date. Must be from 1 to 9999."]
                    pub fn to_date_year(mut self, value: i32) -> Self {
                        self.to_date_year = Some(value);
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GetSearchApplicationSessionStatsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GetSearchApplicationSessionStatsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/stats/session/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("fromDate.day", &self.from_date_day)]);
                        req = req.query(&[("fromDate.month", &self.from_date_month)]);
                        req = req.query(&[("fromDate.year", &self.from_date_year)]);
                        req = req.query(&[("toDate.day", &self.to_date_day)]);
                        req = req.query(&[("toDate.month", &self.to_date_month)]);
                        req = req.query(&[("toDate.year", &self.to_date_year)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
            }
        }
        pub mod user {
            pub mod params {}
            pub struct UserActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> UserActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Actions that can be performed on the searchapplications resource"]
                pub fn searchapplications(
                    &self,
                ) -> crate::resources::stats::user::searchapplications::SearchapplicationsActions
                {
                    crate::resources::stats::user::searchapplications::SearchapplicationsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
            }
            pub mod searchapplications {
                pub mod params {}
                pub struct SearchapplicationsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> SearchapplicationsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Get the users statistics for search application. **Note:** This API requires a standard end user account to execute."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            from_date_day: None,
                            from_date_month: None,
                            from_date_year: None,
                            to_date_day: None,
                            to_date_month: None,
                            to_date_year: None,
                        }
                    }
                }
                #[doc = "Created via [SearchapplicationsActions::get()](struct.SearchapplicationsActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    from_date_day: ::std::option::Option<i32>,
                    from_date_month: ::std::option::Option<i32>,
                    from_date_year: ::std::option::Option<i32>,
                    to_date_day: ::std::option::Option<i32>,
                    to_date_month: ::std::option::Option<i32>,
                    to_date_year: ::std::option::Option<i32>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
                    pub fn from_date_day(mut self, value: i32) -> Self {
                        self.from_date_day = Some(value);
                        self
                    }
                    #[doc = "Month of date. Must be from 1 to 12."]
                    pub fn from_date_month(mut self, value: i32) -> Self {
                        self.from_date_month = Some(value);
                        self
                    }
                    #[doc = "Year of date. Must be from 1 to 9999."]
                    pub fn from_date_year(mut self, value: i32) -> Self {
                        self.from_date_year = Some(value);
                        self
                    }
                    #[doc = "Day of month. Must be from 1 to 31 and valid for the year and month."]
                    pub fn to_date_day(mut self, value: i32) -> Self {
                        self.to_date_day = Some(value);
                        self
                    }
                    #[doc = "Month of date. Must be from 1 to 12."]
                    pub fn to_date_month(mut self, value: i32) -> Self {
                        self.to_date_month = Some(value);
                        self
                    }
                    #[doc = "Year of date. Must be from 1 to 9999."]
                    pub fn to_date_year(mut self, value: i32) -> Self {
                        self.to_date_year = Some(value);
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GetSearchApplicationUserStatsResponse, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GetSearchApplicationUserStatsResponse, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                        output.push_str("v1/stats/user/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("fromDate.day", &self.from_date_day)]);
                        req = req.query(&[("fromDate.month", &self.from_date_month)]);
                        req = req.query(&[("fromDate.year", &self.from_date_year)]);
                        req = req.query(&[("toDate.day", &self.to_date_day)]);
                        req = req.query(&[("toDate.month", &self.to_date_month)]);
                        req = req.query(&[("toDate.year", &self.to_date_year)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
            }
        }
    }
    pub mod v_1 {
        pub mod params {}
        pub struct V1Actions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> V1Actions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Enables `third party` support in Google Cloud Search. **Note:** This API requires an admin account to execute."]
            pub fn initialize_customer(
                &self,
                request: crate::schemas::InitializeCustomerRequest,
            ) -> InitializeCustomerRequestBuilder {
                InitializeCustomerRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    request,
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                }
            }
        }
        #[doc = "Created via [V1Actions::initialize_customer()](struct.V1Actions.html#method.initialize_customer)"]
        #[derive(Debug, Clone)]
        pub struct InitializeCustomerRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            request: crate::schemas::InitializeCustomerRequest,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> InitializeCustomerRequestBuilder<'a> {
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. “raw”, “multipart”)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. “media”, “multipart”)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::Operation, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::Operation, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                let req = req.json(&self.request);
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://cloudsearch.googleapis.com/".to_owned();
                output.push_str("v1:initializeCustomer");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
    }
}
#[derive(Debug)]
pub enum Error {
    OAuth2(Box<dyn ::std::error::Error + Send + Sync>),
    JSON(::serde_json::Error),
    Reqwest {
        reqwest_err: ::reqwest::Error,
        body: Option<String>,
    },
    IO(std::io::Error),
    Other(Box<dyn ::std::error::Error + Send + Sync>),
}

impl Error {
    pub fn json_error(&self) -> Option<&::serde_json::Error> {
        match self {
            Error::OAuth2(_) => None,
            Error::JSON(err) => Some(err),
            Error::Reqwest { .. } => None,
            Error::IO(_) => None,
            Error::Other(_) => None,
        }
    }
}

impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            Error::OAuth2(err) => write!(f, "OAuth2 Error: {}", err),
            Error::JSON(err) => write!(f, "JSON Error: {}", err),
            Error::Reqwest { reqwest_err, body } => {
                write!(f, "Reqwest Error: {}", reqwest_err)?;
                if let Some(body) = body {
                    write!(f, ": {}", body)?;
                }
                Ok(())
            }
            Error::IO(err) => write!(f, "IO Error: {}", err),
            Error::Other(err) => write!(f, "Uknown Error: {}", err),
        }
    }
}

impl ::std::error::Error for Error {}

impl From<::serde_json::Error> for Error {
    fn from(err: ::serde_json::Error) -> Error {
        Error::JSON(err)
    }
}

impl From<::reqwest::Error> for Error {
    fn from(reqwest_err: ::reqwest::Error) -> Error {
        Error::Reqwest {
            reqwest_err,
            body: None,
        }
    }
}

impl From<std::io::Error> for Error {
    fn from(err: std::io::Error) -> Error {
        Error::IO(err)
    }
}
#[allow(dead_code)]
const SIMPLE: &::percent_encoding::AsciiSet = &::percent_encoding::NON_ALPHANUMERIC
    .remove(b'-')
    .remove(b'.')
    .remove(b'_')
    .remove(b'~');

#[allow(dead_code)]
const RESERVED: &::percent_encoding::AsciiSet = &SIMPLE
    .remove(b'%')
    .remove(b':')
    .remove(b'/')
    .remove(b'?')
    .remove(b'#')
    .remove(b'[')
    .remove(b']')
    .remove(b'@')
    .remove(b'!')
    .remove(b'$')
    .remove(b'&')
    .remove(b'\'')
    .remove(b'(')
    .remove(b')')
    .remove(b'*')
    .remove(b'+')
    .remove(b',')
    .remove(b';')
    .remove(b'=');
#[allow(dead_code)]
mod multipart {
    pub(crate) struct RelatedMultiPart {
        parts: Vec<Part>,
        boundary: String,
    }

    impl RelatedMultiPart {
        pub(crate) fn new() -> Self {
            RelatedMultiPart {
                parts: Vec::new(),
                boundary: ::textnonce::TextNonce::sized(68).unwrap().0,
            }
        }

        pub(crate) fn new_part(&mut self, part: Part) {
            self.parts.push(part);
        }

        pub(crate) fn boundary(&self) -> &str {
            &self.boundary
        }

        pub(crate) fn into_reader(self) -> RelatedMultiPartReader {
            let boundary_marker = boundary_marker(&self.boundary);
            RelatedMultiPartReader {
                state: RelatedMultiPartReaderState::WriteBoundary {
                    start: 0,
                    boundary: format!("{}\r\n", &boundary_marker),
                },
                boundary: boundary_marker,
                next_body: None,
                parts: self.parts.into_iter(),
            }
        }
    }

    pub(crate) struct Part {
        content_type: ::mime::Mime,
        body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
    }

    impl Part {
        pub(crate) fn new(
            content_type: ::mime::Mime,
            body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
        ) -> Part {
            Part { content_type, body }
        }
    }

    pub(crate) struct RelatedMultiPartReader {
        state: RelatedMultiPartReaderState,
        boundary: String,
        next_body: Option<Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>>,
        parts: std::vec::IntoIter<Part>,
    }

    enum RelatedMultiPartReaderState {
        WriteBoundary {
            start: usize,
            boundary: String,
        },
        WriteContentType {
            start: usize,
            content_type: Vec<u8>,
        },
        WriteBody {
            body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
        },
    }

    impl futures::io::AsyncRead for RelatedMultiPartReader {
        fn poll_read(
            mut self: std::pin::Pin<&mut Self>,
            ctx: &mut futures::task::Context,
            buf: &mut [u8],
        ) -> futures::task::Poll<Result<usize, futures::io::Error>> {
            use RelatedMultiPartReaderState::*;

            let mut bytes_written: usize = 0;
            loop {
                let rem_buf = &mut buf[bytes_written..];
                match &mut self.state {
                    WriteBoundary { start, boundary } => {
                        let bytes_to_copy = std::cmp::min(boundary.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&boundary.as_bytes()[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == boundary.len() {
                            let next_part = match self.parts.next() {
                                None => break,
                                Some(part) => part,
                            };
                            self.next_body = Some(next_part.body);
                            self.state = WriteContentType {
                                start: 0,
                                content_type: format!(
                                    "Content-Type: {}\r\n\r\n",
                                    next_part.content_type
                                )
                                .into_bytes(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteContentType {
                        start,
                        content_type,
                    } => {
                        let bytes_to_copy =
                            std::cmp::min(content_type.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&content_type[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == content_type.len() {
                            self.state = WriteBody {
                                body: self.next_body.take().unwrap(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteBody { body } => {
                        let body = std::pin::Pin::new(body);
                        let written = match futures::io::AsyncRead::poll_read(body, ctx, rem_buf) {
                            futures::task::Poll::Ready(Ok(n)) => n,
                            futures::task::Poll::Ready(Err(err)) => {
                                return futures::task::Poll::Ready(Err(err));
                            }
                            futures::task::Poll::Pending => return futures::task::Poll::Pending,
                        };
                        bytes_written += written;
                        if written == 0 {
                            self.state = WriteBoundary {
                                start: 0,
                                boundary: format!("\r\n{}\r\n", &self.boundary),
                            };
                        } else {
                            break;
                        }
                    }
                }
            }

            futures::task::Poll::Ready(Ok(bytes_written))
        }
    }

    fn boundary_marker(boundary: &str) -> String {
        let mut marker = String::with_capacity(boundary.len() + 2);
        marker.push_str("--");
        marker.push_str(boundary);
        marker
    }
}
// A serde helper module that can be used with the `with` attribute
// to deserialize any string to a FromStr type and serialize any
// Display type to a String. Google API's encode i64, u64 values as
// strings.
#[allow(dead_code)]
mod parsed_string {
    pub fn serialize<T, S>(
        value: &Option<T>,
        serializer: S,
    ) -> ::std::result::Result<S::Ok, S::Error>
    where
        T: ::std::fmt::Display,
        S: ::serde::Serializer,
    {
        use ::serde::Serialize;
        value.as_ref().map(|x| x.to_string()).serialize(serializer)
    }

    pub fn deserialize<'de, T, D>(deserializer: D) -> ::std::result::Result<Option<T>, D::Error>
    where
        T: ::std::str::FromStr,
        T::Err: ::std::fmt::Display,
        D: ::serde::de::Deserializer<'de>,
    {
        use ::serde::Deserialize;
        match Option::<String>::deserialize(deserializer)? {
            Some(x) => Ok(Some(x.parse().map_err(::serde::de::Error::custom)?)),
            None => Ok(None),
        }
    }
}
/// Represent the ability to extract the `nextPageToken` from a response.
pub trait GetNextPageToken<T> {
    /// Get the `nextPageToken` from a response if present.
    fn next_page_token(&self) -> ::std::option::Option<T>;
}

impl<T: ::std::convert::From<::std::string::String>> GetNextPageToken<T>
    for ::serde_json::Map<::std::string::String, ::serde_json::Value>
{
    fn next_page_token(&self) -> ::std::option::Option<T> {
        self.get("nextPageToken")
            .and_then(|t| t.as_str())
            .map(|s| s.to_owned().into())
    }
}
/// Traits and functions to improve streamable (multiple page) API method handling.
pub mod stream {
    use super::GetNextPageToken;

    /// Extract the items embedded in a page like response.
    pub trait IntoPageItems {
        /// Type of the items list in the page.
        type Items: IntoIterator;

        /// Consume the response and return the embedded items.
        fn into_page_items(self) -> Self::Items;
    }

    /// Represent a API method which can be invoked multiple times to retrieve
    /// multiple pages of items.
    #[async_trait::async_trait]
    pub trait StreamableMethod {
        /// Type of the `pageToken` and `nextPageToken` fields.
        type PageToken;

        /// Update the current page token of the request.
        fn set_page_token(&mut self, value: Self::PageToken);

        /// Execute the request.
        async fn execute<T>(&mut self) -> Result<T, crate::Error>
        where
            T: GetNextPageToken<Self::PageToken> + ::serde::de::DeserializeOwned;
    }

    /// Return a [`Stream`](::futures::Stream) over all pages of the given API
    /// method.
    pub fn page_stream<M, T>(method: M) -> impl ::futures::Stream<Item = Result<T, crate::Error>>
    where
        M: StreamableMethod,
        T: GetNextPageToken<M::PageToken> + ::serde::de::DeserializeOwned,
    {
        ::futures::stream::unfold((method, false), |(mut method, mut finished)| async move {
            if finished {
                return None;
            }
            let response = match method.execute::<T>().await {
                Ok(r) => r,
                Err(err) => return Some((Err(err), (method, false))),
            };
            if let Some(next_page_token) = response.next_page_token() {
                method.set_page_token(next_page_token);
            } else {
                finished = true;
            }

            Some((Ok(response), (method, finished)))
        })
    }

    /// Return a [`Stream`](::futures::Stream) over the items in all pages of
    /// the given API method.
    pub fn page_item_stream<M, T>(
        method: M,
    ) -> impl ::futures::Stream<Item = Result<<T::Items as IntoIterator>::Item, crate::Error>>
    where
        M: StreamableMethod,
        T: GetNextPageToken<M::PageToken> + ::serde::de::DeserializeOwned + IntoPageItems,
    {
        use ::futures::StreamExt;
        use ::futures::TryStreamExt;

        page_stream::<M, T>(method)
            .map_ok(|page| ::futures::stream::iter(page.into_page_items()).map(Ok))
            .try_flatten()
    }
}
