#![allow(rustdoc::bare_urls)]
#![doc = "# Resources and Methods\n* [callback](resources/callback/struct.CallbackActions.html)\n  * [*generateToken*](resources/callback/struct.GenerateTokenRequestBuilder.html)\n* [connector_platform_regions](resources/connector_platform_regions/struct.ConnectorPlatformRegionsActions.html)\n  * [*enumerate*](resources/connector_platform_regions/struct.EnumerateRequestBuilder.html)\n* [projects](resources/projects/struct.ProjectsActions.html)\n  * [locations](resources/projects/locations/struct.LocationsActions.html)\n    * [apps_script_projects](resources/projects/locations/apps_script_projects/struct.AppsScriptProjectsActions.html)\n      * [*create*](resources/projects/locations/apps_script_projects/struct.CreateRequestBuilder.html), [*link*](resources/projects/locations/apps_script_projects/struct.LinkRequestBuilder.html)\n    * [auth_configs](resources/projects/locations/auth_configs/struct.AuthConfigsActions.html)\n      * [*create*](resources/projects/locations/auth_configs/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/auth_configs/struct.DeleteRequestBuilder.html), [*get*](resources/projects/locations/auth_configs/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/auth_configs/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/auth_configs/struct.PatchRequestBuilder.html)\n    * [certificates](resources/projects/locations/certificates/struct.CertificatesActions.html)\n      * [*get*](resources/projects/locations/certificates/struct.GetRequestBuilder.html)\n    * [connections](resources/projects/locations/connections/struct.ConnectionsActions.html)\n      * [*getConnectionSchemaMetadata*](resources/projects/locations/connections/struct.GetConnectionSchemaMetadataRequestBuilder.html), [*list*](resources/projects/locations/connections/struct.ListRequestBuilder.html)\n      * [runtime_action_schemas](resources/projects/locations/connections/runtime_action_schemas/struct.RuntimeActionSchemasActions.html)\n        * [*list*](resources/projects/locations/connections/runtime_action_schemas/struct.ListRequestBuilder.html)\n      * [runtime_entity_schemas](resources/projects/locations/connections/runtime_entity_schemas/struct.RuntimeEntitySchemasActions.html)\n        * [*list*](resources/projects/locations/connections/runtime_entity_schemas/struct.ListRequestBuilder.html)\n    * [integrations](resources/projects/locations/integrations/struct.IntegrationsActions.html)\n      * [*delete*](resources/projects/locations/integrations/struct.DeleteRequestBuilder.html), [*execute*](resources/projects/locations/integrations/struct.ExecuteRequestBuilder.html), [*list*](resources/projects/locations/integrations/struct.ListRequestBuilder.html), [*schedule*](resources/projects/locations/integrations/struct.ScheduleRequestBuilder.html)\n      * [executions](resources/projects/locations/integrations/executions/struct.ExecutionsActions.html)\n        * [*list*](resources/projects/locations/integrations/executions/struct.ListRequestBuilder.html)\n        * [suspensions](resources/projects/locations/integrations/executions/suspensions/struct.SuspensionsActions.html)\n          * [*lift*](resources/projects/locations/integrations/executions/suspensions/struct.LiftRequestBuilder.html), [*list*](resources/projects/locations/integrations/executions/suspensions/struct.ListRequestBuilder.html), [*resolve*](resources/projects/locations/integrations/executions/suspensions/struct.ResolveRequestBuilder.html)\n      * [versions](resources/projects/locations/integrations/versions/struct.VersionsActions.html)\n        * [*create*](resources/projects/locations/integrations/versions/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/integrations/versions/struct.DeleteRequestBuilder.html), [*download*](resources/projects/locations/integrations/versions/struct.DownloadRequestBuilder.html), [*get*](resources/projects/locations/integrations/versions/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/integrations/versions/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/integrations/versions/struct.PatchRequestBuilder.html), [*publish*](resources/projects/locations/integrations/versions/struct.PublishRequestBuilder.html), [*takeoverEditLock*](resources/projects/locations/integrations/versions/struct.TakeoverEditLockRequestBuilder.html), [*unpublish*](resources/projects/locations/integrations/versions/struct.UnpublishRequestBuilder.html), [*upload*](resources/projects/locations/integrations/versions/struct.UploadRequestBuilder.html)\n    * [products](resources/projects/locations/products/struct.ProductsActions.html)\n      * [auth_configs](resources/projects/locations/products/auth_configs/struct.AuthConfigsActions.html)\n        * [*create*](resources/projects/locations/products/auth_configs/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/products/auth_configs/struct.DeleteRequestBuilder.html), [*get*](resources/projects/locations/products/auth_configs/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/products/auth_configs/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/products/auth_configs/struct.PatchRequestBuilder.html)\n      * [certificates](resources/projects/locations/products/certificates/struct.CertificatesActions.html)\n        * [*create*](resources/projects/locations/products/certificates/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/products/certificates/struct.DeleteRequestBuilder.html), [*get*](resources/projects/locations/products/certificates/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/products/certificates/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/products/certificates/struct.PatchRequestBuilder.html)\n      * [integrations](resources/projects/locations/products/integrations/struct.IntegrationsActions.html)\n        * [*execute*](resources/projects/locations/products/integrations/struct.ExecuteRequestBuilder.html), [*list*](resources/projects/locations/products/integrations/struct.ListRequestBuilder.html), [*schedule*](resources/projects/locations/products/integrations/struct.ScheduleRequestBuilder.html)\n        * [executions](resources/projects/locations/products/integrations/executions/struct.ExecutionsActions.html)\n          * [*cancel*](resources/projects/locations/products/integrations/executions/struct.CancelRequestBuilder.html), [*get*](resources/projects/locations/products/integrations/executions/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/products/integrations/executions/struct.ListRequestBuilder.html)\n          * [suspensions](resources/projects/locations/products/integrations/executions/suspensions/struct.SuspensionsActions.html)\n            * [*lift*](resources/projects/locations/products/integrations/executions/suspensions/struct.LiftRequestBuilder.html), [*list*](resources/projects/locations/products/integrations/executions/suspensions/struct.ListRequestBuilder.html), [*resolve*](resources/projects/locations/products/integrations/executions/suspensions/struct.ResolveRequestBuilder.html)\n        * [versions](resources/projects/locations/products/integrations/versions/struct.VersionsActions.html)\n          * [*create*](resources/projects/locations/products/integrations/versions/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/products/integrations/versions/struct.DeleteRequestBuilder.html), [*download*](resources/projects/locations/products/integrations/versions/struct.DownloadRequestBuilder.html), [*get*](resources/projects/locations/products/integrations/versions/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/products/integrations/versions/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/products/integrations/versions/struct.PatchRequestBuilder.html), [*publish*](resources/projects/locations/products/integrations/versions/struct.PublishRequestBuilder.html), [*takeoverEditLock*](resources/projects/locations/products/integrations/versions/struct.TakeoverEditLockRequestBuilder.html), [*unpublish*](resources/projects/locations/products/integrations/versions/struct.UnpublishRequestBuilder.html), [*upload*](resources/projects/locations/products/integrations/versions/struct.UploadRequestBuilder.html)\n      * [integrationtemplates](resources/projects/locations/products/integrationtemplates/struct.IntegrationtemplatesActions.html)\n        * [versions](resources/projects/locations/products/integrationtemplates/versions/struct.VersionsActions.html)\n          * [*create*](resources/projects/locations/products/integrationtemplates/versions/struct.CreateRequestBuilder.html), [*get*](resources/projects/locations/products/integrationtemplates/versions/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/products/integrationtemplates/versions/struct.ListRequestBuilder.html)\n      * [sfdc_instances](resources/projects/locations/products/sfdc_instances/struct.SfdcInstancesActions.html)\n        * [*create*](resources/projects/locations/products/sfdc_instances/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/products/sfdc_instances/struct.DeleteRequestBuilder.html), [*get*](resources/projects/locations/products/sfdc_instances/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/products/sfdc_instances/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/products/sfdc_instances/struct.PatchRequestBuilder.html)\n        * [sfdc_channels](resources/projects/locations/products/sfdc_instances/sfdc_channels/struct.SfdcChannelsActions.html)\n          * [*create*](resources/projects/locations/products/sfdc_instances/sfdc_channels/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/products/sfdc_instances/sfdc_channels/struct.DeleteRequestBuilder.html), [*get*](resources/projects/locations/products/sfdc_instances/sfdc_channels/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/products/sfdc_instances/sfdc_channels/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/products/sfdc_instances/sfdc_channels/struct.PatchRequestBuilder.html)\n    * [sfdc_instances](resources/projects/locations/sfdc_instances/struct.SfdcInstancesActions.html)\n      * [*create*](resources/projects/locations/sfdc_instances/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/sfdc_instances/struct.DeleteRequestBuilder.html), [*get*](resources/projects/locations/sfdc_instances/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/sfdc_instances/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/sfdc_instances/struct.PatchRequestBuilder.html)\n      * [sfdc_channels](resources/projects/locations/sfdc_instances/sfdc_channels/struct.SfdcChannelsActions.html)\n        * [*create*](resources/projects/locations/sfdc_instances/sfdc_channels/struct.CreateRequestBuilder.html), [*delete*](resources/projects/locations/sfdc_instances/sfdc_channels/struct.DeleteRequestBuilder.html), [*get*](resources/projects/locations/sfdc_instances/sfdc_channels/struct.GetRequestBuilder.html), [*list*](resources/projects/locations/sfdc_instances/sfdc_channels/struct.ListRequestBuilder.html), [*patch*](resources/projects/locations/sfdc_instances/sfdc_channels/struct.PatchRequestBuilder.html)\n"]
pub mod scopes {
    #[doc = "See, edit, configure, and delete your Google Cloud data and see the email address for your Google Account.\n\n`https://www.googleapis.com/auth/cloud-platform`"]
    pub const CLOUD_PLATFORM: &str = "https://www.googleapis.com/auth/cloud-platform";
}
pub mod schemas {
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CrmlogErrorCode {
        #[serde(
            rename = "commonErrorCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_error_code:
            ::std::option::Option<crate::schemas::CrmlogErrorCodeCommonErrorCode>,
    }
    impl ::google_field_selector::FieldSelector for CrmlogErrorCode {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CrmlogErrorCode {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum CrmlogErrorCodeCommonErrorCode {
        AlreadyExists,
        AppsScriptExecutionError,
        #[doc = "ASYNC_EVENTBUS_EXECUTION_TIMEOUT is for eventbus internal use only. This error will be counted as server availability error."]
        AsyncEventbusExecutionTimeout,
        Backend,
        ClientUnauthorizedForWorkflow,
        CommonErrorCodeUnspecified,
        Concord,
        Conversion,
        EventBus,
        ExecutionCancelled,
        ExecutionTimeout,
        FailedPrecondition,
        Flume,
        General,
        HttpException,
        Informatica,
        InformaticaBackendUnavailable,
        Internal,
        InvalidAttribute,
        InvalidClient,
        InvalidCredentials,
        InvalidEventExecutionState,
        InvalidFields,
        InvalidParameter,
        InvalidProto,
        InvalidQuotaConfiguration,
        InvalidTaskState,
        InvalidTenant,
        InvalidVectorUser,
        InvalidWorkflow,
        IoError,
        MissingAttribute,
        MissingClient,
        MissingParameter,
        MissingQuotaConfiguration,
        NotFound,
        NotSupportedDataType,
        Permission,
        QuotaEnqueued,
        QuotaThrottled,
        Reltio,
        RequiredFieldsMissing,
        ResumeError,
        RetryableTaskError,
        Rpc,
        RpcPermissionDenied,
        SalesForce,
        ScriptTaskRuntimeError,
        Spanner,
        #[doc = "SYNC_EVENTBUS_EXECUTION_TIMEOUT is for eventbus internal use only."]
        SyncEventbusExecutionTimeout,
        TaskNotFound,
        TransformExpressionEvaluationError,
        TypedTaskInvalidInputOperation,
        TypedTaskInvalidOutputOperation,
        UnauthroizedWorkflowEditorAction,
        UnhandledEventbusError,
        UnhandledTaskError,
        Unimplemented,
        UnsanitizedUserInput,
        ValidationError,
        WorkflowNotFound,
        WrongTenant,
    }
    impl CrmlogErrorCodeCommonErrorCode {
        pub fn as_str(self) -> &'static str {
            match self {
                CrmlogErrorCodeCommonErrorCode::AlreadyExists => "ALREADY_EXISTS",
                CrmlogErrorCodeCommonErrorCode::AppsScriptExecutionError => {
                    "APPS_SCRIPT_EXECUTION_ERROR"
                }
                CrmlogErrorCodeCommonErrorCode::AsyncEventbusExecutionTimeout => {
                    "ASYNC_EVENTBUS_EXECUTION_TIMEOUT"
                }
                CrmlogErrorCodeCommonErrorCode::Backend => "BACKEND",
                CrmlogErrorCodeCommonErrorCode::ClientUnauthorizedForWorkflow => {
                    "CLIENT_UNAUTHORIZED_FOR_WORKFLOW"
                }
                CrmlogErrorCodeCommonErrorCode::CommonErrorCodeUnspecified => {
                    "COMMON_ERROR_CODE_UNSPECIFIED"
                }
                CrmlogErrorCodeCommonErrorCode::Concord => "CONCORD",
                CrmlogErrorCodeCommonErrorCode::Conversion => "CONVERSION",
                CrmlogErrorCodeCommonErrorCode::EventBus => "EVENT_BUS",
                CrmlogErrorCodeCommonErrorCode::ExecutionCancelled => "EXECUTION_CANCELLED",
                CrmlogErrorCodeCommonErrorCode::ExecutionTimeout => "EXECUTION_TIMEOUT",
                CrmlogErrorCodeCommonErrorCode::FailedPrecondition => "FAILED_PRECONDITION",
                CrmlogErrorCodeCommonErrorCode::Flume => "FLUME",
                CrmlogErrorCodeCommonErrorCode::General => "GENERAL",
                CrmlogErrorCodeCommonErrorCode::HttpException => "HTTP_EXCEPTION",
                CrmlogErrorCodeCommonErrorCode::Informatica => "INFORMATICA",
                CrmlogErrorCodeCommonErrorCode::InformaticaBackendUnavailable => {
                    "INFORMATICA_BACKEND_UNAVAILABLE"
                }
                CrmlogErrorCodeCommonErrorCode::Internal => "INTERNAL",
                CrmlogErrorCodeCommonErrorCode::InvalidAttribute => "INVALID_ATTRIBUTE",
                CrmlogErrorCodeCommonErrorCode::InvalidClient => "INVALID_CLIENT",
                CrmlogErrorCodeCommonErrorCode::InvalidCredentials => "INVALID_CREDENTIALS",
                CrmlogErrorCodeCommonErrorCode::InvalidEventExecutionState => {
                    "INVALID_EVENT_EXECUTION_STATE"
                }
                CrmlogErrorCodeCommonErrorCode::InvalidFields => "INVALID_FIELDS",
                CrmlogErrorCodeCommonErrorCode::InvalidParameter => "INVALID_PARAMETER",
                CrmlogErrorCodeCommonErrorCode::InvalidProto => "INVALID_PROTO",
                CrmlogErrorCodeCommonErrorCode::InvalidQuotaConfiguration => {
                    "INVALID_QUOTA_CONFIGURATION"
                }
                CrmlogErrorCodeCommonErrorCode::InvalidTaskState => "INVALID_TASK_STATE",
                CrmlogErrorCodeCommonErrorCode::InvalidTenant => "INVALID_TENANT",
                CrmlogErrorCodeCommonErrorCode::InvalidVectorUser => "INVALID_VECTOR_USER",
                CrmlogErrorCodeCommonErrorCode::InvalidWorkflow => "INVALID_WORKFLOW",
                CrmlogErrorCodeCommonErrorCode::IoError => "IO_ERROR",
                CrmlogErrorCodeCommonErrorCode::MissingAttribute => "MISSING_ATTRIBUTE",
                CrmlogErrorCodeCommonErrorCode::MissingClient => "MISSING_CLIENT",
                CrmlogErrorCodeCommonErrorCode::MissingParameter => "MISSING_PARAMETER",
                CrmlogErrorCodeCommonErrorCode::MissingQuotaConfiguration => {
                    "MISSING_QUOTA_CONFIGURATION"
                }
                CrmlogErrorCodeCommonErrorCode::NotFound => "NOT_FOUND",
                CrmlogErrorCodeCommonErrorCode::NotSupportedDataType => "NOT_SUPPORTED_DATA_TYPE",
                CrmlogErrorCodeCommonErrorCode::Permission => "PERMISSION",
                CrmlogErrorCodeCommonErrorCode::QuotaEnqueued => "QUOTA_ENQUEUED",
                CrmlogErrorCodeCommonErrorCode::QuotaThrottled => "QUOTA_THROTTLED",
                CrmlogErrorCodeCommonErrorCode::Reltio => "RELTIO",
                CrmlogErrorCodeCommonErrorCode::RequiredFieldsMissing => "REQUIRED_FIELDS_MISSING",
                CrmlogErrorCodeCommonErrorCode::ResumeError => "RESUME_ERROR",
                CrmlogErrorCodeCommonErrorCode::RetryableTaskError => "RETRYABLE_TASK_ERROR",
                CrmlogErrorCodeCommonErrorCode::Rpc => "RPC",
                CrmlogErrorCodeCommonErrorCode::RpcPermissionDenied => "RPC_PERMISSION_DENIED",
                CrmlogErrorCodeCommonErrorCode::SalesForce => "SALES_FORCE",
                CrmlogErrorCodeCommonErrorCode::ScriptTaskRuntimeError => {
                    "SCRIPT_TASK_RUNTIME_ERROR"
                }
                CrmlogErrorCodeCommonErrorCode::Spanner => "SPANNER",
                CrmlogErrorCodeCommonErrorCode::SyncEventbusExecutionTimeout => {
                    "SYNC_EVENTBUS_EXECUTION_TIMEOUT"
                }
                CrmlogErrorCodeCommonErrorCode::TaskNotFound => "TASK_NOT_FOUND",
                CrmlogErrorCodeCommonErrorCode::TransformExpressionEvaluationError => {
                    "TRANSFORM_EXPRESSION_EVALUATION_ERROR"
                }
                CrmlogErrorCodeCommonErrorCode::TypedTaskInvalidInputOperation => {
                    "TYPED_TASK_INVALID_INPUT_OPERATION"
                }
                CrmlogErrorCodeCommonErrorCode::TypedTaskInvalidOutputOperation => {
                    "TYPED_TASK_INVALID_OUTPUT_OPERATION"
                }
                CrmlogErrorCodeCommonErrorCode::UnauthroizedWorkflowEditorAction => {
                    "UNAUTHROIZED_WORKFLOW_EDITOR_ACTION"
                }
                CrmlogErrorCodeCommonErrorCode::UnhandledEventbusError => {
                    "UNHANDLED_EVENTBUS_ERROR"
                }
                CrmlogErrorCodeCommonErrorCode::UnhandledTaskError => "UNHANDLED_TASK_ERROR",
                CrmlogErrorCodeCommonErrorCode::Unimplemented => "UNIMPLEMENTED",
                CrmlogErrorCodeCommonErrorCode::UnsanitizedUserInput => "UNSANITIZED_USER_INPUT",
                CrmlogErrorCodeCommonErrorCode::ValidationError => "VALIDATION_ERROR",
                CrmlogErrorCodeCommonErrorCode::WorkflowNotFound => "WORKFLOW_NOT_FOUND",
                CrmlogErrorCodeCommonErrorCode::WrongTenant => "WRONG_TENANT",
            }
        }
    }
    impl ::std::convert::AsRef<str> for CrmlogErrorCodeCommonErrorCode {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for CrmlogErrorCodeCommonErrorCode {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<CrmlogErrorCodeCommonErrorCode, ()> {
            Ok(match s {
                "ALREADY_EXISTS" => CrmlogErrorCodeCommonErrorCode::AlreadyExists,
                "APPS_SCRIPT_EXECUTION_ERROR" => {
                    CrmlogErrorCodeCommonErrorCode::AppsScriptExecutionError
                }
                "ASYNC_EVENTBUS_EXECUTION_TIMEOUT" => {
                    CrmlogErrorCodeCommonErrorCode::AsyncEventbusExecutionTimeout
                }
                "BACKEND" => CrmlogErrorCodeCommonErrorCode::Backend,
                "CLIENT_UNAUTHORIZED_FOR_WORKFLOW" => {
                    CrmlogErrorCodeCommonErrorCode::ClientUnauthorizedForWorkflow
                }
                "COMMON_ERROR_CODE_UNSPECIFIED" => {
                    CrmlogErrorCodeCommonErrorCode::CommonErrorCodeUnspecified
                }
                "CONCORD" => CrmlogErrorCodeCommonErrorCode::Concord,
                "CONVERSION" => CrmlogErrorCodeCommonErrorCode::Conversion,
                "EVENT_BUS" => CrmlogErrorCodeCommonErrorCode::EventBus,
                "EXECUTION_CANCELLED" => CrmlogErrorCodeCommonErrorCode::ExecutionCancelled,
                "EXECUTION_TIMEOUT" => CrmlogErrorCodeCommonErrorCode::ExecutionTimeout,
                "FAILED_PRECONDITION" => CrmlogErrorCodeCommonErrorCode::FailedPrecondition,
                "FLUME" => CrmlogErrorCodeCommonErrorCode::Flume,
                "GENERAL" => CrmlogErrorCodeCommonErrorCode::General,
                "HTTP_EXCEPTION" => CrmlogErrorCodeCommonErrorCode::HttpException,
                "INFORMATICA" => CrmlogErrorCodeCommonErrorCode::Informatica,
                "INFORMATICA_BACKEND_UNAVAILABLE" => {
                    CrmlogErrorCodeCommonErrorCode::InformaticaBackendUnavailable
                }
                "INTERNAL" => CrmlogErrorCodeCommonErrorCode::Internal,
                "INVALID_ATTRIBUTE" => CrmlogErrorCodeCommonErrorCode::InvalidAttribute,
                "INVALID_CLIENT" => CrmlogErrorCodeCommonErrorCode::InvalidClient,
                "INVALID_CREDENTIALS" => CrmlogErrorCodeCommonErrorCode::InvalidCredentials,
                "INVALID_EVENT_EXECUTION_STATE" => {
                    CrmlogErrorCodeCommonErrorCode::InvalidEventExecutionState
                }
                "INVALID_FIELDS" => CrmlogErrorCodeCommonErrorCode::InvalidFields,
                "INVALID_PARAMETER" => CrmlogErrorCodeCommonErrorCode::InvalidParameter,
                "INVALID_PROTO" => CrmlogErrorCodeCommonErrorCode::InvalidProto,
                "INVALID_QUOTA_CONFIGURATION" => {
                    CrmlogErrorCodeCommonErrorCode::InvalidQuotaConfiguration
                }
                "INVALID_TASK_STATE" => CrmlogErrorCodeCommonErrorCode::InvalidTaskState,
                "INVALID_TENANT" => CrmlogErrorCodeCommonErrorCode::InvalidTenant,
                "INVALID_VECTOR_USER" => CrmlogErrorCodeCommonErrorCode::InvalidVectorUser,
                "INVALID_WORKFLOW" => CrmlogErrorCodeCommonErrorCode::InvalidWorkflow,
                "IO_ERROR" => CrmlogErrorCodeCommonErrorCode::IoError,
                "MISSING_ATTRIBUTE" => CrmlogErrorCodeCommonErrorCode::MissingAttribute,
                "MISSING_CLIENT" => CrmlogErrorCodeCommonErrorCode::MissingClient,
                "MISSING_PARAMETER" => CrmlogErrorCodeCommonErrorCode::MissingParameter,
                "MISSING_QUOTA_CONFIGURATION" => {
                    CrmlogErrorCodeCommonErrorCode::MissingQuotaConfiguration
                }
                "NOT_FOUND" => CrmlogErrorCodeCommonErrorCode::NotFound,
                "NOT_SUPPORTED_DATA_TYPE" => CrmlogErrorCodeCommonErrorCode::NotSupportedDataType,
                "PERMISSION" => CrmlogErrorCodeCommonErrorCode::Permission,
                "QUOTA_ENQUEUED" => CrmlogErrorCodeCommonErrorCode::QuotaEnqueued,
                "QUOTA_THROTTLED" => CrmlogErrorCodeCommonErrorCode::QuotaThrottled,
                "RELTIO" => CrmlogErrorCodeCommonErrorCode::Reltio,
                "REQUIRED_FIELDS_MISSING" => CrmlogErrorCodeCommonErrorCode::RequiredFieldsMissing,
                "RESUME_ERROR" => CrmlogErrorCodeCommonErrorCode::ResumeError,
                "RETRYABLE_TASK_ERROR" => CrmlogErrorCodeCommonErrorCode::RetryableTaskError,
                "RPC" => CrmlogErrorCodeCommonErrorCode::Rpc,
                "RPC_PERMISSION_DENIED" => CrmlogErrorCodeCommonErrorCode::RpcPermissionDenied,
                "SALES_FORCE" => CrmlogErrorCodeCommonErrorCode::SalesForce,
                "SCRIPT_TASK_RUNTIME_ERROR" => {
                    CrmlogErrorCodeCommonErrorCode::ScriptTaskRuntimeError
                }
                "SPANNER" => CrmlogErrorCodeCommonErrorCode::Spanner,
                "SYNC_EVENTBUS_EXECUTION_TIMEOUT" => {
                    CrmlogErrorCodeCommonErrorCode::SyncEventbusExecutionTimeout
                }
                "TASK_NOT_FOUND" => CrmlogErrorCodeCommonErrorCode::TaskNotFound,
                "TRANSFORM_EXPRESSION_EVALUATION_ERROR" => {
                    CrmlogErrorCodeCommonErrorCode::TransformExpressionEvaluationError
                }
                "TYPED_TASK_INVALID_INPUT_OPERATION" => {
                    CrmlogErrorCodeCommonErrorCode::TypedTaskInvalidInputOperation
                }
                "TYPED_TASK_INVALID_OUTPUT_OPERATION" => {
                    CrmlogErrorCodeCommonErrorCode::TypedTaskInvalidOutputOperation
                }
                "UNAUTHROIZED_WORKFLOW_EDITOR_ACTION" => {
                    CrmlogErrorCodeCommonErrorCode::UnauthroizedWorkflowEditorAction
                }
                "UNHANDLED_EVENTBUS_ERROR" => {
                    CrmlogErrorCodeCommonErrorCode::UnhandledEventbusError
                }
                "UNHANDLED_TASK_ERROR" => CrmlogErrorCodeCommonErrorCode::UnhandledTaskError,
                "UNIMPLEMENTED" => CrmlogErrorCodeCommonErrorCode::Unimplemented,
                "UNSANITIZED_USER_INPUT" => CrmlogErrorCodeCommonErrorCode::UnsanitizedUserInput,
                "VALIDATION_ERROR" => CrmlogErrorCodeCommonErrorCode::ValidationError,
                "WORKFLOW_NOT_FOUND" => CrmlogErrorCodeCommonErrorCode::WorkflowNotFound,
                "WRONG_TENANT" => CrmlogErrorCodeCommonErrorCode::WrongTenant,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for CrmlogErrorCodeCommonErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for CrmlogErrorCodeCommonErrorCode {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CrmlogErrorCodeCommonErrorCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ALREADY_EXISTS" => CrmlogErrorCodeCommonErrorCode::AlreadyExists,
                "APPS_SCRIPT_EXECUTION_ERROR" => {
                    CrmlogErrorCodeCommonErrorCode::AppsScriptExecutionError
                }
                "ASYNC_EVENTBUS_EXECUTION_TIMEOUT" => {
                    CrmlogErrorCodeCommonErrorCode::AsyncEventbusExecutionTimeout
                }
                "BACKEND" => CrmlogErrorCodeCommonErrorCode::Backend,
                "CLIENT_UNAUTHORIZED_FOR_WORKFLOW" => {
                    CrmlogErrorCodeCommonErrorCode::ClientUnauthorizedForWorkflow
                }
                "COMMON_ERROR_CODE_UNSPECIFIED" => {
                    CrmlogErrorCodeCommonErrorCode::CommonErrorCodeUnspecified
                }
                "CONCORD" => CrmlogErrorCodeCommonErrorCode::Concord,
                "CONVERSION" => CrmlogErrorCodeCommonErrorCode::Conversion,
                "EVENT_BUS" => CrmlogErrorCodeCommonErrorCode::EventBus,
                "EXECUTION_CANCELLED" => CrmlogErrorCodeCommonErrorCode::ExecutionCancelled,
                "EXECUTION_TIMEOUT" => CrmlogErrorCodeCommonErrorCode::ExecutionTimeout,
                "FAILED_PRECONDITION" => CrmlogErrorCodeCommonErrorCode::FailedPrecondition,
                "FLUME" => CrmlogErrorCodeCommonErrorCode::Flume,
                "GENERAL" => CrmlogErrorCodeCommonErrorCode::General,
                "HTTP_EXCEPTION" => CrmlogErrorCodeCommonErrorCode::HttpException,
                "INFORMATICA" => CrmlogErrorCodeCommonErrorCode::Informatica,
                "INFORMATICA_BACKEND_UNAVAILABLE" => {
                    CrmlogErrorCodeCommonErrorCode::InformaticaBackendUnavailable
                }
                "INTERNAL" => CrmlogErrorCodeCommonErrorCode::Internal,
                "INVALID_ATTRIBUTE" => CrmlogErrorCodeCommonErrorCode::InvalidAttribute,
                "INVALID_CLIENT" => CrmlogErrorCodeCommonErrorCode::InvalidClient,
                "INVALID_CREDENTIALS" => CrmlogErrorCodeCommonErrorCode::InvalidCredentials,
                "INVALID_EVENT_EXECUTION_STATE" => {
                    CrmlogErrorCodeCommonErrorCode::InvalidEventExecutionState
                }
                "INVALID_FIELDS" => CrmlogErrorCodeCommonErrorCode::InvalidFields,
                "INVALID_PARAMETER" => CrmlogErrorCodeCommonErrorCode::InvalidParameter,
                "INVALID_PROTO" => CrmlogErrorCodeCommonErrorCode::InvalidProto,
                "INVALID_QUOTA_CONFIGURATION" => {
                    CrmlogErrorCodeCommonErrorCode::InvalidQuotaConfiguration
                }
                "INVALID_TASK_STATE" => CrmlogErrorCodeCommonErrorCode::InvalidTaskState,
                "INVALID_TENANT" => CrmlogErrorCodeCommonErrorCode::InvalidTenant,
                "INVALID_VECTOR_USER" => CrmlogErrorCodeCommonErrorCode::InvalidVectorUser,
                "INVALID_WORKFLOW" => CrmlogErrorCodeCommonErrorCode::InvalidWorkflow,
                "IO_ERROR" => CrmlogErrorCodeCommonErrorCode::IoError,
                "MISSING_ATTRIBUTE" => CrmlogErrorCodeCommonErrorCode::MissingAttribute,
                "MISSING_CLIENT" => CrmlogErrorCodeCommonErrorCode::MissingClient,
                "MISSING_PARAMETER" => CrmlogErrorCodeCommonErrorCode::MissingParameter,
                "MISSING_QUOTA_CONFIGURATION" => {
                    CrmlogErrorCodeCommonErrorCode::MissingQuotaConfiguration
                }
                "NOT_FOUND" => CrmlogErrorCodeCommonErrorCode::NotFound,
                "NOT_SUPPORTED_DATA_TYPE" => CrmlogErrorCodeCommonErrorCode::NotSupportedDataType,
                "PERMISSION" => CrmlogErrorCodeCommonErrorCode::Permission,
                "QUOTA_ENQUEUED" => CrmlogErrorCodeCommonErrorCode::QuotaEnqueued,
                "QUOTA_THROTTLED" => CrmlogErrorCodeCommonErrorCode::QuotaThrottled,
                "RELTIO" => CrmlogErrorCodeCommonErrorCode::Reltio,
                "REQUIRED_FIELDS_MISSING" => CrmlogErrorCodeCommonErrorCode::RequiredFieldsMissing,
                "RESUME_ERROR" => CrmlogErrorCodeCommonErrorCode::ResumeError,
                "RETRYABLE_TASK_ERROR" => CrmlogErrorCodeCommonErrorCode::RetryableTaskError,
                "RPC" => CrmlogErrorCodeCommonErrorCode::Rpc,
                "RPC_PERMISSION_DENIED" => CrmlogErrorCodeCommonErrorCode::RpcPermissionDenied,
                "SALES_FORCE" => CrmlogErrorCodeCommonErrorCode::SalesForce,
                "SCRIPT_TASK_RUNTIME_ERROR" => {
                    CrmlogErrorCodeCommonErrorCode::ScriptTaskRuntimeError
                }
                "SPANNER" => CrmlogErrorCodeCommonErrorCode::Spanner,
                "SYNC_EVENTBUS_EXECUTION_TIMEOUT" => {
                    CrmlogErrorCodeCommonErrorCode::SyncEventbusExecutionTimeout
                }
                "TASK_NOT_FOUND" => CrmlogErrorCodeCommonErrorCode::TaskNotFound,
                "TRANSFORM_EXPRESSION_EVALUATION_ERROR" => {
                    CrmlogErrorCodeCommonErrorCode::TransformExpressionEvaluationError
                }
                "TYPED_TASK_INVALID_INPUT_OPERATION" => {
                    CrmlogErrorCodeCommonErrorCode::TypedTaskInvalidInputOperation
                }
                "TYPED_TASK_INVALID_OUTPUT_OPERATION" => {
                    CrmlogErrorCodeCommonErrorCode::TypedTaskInvalidOutputOperation
                }
                "UNAUTHROIZED_WORKFLOW_EDITOR_ACTION" => {
                    CrmlogErrorCodeCommonErrorCode::UnauthroizedWorkflowEditorAction
                }
                "UNHANDLED_EVENTBUS_ERROR" => {
                    CrmlogErrorCodeCommonErrorCode::UnhandledEventbusError
                }
                "UNHANDLED_TASK_ERROR" => CrmlogErrorCodeCommonErrorCode::UnhandledTaskError,
                "UNIMPLEMENTED" => CrmlogErrorCodeCommonErrorCode::Unimplemented,
                "UNSANITIZED_USER_INPUT" => CrmlogErrorCodeCommonErrorCode::UnsanitizedUserInput,
                "VALIDATION_ERROR" => CrmlogErrorCodeCommonErrorCode::ValidationError,
                "WORKFLOW_NOT_FOUND" => CrmlogErrorCodeCommonErrorCode::WorkflowNotFound,
                "WRONG_TENANT" => CrmlogErrorCodeCommonErrorCode::WrongTenant,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for CrmlogErrorCodeCommonErrorCode {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for CrmlogErrorCodeCommonErrorCode {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusAuthconfigAuthConfigTaskParam { # [doc = "Defines the credential types to be supported as Task may restrict specific types to use, e.g. Cloud SQL Task will use username/password type only."] # [serde (rename = "allowedCredentialTypes" , default , skip_serializing_if = "std::option::Option::is_none")] pub allowed_credential_types : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems > > , # [serde (rename = "allowedServiceAccountInContext" , default , skip_serializing_if = "std::option::Option::is_none")] pub allowed_service_account_in_context : :: std :: option :: Option < bool > , # [doc = "UUID of the AuthConfig."] # [serde (rename = "authConfigId" , default , skip_serializing_if = "std::option::Option::is_none")] pub auth_config_id : :: std :: option :: Option < String > , # [doc = "A space-delimited list of requested scope permissions."] # [serde (rename = "scope" , default , skip_serializing_if = "std::option::Option::is_none")] pub scope : :: std :: option :: Option < String > , # [serde (rename = "useServiceAccountInContext" , default , skip_serializing_if = "std::option::Option::is_none")] pub use_service_account_in_context : :: std :: option :: Option < bool > , }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParam {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParam {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems {
        #[doc = "API key."]
        ApiKey,
        #[doc = "Auth Token, e.g. bearer token."]
        AuthToken,
        #[doc = "Client Certificate only."]
        ClientCertificateOnly,
        CredentialTypeUnspecified,
        #[doc = "JWT Token."]
        Jwt,
        #[doc = "OAuth 2.0 Authorization Code Grant Type."]
        Oauth2AuthorizationCode,
        #[doc = "OAuth 2.0 Client Credentials Grant Type."]
        Oauth2ClientCredentials,
        #[doc = "OAuth 2.0 Implicit Grant Type."]
        Oauth2Implicit,
        #[doc = "OAuth 2.0 Resource Owner Credentials Grant Type."]
        Oauth2ResourceOwnerCredentials,
        #[doc = "Google OIDC ID Token"]
        OidcToken,
        #[doc = "Service Account which can be used to generate token for authentication."]
        ServiceAccount,
        #[doc = "Regular username/password pair."]
        UsernameAndPassword,
    }
    impl EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ApiKey => "API_KEY" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: AuthToken => "AUTH_TOKEN" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ClientCertificateOnly => "CLIENT_CERTIFICATE_ONLY" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: CredentialTypeUnspecified => "CREDENTIAL_TYPE_UNSPECIFIED" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Jwt => "JWT" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2AuthorizationCode => "OAUTH2_AUTHORIZATION_CODE" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2ClientCredentials => "OAUTH2_CLIENT_CREDENTIALS" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2Implicit => "OAUTH2_IMPLICIT" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2ResourceOwnerCredentials => "OAUTH2_RESOURCE_OWNER_CREDENTIALS" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: OidcToken => "OIDC_TOKEN" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ServiceAccount => "SERVICE_ACCOUNT" , EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: UsernameAndPassword => "USERNAME_AND_PASSWORD" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems,
            (),
        > {
            Ok (match s { "API_KEY" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ApiKey , "AUTH_TOKEN" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: AuthToken , "CLIENT_CERTIFICATE_ONLY" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ClientCertificateOnly , "CREDENTIAL_TYPE_UNSPECIFIED" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: CredentialTypeUnspecified , "JWT" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Jwt , "OAUTH2_AUTHORIZATION_CODE" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2AuthorizationCode , "OAUTH2_CLIENT_CREDENTIALS" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2ClientCredentials , "OAUTH2_IMPLICIT" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2Implicit , "OAUTH2_RESOURCE_OWNER_CREDENTIALS" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2ResourceOwnerCredentials , "OIDC_TOKEN" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: OidcToken , "SERVICE_ACCOUNT" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ServiceAccount , "USERNAME_AND_PASSWORD" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: UsernameAndPassword , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "API_KEY" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ApiKey , "AUTH_TOKEN" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: AuthToken , "CLIENT_CERTIFICATE_ONLY" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ClientCertificateOnly , "CREDENTIAL_TYPE_UNSPECIFIED" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: CredentialTypeUnspecified , "JWT" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Jwt , "OAUTH2_AUTHORIZATION_CODE" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2AuthorizationCode , "OAUTH2_CLIENT_CREDENTIALS" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2ClientCredentials , "OAUTH2_IMPLICIT" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2Implicit , "OAUTH2_RESOURCE_OWNER_CREDENTIALS" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: Oauth2ResourceOwnerCredentials , "OIDC_TOKEN" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: OidcToken , "SERVICE_ACCOUNT" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: ServiceAccount , "USERNAME_AND_PASSWORD" => EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems :: UsernameAndPassword , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusAuthconfigAuthConfigTaskParamAllowedCredentialTypesItems
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoAddress {
        #[doc = "Required."]
        #[serde(
            rename = "email",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email: ::std::option::Option<String>,
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "tokens",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tokens: ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoToken>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoAddress {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoAddress {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoAttributes {
        #[doc = "Things like URL, Email, Currency, Timestamp (rather than string, int64â€¦)"]
        #[serde(
            rename = "dataType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_type:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoAttributesDataType>,
        #[doc = "Used to define defaults."]
        #[serde(
            rename = "defaultValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_value:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoValueType>,
        #[doc = "Required for event execution. The validation will be done by the event bus when the event is triggered."]
        #[serde(
            rename = "isRequired",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_required: ::std::option::Option<bool>,
        #[doc = "Used to indicate if a ParameterEntry should be converted to ParamIndexes for ST-Spanner full-text search. DEPRECATED: use searchable."]
        #[serde(
            rename = "isSearchable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_searchable: ::std::option::Option<bool>,
        #[doc = "See"]
        #[serde(
            rename = "logSettings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_settings:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoLogSettings>,
        #[serde(
            rename = "searchable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub searchable:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoAttributesSearchable>,
        #[doc = "List of tasks that can view this property, if empty then all."]
        #[serde(
            rename = "taskVisibility",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_visibility: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoAttributes {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoAttributes {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoAttributesDataType {
        Currency,
        DataTypeUnspecified,
        #[doc = "Domain is a web url string with one top-level private domain and a suffix (for example: google.com, walmart.com)"]
        DomainName,
        Email,
        Timestamp,
        Url,
    }
    impl EnterpriseCrmEventbusProtoAttributesDataType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoAttributesDataType::Currency => "CURRENCY",
                EnterpriseCrmEventbusProtoAttributesDataType::DataTypeUnspecified => {
                    "DATA_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoAttributesDataType::DomainName => "DOMAIN_NAME",
                EnterpriseCrmEventbusProtoAttributesDataType::Email => "EMAIL",
                EnterpriseCrmEventbusProtoAttributesDataType::Timestamp => "TIMESTAMP",
                EnterpriseCrmEventbusProtoAttributesDataType::Url => "URL",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoAttributesDataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoAttributesDataType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoAttributesDataType, ()> {
            Ok(match s {
                "CURRENCY" => EnterpriseCrmEventbusProtoAttributesDataType::Currency,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoAttributesDataType::DataTypeUnspecified
                }
                "DOMAIN_NAME" => EnterpriseCrmEventbusProtoAttributesDataType::DomainName,
                "EMAIL" => EnterpriseCrmEventbusProtoAttributesDataType::Email,
                "TIMESTAMP" => EnterpriseCrmEventbusProtoAttributesDataType::Timestamp,
                "URL" => EnterpriseCrmEventbusProtoAttributesDataType::Url,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoAttributesDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoAttributesDataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoAttributesDataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CURRENCY" => EnterpriseCrmEventbusProtoAttributesDataType::Currency,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoAttributesDataType::DataTypeUnspecified
                }
                "DOMAIN_NAME" => EnterpriseCrmEventbusProtoAttributesDataType::DomainName,
                "EMAIL" => EnterpriseCrmEventbusProtoAttributesDataType::Email,
                "TIMESTAMP" => EnterpriseCrmEventbusProtoAttributesDataType::Timestamp,
                "URL" => EnterpriseCrmEventbusProtoAttributesDataType::Url,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoAttributesDataType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoAttributesDataType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoAttributesSearchable {
        #[doc = "If no, the parameter key and value will not be full-text indexed. In a proto, this value will propagate to all children whose searchable is unspecified."]
        No,
        Unspecified,
        #[doc = "If yes, the parameter key and value will be full-text indexed. In a proto, this value will propagate to all children whose searchable is unspecified."]
        Yes,
    }
    impl EnterpriseCrmEventbusProtoAttributesSearchable {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoAttributesSearchable::No => "NO",
                EnterpriseCrmEventbusProtoAttributesSearchable::Unspecified => "UNSPECIFIED",
                EnterpriseCrmEventbusProtoAttributesSearchable::Yes => "YES",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoAttributesSearchable {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoAttributesSearchable {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoAttributesSearchable, ()> {
            Ok(match s {
                "NO" => EnterpriseCrmEventbusProtoAttributesSearchable::No,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoAttributesSearchable::Unspecified,
                "YES" => EnterpriseCrmEventbusProtoAttributesSearchable::Yes,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoAttributesSearchable {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoAttributesSearchable {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoAttributesSearchable {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NO" => EnterpriseCrmEventbusProtoAttributesSearchable::No,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoAttributesSearchable::Unspecified,
                "YES" => EnterpriseCrmEventbusProtoAttributesSearchable::Yes,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoAttributesSearchable {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoAttributesSearchable {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumList {
        #[serde(
            rename = "enumStrings",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enum_strings: ::std::option::Option<Vec<String>>,
        #[serde(
            rename = "filterType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub filter_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumList
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumList
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType {
        DefaultInclusive,
        Exclusive,
    }
    impl EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType :: DefaultInclusive => "DEFAULT_INCLUSIVE" , EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType :: Exclusive => "EXCLUSIVE" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType,
            (),
        > {
            Ok (match s { "DEFAULT_INCLUSIVE" => EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType :: DefaultInclusive , "EXCLUSIVE" => EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType :: Exclusive , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEFAULT_INCLUSIVE" => EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType :: DefaultInclusive , "EXCLUSIVE" => EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType :: Exclusive , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumListFilterType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoBaseAlertConfigThresholdValue {
        #[serde(
            rename = "absolute",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub absolute: ::std::option::Option<i64>,
        #[serde(
            rename = "percentage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub percentage: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoBaseAlertConfigThresholdValue
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoBaseAlertConfigThresholdValue
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoBaseFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBaseFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoBaseFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoBaseFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        Environment,
        GetExecutionId,
        GetIntegrationName,
        GetProjectId,
        GetRegion,
        GetUuid,
        IntList,
        NowInMillis,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::Environment => "ENVIRONMENT",
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetExecutionId => {
                    "GET_EXECUTION_ID"
                }
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetIntegrationName => {
                    "GET_INTEGRATION_NAME"
                }
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetProjectId => {
                    "GET_PROJECT_ID"
                }
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetRegion => "GET_REGION",
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetUuid => "GET_UUID",
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::IntList => "INT_LIST",
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::NowInMillis => "NOW_IN_MILLIS",
                EnterpriseCrmEventbusProtoBaseFunctionFunctionName::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoBaseFunctionFunctionName, ()> {
            Ok(match s {
                "ENVIRONMENT" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::Environment,
                "GET_EXECUTION_ID" => {
                    EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetExecutionId
                }
                "GET_INTEGRATION_NAME" => {
                    EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetIntegrationName
                }
                "GET_PROJECT_ID" => {
                    EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetProjectId
                }
                "GET_REGION" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetRegion,
                "GET_UUID" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetUuid,
                "INT_LIST" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::IntList,
                "NOW_IN_MILLIS" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::NowInMillis,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ENVIRONMENT" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::Environment,
                "GET_EXECUTION_ID" => {
                    EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetExecutionId
                }
                "GET_INTEGRATION_NAME" => {
                    EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetIntegrationName
                }
                "GET_PROJECT_ID" => {
                    EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetProjectId
                }
                "GET_REGION" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetRegion,
                "GET_UUID" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::GetUuid,
                "INT_LIST" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::IntList,
                "NOW_IN_MILLIS" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::NowInMillis,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoBaseFunctionFunctionName::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoBaseFunctionFunctionName {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoBaseValue {
        #[doc = "Start with a function that does not build on existing values. Eg. CurrentTime, Min, Max, Exists, etc."]
        #[serde(
            rename = "baseFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub base_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoFunction>,
        #[doc = "Start with a literal value."]
        #[serde(
            rename = "literalValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub literal_value:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterValueType>,
        #[doc = "Start with a reference value to dereference."]
        #[serde(
            rename = "referenceValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reference_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoBaseValue {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoBaseValue {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoBooleanArrayFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoBooleanArrayFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoBooleanArrayFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName {
        Append,
        AppendAll,
        Contains,
        Filter,
        ForEach,
        Get,
        Remove,
        RemoveAt,
        Set,
        Size,
        ToJson,
        ToSet,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Append => "APPEND",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::AppendAll => {
                    "APPEND_ALL"
                }
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Contains => "CONTAINS",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Filter => "FILTER",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ForEach => "FOR_EACH",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Get => "GET",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Remove => "REMOVE",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::RemoveAt => "REMOVE_AT",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Set => "SET",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Size => "SIZE",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ToSet => "TO_SET",
                EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Unspecified => {
                    "UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName, ()>
        {
            Ok(match s {
                "APPEND" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Append,
                "APPEND_ALL" => {
                    EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::AppendAll
                }
                "CONTAINS" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Get,
                "REMOVE" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Size,
                "TO_JSON" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Unspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APPEND" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Append,
                "APPEND_ALL" => {
                    EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::AppendAll
                }
                "CONTAINS" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Get,
                "REMOVE" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Size,
                "TO_JSON" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName::Unspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoBooleanArrayFunctionFunctionName
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoBooleanFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBooleanFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoBooleanFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoBooleanFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoBooleanFunctionFunctionName {
        And,
        Equals,
        Nand,
        Nor,
        Not,
        Or,
        ToJson,
        ToString,
        Unspecified,
        Xnor,
        Xor,
    }
    impl EnterpriseCrmEventbusProtoBooleanFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::And => "AND",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Equals => "EQUALS",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Nand => "NAND",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Nor => "NOR",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Not => "NOT",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Or => "OR",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::ToString => "TO_STRING",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Unspecified => "UNSPECIFIED",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Xnor => "XNOR",
                EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Xor => "XOR",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoBooleanFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoBooleanFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoBooleanFunctionFunctionName, ()>
        {
            Ok(match s {
                "AND" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::And,
                "EQUALS" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Equals,
                "NAND" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Nand,
                "NOR" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Nor,
                "NOT" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Not,
                "OR" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Or,
                "TO_JSON" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::ToJson,
                "TO_STRING" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::ToString,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Unspecified,
                "XNOR" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Xnor,
                "XOR" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Xor,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoBooleanFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoBooleanFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoBooleanFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AND" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::And,
                "EQUALS" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Equals,
                "NAND" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Nand,
                "NOR" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Nor,
                "NOT" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Not,
                "OR" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Or,
                "TO_JSON" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::ToJson,
                "TO_STRING" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::ToString,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Unspecified,
                "XNOR" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Xnor,
                "XOR" => EnterpriseCrmEventbusProtoBooleanFunctionFunctionName::Xor,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoBooleanFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoBooleanFunctionFunctionName
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoBooleanParameterArray {
        #[serde(
            rename = "booleanValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_values: ::std::option::Option<Vec<bool>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoBooleanParameterArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoBooleanParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoBuganizerNotification {
        #[doc = "Whom to assign the new bug. Optional."]
        #[serde(
            rename = "assigneeEmailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub assignee_email_address: ::std::option::Option<String>,
        #[doc = "ID of the buganizer component within which to create a new issue. Required."]
        #[serde(
            rename = "componentId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub component_id: ::std::option::Option<i64>,
        #[doc = "ID of the buganizer template to use. Optional."]
        #[serde(
            rename = "templateId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub template_id: ::std::option::Option<i64>,
        #[doc = "Title of the issue to be created. Required."]
        #[serde(
            rename = "title",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub title: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoBuganizerNotification {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoBuganizerNotification {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoCloudSchedulerConfig {
        #[doc = "Required. The cron tab of cloud scheduler trigger."]
        #[serde(
            rename = "cronTab",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cron_tab: ::std::option::Option<String>,
        #[doc = "Optional. When the job was deleted from Pantheon UI, error_message will be populated when Get/List integrations"]
        #[serde(
            rename = "errorMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_message: ::std::option::Option<String>,
        #[doc = "Required. The location where associated cloud scheduler job will be created"]
        #[serde(
            rename = "location",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub location: ::std::option::Option<String>,
        #[doc = "Required. Service account used by Cloud Scheduler to trigger the integration at scheduled time"]
        #[serde(
            rename = "serviceAccountEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_account_email: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoCloudSchedulerConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoCloudSchedulerConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoCombinedCondition {
        #[doc = "A set of individual constituent conditions."]
        #[serde(
            rename = "conditions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub conditions:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoCondition>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoCombinedCondition {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoCombinedCondition {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoCondition {
        #[doc = "Key thatâ€™s evaluated against the `value`. Please note the data type of the runtime value associated with the key should match the data type of `value`, else an IllegalArgumentException is thrown."]
        #[serde(
            rename = "eventPropertyKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_property_key: ::std::option::Option<String>,
        #[doc = "Operator used to evaluate the condition. Please note that an operator with an inappropriate key/value operand will result in IllegalArgumentException, e.g. CONTAINS with boolean key/value pair."]
        #[serde(
            rename = "operator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operator:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoConditionOperator>,
        #[doc = "Value thatâ€™s checked for the key."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoValueType>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoCondition {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoCondition {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoConditionOperator {
        Contains,
        DoesNotExist,
        Equals,
        Exists,
        GreaterThan,
        IsEmpty,
        IsNotEmpty,
        LessThan,
        Unset,
    }
    impl EnterpriseCrmEventbusProtoConditionOperator {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoConditionOperator::Contains => "CONTAINS",
                EnterpriseCrmEventbusProtoConditionOperator::DoesNotExist => "DOES_NOT_EXIST",
                EnterpriseCrmEventbusProtoConditionOperator::Equals => "EQUALS",
                EnterpriseCrmEventbusProtoConditionOperator::Exists => "EXISTS",
                EnterpriseCrmEventbusProtoConditionOperator::GreaterThan => "GREATER_THAN",
                EnterpriseCrmEventbusProtoConditionOperator::IsEmpty => "IS_EMPTY",
                EnterpriseCrmEventbusProtoConditionOperator::IsNotEmpty => "IS_NOT_EMPTY",
                EnterpriseCrmEventbusProtoConditionOperator::LessThan => "LESS_THAN",
                EnterpriseCrmEventbusProtoConditionOperator::Unset => "UNSET",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoConditionOperator {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoConditionOperator {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoConditionOperator, ()> {
            Ok(match s {
                "CONTAINS" => EnterpriseCrmEventbusProtoConditionOperator::Contains,
                "DOES_NOT_EXIST" => EnterpriseCrmEventbusProtoConditionOperator::DoesNotExist,
                "EQUALS" => EnterpriseCrmEventbusProtoConditionOperator::Equals,
                "EXISTS" => EnterpriseCrmEventbusProtoConditionOperator::Exists,
                "GREATER_THAN" => EnterpriseCrmEventbusProtoConditionOperator::GreaterThan,
                "IS_EMPTY" => EnterpriseCrmEventbusProtoConditionOperator::IsEmpty,
                "IS_NOT_EMPTY" => EnterpriseCrmEventbusProtoConditionOperator::IsNotEmpty,
                "LESS_THAN" => EnterpriseCrmEventbusProtoConditionOperator::LessThan,
                "UNSET" => EnterpriseCrmEventbusProtoConditionOperator::Unset,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoConditionOperator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoConditionOperator {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoConditionOperator {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CONTAINS" => EnterpriseCrmEventbusProtoConditionOperator::Contains,
                "DOES_NOT_EXIST" => EnterpriseCrmEventbusProtoConditionOperator::DoesNotExist,
                "EQUALS" => EnterpriseCrmEventbusProtoConditionOperator::Equals,
                "EXISTS" => EnterpriseCrmEventbusProtoConditionOperator::Exists,
                "GREATER_THAN" => EnterpriseCrmEventbusProtoConditionOperator::GreaterThan,
                "IS_EMPTY" => EnterpriseCrmEventbusProtoConditionOperator::IsEmpty,
                "IS_NOT_EMPTY" => EnterpriseCrmEventbusProtoConditionOperator::IsNotEmpty,
                "LESS_THAN" => EnterpriseCrmEventbusProtoConditionOperator::LessThan,
                "UNSET" => EnterpriseCrmEventbusProtoConditionOperator::Unset,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoConditionOperator {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoConditionOperator {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoConditionResult {
        #[doc = "the current task number."]
        #[serde(
            rename = "currentTaskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub current_task_number: ::std::option::Option<String>,
        #[doc = "the next task number."]
        #[serde(
            rename = "nextTaskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_task_number: ::std::option::Option<String>,
        #[doc = "the result comes out after evaluate the combined condition. True if thereâ€™s no combined condition specified."]
        #[serde(
            rename = "result",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub result: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoConditionResult {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoConditionResult {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoConnectorsConnection {
        #[doc = "Connection name Format: projects/{project}/locations/{location}/connections/{connection}"]
        #[serde(
            rename = "connectionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connection_name: ::std::option::Option<String>,
        #[doc = "Connector version Format: projects/{project}/locations/{location}/providers/{provider}/connectors/{connector}/versions/{version}"]
        #[serde(
            rename = "connectorVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connector_version: ::std::option::Option<String>,
        #[doc = "Service name Format: projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}"]
        #[serde(
            rename = "serviceName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoConnectorsConnection {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoConnectorsConnection {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfig {
        #[doc = "User-selected connection."]
        #[serde(
            rename = "connection",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connection:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoConnectorsConnection>,
        #[doc = "Operation to perform using the configured connection."]
        #[serde(
            rename = "operation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub operation: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation {
        CreateEntity,
        DeleteEntity,
        ExecuteAction,
        GetEntity,
        ListEntities,
        OperationUnspecified,
        UpdateEntity,
    }
    impl EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: CreateEntity => "CREATE_ENTITY" , EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: DeleteEntity => "DELETE_ENTITY" , EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: ExecuteAction => "EXECUTE_ACTION" , EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: GetEntity => "GET_ENTITY" , EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: ListEntities => "LIST_ENTITIES" , EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: OperationUnspecified => "OPERATION_UNSPECIFIED" , EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: UpdateEntity => "UPDATE_ENTITY" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation,
            (),
        > {
            Ok (match s { "CREATE_ENTITY" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: CreateEntity , "DELETE_ENTITY" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: DeleteEntity , "EXECUTE_ACTION" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: ExecuteAction , "GET_ENTITY" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: GetEntity , "LIST_ENTITIES" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: ListEntities , "OPERATION_UNSPECIFIED" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: OperationUnspecified , "UPDATE_ENTITY" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: UpdateEntity , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "CREATE_ENTITY" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: CreateEntity , "DELETE_ENTITY" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: DeleteEntity , "EXECUTE_ACTION" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: ExecuteAction , "GET_ENTITY" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: GetEntity , "LIST_ENTITIES" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: ListEntities , "OPERATION_UNSPECIFIED" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: OperationUnspecified , "UPDATE_ENTITY" => EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation :: UpdateEntity , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoConnectorsGenericConnectorTaskConfigOperation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoCoordinate {
        #[serde(
            rename = "x",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub x: ::std::option::Option<i32>,
        #[serde(
            rename = "y",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub y: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoCoordinate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoCoordinate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoCustomSuspensionRequest {
        #[doc = "Request to fire an event containing the SuspensionInfo message."]
        #[serde(
            rename = "postToQueueWithTriggerIdRequest",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub post_to_queue_with_trigger_id_request: ::std::option::Option<
            crate::schemas::GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequest,
        >,
        #[doc = "In the fired event, set the SuspensionInfo message as the value for this key."]
        #[serde(
            rename = "suspensionInfoEventParameterKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspension_info_event_parameter_key: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoCustomSuspensionRequest {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoCustomSuspensionRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoDoubleArray {
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<f64>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoDoubleArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoDoubleArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoDoubleArrayFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoDoubleArrayFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoDoubleArrayFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName {
        Append,
        AppendAll,
        Avg,
        Contains,
        Filter,
        ForEach,
        Get,
        Max,
        Min,
        Remove,
        RemoveAt,
        Set,
        Size,
        Sum,
        ToJson,
        ToSet,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Append => "APPEND",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::AppendAll => {
                    "APPEND_ALL"
                }
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Avg => "AVG",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Contains => "CONTAINS",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Filter => "FILTER",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ForEach => "FOR_EACH",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Get => "GET",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Max => "MAX",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Min => "MIN",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Remove => "REMOVE",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::RemoveAt => "REMOVE_AT",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Set => "SET",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Size => "SIZE",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Sum => "SUM",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ToSet => "TO_SET",
                EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Unspecified => {
                    "UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName, ()>
        {
            Ok(match s {
                "APPEND" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Append,
                "APPEND_ALL" => {
                    EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::AppendAll
                }
                "AVG" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Avg,
                "CONTAINS" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Get,
                "MAX" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Max,
                "MIN" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Min,
                "REMOVE" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Size,
                "SUM" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Sum,
                "TO_JSON" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Unspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APPEND" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Append,
                "APPEND_ALL" => {
                    EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::AppendAll
                }
                "AVG" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Avg,
                "CONTAINS" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Get,
                "MAX" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Max,
                "MIN" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Min,
                "REMOVE" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Size,
                "SUM" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Sum,
                "TO_JSON" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName::Unspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoDoubleArrayFunctionFunctionName
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoDoubleFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoDoubleFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoDoubleFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoDoubleFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoDoubleFunctionFunctionName {
        Add,
        Ceil,
        Divide,
        Equals,
        Exponent,
        Floor,
        GreaterThan,
        GreaterThanEquals,
        LessThan,
        LessThanEquals,
        Mod,
        Multiply,
        Round,
        Subtract,
        ToJson,
        ToString,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoDoubleFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Add => "ADD",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Ceil => "CEIL",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Divide => "DIVIDE",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Equals => "EQUALS",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Exponent => "EXPONENT",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Floor => "FLOOR",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::GreaterThan => "GREATER_THAN",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::GreaterThanEquals => {
                    "GREATER_THAN_EQUALS"
                }
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::LessThan => "LESS_THAN",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::LessThanEquals => {
                    "LESS_THAN_EQUALS"
                }
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Mod => "MOD",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Multiply => "MULTIPLY",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Round => "ROUND",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Subtract => "SUBTRACT",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::ToString => "TO_STRING",
                EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoDoubleFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoDoubleFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoDoubleFunctionFunctionName, ()>
        {
            Ok(match s {
                "ADD" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Add,
                "CEIL" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Ceil,
                "DIVIDE" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Divide,
                "EQUALS" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Equals,
                "EXPONENT" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Exponent,
                "FLOOR" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Floor,
                "GREATER_THAN" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::GreaterThan,
                "GREATER_THAN_EQUALS" => {
                    EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::GreaterThanEquals
                }
                "LESS_THAN" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::LessThan,
                "LESS_THAN_EQUALS" => {
                    EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::LessThanEquals
                }
                "MOD" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Mod,
                "MULTIPLY" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Multiply,
                "ROUND" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Round,
                "SUBTRACT" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Subtract,
                "TO_JSON" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::ToJson,
                "TO_STRING" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::ToString,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoDoubleFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoDoubleFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoDoubleFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADD" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Add,
                "CEIL" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Ceil,
                "DIVIDE" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Divide,
                "EQUALS" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Equals,
                "EXPONENT" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Exponent,
                "FLOOR" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Floor,
                "GREATER_THAN" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::GreaterThan,
                "GREATER_THAN_EQUALS" => {
                    EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::GreaterThanEquals
                }
                "LESS_THAN" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::LessThan,
                "LESS_THAN_EQUALS" => {
                    EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::LessThanEquals
                }
                "MOD" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Mod,
                "MULTIPLY" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Multiply,
                "ROUND" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Round,
                "SUBTRACT" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Subtract,
                "TO_JSON" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::ToJson,
                "TO_STRING" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::ToString,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoDoubleFunctionFunctionName::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoDoubleFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoDoubleFunctionFunctionName {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoDoubleParameterArray {
        #[serde(
            rename = "doubleValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_values: ::std::option::Option<Vec<f64>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoDoubleParameterArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoDoubleParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoErrorDetail {
        #[doc = "The associated error-code, which can be a common or internal code."]
        #[serde(
            rename = "errorCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_code: ::std::option::Option<crate::schemas::CrmlogErrorCode>,
        #[doc = "The full text of the error message, including any parameters that were thrown along with the exception."]
        #[serde(
            rename = "errorMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_message: ::std::option::Option<String>,
        #[doc = "The severity of the error: ERROR|WARN|INFO."]
        #[serde(
            rename = "severity",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub severity:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoErrorDetailSeverity>,
        #[doc = "The task try-number, in which, the error occurred. If zero, the error happened at the event level."]
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoErrorDetail {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoErrorDetail {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoErrorDetailSeverity {
        Error,
        Info,
        SeverityUnspecified,
        Warn,
    }
    impl EnterpriseCrmEventbusProtoErrorDetailSeverity {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoErrorDetailSeverity::Error => "ERROR",
                EnterpriseCrmEventbusProtoErrorDetailSeverity::Info => "INFO",
                EnterpriseCrmEventbusProtoErrorDetailSeverity::SeverityUnspecified => {
                    "SEVERITY_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoErrorDetailSeverity::Warn => "WARN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoErrorDetailSeverity {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoErrorDetailSeverity {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoErrorDetailSeverity, ()> {
            Ok(match s {
                "ERROR" => EnterpriseCrmEventbusProtoErrorDetailSeverity::Error,
                "INFO" => EnterpriseCrmEventbusProtoErrorDetailSeverity::Info,
                "SEVERITY_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoErrorDetailSeverity::SeverityUnspecified
                }
                "WARN" => EnterpriseCrmEventbusProtoErrorDetailSeverity::Warn,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoErrorDetailSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoErrorDetailSeverity {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoErrorDetailSeverity {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ERROR" => EnterpriseCrmEventbusProtoErrorDetailSeverity::Error,
                "INFO" => EnterpriseCrmEventbusProtoErrorDetailSeverity::Info,
                "SEVERITY_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoErrorDetailSeverity::SeverityUnspecified
                }
                "WARN" => EnterpriseCrmEventbusProtoErrorDetailSeverity::Warn,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoErrorDetailSeverity {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoErrorDetailSeverity {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoEventBusProperties {
        #[doc = "An unordered list of property entries."]
        #[serde(
            rename = "properties",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub properties:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoPropertyEntry>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoEventBusProperties {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoEventBusProperties {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoEventExecutionDetails {
        #[serde(
            rename = "eventAttemptStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_attempt_stats: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmEventbusProtoEventExecutionDetailsEventAttemptStats>,
        >,
        #[serde(
            rename = "eventExecutionSnapshot",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_execution_snapshot: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmEventbusProtoEventExecutionSnapshot>,
        >,
        #[serde(
            rename = "eventExecutionState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_execution_state: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState,
        >,
        #[doc = "Indicates the number of times the execution has restarted from the beginning."]
        #[serde(
            rename = "eventRetriesFromBeginningCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_retries_from_beginning_count: ::std::option::Option<i32>,
        #[doc = "The log file path (aka. cns address) for this event."]
        #[serde(
            rename = "logFilePath",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_file_path: ::std::option::Option<String>,
        #[doc = "The network address (aka. bns address) that indicates where the event executor is running."]
        #[serde(
            rename = "networkAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub network_address: ::std::option::Option<String>,
        #[doc = "Next scheduled execution time in case the execution status was RETRY_ON_HOLD."]
        #[serde(
            rename = "nextExecutionTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub next_execution_time: ::std::option::Option<i64>,
        #[doc = "Used internally and shouldnâ€™t be exposed to users. A counter for the cron job to record how many times this event is in in_process state but donâ€™t have a lock consecutively/"]
        #[serde(
            rename = "ryeLockUnheldCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rye_lock_unheld_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoEventExecutionDetails {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoEventExecutionDetails {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState {
        #[doc = "Event execution canceled by user. Thereâ€™s no more change after this state."]
        Canceled,
        #[doc = "Event execution failed. Thereâ€™s no more change after this state."]
        Failed,
        #[doc = "Event is under processing."]
        InProcess,
        #[doc = "Event is received and waiting for the execution. This happens when firing the event via â€œpostToQueueâ€ or â€œscheduleâ€."]
        OnHold,
        #[doc = "Event execution failed and waiting for retry."]
        RetryOnHold,
        #[doc = "Event execution successfully finished. Thereâ€™s no more change after this state."]
        Succeeded,
        #[doc = "Event execution suspended and waiting for manual intervention."]
        Suspended,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Canceled => {
                    "CANCELED"
                }
                EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Failed => {
                    "FAILED"
                }
                EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::InProcess => {
                    "IN_PROCESS"
                }
                EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::OnHold => {
                    "ON_HOLD"
                }
                EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::RetryOnHold => {
                    "RETRY_ON_HOLD"
                }
                EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Succeeded => {
                    "SUCCEEDED"
                }
                EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Suspended => {
                    "SUSPENDED"
                }
                EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Unspecified => {
                    "UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState,
            (),
        > {
            Ok(match s {
                "CANCELED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Canceled
                }
                "FAILED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Failed
                }
                "IN_PROCESS" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::InProcess
                }
                "ON_HOLD" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::OnHold
                }
                "RETRY_ON_HOLD" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::RetryOnHold
                }
                "SUCCEEDED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Succeeded
                }
                "SUSPENDED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Suspended
                }
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Unspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CANCELED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Canceled
                }
                "FAILED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Failed
                }
                "IN_PROCESS" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::InProcess
                }
                "ON_HOLD" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::OnHold
                }
                "RETRY_ON_HOLD" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::RetryOnHold
                }
                "SUCCEEDED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Succeeded
                }
                "SUSPENDED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Suspended
                }
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState::Unspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoEventExecutionDetailsEventAttemptStats {
        #[doc = "The end time of the event execution for current attempt."]
        #[serde(
            rename = "endTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub end_time: ::std::option::Option<i64>,
        #[doc = "The start time of the event execution for current attempt. This could be in the future if itâ€™s been scheduled."]
        #[serde(
            rename = "startTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub start_time: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoEventExecutionDetailsEventAttemptStats
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoEventExecutionDetailsEventAttemptStats
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoEventExecutionSnapshot { # [doc = "Indicates â€œright after which checkpoint taskâ€™s executionâ€ this snapshot is taken."] # [serde (rename = "checkpointTaskNumber" , default , skip_serializing_if = "std::option::Option::is_none")] pub checkpoint_task_number : :: std :: option :: Option < String > , # [doc = "All of the computed conditions that been calculated."] # [serde (rename = "conditionResults" , default , skip_serializing_if = "std::option::Option::is_none")] pub condition_results : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmEventbusProtoConditionResult > > , # [doc = "The parameters in Event object that differs from last snapshot."] # [serde (rename = "diffParams" , default , skip_serializing_if = "std::option::Option::is_none")] pub diff_params : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoEventParameters > , # [doc = "Points to the event execution info this snapshot belongs to."] # [serde (rename = "eventExecutionInfoId" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_execution_info_id : :: std :: option :: Option < String > , # [doc = "Auto-generated. Used as primary key for EventExecutionSnapshots table."] # [serde (rename = "eventExecutionSnapshotId" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_execution_snapshot_id : :: std :: option :: Option < String > , # [serde (rename = "eventExecutionSnapshotMetadata" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_execution_snapshot_metadata : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoEventExecutionSnapshotEventExecutionSnapshotMetadata > , # [doc = "The parameters in Event object."] # [serde (rename = "eventParams" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_params : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoEventParameters > , # [doc = "indicate whether snapshot exceeded maximum size before clean up"] # [serde (rename = "exceedMaxSize" , default , skip_serializing_if = "std::option::Option::is_none")] pub exceed_max_size : :: std :: option :: Option < bool > , # [doc = "Indicates when this snapshot is taken."] # [serde (rename = "snapshotTime" , default , skip_serializing_if = "std::option::Option::is_none")] # [serde (with = "crate::parsed_string")] pub snapshot_time : :: std :: option :: Option < i64 > , # [doc = "All of the task execution details at the given point of time."] # [serde (rename = "taskExecutionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub task_execution_details : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmEventbusProtoTaskExecutionDetails > > , # [doc = "The task name associated with this snapshot. Could be empty."] # [serde (rename = "taskName" , default , skip_serializing_if = "std::option::Option::is_none")] pub task_name : :: std :: option :: Option < String > , }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoEventExecutionSnapshot {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoEventExecutionSnapshot {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoEventExecutionSnapshotEventExecutionSnapshotMetadata {
        #[doc = "the event attempt number this snapshot belongs to."]
        #[serde(
            rename = "eventAttemptNum",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_attempt_num: ::std::option::Option<i32>,
        #[doc = "the task attempt number this snapshot belongs to. Could be empty."]
        #[serde(
            rename = "taskAttemptNum",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_attempt_num: ::std::option::Option<i32>,
        #[doc = "the task name associated with this snapshot. Could be empty."]
        #[serde(
            rename = "taskName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_name: ::std::option::Option<String>,
        #[doc = "The task number associated with this snapshot. Could be empty."]
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoEventExecutionSnapshotEventExecutionSnapshotMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoEventExecutionSnapshotEventExecutionSnapshotMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoEventParameters {
        #[doc = "Parameters are a part of Event and can be used to communicate between different tasks that are part of the same integration execution."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoParameterEntry>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoEventParameters {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoEventParameters {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoExecutionTraceInfo {
        #[doc = "Parent event execution info id that triggers the current execution through SubWorkflowExecutorTask."]
        #[serde(
            rename = "parentEventExecutionInfoId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parent_event_execution_info_id: ::std::option::Option<String>,
        #[doc = "Used to aggregate ExecutionTraceInfo."]
        #[serde(
            rename = "traceId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trace_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoExecutionTraceInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoExecutionTraceInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoExternalTraffic {
        #[doc = "Userâ€™s GCP project id the traffic is referring to."]
        #[serde(
            rename = "gcpProjectId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcp_project_id: ::std::option::Option<String>,
        #[doc = "Userâ€™s GCP project number the traffic is referring to."]
        #[serde(
            rename = "gcpProjectNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gcp_project_number: ::std::option::Option<String>,
        #[doc = "Location for the userâ€™s request."]
        #[serde(
            rename = "location",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub location: ::std::option::Option<String>,
        #[doc = "LINT.ThenChange(//depot/google3/enterprise/crm/eventbus/proto/product.proto:product, //depot/google3/java/com/google/enterprise/crm/integrationplatform/api/utils/ConverterUtils.java:source_to_product)"]
        #[serde(
            rename = "source",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub source:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoExternalTrafficSource>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoExternalTraffic {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoExternalTraffic {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoExternalTrafficSource {
        Apigee,
        Security,
        SourceUnspecified,
    }
    impl EnterpriseCrmEventbusProtoExternalTrafficSource {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoExternalTrafficSource::Apigee => "APIGEE",
                EnterpriseCrmEventbusProtoExternalTrafficSource::Security => "SECURITY",
                EnterpriseCrmEventbusProtoExternalTrafficSource::SourceUnspecified => {
                    "SOURCE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoExternalTrafficSource {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoExternalTrafficSource {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoExternalTrafficSource, ()> {
            Ok(match s {
                "APIGEE" => EnterpriseCrmEventbusProtoExternalTrafficSource::Apigee,
                "SECURITY" => EnterpriseCrmEventbusProtoExternalTrafficSource::Security,
                "SOURCE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoExternalTrafficSource::SourceUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoExternalTrafficSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoExternalTrafficSource {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoExternalTrafficSource {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APIGEE" => EnterpriseCrmEventbusProtoExternalTrafficSource::Apigee,
                "SECURITY" => EnterpriseCrmEventbusProtoExternalTrafficSource::Security,
                "SOURCE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoExternalTrafficSource::SourceUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoExternalTrafficSource {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoExternalTrafficSource {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoFailurePolicy {
        #[doc = "Required if retry_strategy is FIXED_INTERVAL or LINEAR/EXPONENTIAL_BACKOFF/RESTART_WORKFLOW_WITH_BACKOFF. Defines the initial interval for backoff."]
        #[serde(
            rename = "intervalInSeconds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub interval_in_seconds: ::std::option::Option<i64>,
        #[doc = "Required if retry_strategy is FIXED_INTERVAL or LINEAR/EXPONENTIAL_BACKOFF/RESTART_WORKFLOW_WITH_BACKOFF. Defines the number of times the task will be retried if failed."]
        #[serde(
            rename = "maxNumRetries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_num_retries: ::std::option::Option<i32>,
        #[doc = "Defines what happens to the task upon failure."]
        #[serde(
            rename = "retryStrategy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retry_strategy: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoFailurePolicy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoFailurePolicy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy {
        #[doc = "The task will be retried after an exponentially increasing period of time with each failure. A jitter is added to each exponential interval so that concurrently failing tasks of the same type do not end up retrying after the exact same exponential interval. A max-retry count is required to be specified with this strategy. `max_num_retries` and `interval_in_seconds` must be specified."]
        ExponentialBackoff,
        #[doc = "Causes a permanent failure of the event. It is different from NONE because this will mark the event as FAILED by shutting down the event execution."]
        Fatal,
        #[doc = "The task will be retried from the failed task onwards after a fixed delay. A max-retry count is required to be specified with this strategy. A jitter is added to each exponential interval so that concurrently failing tasks of the same type do not end up retrying after the exact same exponential interval. Max_num_retries and interval_in_seconds must be specified."]
        FixedInterval,
        #[doc = "Ignores the failure of this task. The rest of the workflow will be executed Assuming this task succeeded."]
        Ignore,
        #[doc = "The task will be retried from the failed task onwards after a fixed delay that linearly increases with each retry attempt. A jitter is added to each exponential interval so that concurrently failing tasks of the same type do not end up retrying after the exact same exponential interval. A max-retry count is required to be specified with this strategy. Max_num_retries and interval_in_seconds must be specified."]
        LinearBackoff,
        #[doc = "Causes a permanent failure of the task. However, if the last task(s) of event was successfully completed despite the failure of this task, it has no impact on the workflow."]
        None,
        #[doc = "The entire workflow will be restarted with the initial parameters that were set when the event was fired. A max-retry count is required to be specified with this strategy. `max_num_retries` and `interval_in_seconds` must be specified."]
        RestartWorkflowWithBackoff,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy :: ExponentialBackoff => "EXPONENTIAL_BACKOFF" , EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy :: Fatal => "FATAL" , EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy :: FixedInterval => "FIXED_INTERVAL" , EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy :: Ignore => "IGNORE" , EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy :: LinearBackoff => "LINEAR_BACKOFF" , EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy :: None => "NONE" , EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy :: RestartWorkflowWithBackoff => "RESTART_WORKFLOW_WITH_BACKOFF" , EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy :: Unspecified => "UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy, ()>
        {
            Ok(match s {
                "EXPONENTIAL_BACKOFF" => {
                    EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::ExponentialBackoff
                }
                "FATAL" => EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::Fatal,
                "FIXED_INTERVAL" => {
                    EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::FixedInterval
                }
                "IGNORE" => EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::Ignore,
                "LINEAR_BACKOFF" => {
                    EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::LinearBackoff
                }
                "NONE" => EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::None,
                "RESTART_WORKFLOW_WITH_BACKOFF" => {
                    EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::RestartWorkflowWithBackoff
                }
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EXPONENTIAL_BACKOFF" => {
                    EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::ExponentialBackoff
                }
                "FATAL" => EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::Fatal,
                "FIXED_INTERVAL" => {
                    EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::FixedInterval
                }
                "IGNORE" => EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::Ignore,
                "LINEAR_BACKOFF" => {
                    EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::LinearBackoff
                }
                "NONE" => EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::None,
                "RESTART_WORKFLOW_WITH_BACKOFF" => {
                    EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::RestartWorkflowWithBackoff
                }
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoFailurePolicyRetryStrategy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoField {
        #[doc = "By default, if the cardinality is unspecified the field is considered required while mapping."]
        #[serde(
            rename = "cardinality",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cardinality:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoFieldCardinality>,
        #[doc = "This holds the default values for the fields. This value is supplied by user so may or may not contain PII or SPII data."]
        #[serde(
            rename = "defaultValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_value:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterValueType>,
        #[doc = "Specifies the data type of the field."]
        #[serde(
            rename = "fieldType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub field_type:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoFieldFieldType>,
        #[doc = "Optional. The fully qualified proto name (e.g. enterprise.crm.storage.Account). Required for output field of type PROTO_VALUE or PROTO_ARRAY. For e.g., if input field_type is BYTES and output field_type is PROTO_VALUE, then fully qualified proto type url should be provided to parse the input bytes. If field_type is \\*\\_ARRAY, then all the converted protos are of the same type."]
        #[serde(
            rename = "protoDefPath",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_def_path: ::std::option::Option<String>,
        #[doc = "This holds the reference key of the workflow or task parameter. 1. Any workflow parameter, for e.g. $workflowParam1$. 2. Any task input or output parameter, for e.g. $task1_param1$. 3. Any workflow or task parameters with subfield references, for e.g., $task1_param1.employee.id$"]
        #[serde(
            rename = "referenceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reference_key: ::std::option::Option<String>,
        #[doc = "This is the transform expression to fetch the input field value. for e.g. $param1$.CONCAT(â€˜testâ€™). Keep points - 1. Only input field can have a transform expression. 2. If a transform expression is provided, reference_key will be ignored. 3. If no value is returned after evaluation of transform expression, default_value can be mapped if provided. 4. The field_type should be the type of the final object returned after the transform expression is evaluated. Scrubs the transform expression before logging as value provided by user so may or may not contain PII or SPII data."]
        #[serde(
            rename = "transformExpression",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transform_expression:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoTransformExpression>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoField {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoField {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoFieldCardinality {
        #[doc = "If field cardinality is set to optional, ignore errors if input field value is null or the reference_key is not found."]
        Optional,
        #[doc = "For fields with unspecified cardinality."]
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoFieldCardinality {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoFieldCardinality::Optional => "OPTIONAL",
                EnterpriseCrmEventbusProtoFieldCardinality::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoFieldCardinality {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoFieldCardinality {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoFieldCardinality, ()> {
            Ok(match s {
                "OPTIONAL" => EnterpriseCrmEventbusProtoFieldCardinality::Optional,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoFieldCardinality::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoFieldCardinality {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoFieldCardinality {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoFieldCardinality {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "OPTIONAL" => EnterpriseCrmEventbusProtoFieldCardinality::Optional,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoFieldCardinality::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoFieldCardinality {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoFieldCardinality {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoFieldFieldType {
        BooleanArray,
        BooleanValue,
        #[doc = "BYTES and BYTES_ARRAY data types are not allowed for top-level params. Theyâ€™re only meant to support protobufs with BYTES (sub)fields."]
        Bytes,
        BytesArray,
        DataTypeUnspecified,
        DoubleArray,
        DoubleValue,
        IntArray,
        IntValue,
        JsonValue,
        NonSerializableObject,
        ProtoArray,
        ProtoEnum,
        ProtoEnumArray,
        ProtoValue,
        SerializedObjectValue,
        StringArray,
        StringValue,
    }
    impl EnterpriseCrmEventbusProtoFieldFieldType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoFieldFieldType::BooleanArray => "BOOLEAN_ARRAY",
                EnterpriseCrmEventbusProtoFieldFieldType::BooleanValue => "BOOLEAN_VALUE",
                EnterpriseCrmEventbusProtoFieldFieldType::Bytes => "BYTES",
                EnterpriseCrmEventbusProtoFieldFieldType::BytesArray => "BYTES_ARRAY",
                EnterpriseCrmEventbusProtoFieldFieldType::DataTypeUnspecified => {
                    "DATA_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoFieldFieldType::DoubleArray => "DOUBLE_ARRAY",
                EnterpriseCrmEventbusProtoFieldFieldType::DoubleValue => "DOUBLE_VALUE",
                EnterpriseCrmEventbusProtoFieldFieldType::IntArray => "INT_ARRAY",
                EnterpriseCrmEventbusProtoFieldFieldType::IntValue => "INT_VALUE",
                EnterpriseCrmEventbusProtoFieldFieldType::JsonValue => "JSON_VALUE",
                EnterpriseCrmEventbusProtoFieldFieldType::NonSerializableObject => {
                    "NON_SERIALIZABLE_OBJECT"
                }
                EnterpriseCrmEventbusProtoFieldFieldType::ProtoArray => "PROTO_ARRAY",
                EnterpriseCrmEventbusProtoFieldFieldType::ProtoEnum => "PROTO_ENUM",
                EnterpriseCrmEventbusProtoFieldFieldType::ProtoEnumArray => "PROTO_ENUM_ARRAY",
                EnterpriseCrmEventbusProtoFieldFieldType::ProtoValue => "PROTO_VALUE",
                EnterpriseCrmEventbusProtoFieldFieldType::SerializedObjectValue => {
                    "SERIALIZED_OBJECT_VALUE"
                }
                EnterpriseCrmEventbusProtoFieldFieldType::StringArray => "STRING_ARRAY",
                EnterpriseCrmEventbusProtoFieldFieldType::StringValue => "STRING_VALUE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoFieldFieldType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoFieldFieldType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoFieldFieldType, ()> {
            Ok(match s {
                "BOOLEAN_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::BooleanArray,
                "BOOLEAN_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::BooleanValue,
                "BYTES" => EnterpriseCrmEventbusProtoFieldFieldType::Bytes,
                "BYTES_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::BytesArray,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoFieldFieldType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::DoubleArray,
                "DOUBLE_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::DoubleValue,
                "INT_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::IntArray,
                "INT_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::IntValue,
                "JSON_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmEventbusProtoFieldFieldType::NonSerializableObject
                }
                "PROTO_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::ProtoArray,
                "PROTO_ENUM" => EnterpriseCrmEventbusProtoFieldFieldType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::ProtoEnumArray,
                "PROTO_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::ProtoValue,
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmEventbusProtoFieldFieldType::SerializedObjectValue
                }
                "STRING_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::StringArray,
                "STRING_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::StringValue,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoFieldFieldType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoFieldFieldType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoFieldFieldType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOOLEAN_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::BooleanArray,
                "BOOLEAN_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::BooleanValue,
                "BYTES" => EnterpriseCrmEventbusProtoFieldFieldType::Bytes,
                "BYTES_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::BytesArray,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoFieldFieldType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::DoubleArray,
                "DOUBLE_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::DoubleValue,
                "INT_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::IntArray,
                "INT_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::IntValue,
                "JSON_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmEventbusProtoFieldFieldType::NonSerializableObject
                }
                "PROTO_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::ProtoArray,
                "PROTO_ENUM" => EnterpriseCrmEventbusProtoFieldFieldType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::ProtoEnumArray,
                "PROTO_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::ProtoValue,
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmEventbusProtoFieldFieldType::SerializedObjectValue
                }
                "STRING_ARRAY" => EnterpriseCrmEventbusProtoFieldFieldType::StringArray,
                "STRING_VALUE" => EnterpriseCrmEventbusProtoFieldFieldType::StringValue,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoFieldFieldType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoFieldFieldType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoFieldMappingConfig {
        #[serde(
            rename = "mappedFields",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mapped_fields:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoMappedField>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoFieldMappingConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoFieldMappingConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoFunction {
        #[doc = "The name of the function to perform."]
        #[serde(
            rename = "functionType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_type:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoFunctionType>,
        #[doc = "List of parameters required for the transformation."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmEventbusProtoTransformExpression>,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoFunctionType {
        #[doc = "LINT.IfChange"]
        #[serde(
            rename = "baseFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub base_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoBaseFunction>,
        #[serde(
            rename = "booleanArrayFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_array_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoBooleanArrayFunction>,
        #[serde(
            rename = "booleanFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoBooleanFunction>,
        #[serde(
            rename = "doubleArrayFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_array_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoDoubleArrayFunction>,
        #[serde(
            rename = "doubleFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoDoubleFunction>,
        #[serde(
            rename = "intArrayFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_array_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoIntArrayFunction>,
        #[serde(
            rename = "intFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoIntFunction>,
        #[doc = "LINT.ThenChange(//depot/google3/alkali/apps/integrationplatform/client/workflow_editor/utils/transform_function.ts)"]
        #[serde(
            rename = "jsonFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub json_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoJsonFunction>,
        #[serde(
            rename = "protoArrayFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_array_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoProtoArrayFunction>,
        #[serde(
            rename = "protoFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoProtoFunction>,
        #[serde(
            rename = "stringArrayFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_array_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoStringArrayFunction>,
        #[serde(
            rename = "stringFunction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_function:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoStringFunction>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoFunctionType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoFunctionType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoIntArray {
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<i64>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoIntArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoIntArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoIntArrayFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoIntArrayFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoIntArrayFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName {
        Append,
        AppendAll,
        Avg,
        Contains,
        Filter,
        ForEach,
        Get,
        Max,
        Min,
        Remove,
        RemoveAt,
        Set,
        Size,
        Sum,
        ToJson,
        ToSet,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Append => "APPEND",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::AppendAll => "APPEND_ALL",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Avg => "AVG",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Contains => "CONTAINS",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Filter => "FILTER",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ForEach => "FOR_EACH",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Get => "GET",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Max => "MAX",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Min => "MIN",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Remove => "REMOVE",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::RemoveAt => "REMOVE_AT",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Set => "SET",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Size => "SIZE",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Sum => "SUM",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ToSet => "TO_SET",
                EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Unspecified => {
                    "UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName, ()>
        {
            Ok(match s {
                "APPEND" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Append,
                "APPEND_ALL" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::AppendAll,
                "AVG" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Avg,
                "CONTAINS" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Get,
                "MAX" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Max,
                "MIN" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Min,
                "REMOVE" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Size,
                "SUM" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Sum,
                "TO_JSON" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Unspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APPEND" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Append,
                "APPEND_ALL" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::AppendAll,
                "AVG" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Avg,
                "CONTAINS" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Get,
                "MAX" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Max,
                "MIN" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Min,
                "REMOVE" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Size,
                "SUM" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Sum,
                "TO_JSON" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName::Unspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoIntArrayFunctionFunctionName
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoIntFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoIntFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoIntFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoIntFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        Add,
        Divide,
        EpochToHumanReadableTime,
        Equals,
        Exponent,
        GreaterThan,
        GreaterThanEqualTo,
        LessThan,
        LessThanEqualTo,
        Mod,
        Multiply,
        Subtract,
        ToDouble,
        ToJson,
        ToString,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::Add => "ADD",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::Divide => "DIVIDE",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::EpochToHumanReadableTime => {
                    "EPOCH_TO_HUMAN_READABLE_TIME"
                }
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::Equals => "EQUALS",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::Exponent => "EXPONENT",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::GreaterThan => "GREATER_THAN",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::GreaterThanEqualTo => {
                    "GREATER_THAN_EQUAL_TO"
                }
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::LessThan => "LESS_THAN",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::LessThanEqualTo => {
                    "LESS_THAN_EQUAL_TO"
                }
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::Mod => "MOD",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::Multiply => "MULTIPLY",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::Subtract => "SUBTRACT",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToDouble => "TO_DOUBLE",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToString => "TO_STRING",
                EnterpriseCrmEventbusProtoIntFunctionFunctionName::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoIntFunctionFunctionName, ()> {
            Ok(match s {
                "ADD" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Add,
                "DIVIDE" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Divide,
                "EPOCH_TO_HUMAN_READABLE_TIME" => {
                    EnterpriseCrmEventbusProtoIntFunctionFunctionName::EpochToHumanReadableTime
                }
                "EQUALS" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Equals,
                "EXPONENT" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Exponent,
                "GREATER_THAN" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::GreaterThan,
                "GREATER_THAN_EQUAL_TO" => {
                    EnterpriseCrmEventbusProtoIntFunctionFunctionName::GreaterThanEqualTo
                }
                "LESS_THAN" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::LessThan,
                "LESS_THAN_EQUAL_TO" => {
                    EnterpriseCrmEventbusProtoIntFunctionFunctionName::LessThanEqualTo
                }
                "MOD" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Mod,
                "MULTIPLY" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Multiply,
                "SUBTRACT" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Subtract,
                "TO_DOUBLE" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToDouble,
                "TO_JSON" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToJson,
                "TO_STRING" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToString,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ADD" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Add,
                "DIVIDE" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Divide,
                "EPOCH_TO_HUMAN_READABLE_TIME" => {
                    EnterpriseCrmEventbusProtoIntFunctionFunctionName::EpochToHumanReadableTime
                }
                "EQUALS" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Equals,
                "EXPONENT" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Exponent,
                "GREATER_THAN" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::GreaterThan,
                "GREATER_THAN_EQUAL_TO" => {
                    EnterpriseCrmEventbusProtoIntFunctionFunctionName::GreaterThanEqualTo
                }
                "LESS_THAN" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::LessThan,
                "LESS_THAN_EQUAL_TO" => {
                    EnterpriseCrmEventbusProtoIntFunctionFunctionName::LessThanEqualTo
                }
                "MOD" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Mod,
                "MULTIPLY" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Multiply,
                "SUBTRACT" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Subtract,
                "TO_DOUBLE" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToDouble,
                "TO_JSON" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToJson,
                "TO_STRING" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::ToString,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoIntFunctionFunctionName::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoIntFunctionFunctionName {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoIntParameterArray {
        #[serde(
            rename = "intValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_values: ::std::option::Option<Vec<i64>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoIntParameterArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoIntParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoJsonFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoJsonFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoJsonFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoJsonFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        AppendElement,
        Equals,
        #[doc = "next id: 24"]
        FilterElements,
        Flatten,
        FlattenOnce,
        ForEach,
        GetElement,
        GetProperty,
        Merge,
        RemoveProperty,
        ResolveTemplate,
        SetProperty,
        Size,
        ToBoolean,
        ToBooleanArray,
        ToDouble,
        ToDoubleArray,
        ToInt,
        ToIntArray,
        ToProto,
        ToProtoArray,
        ToString,
        ToStringArray,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::AppendElement => {
                    "APPEND_ELEMENT"
                }
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Equals => "EQUALS",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::FilterElements => {
                    "FILTER_ELEMENTS"
                }
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Flatten => "FLATTEN",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::FlattenOnce => "FLATTEN_ONCE",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ForEach => "FOR_EACH",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::GetElement => "GET_ELEMENT",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::GetProperty => "GET_PROPERTY",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Merge => "MERGE",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::RemoveProperty => {
                    "REMOVE_PROPERTY"
                }
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ResolveTemplate => {
                    "RESOLVE_TEMPLATE"
                }
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::SetProperty => "SET_PROPERTY",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Size => "SIZE",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToBoolean => "TO_BOOLEAN",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToBooleanArray => {
                    "TO_BOOLEAN_ARRAY"
                }
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToDouble => "TO_DOUBLE",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToDoubleArray => {
                    "TO_DOUBLE_ARRAY"
                }
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToInt => "TO_INT",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToIntArray => "TO_INT_ARRAY",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToProto => "TO_PROTO",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToProtoArray => {
                    "TO_PROTO_ARRAY"
                }
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToString => "TO_STRING",
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToStringArray => {
                    "TO_STRING_ARRAY"
                }
                EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoJsonFunctionFunctionName, ()> {
            Ok(match s {
                "APPEND_ELEMENT" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::AppendElement
                }
                "EQUALS" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Equals,
                "FILTER_ELEMENTS" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::FilterElements
                }
                "FLATTEN" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Flatten,
                "FLATTEN_ONCE" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::FlattenOnce,
                "FOR_EACH" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ForEach,
                "GET_ELEMENT" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::GetElement,
                "GET_PROPERTY" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::GetProperty,
                "MERGE" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Merge,
                "REMOVE_PROPERTY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::RemoveProperty
                }
                "RESOLVE_TEMPLATE" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ResolveTemplate
                }
                "SET_PROPERTY" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::SetProperty,
                "SIZE" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Size,
                "TO_BOOLEAN" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToBoolean,
                "TO_BOOLEAN_ARRAY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToBooleanArray
                }
                "TO_DOUBLE" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToDouble,
                "TO_DOUBLE_ARRAY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToDoubleArray
                }
                "TO_INT" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToInt,
                "TO_INT_ARRAY" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToIntArray,
                "TO_PROTO" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToProto,
                "TO_PROTO_ARRAY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToProtoArray
                }
                "TO_STRING" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToString,
                "TO_STRING_ARRAY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToStringArray
                }
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APPEND_ELEMENT" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::AppendElement
                }
                "EQUALS" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Equals,
                "FILTER_ELEMENTS" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::FilterElements
                }
                "FLATTEN" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Flatten,
                "FLATTEN_ONCE" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::FlattenOnce,
                "FOR_EACH" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ForEach,
                "GET_ELEMENT" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::GetElement,
                "GET_PROPERTY" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::GetProperty,
                "MERGE" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Merge,
                "REMOVE_PROPERTY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::RemoveProperty
                }
                "RESOLVE_TEMPLATE" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ResolveTemplate
                }
                "SET_PROPERTY" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::SetProperty,
                "SIZE" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Size,
                "TO_BOOLEAN" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToBoolean,
                "TO_BOOLEAN_ARRAY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToBooleanArray
                }
                "TO_DOUBLE" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToDouble,
                "TO_DOUBLE_ARRAY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToDoubleArray
                }
                "TO_INT" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToInt,
                "TO_INT_ARRAY" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToIntArray,
                "TO_PROTO" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToProto,
                "TO_PROTO_ARRAY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToProtoArray
                }
                "TO_STRING" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToString,
                "TO_STRING_ARRAY" => {
                    EnterpriseCrmEventbusProtoJsonFunctionFunctionName::ToStringArray
                }
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoJsonFunctionFunctionName::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoJsonFunctionFunctionName {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoLogSettings {
        #[doc = "The name of corresponding logging field of the event property. If omitted, assumes the same name as the event property key."]
        #[serde(
            rename = "logFieldName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_field_name: ::std::option::Option<String>,
        #[doc = "Contains the scrubbing options, such as whether to scrub, obfuscate, etc."]
        #[serde(
            rename = "sanitizeOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sanitize_options:
            ::std::option::Option<crate::schemas::EnterpriseCrmLoggingGwsSanitizeOptions>,
        #[serde(
            rename = "seedPeriod",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub seed_period:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoLogSettingsSeedPeriod>,
        #[serde(
            rename = "seedScope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub seed_scope:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoLogSettingsSeedScope>,
        #[doc = "Contains the field limits for shortening, such as max string length and max array length."]
        #[serde(
            rename = "shorteningLimits",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shortening_limits:
            ::std::option::Option<crate::schemas::EnterpriseCrmLoggingGwsFieldLimits>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoLogSettings {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoLogSettings {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        #[doc = "Sanitized values remain constant for the day of the event."]
        Day,
        #[doc = "Sanitized values remain constant for the month of the event."]
        Month,
        SeedPeriodUnspecified,
        #[doc = "Sanitized values remain constant for the week of the event; may cross month boundaries."]
        Week,
    }
    impl EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Day => "DAY",
                EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Month => "MONTH",
                EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::SeedPeriodUnspecified => {
                    "SEED_PERIOD_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Week => "WEEK",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoLogSettingsSeedPeriod, ()> {
            Ok(match s {
                "DAY" => EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Day,
                "MONTH" => EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Month,
                "SEED_PERIOD_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::SeedPeriodUnspecified
                }
                "WEEK" => EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Week,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DAY" => EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Day,
                "MONTH" => EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Month,
                "SEED_PERIOD_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::SeedPeriodUnspecified
                }
                "WEEK" => EnterpriseCrmEventbusProtoLogSettingsSeedPeriod::Week,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoLogSettingsSeedPeriod {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        #[doc = "Hash computations include the event name."]
        EventName,
        #[doc = "Hash computations include the param name."]
        ParamName,
        SeedScopeUnspecified,
        #[doc = "Hash computations include a time period."]
        TimePeriod,
    }
    impl EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoLogSettingsSeedScope::EventName => "EVENT_NAME",
                EnterpriseCrmEventbusProtoLogSettingsSeedScope::ParamName => "PARAM_NAME",
                EnterpriseCrmEventbusProtoLogSettingsSeedScope::SeedScopeUnspecified => {
                    "SEED_SCOPE_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoLogSettingsSeedScope::TimePeriod => "TIME_PERIOD",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoLogSettingsSeedScope, ()> {
            Ok(match s {
                "EVENT_NAME" => EnterpriseCrmEventbusProtoLogSettingsSeedScope::EventName,
                "PARAM_NAME" => EnterpriseCrmEventbusProtoLogSettingsSeedScope::ParamName,
                "SEED_SCOPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoLogSettingsSeedScope::SeedScopeUnspecified
                }
                "TIME_PERIOD" => EnterpriseCrmEventbusProtoLogSettingsSeedScope::TimePeriod,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EVENT_NAME" => EnterpriseCrmEventbusProtoLogSettingsSeedScope::EventName,
                "PARAM_NAME" => EnterpriseCrmEventbusProtoLogSettingsSeedScope::ParamName,
                "SEED_SCOPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoLogSettingsSeedScope::SeedScopeUnspecified
                }
                "TIME_PERIOD" => EnterpriseCrmEventbusProtoLogSettingsSeedScope::TimePeriod,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoLogSettingsSeedScope {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoLoopMetadata {
        #[doc = "Starting from 1, not 0."]
        #[serde(
            rename = "currentIterationCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub current_iteration_count: ::std::option::Option<i64>,
        #[doc = "Needs to be set by the loop impl class before each iteration. The abstract loop class will append the request and response to it. Eg. The foreach Loop will clean up and set it as the current iteration element at the start of each loop. The post request and response will be appended to the value once they are available."]
        #[serde(
            rename = "currentIterationDetail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub current_iteration_detail: ::std::option::Option<String>,
        #[doc = "Add the error message when loops fail."]
        #[serde(
            rename = "errorMsg",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_msg: ::std::option::Option<String>,
        #[doc = "Indicates where in the loop logic did it error out."]
        #[serde(
            rename = "failureLocation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub failure_location: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoLoopMetadataFailureLocation,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoLoopMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoLoopMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoLoopMetadataFailureLocation {
        #[doc = "Building the iteration request"]
        BuildingRequest,
        #[doc = "Evaluating the while loop condition."]
        ConditionEvaluation,
        #[doc = "Getting the list to iterate."]
        GettingListToIterate,
        #[doc = "Param aggregation failed."]
        ParamAggregating,
        #[doc = "Param overrides failed."]
        ParamOverriding,
        #[doc = "Setting for loop current element failed."]
        SettingIterationElement,
        #[doc = "Subworkflow failed while firing/running."]
        Subworkflow,
        #[doc = "No error or Unknown."]
        Unknown,
    }
    impl EnterpriseCrmEventbusProtoLoopMetadataFailureLocation {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::BuildingRequest => {
                    "BUILDING_REQUEST"
                }
                EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ConditionEvaluation => {
                    "CONDITION_EVALUATION"
                }
                EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::GettingListToIterate => {
                    "GETTING_LIST_TO_ITERATE"
                }
                EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ParamAggregating => {
                    "PARAM_AGGREGATING"
                }
                EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ParamOverriding => {
                    "PARAM_OVERRIDING"
                }
                EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::SettingIterationElement => {
                    "SETTING_ITERATION_ELEMENT"
                }
                EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::Subworkflow => "SUBWORKFLOW",
                EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoLoopMetadataFailureLocation {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoLoopMetadataFailureLocation {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoLoopMetadataFailureLocation, ()>
        {
            Ok(match s {
                "BUILDING_REQUEST" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::BuildingRequest
                }
                "CONDITION_EVALUATION" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ConditionEvaluation
                }
                "GETTING_LIST_TO_ITERATE" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::GettingListToIterate
                }
                "PARAM_AGGREGATING" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ParamAggregating
                }
                "PARAM_OVERRIDING" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ParamOverriding
                }
                "SETTING_ITERATION_ELEMENT" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::SettingIterationElement
                }
                "SUBWORKFLOW" => EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::Subworkflow,
                "UNKNOWN" => EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoLoopMetadataFailureLocation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoLoopMetadataFailureLocation {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoLoopMetadataFailureLocation {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BUILDING_REQUEST" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::BuildingRequest
                }
                "CONDITION_EVALUATION" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ConditionEvaluation
                }
                "GETTING_LIST_TO_ITERATE" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::GettingListToIterate
                }
                "PARAM_AGGREGATING" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ParamAggregating
                }
                "PARAM_OVERRIDING" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::ParamOverriding
                }
                "SETTING_ITERATION_ELEMENT" => {
                    EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::SettingIterationElement
                }
                "SUBWORKFLOW" => EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::Subworkflow,
                "UNKNOWN" => EnterpriseCrmEventbusProtoLoopMetadataFailureLocation::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoLoopMetadataFailureLocation
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoLoopMetadataFailureLocation
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoMappedField {
        #[doc = "The input field being mapped from."]
        #[serde(
            rename = "inputField",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_field: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoField>,
        #[doc = "The output field being mapped to."]
        #[serde(
            rename = "outputField",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_field: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoField>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoMappedField {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoMappedField {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoNextTask {
        #[doc = "Combined condition for this task to become an eligible next task. Each of these combined_conditions are joined with logical OR. DEPRECATED: use `condition`"]
        #[serde(
            rename = "combinedConditions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub combined_conditions:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoCombinedCondition>>,
        #[doc = "Standard filter expression for this task to become an eligible next task."]
        #[serde(
            rename = "condition",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub condition: ::std::option::Option<String>,
        #[doc = "User-provided description intended to give more business context about the next task edge or condition."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "User-provided label that is attached to this edge in the UI."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "ID of the next task."]
        #[serde(
            rename = "taskConfigId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_config_id: ::std::option::Option<String>,
        #[doc = "Task number of the next task."]
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoNextTask {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoNextTask {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoNextTeardownTask {
        #[doc = "Required. Name of the next teardown task."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoNextTeardownTask {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoNextTeardownTask {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoNodeIdentifier {
        #[doc = "Configuration of the edge."]
        #[serde(
            rename = "elementIdentifier",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub element_identifier: ::std::option::Option<String>,
        #[doc = "Destination node where the edge ends. It can only be a task config."]
        #[serde(
            rename = "elementType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub element_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoNodeIdentifierElementType,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoNodeIdentifier {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoNodeIdentifier {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoNodeIdentifierElementType {
        TaskConfig,
        TriggerConfig,
        UnknownType,
    }
    impl EnterpriseCrmEventbusProtoNodeIdentifierElementType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoNodeIdentifierElementType::TaskConfig => "TASK_CONFIG",
                EnterpriseCrmEventbusProtoNodeIdentifierElementType::TriggerConfig => {
                    "TRIGGER_CONFIG"
                }
                EnterpriseCrmEventbusProtoNodeIdentifierElementType::UnknownType => "UNKNOWN_TYPE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoNodeIdentifierElementType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoNodeIdentifierElementType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoNodeIdentifierElementType, ()>
        {
            Ok(match s {
                "TASK_CONFIG" => EnterpriseCrmEventbusProtoNodeIdentifierElementType::TaskConfig,
                "TRIGGER_CONFIG" => {
                    EnterpriseCrmEventbusProtoNodeIdentifierElementType::TriggerConfig
                }
                "UNKNOWN_TYPE" => EnterpriseCrmEventbusProtoNodeIdentifierElementType::UnknownType,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoNodeIdentifierElementType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoNodeIdentifierElementType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoNodeIdentifierElementType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "TASK_CONFIG" => EnterpriseCrmEventbusProtoNodeIdentifierElementType::TaskConfig,
                "TRIGGER_CONFIG" => {
                    EnterpriseCrmEventbusProtoNodeIdentifierElementType::TriggerConfig
                }
                "UNKNOWN_TYPE" => EnterpriseCrmEventbusProtoNodeIdentifierElementType::UnknownType,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoNodeIdentifierElementType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoNodeIdentifierElementType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoNotification {
        #[serde(
            rename = "buganizerNotification",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub buganizer_notification:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoBuganizerNotification>,
        #[serde(
            rename = "emailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email_address: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoAddress>,
        #[serde(
            rename = "escalatorQueue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub escalator_queue: ::std::option::Option<String>,
        #[serde(
            rename = "pubsubTopic",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pubsub_topic: ::std::option::Option<String>,
        #[doc = "If the out-of-the-box email/pubsub notifications are not suitable and custom logic is required, fire a workflow containing all info needed to notify users to resume execution."]
        #[serde(
            rename = "request",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoCustomSuspensionRequest,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoNotification {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoNotification {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoParamSpecEntryConfig {
        #[doc = "A short phrase to describe what this parameter contains."]
        #[serde(
            rename = "descriptivePhrase",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub descriptive_phrase: ::std::option::Option<String>,
        #[doc = "Detailed help text for this parameter containing information not provided elsewhere. For example, instructions on how to migrate from a deprecated parameter."]
        #[serde(
            rename = "helpText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub help_text: ::std::option::Option<String>,
        #[doc = "Whether the default value is hidden in the UI."]
        #[serde(
            rename = "hideDefaultValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hide_default_value: ::std::option::Option<bool>,
        #[serde(
            rename = "inputDisplayOption",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_display_option: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption,
        >,
        #[doc = "Whether this field is hidden in the UI."]
        #[serde(
            rename = "isHidden",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_hidden: ::std::option::Option<bool>,
        #[doc = "A user-friendly label for the parameter."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[serde(
            rename = "parameterNameOption",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameter_name_option: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption,
        >,
        #[doc = "A user-friendly label for subSection under which the parameter will be displayed."]
        #[serde(
            rename = "subSectionLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sub_section_label: ::std::option::Option<String>,
        #[doc = "Placeholder text which will appear in the UI input form for this parameter."]
        #[serde(
            rename = "uiPlaceholderText",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ui_placeholder_text: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoParamSpecEntryConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoParamSpecEntryConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption {
        #[doc = "A toggle button for boolean parameters."]
        BooleanToggle,
        #[doc = "A single-line input for strings, a numeric input box for numbers, or a checkbox for booleans."]
        Default,
        #[doc = "A slider to select a numerical value. The default range is \\[0, 100\\]."]
        NumberSlider,
        #[doc = "A multi-line input box for longer strings/string templates."]
        StringMultiLine,
    }
    impl EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: BooleanToggle => "BOOLEAN_TOGGLE" , EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: Default => "DEFAULT" , EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: NumberSlider => "NUMBER_SLIDER" , EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: StringMultiLine => "STRING_MULTI_LINE" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption,
            (),
        > {
            Ok (match s { "BOOLEAN_TOGGLE" => EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: BooleanToggle , "DEFAULT" => EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: Default , "NUMBER_SLIDER" => EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: NumberSlider , "STRING_MULTI_LINE" => EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: StringMultiLine , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "BOOLEAN_TOGGLE" => EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: BooleanToggle , "DEFAULT" => EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: Default , "NUMBER_SLIDER" => EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: NumberSlider , "STRING_MULTI_LINE" => EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption :: StringMultiLine , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoParamSpecEntryConfigInputDisplayOption
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption {
        #[doc = "This field is not a parameter name."]
        DefaultNotParameterName,
        #[doc = "If this field is a string and this option is selected, the field will be interpreted as a parameter name. Users will be able to choose a variable using the autocomplete, but the name will be stored as a literal string."]
        IsParameterName,
        #[doc = "If this field is a ParameterMap and this option is selected, the mapâ€™s keys will be interpreted as parameter names. Ignored if this field is not a ParameterMap."]
        KeyIsParameterName,
        #[doc = "If this field is a ParameterMap and this option is selected, the mapâ€™s values will be interpreted as parameter names. Ignored if this field is not a ParameterMap."]
        ValueIsParameterName,
    }
    impl EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: DefaultNotParameterName => "DEFAULT_NOT_PARAMETER_NAME" , EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: IsParameterName => "IS_PARAMETER_NAME" , EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: KeyIsParameterName => "KEY_IS_PARAMETER_NAME" , EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: ValueIsParameterName => "VALUE_IS_PARAMETER_NAME" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption,
            (),
        > {
            Ok (match s { "DEFAULT_NOT_PARAMETER_NAME" => EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: DefaultNotParameterName , "IS_PARAMETER_NAME" => EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: IsParameterName , "KEY_IS_PARAMETER_NAME" => EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: KeyIsParameterName , "VALUE_IS_PARAMETER_NAME" => EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: ValueIsParameterName , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEFAULT_NOT_PARAMETER_NAME" => EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: DefaultNotParameterName , "IS_PARAMETER_NAME" => EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: IsParameterName , "KEY_IS_PARAMETER_NAME" => EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: KeyIsParameterName , "VALUE_IS_PARAMETER_NAME" => EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption :: ValueIsParameterName , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoParamSpecEntryConfigParameterNameOption
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoParamSpecEntryProtoDefinition {
        #[doc = "The fully-qualified proto name. This message, for example, would be â€œenterprise.crm.eventbus.proto.ParamSpecEntry.ProtoDefinitionâ€."]
        #[serde(
            rename = "fullName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub full_name: ::std::option::Option<String>,
        #[doc = "Path to the proto file that contains the message typeâ€™s definition."]
        #[serde(
            rename = "path",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub path: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoParamSpecEntryProtoDefinition
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoParamSpecEntryProtoDefinition
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoParamSpecEntryValidationRule {
        #[serde(
            rename = "doubleRange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_range: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleDoubleRange,
        >,
        #[serde(
            rename = "intRange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_range: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleIntRange,
        >,
        #[serde(
            rename = "stringRegex",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_regex: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleStringRegex,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoParamSpecEntryValidationRule
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoParamSpecEntryValidationRule
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleDoubleRange {
        #[doc = "The inclusive maximum of the acceptable range."]
        #[serde(
            rename = "max",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max: ::std::option::Option<f64>,
        #[doc = "The inclusive minimum of the acceptable range."]
        #[serde(
            rename = "min",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub min: ::std::option::Option<f64>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleDoubleRange
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleDoubleRange
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleIntRange {
        #[doc = "The inclusive maximum of the acceptable range."]
        #[serde(
            rename = "max",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub max: ::std::option::Option<i64>,
        #[doc = "The inclusive minimum of the acceptable range."]
        #[serde(
            rename = "min",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub min: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleIntRange
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleIntRange
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleStringRegex {
        #[doc = "Whether the regex matcher is applied exclusively (if true, matching values will be rejected)."]
        #[serde(
            rename = "exclusive",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub exclusive: ::std::option::Option<bool>,
        #[doc = "The regex applied to the input value(s)."]
        #[serde(
            rename = "regex",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub regex: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleStringRegex
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoParamSpecEntryValidationRuleStringRegex
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoParameterEntry {
        #[doc = "Key is used to retrieve the corresponding parameter value. This should be unique for a given fired event. These parameters must be predefined in the integration definition."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "Values for the defined keys. Each value can either be string, int, double or any proto message."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterValueType>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoParameterEntry {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoParameterEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoParameterMap {
        #[serde(
            rename = "entries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub entries:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoParameterMapEntry>>,
        #[doc = "Option to specify key value type for all entries of the map. If provided then field types for all entries must conform to this."]
        #[serde(
            rename = "keyType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key_type:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterMapKeyType>,
        #[serde(
            rename = "valueType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value_type:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterMapValueType>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoParameterMap {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoParameterMap {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoParameterMapKeyType {
        BooleanArray,
        BooleanValue,
        #[doc = "BYTES and BYTES_ARRAY data types are not allowed for top-level params. Theyâ€™re only meant to support protobufs with BYTES (sub)fields."]
        Bytes,
        BytesArray,
        DataTypeUnspecified,
        DoubleArray,
        DoubleValue,
        IntArray,
        IntValue,
        JsonValue,
        NonSerializableObject,
        ProtoArray,
        ProtoEnum,
        ProtoEnumArray,
        ProtoValue,
        SerializedObjectValue,
        StringArray,
        StringValue,
    }
    impl EnterpriseCrmEventbusProtoParameterMapKeyType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoParameterMapKeyType::BooleanArray => "BOOLEAN_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapKeyType::BooleanValue => "BOOLEAN_VALUE",
                EnterpriseCrmEventbusProtoParameterMapKeyType::Bytes => "BYTES",
                EnterpriseCrmEventbusProtoParameterMapKeyType::BytesArray => "BYTES_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapKeyType::DataTypeUnspecified => {
                    "DATA_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoParameterMapKeyType::DoubleArray => "DOUBLE_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapKeyType::DoubleValue => "DOUBLE_VALUE",
                EnterpriseCrmEventbusProtoParameterMapKeyType::IntArray => "INT_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapKeyType::IntValue => "INT_VALUE",
                EnterpriseCrmEventbusProtoParameterMapKeyType::JsonValue => "JSON_VALUE",
                EnterpriseCrmEventbusProtoParameterMapKeyType::NonSerializableObject => {
                    "NON_SERIALIZABLE_OBJECT"
                }
                EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoArray => "PROTO_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoEnum => "PROTO_ENUM",
                EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoEnumArray => "PROTO_ENUM_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoValue => "PROTO_VALUE",
                EnterpriseCrmEventbusProtoParameterMapKeyType::SerializedObjectValue => {
                    "SERIALIZED_OBJECT_VALUE"
                }
                EnterpriseCrmEventbusProtoParameterMapKeyType::StringArray => "STRING_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapKeyType::StringValue => "STRING_VALUE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoParameterMapKeyType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoParameterMapKeyType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoParameterMapKeyType, ()> {
            Ok(match s {
                "BOOLEAN_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::BooleanArray,
                "BOOLEAN_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::BooleanValue,
                "BYTES" => EnterpriseCrmEventbusProtoParameterMapKeyType::Bytes,
                "BYTES_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::BytesArray,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoParameterMapKeyType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::DoubleArray,
                "DOUBLE_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::DoubleValue,
                "INT_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::IntArray,
                "INT_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::IntValue,
                "JSON_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmEventbusProtoParameterMapKeyType::NonSerializableObject
                }
                "PROTO_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoArray,
                "PROTO_ENUM" => EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoEnumArray,
                "PROTO_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoValue,
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmEventbusProtoParameterMapKeyType::SerializedObjectValue
                }
                "STRING_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::StringArray,
                "STRING_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::StringValue,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoParameterMapKeyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoParameterMapKeyType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoParameterMapKeyType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOOLEAN_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::BooleanArray,
                "BOOLEAN_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::BooleanValue,
                "BYTES" => EnterpriseCrmEventbusProtoParameterMapKeyType::Bytes,
                "BYTES_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::BytesArray,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoParameterMapKeyType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::DoubleArray,
                "DOUBLE_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::DoubleValue,
                "INT_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::IntArray,
                "INT_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::IntValue,
                "JSON_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmEventbusProtoParameterMapKeyType::NonSerializableObject
                }
                "PROTO_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoArray,
                "PROTO_ENUM" => EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoEnumArray,
                "PROTO_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::ProtoValue,
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmEventbusProtoParameterMapKeyType::SerializedObjectValue
                }
                "STRING_ARRAY" => EnterpriseCrmEventbusProtoParameterMapKeyType::StringArray,
                "STRING_VALUE" => EnterpriseCrmEventbusProtoParameterMapKeyType::StringValue,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoParameterMapKeyType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoParameterMapKeyType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoParameterMapValueType {
        BooleanArray,
        BooleanValue,
        #[doc = "BYTES and BYTES_ARRAY data types are not allowed for top-level params. Theyâ€™re only meant to support protobufs with BYTES (sub)fields."]
        Bytes,
        BytesArray,
        DataTypeUnspecified,
        DoubleArray,
        DoubleValue,
        IntArray,
        IntValue,
        JsonValue,
        NonSerializableObject,
        ProtoArray,
        ProtoEnum,
        ProtoEnumArray,
        ProtoValue,
        SerializedObjectValue,
        StringArray,
        StringValue,
    }
    impl EnterpriseCrmEventbusProtoParameterMapValueType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoParameterMapValueType::BooleanArray => "BOOLEAN_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapValueType::BooleanValue => "BOOLEAN_VALUE",
                EnterpriseCrmEventbusProtoParameterMapValueType::Bytes => "BYTES",
                EnterpriseCrmEventbusProtoParameterMapValueType::BytesArray => "BYTES_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapValueType::DataTypeUnspecified => {
                    "DATA_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoParameterMapValueType::DoubleArray => "DOUBLE_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapValueType::DoubleValue => "DOUBLE_VALUE",
                EnterpriseCrmEventbusProtoParameterMapValueType::IntArray => "INT_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapValueType::IntValue => "INT_VALUE",
                EnterpriseCrmEventbusProtoParameterMapValueType::JsonValue => "JSON_VALUE",
                EnterpriseCrmEventbusProtoParameterMapValueType::NonSerializableObject => {
                    "NON_SERIALIZABLE_OBJECT"
                }
                EnterpriseCrmEventbusProtoParameterMapValueType::ProtoArray => "PROTO_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapValueType::ProtoEnum => "PROTO_ENUM",
                EnterpriseCrmEventbusProtoParameterMapValueType::ProtoEnumArray => {
                    "PROTO_ENUM_ARRAY"
                }
                EnterpriseCrmEventbusProtoParameterMapValueType::ProtoValue => "PROTO_VALUE",
                EnterpriseCrmEventbusProtoParameterMapValueType::SerializedObjectValue => {
                    "SERIALIZED_OBJECT_VALUE"
                }
                EnterpriseCrmEventbusProtoParameterMapValueType::StringArray => "STRING_ARRAY",
                EnterpriseCrmEventbusProtoParameterMapValueType::StringValue => "STRING_VALUE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoParameterMapValueType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoParameterMapValueType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoParameterMapValueType, ()> {
            Ok(match s {
                "BOOLEAN_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::BooleanArray,
                "BOOLEAN_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::BooleanValue,
                "BYTES" => EnterpriseCrmEventbusProtoParameterMapValueType::Bytes,
                "BYTES_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::BytesArray,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoParameterMapValueType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::DoubleArray,
                "DOUBLE_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::DoubleValue,
                "INT_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::IntArray,
                "INT_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::IntValue,
                "JSON_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmEventbusProtoParameterMapValueType::NonSerializableObject
                }
                "PROTO_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::ProtoArray,
                "PROTO_ENUM" => EnterpriseCrmEventbusProtoParameterMapValueType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmEventbusProtoParameterMapValueType::ProtoEnumArray
                }
                "PROTO_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::ProtoValue,
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmEventbusProtoParameterMapValueType::SerializedObjectValue
                }
                "STRING_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::StringArray,
                "STRING_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::StringValue,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoParameterMapValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoParameterMapValueType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoParameterMapValueType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOOLEAN_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::BooleanArray,
                "BOOLEAN_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::BooleanValue,
                "BYTES" => EnterpriseCrmEventbusProtoParameterMapValueType::Bytes,
                "BYTES_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::BytesArray,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoParameterMapValueType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::DoubleArray,
                "DOUBLE_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::DoubleValue,
                "INT_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::IntArray,
                "INT_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::IntValue,
                "JSON_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmEventbusProtoParameterMapValueType::NonSerializableObject
                }
                "PROTO_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::ProtoArray,
                "PROTO_ENUM" => EnterpriseCrmEventbusProtoParameterMapValueType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmEventbusProtoParameterMapValueType::ProtoEnumArray
                }
                "PROTO_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::ProtoValue,
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmEventbusProtoParameterMapValueType::SerializedObjectValue
                }
                "STRING_ARRAY" => EnterpriseCrmEventbusProtoParameterMapValueType::StringArray,
                "STRING_VALUE" => EnterpriseCrmEventbusProtoParameterMapValueType::StringValue,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoParameterMapValueType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoParameterMapValueType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoParameterMapEntry {
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterMapField>,
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterMapField>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoParameterMapEntry {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoParameterMapEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoParameterMapField {
        #[doc = "Passing a literal value."]
        #[serde(
            rename = "literalValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub literal_value:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterValueType>,
        #[doc = "Referencing one of the WF variables."]
        #[serde(
            rename = "referenceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reference_key: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoParameterMapField {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoParameterMapField {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoParameterValueType {
        #[serde(
            rename = "booleanArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_array:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoBooleanParameterArray>,
        #[serde(
            rename = "booleanValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_value: ::std::option::Option<bool>,
        #[serde(
            rename = "doubleArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_array:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoDoubleParameterArray>,
        #[serde(
            rename = "doubleValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_value: ::std::option::Option<f64>,
        #[serde(
            rename = "intArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_array:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoIntParameterArray>,
        #[serde(
            rename = "intValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub int_value: ::std::option::Option<i64>,
        #[serde(
            rename = "protoArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_array:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoProtoParameterArray>,
        #[serde(
            rename = "protoValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_value:
            ::std::option::Option<::std::collections::BTreeMap<String, ::serde_json::Value>>,
        #[serde(
            rename = "serializedObjectValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub serialized_object_value: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoSerializedObjectParameter,
        >,
        #[serde(
            rename = "stringArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_array:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoStringParameterArray>,
        #[serde(
            rename = "stringValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoParameterValueType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoParameterValueType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoPropertyEntry {
        #[doc = "Key is used to retrieve the corresponding property value. This should be unique for a given fired event. The Tasks should be aware of the keys used while firing the events for them to be able to retrieve the values."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "Values for the defined keys. Each value can either be string, int, double or any proto message."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoValueType>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoPropertyEntry {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoPropertyEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoProtoArrayFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoProtoArrayFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoProtoArrayFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName {
        Append,
        AppendAll,
        Contains,
        Filter,
        ForEach,
        Get,
        Remove,
        RemoveAt,
        Set,
        Size,
        ToJson,
        ToSet,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Append => "APPEND",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::AppendAll => "APPEND_ALL",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Contains => "CONTAINS",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Filter => "FILTER",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ForEach => "FOR_EACH",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Get => "GET",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Remove => "REMOVE",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::RemoveAt => "REMOVE_AT",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Set => "SET",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Size => "SIZE",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ToSet => "TO_SET",
                EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Unspecified => {
                    "UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName, ()>
        {
            Ok(match s {
                "APPEND" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Append,
                "APPEND_ALL" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::AppendAll,
                "CONTAINS" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Get,
                "REMOVE" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Size,
                "TO_JSON" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Unspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APPEND" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Append,
                "APPEND_ALL" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::AppendAll,
                "CONTAINS" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Get,
                "REMOVE" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Size,
                "TO_JSON" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName::Unspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoProtoArrayFunctionFunctionName
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoProtoFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoProtoFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoProtoFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoProtoFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoProtoFunctionFunctionName {
        Equals,
        GetBooleanArraySubfield,
        GetBooleanSubfield,
        GetBytesSubfieldAsProto,
        GetBytesSubfieldAsUtf8String,
        GetDoubleArraySubfield,
        GetDoubleSubfield,
        GetIntArraySubfield,
        GetIntSubfield,
        GetProtoArraySubfield,
        GetProtoSubfield,
        GetStringArraySubfield,
        GetStringSubfield,
        ToJson,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoProtoFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: Equals => "EQUALS" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBooleanArraySubfield => "GET_BOOLEAN_ARRAY_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBooleanSubfield => "GET_BOOLEAN_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBytesSubfieldAsProto => "GET_BYTES_SUBFIELD_AS_PROTO" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBytesSubfieldAsUtf8String => "GET_BYTES_SUBFIELD_AS_UTF_8_STRING" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetDoubleArraySubfield => "GET_DOUBLE_ARRAY_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetDoubleSubfield => "GET_DOUBLE_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetIntArraySubfield => "GET_INT_ARRAY_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetIntSubfield => "GET_INT_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetProtoArraySubfield => "GET_PROTO_ARRAY_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetProtoSubfield => "GET_PROTO_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetStringArraySubfield => "GET_STRING_ARRAY_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetStringSubfield => "GET_STRING_SUBFIELD" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: ToJson => "TO_JSON" , EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: Unspecified => "UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoProtoFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoProtoFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoProtoFunctionFunctionName, ()>
        {
            Ok (match s { "EQUALS" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: Equals , "GET_BOOLEAN_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBooleanArraySubfield , "GET_BOOLEAN_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBooleanSubfield , "GET_BYTES_SUBFIELD_AS_PROTO" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBytesSubfieldAsProto , "GET_BYTES_SUBFIELD_AS_UTF_8_STRING" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBytesSubfieldAsUtf8String , "GET_DOUBLE_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetDoubleArraySubfield , "GET_DOUBLE_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetDoubleSubfield , "GET_INT_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetIntArraySubfield , "GET_INT_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetIntSubfield , "GET_PROTO_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetProtoArraySubfield , "GET_PROTO_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetProtoSubfield , "GET_STRING_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetStringArraySubfield , "GET_STRING_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetStringSubfield , "TO_JSON" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: ToJson , "UNSPECIFIED" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: Unspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoProtoFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoProtoFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoProtoFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "EQUALS" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: Equals , "GET_BOOLEAN_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBooleanArraySubfield , "GET_BOOLEAN_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBooleanSubfield , "GET_BYTES_SUBFIELD_AS_PROTO" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBytesSubfieldAsProto , "GET_BYTES_SUBFIELD_AS_UTF_8_STRING" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetBytesSubfieldAsUtf8String , "GET_DOUBLE_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetDoubleArraySubfield , "GET_DOUBLE_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetDoubleSubfield , "GET_INT_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetIntArraySubfield , "GET_INT_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetIntSubfield , "GET_PROTO_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetProtoArraySubfield , "GET_PROTO_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetProtoSubfield , "GET_STRING_ARRAY_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetStringArraySubfield , "GET_STRING_SUBFIELD" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: GetStringSubfield , "TO_JSON" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: ToJson , "UNSPECIFIED" => EnterpriseCrmEventbusProtoProtoFunctionFunctionName :: Unspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoProtoFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoProtoFunctionFunctionName {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoProtoParameterArray {
        #[serde(
            rename = "protoValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_values:
            ::std::option::Option<Vec<::std::collections::BTreeMap<String, ::serde_json::Value>>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoProtoParameterArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoProtoParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoScatterResponse {
        #[doc = "The error message of the failure if applicable."]
        #[serde(
            rename = "errorMsg",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_msg: ::std::option::Option<String>,
        #[doc = "The execution ids of each Subworkflow fired by this scatter."]
        #[serde(
            rename = "executionIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_ids: ::std::option::Option<Vec<String>>,
        #[doc = "If execution is sync, this is true if the execution passed and false if it failed. If the execution is async, this is true if the WF was fired off successfully, and false if it failed to execute. The success or failure of the subworkflows executed are not captured."]
        #[serde(
            rename = "isSuccessful",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_successful: ::std::option::Option<bool>,
        #[doc = "A list of all the response parameters in the aggregtorMap stored with the remapped key."]
        #[serde(
            rename = "responseParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub response_params:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoParameterEntry>>,
        #[doc = "The element that was scattered for this execution."]
        #[serde(
            rename = "scatterElement",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scatter_element:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParameterValueType>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoScatterResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoScatterResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoSerializedObjectParameter {
        #[serde(
            rename = "objectValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_value: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoSerializedObjectParameter
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoSerializedObjectParameter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoStringArray {
        #[serde(
            rename = "values",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoStringArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoStringArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoStringArrayFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoStringArrayFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoStringArrayFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName {
        Append,
        AppendAll,
        Contains,
        Filter,
        ForEach,
        Get,
        Remove,
        RemoveAt,
        Set,
        Size,
        ToJson,
        ToSet,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Append => "APPEND",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::AppendAll => {
                    "APPEND_ALL"
                }
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Contains => "CONTAINS",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Filter => "FILTER",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ForEach => "FOR_EACH",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Get => "GET",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Remove => "REMOVE",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::RemoveAt => "REMOVE_AT",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Set => "SET",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Size => "SIZE",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ToSet => "TO_SET",
                EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Unspecified => {
                    "UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName, ()>
        {
            Ok(match s {
                "APPEND" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Append,
                "APPEND_ALL" => {
                    EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::AppendAll
                }
                "CONTAINS" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Get,
                "REMOVE" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Size,
                "TO_JSON" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Unspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APPEND" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Append,
                "APPEND_ALL" => {
                    EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::AppendAll
                }
                "CONTAINS" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Contains,
                "FILTER" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Filter,
                "FOR_EACH" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ForEach,
                "GET" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Get,
                "REMOVE" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Remove,
                "REMOVE_AT" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::RemoveAt,
                "SET" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Set,
                "SIZE" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Size,
                "TO_JSON" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ToJson,
                "TO_SET" => EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::ToSet,
                "UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName::Unspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoStringArrayFunctionFunctionName
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoStringFunction {
        #[serde(
            rename = "functionName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub function_name: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoStringFunctionFunctionName,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoStringFunction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoStringFunction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoStringFunctionFunctionName {
        Concat,
        Contains,
        Equals,
        EqualsIgnoreCase,
        Length,
        ReplaceAll,
        ResolveTemplate,
        Split,
        Substring,
        ToBase64,
        ToBoolean,
        ToDouble,
        ToInt,
        ToJson,
        ToLowercase,
        ToUppercase,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoStringFunctionFunctionName {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::Concat => "CONCAT",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::Contains => "CONTAINS",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::Equals => "EQUALS",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::EqualsIgnoreCase => {
                    "EQUALS_IGNORE_CASE"
                }
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::Length => "LENGTH",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ReplaceAll => "REPLACE_ALL",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ResolveTemplate => {
                    "RESOLVE_TEMPLATE"
                }
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::Split => "SPLIT",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::Substring => "SUBSTRING",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToBase64 => "TO_BASE_64",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToBoolean => "TO_BOOLEAN",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToDouble => "TO_DOUBLE",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToInt => "TO_INT",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToJson => "TO_JSON",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToLowercase => "TO_LOWERCASE",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToUppercase => "TO_UPPERCASE",
                EnterpriseCrmEventbusProtoStringFunctionFunctionName::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoStringFunctionFunctionName {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoStringFunctionFunctionName {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoStringFunctionFunctionName, ()>
        {
            Ok(match s {
                "CONCAT" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Concat,
                "CONTAINS" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Contains,
                "EQUALS" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Equals,
                "EQUALS_IGNORE_CASE" => {
                    EnterpriseCrmEventbusProtoStringFunctionFunctionName::EqualsIgnoreCase
                }
                "LENGTH" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Length,
                "REPLACE_ALL" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ReplaceAll,
                "RESOLVE_TEMPLATE" => {
                    EnterpriseCrmEventbusProtoStringFunctionFunctionName::ResolveTemplate
                }
                "SPLIT" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Split,
                "SUBSTRING" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Substring,
                "TO_BASE_64" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToBase64,
                "TO_BOOLEAN" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToBoolean,
                "TO_DOUBLE" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToDouble,
                "TO_INT" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToInt,
                "TO_JSON" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToJson,
                "TO_LOWERCASE" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToLowercase,
                "TO_UPPERCASE" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToUppercase,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoStringFunctionFunctionName {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoStringFunctionFunctionName {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoStringFunctionFunctionName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CONCAT" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Concat,
                "CONTAINS" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Contains,
                "EQUALS" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Equals,
                "EQUALS_IGNORE_CASE" => {
                    EnterpriseCrmEventbusProtoStringFunctionFunctionName::EqualsIgnoreCase
                }
                "LENGTH" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Length,
                "REPLACE_ALL" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ReplaceAll,
                "RESOLVE_TEMPLATE" => {
                    EnterpriseCrmEventbusProtoStringFunctionFunctionName::ResolveTemplate
                }
                "SPLIT" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Split,
                "SUBSTRING" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Substring,
                "TO_BASE_64" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToBase64,
                "TO_BOOLEAN" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToBoolean,
                "TO_DOUBLE" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToDouble,
                "TO_INT" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToInt,
                "TO_JSON" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToJson,
                "TO_LOWERCASE" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToLowercase,
                "TO_UPPERCASE" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::ToUppercase,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoStringFunctionFunctionName::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoStringFunctionFunctionName
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoStringFunctionFunctionName {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoStringParameterArray {
        #[serde(
            rename = "stringValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoStringParameterArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoStringParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoSuccessPolicy {
        #[doc = "State to which the execution snapshot status will be set if the task succeeds."]
        #[serde(
            rename = "finalState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub final_state: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoSuccessPolicyFinalState,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoSuccessPolicy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoSuccessPolicy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        #[doc = "The default behavior, where successful tasks will be marked as SUCCEEDED."]
        Succeeded,
        #[doc = "Sets the state to SUSPENDED after executing. This is required for SuspensionTask; event execution will continue once the user calls ResolveSuspensions with the event_execution_info_id and the task number."]
        Suspended,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Succeeded => "SUCCEEDED",
                EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Suspended => "SUSPENDED",
                EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoSuccessPolicyFinalState, ()> {
            Ok(match s {
                "SUCCEEDED" => EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Succeeded,
                "SUSPENDED" => EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Suspended,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "SUCCEEDED" => EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Succeeded,
                "SUSPENDED" => EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Suspended,
                "UNSPECIFIED" => EnterpriseCrmEventbusProtoSuccessPolicyFinalState::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoSuccessPolicyFinalState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoSuspensionAuthPermissions {
        #[doc = "Represents a Gaia identity for a person or service account."]
        #[serde(
            rename = "gaiaIdentity",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gaia_identity: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoSuspensionAuthPermissionsGaiaIdentity,
        >,
        #[serde(
            rename = "googleGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub google_group: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoSuspensionAuthPermissionsGaiaIdentity,
        >,
        #[serde(
            rename = "loasRole",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub loas_role: ::std::option::Option<String>,
        #[serde(
            rename = "mdbGroup",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mdb_group: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoSuspensionAuthPermissions
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoSuspensionAuthPermissions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoSuspensionAuthPermissionsGaiaIdentity {
        #[serde(
            rename = "emailAddress",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email_address: ::std::option::Option<String>,
        #[serde(
            rename = "gaiaId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub gaia_id: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoSuspensionAuthPermissionsGaiaIdentity
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoSuspensionAuthPermissionsGaiaIdentity
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoSuspensionConfig {
        #[doc = "Optional information to provide recipients of the suspension in addition to the resolution URL, typically containing relevant parameter values from the originating workflow."]
        #[serde(
            rename = "customMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub custom_message: ::std::option::Option<String>,
        #[serde(
            rename = "notifications",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub notifications:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoNotification>>,
        #[doc = "Indicates the next steps when no external actions happen on the suspension."]
        #[serde(
            rename = "suspensionExpiration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspension_expiration:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoSuspensionExpiration>,
        #[doc = "Identities able to resolve this suspension."]
        #[serde(
            rename = "whoMayResolve",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub who_may_resolve: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmEventbusProtoSuspensionAuthPermissions>,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoSuspensionConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoSuspensionConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoSuspensionExpiration {
        #[doc = "Milliseconds after which the suspension expires, if no action taken."]
        #[serde(
            rename = "expireAfterMs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub expire_after_ms: ::std::option::Option<i32>,
        #[doc = "Whether the suspension will be REJECTED or LIFTED upon expiration. REJECTED is the default behavior."]
        #[serde(
            rename = "liftWhenExpired",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lift_when_expired: ::std::option::Option<bool>,
        #[doc = "Milliseconds after which the previous suspension action reminder, if any, is sent using the selected notification option, for a suspension which is still PENDING_UNSPECIFIED."]
        #[serde(
            rename = "remindAfterMs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub remind_after_ms: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoSuspensionExpiration {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoSuspensionExpiration {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoSuspensionResolutionInfo {
        #[serde(
            rename = "audit",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub audit: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoSuspensionResolutionInfoAudit,
        >,
        #[doc = "Auto-generated."]
        #[serde(
            rename = "createdTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub created_timestamp: ::std::option::Option<String>,
        #[doc = "Required. ID of the associated execution."]
        #[serde(
            rename = "eventExecutionInfoId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_execution_info_id: ::std::option::Option<String>,
        #[doc = "The origin of the suspension for periodic notifications."]
        #[serde(
            rename = "externalTraffic",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub external_traffic:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoExternalTraffic>,
        #[doc = "Auto-generated."]
        #[serde(
            rename = "lastModifiedTimestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_modified_timestamp: ::std::option::Option<String>,
        #[doc = "Which Google product the suspension belongs to. If not set, the suspension belongs to Integration Platform by default."]
        #[serde(
            rename = "product",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub product: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct,
        >,
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus,
        >,
        #[serde(
            rename = "suspensionConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspension_config:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoSuspensionConfig>,
        #[doc = "Primary key for the SuspensionResolutionInfoTable."]
        #[serde(
            rename = "suspensionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspension_id: ::std::option::Option<String>,
        #[doc = "Required. Task number of the associated SuspensionTask."]
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<String>,
        #[doc = "Required. The name of the originating workflow."]
        #[serde(
            rename = "workflowName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub workflow_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoSuspensionResolutionInfo {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoSuspensionResolutionInfo {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct {
        Apigee,
        Ip,
        Security,
        UnspecifiedProduct,
    }
    impl EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Apigee => "APIGEE",
                EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Ip => "IP",
                EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Security => "SECURITY",
                EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::UnspecifiedProduct => {
                    "UNSPECIFIED_PRODUCT"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct, ()>
        {
            Ok(match s {
                "APIGEE" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Apigee,
                "IP" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Ip,
                "SECURITY" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Security,
                "UNSPECIFIED_PRODUCT" => {
                    EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::UnspecifiedProduct
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APIGEE" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Apigee,
                "IP" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Ip,
                "SECURITY" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::Security,
                "UNSPECIFIED_PRODUCT" => {
                    EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct::UnspecifiedProduct
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoSuspensionResolutionInfoProduct
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus {
        Lifted,
        PendingUnspecified,
        Rejected,
    }
    impl EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::Lifted => "LIFTED",
                EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::PendingUnspecified => {
                    "PENDING_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::Rejected => "REJECTED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus, ()>
        {
            Ok(match s {
                "LIFTED" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::Lifted,
                "PENDING_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::PendingUnspecified
                }
                "REJECTED" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::Rejected,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "LIFTED" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::Lifted,
                "PENDING_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::PendingUnspecified
                }
                "REJECTED" => EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus::Rejected,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoSuspensionResolutionInfoStatus
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoSuspensionResolutionInfoAudit {
        #[serde(
            rename = "resolvedBy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resolved_by: ::std::option::Option<String>,
        #[serde(
            rename = "resolvedByCpi",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resolved_by_cpi: ::std::option::Option<String>,
        #[serde(
            rename = "timestamp",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub timestamp: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoSuspensionResolutionInfoAudit
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoSuspensionResolutionInfoAudit
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoTaskAlertConfig {
        #[doc = "The period over which the metric value should be aggregated and evaluated. Format is , where integer should be a positive integer and unit should be one of (s,m,h,d,w) meaning (second, minute, hour, day, week)."]
        #[serde(
            rename = "aggregationPeriod",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub aggregation_period: ::std::option::Option<String>,
        #[doc = "Set to false by default. When set to true, the metrics are not aggregated or pushed to Monarch for this workflow alert."]
        #[serde(
            rename = "alertDisabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alert_disabled: ::std::option::Option<bool>,
        #[doc = "A name to identify this alert. This will be displayed in the alert subject. If set, this name should be unique in within the scope of the containing workflow."]
        #[serde(
            rename = "alertName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alert_name: ::std::option::Option<String>,
        #[doc = "Client associated with this alert configuration. Must be a client enabled in one of the containing workflowâ€™s triggers."]
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "Should be specified only for TASK_AVERAGE_DURATION and TASK_PERCENTILE_DURATION metrics. This member should be used to specify what duration value the metrics should exceed for the alert to trigger."]
        #[serde(
            rename = "durationThresholdMs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub duration_threshold_ms: ::std::option::Option<i64>,
        #[serde(
            rename = "errorEnumList",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_enum_list: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumList,
        >,
        #[serde(
            rename = "metricType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metric_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoTaskAlertConfigMetricType,
        >,
        #[doc = "For how many contiguous aggregation periods should the expected min or max be violated for the alert to be fired."]
        #[serde(
            rename = "numAggregationPeriods",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_aggregation_periods: ::std::option::Option<i32>,
        #[doc = "Only count final task attempts, not retries."]
        #[serde(
            rename = "onlyFinalAttempt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub only_final_attempt: ::std::option::Option<bool>,
        #[doc = "Link to a playbook for resolving the issue that triggered this alert."]
        #[serde(
            rename = "playbookUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub playbook_url: ::std::option::Option<String>,
        #[doc = "The threshold type for which this alert is being configured. If value falls below expected_min or exceeds expected_max, an alert will be fired."]
        #[serde(
            rename = "thresholdType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub threshold_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType,
        >,
        #[doc = "The metric value, above or below which the alert should be triggered."]
        #[serde(
            rename = "thresholdValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub threshold_value: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBaseAlertConfigThresholdValue,
        >,
        #[serde(
            rename = "warningEnumList",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub warning_enum_list: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumList,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskAlertConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskAlertConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskAlertConfigMetricType {
        #[doc = "The default value. Metric type should always be set to one of the other non-default values, otherwise it will result in an INVALID_ARGUMENT error."]
        MetricTypeUnspecified,
        #[doc = "Specifies alerting on the average duration of execution for the enclosing task."]
        TaskAverageDuration,
        #[doc = "Specifies alerting on the rate of errors (potentially for a specific set of enum values) for the enclosing TaskConfig."]
        TaskErrorRate,
        #[doc = "Specifies alerting on the duration of a particular percentile of task executions. E.g. If 10% or more of the task executions have durations above 5 seconds, alert."]
        TaskPercentileDuration,
        #[doc = "Specifies alerting on the number of instances for the enclosing TaskConfig executed in the given aggregation_period."]
        TaskRate,
        #[doc = "Specifies alerting on the rate of warnings (potentially for a specific set of enum values) for the enclosing TaskConfig. Warnings use the same enum values as errors."]
        TaskWarningRate,
    }
    impl EnterpriseCrmEventbusProtoTaskAlertConfigMetricType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::MetricTypeUnspecified => {
                    "METRIC_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskAverageDuration => {
                    "TASK_AVERAGE_DURATION"
                }
                EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskErrorRate => {
                    "TASK_ERROR_RATE"
                }
                EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskPercentileDuration => {
                    "TASK_PERCENTILE_DURATION"
                }
                EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskRate => "TASK_RATE",
                EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskWarningRate => {
                    "TASK_WARNING_RATE"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoTaskAlertConfigMetricType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskAlertConfigMetricType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoTaskAlertConfigMetricType, ()>
        {
            Ok(match s {
                "METRIC_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::MetricTypeUnspecified
                }
                "TASK_AVERAGE_DURATION" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskAverageDuration
                }
                "TASK_ERROR_RATE" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskErrorRate
                }
                "TASK_PERCENTILE_DURATION" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskPercentileDuration
                }
                "TASK_RATE" => EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskRate,
                "TASK_WARNING_RATE" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskWarningRate
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskAlertConfigMetricType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskAlertConfigMetricType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoTaskAlertConfigMetricType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "METRIC_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::MetricTypeUnspecified
                }
                "TASK_AVERAGE_DURATION" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskAverageDuration
                }
                "TASK_ERROR_RATE" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskErrorRate
                }
                "TASK_PERCENTILE_DURATION" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskPercentileDuration
                }
                "TASK_RATE" => EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskRate,
                "TASK_WARNING_RATE" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigMetricType::TaskWarningRate
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoTaskAlertConfigMetricType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskAlertConfigMetricType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType {
        ExpectedMax,
        #[doc = "Note that this field will only trigger alerts if the workflow specifying it runs at least once in 24 hours (which is our in-memory retention period for monarch streams). Also note that `aggregation_period` for this alert configuration must be less than 24 hours."]
        ExpectedMin,
        UnspecifiedThresholdType,
    }
    impl EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType :: ExpectedMax => "EXPECTED_MAX" , EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType :: ExpectedMin => "EXPECTED_MIN" , EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType :: UnspecifiedThresholdType => "UNSPECIFIED_THRESHOLD_TYPE" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType, ()>
        {
            Ok(match s {
                "EXPECTED_MAX" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType::ExpectedMax
                }
                "EXPECTED_MIN" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType::ExpectedMin
                }
                "UNSPECIFIED_THRESHOLD_TYPE" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType::UnspecifiedThresholdType
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EXPECTED_MAX" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType::ExpectedMax
                }
                "EXPECTED_MIN" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType::ExpectedMin
                }
                "UNSPECIFIED_THRESHOLD_TYPE" => {
                    EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType::UnspecifiedThresholdType
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoTaskAlertConfigThresholdType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoTaskExecutionDetails {
        #[serde(
            rename = "taskAttemptStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_attempt_stats: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskAttemptStats>,
        >,
        #[serde(
            rename = "taskExecutionState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_execution_state: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState,
        >,
        #[doc = "Pointer to the task config it used for execution."]
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskExecutionDetails {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskExecutionDetails {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState {
        #[doc = "Task execution canceled when in progress. This happens when event execution been canceled or any other task fall in fatal state."]
        Canceled,
        #[doc = "Task execution failed. Thereâ€™s no more change after this state."]
        Failed,
        #[doc = "Task execution failed and cause the whole event execution to fail immediately. Thereâ€™s no more change after this state."]
        Fatal,
        #[doc = "Task is under processing."]
        InProcess,
        #[doc = "Task is waiting for its precondition tasks to finish to start the execution."]
        PendingExecution,
        #[doc = "Task is waiting for its dependency tasksâ€™ rollback to finish to start its rollback."]
        PendingRollback,
        #[doc = "Task execution failed and waiting for retry."]
        RetryOnHold,
        #[doc = "Task is rolling back."]
        RollbackInProcess,
        #[doc = "Task is rolled back. This is the state we will set regardless of rollback succeeding or failing."]
        Rolledback,
        #[doc = "Task execution skipped. This happens when its precondition wasnâ€™t met, or the event execution been canceled before reach to the task. Thereâ€™s no more changes after this state."]
        Skipped,
        #[doc = "Task execution successfully finished. Thereâ€™s no more change after this state."]
        Succeed,
        #[doc = "Task is a SuspensionTask which has executed once, creating a pending suspension."]
        Suspended,
        Unspecified,
    }
    impl EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Canceled => "CANCELED" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Failed => "FAILED" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Fatal => "FATAL" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: InProcess => "IN_PROCESS" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: PendingExecution => "PENDING_EXECUTION" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: PendingRollback => "PENDING_ROLLBACK" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: RetryOnHold => "RETRY_ON_HOLD" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: RollbackInProcess => "ROLLBACK_IN_PROCESS" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Rolledback => "ROLLEDBACK" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Skipped => "SKIPPED" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Succeed => "SUCCEED" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Suspended => "SUSPENDED" , EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Unspecified => "UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState,
            (),
        > {
            Ok (match s { "CANCELED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Canceled , "FAILED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Failed , "FATAL" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Fatal , "IN_PROCESS" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: InProcess , "PENDING_EXECUTION" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: PendingExecution , "PENDING_ROLLBACK" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: PendingRollback , "RETRY_ON_HOLD" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: RetryOnHold , "ROLLBACK_IN_PROCESS" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: RollbackInProcess , "ROLLEDBACK" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Rolledback , "SKIPPED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Skipped , "SUCCEED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Succeed , "SUSPENDED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Suspended , "UNSPECIFIED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Unspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "CANCELED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Canceled , "FAILED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Failed , "FATAL" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Fatal , "IN_PROCESS" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: InProcess , "PENDING_EXECUTION" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: PendingExecution , "PENDING_ROLLBACK" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: PendingRollback , "RETRY_ON_HOLD" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: RetryOnHold , "ROLLBACK_IN_PROCESS" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: RollbackInProcess , "ROLLEDBACK" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Rolledback , "SKIPPED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Skipped , "SUCCEED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Succeed , "SUSPENDED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Suspended , "UNSPECIFIED" => EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState :: Unspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskExecutionState
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskAttemptStats {
        #[doc = "The end time of the task execution for current attempt."]
        #[serde(
            rename = "endTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub end_time: ::std::option::Option<i64>,
        #[doc = "The start time of the task execution for current attempt. This could be in the future if itâ€™s been scheduled."]
        #[serde(
            rename = "startTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub start_time: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskAttemptStats
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoTaskExecutionDetailsTaskAttemptStats
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoTaskMetadata {
        #[doc = "The new task name to replace the current task if it is deprecated. Otherwise, it is the same as the current task name."]
        #[serde(
            rename = "activeTaskName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub active_task_name: ::std::option::Option<String>,
        #[serde(
            rename = "admins",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub admins:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoTaskMetadataAdmin>>,
        #[serde(
            rename = "category",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub category:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoTaskMetadataCategory>,
        #[doc = "The Code Search link to the Task Java file."]
        #[serde(
            rename = "codeSearchLink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub code_search_link: ::std::option::Option<String>,
        #[doc = "Controls whether JSON workflow parameters are validated against provided schemas before and/or after this taskâ€™s execution."]
        #[serde(
            rename = "defaultJsonValidationOption",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_json_validation_option: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption,
        >,
        #[doc = "Contains the initial configuration of the task with default values set. For now, The string should be compatible to an ASCII-proto format."]
        #[serde(
            rename = "defaultSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_spec: ::std::option::Option<String>,
        #[doc = "In a few sentences, describe the purpose and usage of the task."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "The string name to show on the task list on the Workflow editor screen. This should be a very short, one to two words name for the task. (e.g. â€œSend Mailâ€)"]
        #[serde(
            rename = "descriptiveName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub descriptive_name: ::std::option::Option<String>,
        #[doc = "Snippet of markdown documentation to embed in the RHP for this task."]
        #[serde(
            rename = "docMarkdown",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub doc_markdown: ::std::option::Option<String>,
        #[serde(
            rename = "externalCategory",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub external_category: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoTaskMetadataExternalCategory,
        >,
        #[doc = "Sequence with which the task in specific category to be displayed in task discovery panel for external users."]
        #[serde(
            rename = "externalCategorySequence",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub external_category_sequence: ::std::option::Option<i32>,
        #[doc = "External-facing documention embedded in the RHP for this task."]
        #[serde(
            rename = "externalDocHtml",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub external_doc_html: ::std::option::Option<String>,
        #[doc = "Doc link for external-facing documentation (separate from g3doc)."]
        #[serde(
            rename = "externalDocLink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub external_doc_link: ::std::option::Option<String>,
        #[doc = "DEPRECATED: Use external_doc_html."]
        #[serde(
            rename = "externalDocMarkdown",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub external_doc_markdown: ::std::option::Option<String>,
        #[doc = "URL to the associated G3 Doc for the task if available"]
        #[serde(
            rename = "g3DocLink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub g_3_doc_link: ::std::option::Option<String>,
        #[doc = "URL to gstatic image icon for this task. This icon shows up on the task list panel along with the task name in the Workflow Editor screen. Use the 24p, 2x, gray color icon image format."]
        #[serde(
            rename = "iconLink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub icon_link: ::std::option::Option<String>,
        #[doc = "The deprecation status of the current task. Default value is false;"]
        #[serde(
            rename = "isDeprecated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_deprecated: ::std::option::Option<bool>,
        #[doc = "The actual class name or the annotated name of the task. Task Author should initialize this field with value from the getName() method of the Task class."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "External-facing documention for standalone IP in pantheon embedded in the RHP for this task. Non null only if different from external_doc_html"]
        #[serde(
            rename = "standaloneExternalDocHtml",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub standalone_external_doc_html: ::std::option::Option<String>,
        #[doc = "Allows author to indicate if the task is ready to use or not. If not set, then it will default to INACTIVE."]
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoTaskMetadataStatus>,
        #[serde(
            rename = "system",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub system:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoTaskMetadataSystem>,
        #[doc = "A set of tags that pertain to a particular task. This can be used to improve the searchability of tasks with several names (â€œREST Callerâ€ vs. â€œCall REST Endpointâ€) or to help users find tasks based on related words."]
        #[serde(
            rename = "tags",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tags: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskMetadataCategory {
        #[doc = "Tasks that are relevant to cloud systems teams and typically"]
        CloudSystems,
        Connector,
        Custom,
        #[doc = "include connecting to Vector salesforce, CRM Hub Spanner etc. Task entities that derive from a custom task template."]
        CustomTaskTemplate,
        DataManipulation,
        FlowControl,
        #[doc = "Internal IP tasks that should not be available in the UI."]
        Hidden,
        Scripting,
        UnspecifiedCategory,
    }
    impl EnterpriseCrmEventbusProtoTaskMetadataCategory {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoTaskMetadataCategory::CloudSystems => "CLOUD_SYSTEMS",
                EnterpriseCrmEventbusProtoTaskMetadataCategory::Connector => "CONNECTOR",
                EnterpriseCrmEventbusProtoTaskMetadataCategory::Custom => "CUSTOM",
                EnterpriseCrmEventbusProtoTaskMetadataCategory::CustomTaskTemplate => {
                    "CUSTOM_TASK_TEMPLATE"
                }
                EnterpriseCrmEventbusProtoTaskMetadataCategory::DataManipulation => {
                    "DATA_MANIPULATION"
                }
                EnterpriseCrmEventbusProtoTaskMetadataCategory::FlowControl => "FLOW_CONTROL",
                EnterpriseCrmEventbusProtoTaskMetadataCategory::Hidden => "HIDDEN",
                EnterpriseCrmEventbusProtoTaskMetadataCategory::Scripting => "SCRIPTING",
                EnterpriseCrmEventbusProtoTaskMetadataCategory::UnspecifiedCategory => {
                    "UNSPECIFIED_CATEGORY"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoTaskMetadataCategory {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskMetadataCategory {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoTaskMetadataCategory, ()> {
            Ok(match s {
                "CLOUD_SYSTEMS" => EnterpriseCrmEventbusProtoTaskMetadataCategory::CloudSystems,
                "CONNECTOR" => EnterpriseCrmEventbusProtoTaskMetadataCategory::Connector,
                "CUSTOM" => EnterpriseCrmEventbusProtoTaskMetadataCategory::Custom,
                "CUSTOM_TASK_TEMPLATE" => {
                    EnterpriseCrmEventbusProtoTaskMetadataCategory::CustomTaskTemplate
                }
                "DATA_MANIPULATION" => {
                    EnterpriseCrmEventbusProtoTaskMetadataCategory::DataManipulation
                }
                "FLOW_CONTROL" => EnterpriseCrmEventbusProtoTaskMetadataCategory::FlowControl,
                "HIDDEN" => EnterpriseCrmEventbusProtoTaskMetadataCategory::Hidden,
                "SCRIPTING" => EnterpriseCrmEventbusProtoTaskMetadataCategory::Scripting,
                "UNSPECIFIED_CATEGORY" => {
                    EnterpriseCrmEventbusProtoTaskMetadataCategory::UnspecifiedCategory
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskMetadataCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskMetadataCategory {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoTaskMetadataCategory {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CLOUD_SYSTEMS" => EnterpriseCrmEventbusProtoTaskMetadataCategory::CloudSystems,
                "CONNECTOR" => EnterpriseCrmEventbusProtoTaskMetadataCategory::Connector,
                "CUSTOM" => EnterpriseCrmEventbusProtoTaskMetadataCategory::Custom,
                "CUSTOM_TASK_TEMPLATE" => {
                    EnterpriseCrmEventbusProtoTaskMetadataCategory::CustomTaskTemplate
                }
                "DATA_MANIPULATION" => {
                    EnterpriseCrmEventbusProtoTaskMetadataCategory::DataManipulation
                }
                "FLOW_CONTROL" => EnterpriseCrmEventbusProtoTaskMetadataCategory::FlowControl,
                "HIDDEN" => EnterpriseCrmEventbusProtoTaskMetadataCategory::Hidden,
                "SCRIPTING" => EnterpriseCrmEventbusProtoTaskMetadataCategory::Scripting,
                "UNSPECIFIED_CATEGORY" => {
                    EnterpriseCrmEventbusProtoTaskMetadataCategory::UnspecifiedCategory
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskMetadataCategory {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskMetadataCategory {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption {
        #[doc = "Validate all potential output JSON parameters against schemas specified in WorkflowParameters."]
        PostExecution,
        #[doc = "Validate all potential input JSON parameters against schemas specified in WorkflowParameters."]
        PreExecution,
        #[doc = "Perform both PRE_EXECUTION and POST_EXECUTION validations."]
        PrePostExecution,
        #[doc = "Do not run any validation against JSON schemas."]
        Skip,
        #[doc = "As per the default behavior, no validation will be run. Will not override any option set in a Task."]
        UnspecifiedJsonValidationOption,
    }
    impl EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PostExecution => "POST_EXECUTION" , EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PreExecution => "PRE_EXECUTION" , EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PrePostExecution => "PRE_POST_EXECUTION" , EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: Skip => "SKIP" , EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: UnspecifiedJsonValidationOption => "UNSPECIFIED_JSON_VALIDATION_OPTION" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption,
            (),
        > {
            Ok (match s { "POST_EXECUTION" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PostExecution , "PRE_EXECUTION" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PreExecution , "PRE_POST_EXECUTION" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PrePostExecution , "SKIP" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: Skip , "UNSPECIFIED_JSON_VALIDATION_OPTION" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: UnspecifiedJsonValidationOption , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "POST_EXECUTION" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PostExecution , "PRE_EXECUTION" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PreExecution , "PRE_POST_EXECUTION" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: PrePostExecution , "SKIP" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: Skip , "UNSPECIFIED_JSON_VALIDATION_OPTION" => EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption :: UnspecifiedJsonValidationOption , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoTaskMetadataDefaultJsonValidationOption
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskMetadataExternalCategory {
        Connectors,
        Core,
        UnspecifiedExternalCategory,
    }
    impl EnterpriseCrmEventbusProtoTaskMetadataExternalCategory {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: Connectors => "CONNECTORS" , EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: Core => "CORE" , EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: UnspecifiedExternalCategory => "UNSPECIFIED_EXTERNAL_CATEGORY" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoTaskMetadataExternalCategory {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskMetadataExternalCategory {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoTaskMetadataExternalCategory, ()>
        {
            Ok (match s { "CONNECTORS" => EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: Connectors , "CORE" => EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: Core , "UNSPECIFIED_EXTERNAL_CATEGORY" => EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: UnspecifiedExternalCategory , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskMetadataExternalCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskMetadataExternalCategory {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoTaskMetadataExternalCategory {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "CONNECTORS" => EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: Connectors , "CORE" => EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: Core , "UNSPECIFIED_EXTERNAL_CATEGORY" => EnterpriseCrmEventbusProtoTaskMetadataExternalCategory :: UnspecifiedExternalCategory , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoTaskMetadataExternalCategory
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoTaskMetadataExternalCategory
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskMetadataStatus {
        #[doc = "Available for use."]
        Active,
        #[doc = "Still in-progress or incomplete, and not intended for use."]
        DefaultInactive,
        #[doc = "Default value. Actual Task Status should always be set to either INACTIVE or ACTIVE. If none is specified at runtime, it will be set to INACTIVE."]
        UnspecifiedStatus,
    }
    impl EnterpriseCrmEventbusProtoTaskMetadataStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoTaskMetadataStatus::Active => "ACTIVE",
                EnterpriseCrmEventbusProtoTaskMetadataStatus::DefaultInactive => "DEFAULT_INACTIVE",
                EnterpriseCrmEventbusProtoTaskMetadataStatus::UnspecifiedStatus => {
                    "UNSPECIFIED_STATUS"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoTaskMetadataStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskMetadataStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoTaskMetadataStatus, ()> {
            Ok(match s {
                "ACTIVE" => EnterpriseCrmEventbusProtoTaskMetadataStatus::Active,
                "DEFAULT_INACTIVE" => EnterpriseCrmEventbusProtoTaskMetadataStatus::DefaultInactive,
                "UNSPECIFIED_STATUS" => {
                    EnterpriseCrmEventbusProtoTaskMetadataStatus::UnspecifiedStatus
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskMetadataStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskMetadataStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoTaskMetadataStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVE" => EnterpriseCrmEventbusProtoTaskMetadataStatus::Active,
                "DEFAULT_INACTIVE" => EnterpriseCrmEventbusProtoTaskMetadataStatus::DefaultInactive,
                "UNSPECIFIED_STATUS" => {
                    EnterpriseCrmEventbusProtoTaskMetadataStatus::UnspecifiedStatus
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskMetadataStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskMetadataStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskMetadataSystem {
        Buganizer,
        CloudSql,
        DataBridge,
        Email,
        Generic,
        GoogleGroups,
        Plx,
        Salesforce,
        Sheets,
        Spanner,
        UnspecifiedSystem,
    }
    impl EnterpriseCrmEventbusProtoTaskMetadataSystem {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoTaskMetadataSystem::Buganizer => "BUGANIZER",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::CloudSql => "CLOUD_SQL",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::DataBridge => "DATA_BRIDGE",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::Email => "EMAIL",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::Generic => "GENERIC",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::GoogleGroups => "GOOGLE_GROUPS",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::Plx => "PLX",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::Salesforce => "SALESFORCE",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::Sheets => "SHEETS",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::Spanner => "SPANNER",
                EnterpriseCrmEventbusProtoTaskMetadataSystem::UnspecifiedSystem => {
                    "UNSPECIFIED_SYSTEM"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoTaskMetadataSystem {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskMetadataSystem {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoTaskMetadataSystem, ()> {
            Ok(match s {
                "BUGANIZER" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Buganizer,
                "CLOUD_SQL" => EnterpriseCrmEventbusProtoTaskMetadataSystem::CloudSql,
                "DATA_BRIDGE" => EnterpriseCrmEventbusProtoTaskMetadataSystem::DataBridge,
                "EMAIL" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Email,
                "GENERIC" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Generic,
                "GOOGLE_GROUPS" => EnterpriseCrmEventbusProtoTaskMetadataSystem::GoogleGroups,
                "PLX" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Plx,
                "SALESFORCE" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Salesforce,
                "SHEETS" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Sheets,
                "SPANNER" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Spanner,
                "UNSPECIFIED_SYSTEM" => {
                    EnterpriseCrmEventbusProtoTaskMetadataSystem::UnspecifiedSystem
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskMetadataSystem {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskMetadataSystem {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoTaskMetadataSystem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BUGANIZER" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Buganizer,
                "CLOUD_SQL" => EnterpriseCrmEventbusProtoTaskMetadataSystem::CloudSql,
                "DATA_BRIDGE" => EnterpriseCrmEventbusProtoTaskMetadataSystem::DataBridge,
                "EMAIL" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Email,
                "GENERIC" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Generic,
                "GOOGLE_GROUPS" => EnterpriseCrmEventbusProtoTaskMetadataSystem::GoogleGroups,
                "PLX" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Plx,
                "SALESFORCE" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Salesforce,
                "SHEETS" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Sheets,
                "SPANNER" => EnterpriseCrmEventbusProtoTaskMetadataSystem::Spanner,
                "UNSPECIFIED_SYSTEM" => {
                    EnterpriseCrmEventbusProtoTaskMetadataSystem::UnspecifiedSystem
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskMetadataSystem {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskMetadataSystem {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoTaskMetadataAdmin {
        #[serde(
            rename = "googleGroupEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub google_group_email: ::std::option::Option<String>,
        #[serde(
            rename = "userEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_email: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskMetadataAdmin {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskMetadataAdmin {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoTaskUiConfig {
        #[doc = "Configurations of included config modules."]
        #[serde(
            rename = "taskUiModuleConfigs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_ui_module_configs: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmEventbusProtoTaskUiModuleConfig>,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskUiConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskUiConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoTaskUiModuleConfig {
        #[doc = "ID of the config module."]
        #[serde(
            rename = "moduleId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub module_id: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTaskUiModuleConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskUiModuleConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId {
        #[doc = "Supports navigating to Apps Script editor"]
        AppsScriptNavigator,
        #[doc = "Configures a CloudSql Task."]
        CloudSql,
        #[doc = "Supports editing error handling settings such as retry strategy."]
        ErrorHandling,
        #[doc = "Configures a FieldMappingTask."]
        FieldMapping,
        #[doc = "Configure a GenericConnectorTask."]
        GenericConnectorTask,
        #[doc = "Supports editing label of a task config."]
        Label,
        #[doc = "Supports editing preconditions of a task config."]
        Precondition,
        #[doc = "Contains embedded in-product documentation for a task."]
        Readme,
        #[doc = "UI widget for the rest caller task."]
        RestCaller,
        #[doc = "Supports editing task parameters associated with an RPC/stubby task."]
        Rpc,
        #[doc = "Configures a GenericStubbyTypedTask."]
        RpcTyped,
        #[doc = "Supports adding, editing, and deleting the scripts associated with a script task, as well as modifying the input/output parameters."]
        ScriptEditor,
        #[doc = "Configures a SubWorkflowExecutorTask."]
        SubWorkflow,
        #[doc = "Configures a SubWorkflowForEachLoopTask."]
        SubWorkflowForEachLoop,
        #[doc = "Configures a SubWorkflowScatterGatherTask."]
        SubWorkflowScatterGather,
        #[doc = "Configures a SuspensionTask."]
        Suspension,
        #[doc = "Supports editing values of declared input parameters of a task. Think of it as a â€œstrongly typedâ€ upgrade to the TASK_PARAM_TABLE."]
        TaskParamForm,
        #[doc = "Supports adding, removing and editing task parameter values in a table with little assistance or restriction."]
        TaskParamTable,
        #[doc = "Contains readonly task information, including input/output type info."]
        TaskSummary,
        #[doc = "Default"]
        UnspecifiedTaskModule,
    }
    impl EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::AppsScriptNavigator => {
                    "APPS_SCRIPT_NAVIGATOR"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::CloudSql => "CLOUD_SQL",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::ErrorHandling => {
                    "ERROR_HANDLING"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::FieldMapping => {
                    "FIELD_MAPPING"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::GenericConnectorTask => {
                    "GENERIC_CONNECTOR_TASK"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Label => "LABEL",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Precondition => {
                    "PRECONDITION"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Readme => "README",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::RestCaller => "REST_CALLER",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Rpc => "RPC",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::RpcTyped => "RPC_TYPED",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::ScriptEditor => {
                    "SCRIPT_EDITOR"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflow => "SUB_WORKFLOW",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflowForEachLoop => {
                    "SUB_WORKFLOW_FOR_EACH_LOOP"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflowScatterGather => {
                    "SUB_WORKFLOW_SCATTER_GATHER"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Suspension => "SUSPENSION",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskParamForm => {
                    "TASK_PARAM_FORM"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskParamTable => {
                    "TASK_PARAM_TABLE"
                }
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskSummary => "TASK_SUMMARY",
                EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::UnspecifiedTaskModule => {
                    "UNSPECIFIED_TASK_MODULE"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId, ()>
        {
            Ok(match s {
                "APPS_SCRIPT_NAVIGATOR" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::AppsScriptNavigator
                }
                "CLOUD_SQL" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::CloudSql,
                "ERROR_HANDLING" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::ErrorHandling
                }
                "FIELD_MAPPING" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::FieldMapping
                }
                "GENERIC_CONNECTOR_TASK" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::GenericConnectorTask
                }
                "LABEL" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Label,
                "PRECONDITION" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Precondition
                }
                "README" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Readme,
                "REST_CALLER" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::RestCaller,
                "RPC" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Rpc,
                "RPC_TYPED" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::RpcTyped,
                "SCRIPT_EDITOR" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::ScriptEditor
                }
                "SUB_WORKFLOW" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflow,
                "SUB_WORKFLOW_FOR_EACH_LOOP" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflowForEachLoop
                }
                "SUB_WORKFLOW_SCATTER_GATHER" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflowScatterGather
                }
                "SUSPENSION" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Suspension,
                "TASK_PARAM_FORM" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskParamForm
                }
                "TASK_PARAM_TABLE" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskParamTable
                }
                "TASK_SUMMARY" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskSummary,
                "UNSPECIFIED_TASK_MODULE" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::UnspecifiedTaskModule
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APPS_SCRIPT_NAVIGATOR" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::AppsScriptNavigator
                }
                "CLOUD_SQL" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::CloudSql,
                "ERROR_HANDLING" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::ErrorHandling
                }
                "FIELD_MAPPING" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::FieldMapping
                }
                "GENERIC_CONNECTOR_TASK" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::GenericConnectorTask
                }
                "LABEL" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Label,
                "PRECONDITION" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Precondition
                }
                "README" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Readme,
                "REST_CALLER" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::RestCaller,
                "RPC" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Rpc,
                "RPC_TYPED" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::RpcTyped,
                "SCRIPT_EDITOR" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::ScriptEditor
                }
                "SUB_WORKFLOW" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflow,
                "SUB_WORKFLOW_FOR_EACH_LOOP" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflowForEachLoop
                }
                "SUB_WORKFLOW_SCATTER_GATHER" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::SubWorkflowScatterGather
                }
                "SUSPENSION" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::Suspension,
                "TASK_PARAM_FORM" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskParamForm
                }
                "TASK_PARAM_TABLE" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskParamTable
                }
                "TASK_SUMMARY" => EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::TaskSummary,
                "UNSPECIFIED_TASK_MODULE" => {
                    EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId::UnspecifiedTaskModule
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTaskUiModuleConfigModuleId {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoTeardown {
        #[doc = "Required."]
        #[serde(
            rename = "teardownTaskConfigs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub teardown_task_configs: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmEventbusProtoTeardownTaskConfig>,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTeardown {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTeardown {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoTeardownTaskConfig {
        #[doc = "The creatorâ€™s email address."]
        #[serde(
            rename = "creatorEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub creator_email: ::std::option::Option<String>,
        #[doc = "Required. Unique identifier of the teardown task within this Config. We use this field as the identifier to find next teardown tasks."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "nextTeardownTask",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_teardown_task:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoNextTeardownTask>,
        #[doc = "The parameters the user can pass to this task."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoEventParameters>,
        #[serde(
            rename = "properties",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub properties:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoEventBusProperties>,
        #[doc = "Required. Implementation class name."]
        #[serde(
            rename = "teardownTaskImplementationClassName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub teardown_task_implementation_class_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTeardownTaskConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTeardownTaskConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoToken {
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoToken {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoToken {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoTransformExpression {
        #[doc = "Initial value upon which to perform transformations."]
        #[serde(
            rename = "initialValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub initial_value:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoBaseValue>,
        #[doc = "Transformations to be applied sequentially."]
        #[serde(
            rename = "transformationFunctions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transformation_functions:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoFunction>>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTransformExpression {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTransformExpression {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoTriggerCriteria {
        #[doc = "Required. Standard filter expression, when true the workflow will be executed. If thereâ€™s no trigger_criteria_task_implementation_class_name specified, the condition will be validated directly."]
        #[serde(
            rename = "condition",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub condition: ::std::option::Option<String>,
        #[doc = "Optional. To be used in TaskConfig for the implementation class."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoEventParameters>,
        #[doc = "Optional. Implementation class name. The class should implement the â€œTypedTaskâ€ interface."]
        #[serde(
            rename = "triggerCriteriaTaskImplementationClassName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_criteria_task_implementation_class_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoTriggerCriteria {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoTriggerCriteria {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmEventbusProtoValueType {
        #[serde(
            rename = "booleanValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_value: ::std::option::Option<bool>,
        #[serde(
            rename = "doubleArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_array:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoDoubleArray>,
        #[serde(
            rename = "doubleValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_value: ::std::option::Option<f64>,
        #[serde(
            rename = "intArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_array: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoIntArray>,
        #[serde(
            rename = "intValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub int_value: ::std::option::Option<i64>,
        #[serde(
            rename = "protoValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_value:
            ::std::option::Option<::std::collections::BTreeMap<String, ::serde_json::Value>>,
        #[serde(
            rename = "stringArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_array:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoStringArray>,
        #[serde(
            rename = "stringValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoValueType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoValueType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusProtoWorkflowAlertConfig {
        #[doc = "For an EXPECTED_MIN threshold, this aggregation_period must be lesser than 24 hours."]
        #[serde(
            rename = "aggregationPeriod",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub aggregation_period: ::std::option::Option<String>,
        #[doc = "Set to false by default. When set to true, the metrics are not aggregated or pushed to Monarch for this workflow alert."]
        #[serde(
            rename = "alertDisabled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alert_disabled: ::std::option::Option<bool>,
        #[doc = "A name to identify this alert. This will be displayed in the alert subject. If set, this name should be unique within the scope of the workflow."]
        #[serde(
            rename = "alertName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alert_name: ::std::option::Option<String>,
        #[doc = "Client associated with this alert configuration."]
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "Should be specified only for \\*AVERAGE_DURATION and \\*PERCENTILE_DURATION metrics. This member should be used to specify what duration value the metrics should exceed for the alert to trigger."]
        #[serde(
            rename = "durationThresholdMs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub duration_threshold_ms: ::std::option::Option<i64>,
        #[serde(
            rename = "errorEnumList",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_enum_list: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumList,
        >,
        #[serde(
            rename = "metricType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metric_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType,
        >,
        #[doc = "For how many contiguous aggregation periods should the expected min or max be violated for the alert to be fired."]
        #[serde(
            rename = "numAggregationPeriods",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub num_aggregation_periods: ::std::option::Option<i32>,
        #[doc = "For either events or tasks, depending on the type of alert, count only final attempts, not retries."]
        #[serde(
            rename = "onlyFinalAttempt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub only_final_attempt: ::std::option::Option<bool>,
        #[doc = "Link to a playbook for resolving the issue that triggered this alert."]
        #[serde(
            rename = "playbookUrl",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub playbook_url: ::std::option::Option<String>,
        #[doc = "The threshold type, whether lower(expected_min) or upper(expected_max), for which this alert is being configured. If value falls below expected_min or exceeds expected_max, an alert will be fired."]
        #[serde(
            rename = "thresholdType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub threshold_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType,
        >,
        #[doc = "The metric value, above or below which the alert should be triggered."]
        #[serde(
            rename = "thresholdValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub threshold_value: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBaseAlertConfigThresholdValue,
        >,
        #[serde(
            rename = "warningEnumList",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub warning_enum_list: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoBaseAlertConfigErrorEnumList,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusProtoWorkflowAlertConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusProtoWorkflowAlertConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType {
        #[doc = "Specifies alerting on the average duration of executions for this workflow."]
        EventAverageDuration,
        #[doc = "Specifies alerting on the rate of errors for the enclosing workflow."]
        EventErrorRate,
        #[doc = "Specifies alerting on the duration value of a particular percentile of workflow executions. E.g. If 10% or more of the workflow executions have durations above 5 seconds, alert."]
        EventPercentileDuration,
        #[doc = "Specifies alerting on the number of events executed in the given aggregation_period."]
        EventRate,
        #[doc = "Specifies alerting on the rate of warnings for the enclosing workflow. Warnings use the same enum values as errors."]
        EventWarningRate,
        #[doc = "The default value. Metric type should always be set to one of the other non-default values, otherwise it will result in an INVALID_ARGUMENT error."]
        MetricTypeUnspecified,
        #[doc = "Specifies alerting on the average duration of any task in the enclosing workflow,"]
        TaskAverageDuration,
        #[doc = "Specifies alerting on the rate of errors for any task in the enclosing workflow."]
        TaskErrorRate,
        #[doc = "Specifies alerting on the duration value of a particular percentile of any task executions within the enclosing workflow. E.g. If 10% or more of the task executions in the workflow have durations above 5 seconds, alert."]
        TaskPercentileDuration,
        #[doc = "Specifies alerting on the rate of executions over all tasks in the enclosing workflow."]
        TaskRate,
        #[doc = "Specifies alerting on the rate of warnings for any task in the enclosing workflow."]
        TaskWarningRate,
    }
    impl EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: EventAverageDuration => "EVENT_AVERAGE_DURATION" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: EventErrorRate => "EVENT_ERROR_RATE" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: EventPercentileDuration => "EVENT_PERCENTILE_DURATION" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: EventRate => "EVENT_RATE" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: EventWarningRate => "EVENT_WARNING_RATE" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: MetricTypeUnspecified => "METRIC_TYPE_UNSPECIFIED" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: TaskAverageDuration => "TASK_AVERAGE_DURATION" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: TaskErrorRate => "TASK_ERROR_RATE" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: TaskPercentileDuration => "TASK_PERCENTILE_DURATION" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: TaskRate => "TASK_RATE" , EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType :: TaskWarningRate => "TASK_WARNING_RATE" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType, ()>
        {
            Ok(match s {
                "EVENT_AVERAGE_DURATION" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventAverageDuration
                }
                "EVENT_ERROR_RATE" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventErrorRate
                }
                "EVENT_PERCENTILE_DURATION" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventPercentileDuration
                }
                "EVENT_RATE" => EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventRate,
                "EVENT_WARNING_RATE" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventWarningRate
                }
                "METRIC_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::MetricTypeUnspecified
                }
                "TASK_AVERAGE_DURATION" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskAverageDuration
                }
                "TASK_ERROR_RATE" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskErrorRate
                }
                "TASK_PERCENTILE_DURATION" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskPercentileDuration
                }
                "TASK_RATE" => EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskRate,
                "TASK_WARNING_RATE" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskWarningRate
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EVENT_AVERAGE_DURATION" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventAverageDuration
                }
                "EVENT_ERROR_RATE" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventErrorRate
                }
                "EVENT_PERCENTILE_DURATION" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventPercentileDuration
                }
                "EVENT_RATE" => EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventRate,
                "EVENT_WARNING_RATE" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::EventWarningRate
                }
                "METRIC_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::MetricTypeUnspecified
                }
                "TASK_AVERAGE_DURATION" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskAverageDuration
                }
                "TASK_ERROR_RATE" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskErrorRate
                }
                "TASK_PERCENTILE_DURATION" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskPercentileDuration
                }
                "TASK_RATE" => EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskRate,
                "TASK_WARNING_RATE" => {
                    EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType::TaskWarningRate
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoWorkflowAlertConfigMetricType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType {
        ExpectedMax,
        #[doc = "Note that this field will only trigger alerts if the workflow specifying it runs at least once in 24 hours (which is our in-memory retention period for monarch streams). Also note that `aggregation_period` for this alert configuration must be less than 24 hours."]
        ExpectedMin,
        UnspecifiedThresholdType,
    }
    impl EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: ExpectedMax => "EXPECTED_MAX" , EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: ExpectedMin => "EXPECTED_MIN" , EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: UnspecifiedThresholdType => "UNSPECIFIED_THRESHOLD_TYPE" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType, ()>
        {
            Ok (match s { "EXPECTED_MAX" => EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: ExpectedMax , "EXPECTED_MIN" => EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: ExpectedMin , "UNSPECIFIED_THRESHOLD_TYPE" => EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: UnspecifiedThresholdType , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "EXPECTED_MAX" => EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: ExpectedMax , "EXPECTED_MIN" => EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: ExpectedMin , "UNSPECIFIED_THRESHOLD_TYPE" => EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType :: UnspecifiedThresholdType , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmEventbusProtoWorkflowAlertConfigThresholdType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusStats {
        #[doc = "Dimensions that these stats have been aggregated on."]
        #[serde(
            rename = "dimensions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dimensions: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusStatsDimensions>,
        #[doc = "Average duration in seconds."]
        #[serde(
            rename = "durationInSeconds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub duration_in_seconds: ::std::option::Option<f64>,
        #[doc = "Average error rate."]
        #[serde(
            rename = "errorRate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_rate: ::std::option::Option<f64>,
        #[doc = "Queries per second."]
        #[serde(
            rename = "qps",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub qps: ::std::option::Option<f64>,
        #[doc = "Average warning rate."]
        #[serde(
            rename = "warningRate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub warning_rate: ::std::option::Option<f64>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmEventbusStatsDimensions {
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "Whether to include or exclude the enums matching the regex."]
        #[serde(
            rename = "enumFilterType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enum_filter_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusStatsDimensionsEnumFilterType,
        >,
        #[serde(
            rename = "errorEnumString",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_enum_string: ::std::option::Option<String>,
        #[serde(
            rename = "retryAttempt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retry_attempt:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusStatsDimensionsRetryAttempt>,
        #[serde(
            rename = "taskName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_name: ::std::option::Option<String>,
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<String>,
        #[doc = "Stats have been or will be aggregated on set fields for any semantically-meaningful combination."]
        #[serde(
            rename = "triggerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_id: ::std::option::Option<String>,
        #[serde(
            rename = "warningEnumString",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub warning_enum_string: ::std::option::Option<String>,
        #[serde(
            rename = "workflowId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub workflow_id: ::std::option::Option<String>,
        #[serde(
            rename = "workflowName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub workflow_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusStatsDimensions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusStatsDimensions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        DefaultInclusive,
        Exclusive,
    }
    impl EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusStatsDimensionsEnumFilterType::DefaultInclusive => {
                    "DEFAULT_INCLUSIVE"
                }
                EnterpriseCrmEventbusStatsDimensionsEnumFilterType::Exclusive => "EXCLUSIVE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusStatsDimensionsEnumFilterType, ()> {
            Ok(match s {
                "DEFAULT_INCLUSIVE" => {
                    EnterpriseCrmEventbusStatsDimensionsEnumFilterType::DefaultInclusive
                }
                "EXCLUSIVE" => EnterpriseCrmEventbusStatsDimensionsEnumFilterType::Exclusive,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEFAULT_INCLUSIVE" => {
                    EnterpriseCrmEventbusStatsDimensionsEnumFilterType::DefaultInclusive
                }
                "EXCLUSIVE" => EnterpriseCrmEventbusStatsDimensionsEnumFilterType::Exclusive,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusStatsDimensionsEnumFilterType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        #[doc = "Task has been deliberately canceled."]
        Canceled,
        #[doc = "Task has completed successfully or has depleted all retry attempts."]
        Final,
        #[doc = "Task has failed but may be retried."]
        Retryable,
        Unspecified,
    }
    impl EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Canceled => "CANCELED",
                EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Final => "FINAL",
                EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Retryable => "RETRYABLE",
                EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Unspecified => "UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmEventbusStatsDimensionsRetryAttempt, ()> {
            Ok(match s {
                "CANCELED" => EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Canceled,
                "FINAL" => EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Final,
                "RETRYABLE" => EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Retryable,
                "UNSPECIFIED" => EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Unspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CANCELED" => EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Canceled,
                "FINAL" => EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Final,
                "RETRYABLE" => EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Retryable,
                "UNSPECIFIED" => EnterpriseCrmEventbusStatsDimensionsRetryAttempt::Unspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmEventbusStatsDimensionsRetryAttempt {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmFrontendsEventbusProtoBooleanParameterArray {
        #[serde(
            rename = "booleanValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_values: ::std::option::Option<Vec<bool>>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoBooleanParameterArray
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoBooleanParameterArray
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmFrontendsEventbusProtoDoubleParameterArray {
        #[serde(
            rename = "doubleValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_values: ::std::option::Option<Vec<f64>>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoDoubleParameterArray
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoDoubleParameterArray
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoEventExecutionDetails { # [serde (rename = "eventAttemptStats" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_attempt_stats : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmEventbusProtoEventExecutionDetailsEventAttemptStats > > , # [doc = "After snapshot migration, this field will no longer be populated, but old execution snapshots will still be accessible."] # [serde (rename = "eventExecutionSnapshot" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_execution_snapshot : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoEventExecutionSnapshot > > , # [doc = "The execution state of this event."] # [serde (rename = "eventExecutionState" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_execution_state : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState > , # [doc = "Indicates the number of times the execution has restarted from the beginning."] # [serde (rename = "eventRetriesFromBeginningCount" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_retries_from_beginning_count : :: std :: option :: Option < i32 > , # [doc = "The log file path (aka. cns address) for this event."] # [serde (rename = "logFilePath" , default , skip_serializing_if = "std::option::Option::is_none")] pub log_file_path : :: std :: option :: Option < String > , # [doc = "The network address (aka. bns address) that indicates where the event executor is running."] # [serde (rename = "networkAddress" , default , skip_serializing_if = "std::option::Option::is_none")] pub network_address : :: std :: option :: Option < String > , # [doc = "Next scheduled execution time in case the execution status was RETRY_ON_HOLD."] # [serde (rename = "nextExecutionTime" , default , skip_serializing_if = "std::option::Option::is_none")] # [serde (with = "crate::parsed_string")] pub next_execution_time : :: std :: option :: Option < i64 > , # [doc = "Used internally and shouldnâ€™t be exposed to users. A counter for the cron job to record how many times this event is in in_process state but donâ€™t have a lock consecutively/"] # [serde (rename = "ryeLockUnheldCount" , default , skip_serializing_if = "std::option::Option::is_none")] pub rye_lock_unheld_count : :: std :: option :: Option < i32 > , }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetails
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetails
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState {
        #[doc = "Event execution canceled by user. Thereâ€™s no more change after this state."]
        Canceled,
        #[doc = "Event execution failed. Thereâ€™s no more change after this state."]
        Failed,
        #[doc = "Event is under processing."]
        InProcess,
        #[doc = "Event is received and waiting for the execution. This happens when firing the event via â€œpostToQueueâ€ or â€œscheduleâ€."]
        OnHold,
        #[doc = "Event execution failed and waiting for retry."]
        RetryOnHold,
        #[doc = "Event execution successfully finished. Thereâ€™s no more change after this state."]
        Succeeded,
        #[doc = "Event execution suspended and waiting for manual intervention."]
        Suspended,
        Unspecified,
    }
    impl EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Canceled => "CANCELED" , EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Failed => "FAILED" , EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: InProcess => "IN_PROCESS" , EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: OnHold => "ON_HOLD" , EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: RetryOnHold => "RETRY_ON_HOLD" , EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Succeeded => "SUCCEEDED" , EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Suspended => "SUSPENDED" , EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Unspecified => "UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState,
            (),
        > {
            Ok (match s { "CANCELED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Canceled , "FAILED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Failed , "IN_PROCESS" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: InProcess , "ON_HOLD" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: OnHold , "RETRY_ON_HOLD" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: RetryOnHold , "SUCCEEDED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Succeeded , "SUSPENDED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Suspended , "UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Unspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "CANCELED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Canceled , "FAILED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Failed , "IN_PROCESS" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: InProcess , "ON_HOLD" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: OnHold , "RETRY_ON_HOLD" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: RetryOnHold , "SUCCEEDED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Succeeded , "SUSPENDED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Suspended , "UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState :: Unspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionDetailsEventExecutionState
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoEventExecutionInfo {
        #[doc = "The event data user sends as request."]
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "Auto-generated."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub create_time: ::std::option::Option<i64>,
        #[doc = "Final error-code if event failed."]
        #[serde(
            rename = "errorCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_code: ::std::option::Option<crate::schemas::CrmlogErrorCode>,
        #[doc = "Errors, warnings, and informationals associated with the workflow/task. The order in which the errors were added by the workflow/task is maintained."]
        #[serde(
            rename = "errors",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub errors:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoErrorDetail>>,
        #[doc = "The execution info about this event."]
        #[serde(
            rename = "eventExecutionDetails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_execution_details: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventExecutionDetails,
        >,
        #[doc = "Auto-generated primary key."]
        #[serde(
            rename = "eventExecutionInfoId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_execution_info_id: ::std::option::Option<String>,
        #[doc = "Execution trace info to aggregate parent-child executions."]
        #[serde(
            rename = "executionTraceInfo",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_trace_info:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoExecutionTraceInfo>,
        #[doc = "Auto-generated."]
        #[serde(
            rename = "lastModifiedTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub last_modified_time: ::std::option::Option<i64>,
        #[doc = "The ways user posts this event."]
        #[serde(
            rename = "postMethod",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub post_method: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod,
        >,
        #[doc = "Which Google product the execution_info belongs to. If not set, the execution_info belongs to Integration Platform by default."]
        #[serde(
            rename = "product",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub product: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct,
        >,
        #[doc = "Optional. This is used to de-dup incoming request."]
        #[serde(
            rename = "requestId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_id: ::std::option::Option<String>,
        #[doc = "Event parameters come in as part of the request."]
        #[serde(
            rename = "requestParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_params: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventParameters,
        >,
        #[doc = "Event parameters come out as part of the response."]
        #[serde(
            rename = "responseParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub response_params: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventParameters,
        >,
        #[doc = "Workflow snapshot number."]
        #[serde(
            rename = "snapshotNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub snapshot_number: ::std::option::Option<i64>,
        #[doc = "Tenant this event is created. Used to reschedule the event to correct tenant."]
        #[serde(
            rename = "tenant",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tenant: ::std::option::Option<String>,
        #[doc = "The trigger id of the workflow trigger config. If both trigger_id and client_id is present, the workflow is executed from the start tasks provided by the matching trigger config otherwise it is executed from the default start tasks."]
        #[serde(
            rename = "triggerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_id: ::std::option::Option<String>,
        #[doc = "Required. Pointer to the workflow it is executing."]
        #[serde(
            rename = "workflowId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub workflow_id: ::std::option::Option<String>,
        #[doc = "Name of the workflow."]
        #[serde(
            rename = "workflowName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub workflow_name: ::std::option::Option<String>,
        #[doc = "Time interval in seconds to schedule retry of workflow in manifold when workflow is already running"]
        #[serde(
            rename = "workflowRetryBackoffIntervalSeconds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub workflow_retry_backoff_interval_seconds: ::std::option::Option<i64>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfo
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfo
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod {
        Post,
        PostByEventConfigId,
        PostToQueue,
        PostWithEventDetails,
        Schedule,
        Unspecified,
    }
    impl EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Post => "POST" , EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostByEventConfigId => "POST_BY_EVENT_CONFIG_ID" , EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostToQueue => "POST_TO_QUEUE" , EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostWithEventDetails => "POST_WITH_EVENT_DETAILS" , EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Schedule => "SCHEDULE" , EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Unspecified => "UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod,
            (),
        > {
            Ok (match s { "POST" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Post , "POST_BY_EVENT_CONFIG_ID" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostByEventConfigId , "POST_TO_QUEUE" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostToQueue , "POST_WITH_EVENT_DETAILS" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostWithEventDetails , "SCHEDULE" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Schedule , "UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Unspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "POST" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Post , "POST_BY_EVENT_CONFIG_ID" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostByEventConfigId , "POST_TO_QUEUE" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostToQueue , "POST_WITH_EVENT_DETAILS" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: PostWithEventDetails , "SCHEDULE" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Schedule , "UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod :: Unspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoPostMethod
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct {
        Apigee,
        Ip,
        Security,
        UnspecifiedProduct,
    }
    impl EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct :: Apigee => "APIGEE" , EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct :: Ip => "IP" , EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct :: Security => "SECURITY" , EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct :: UnspecifiedProduct => "UNSPECIFIED_PRODUCT" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct, ()>
        {
            Ok(match s {
                "APIGEE" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct::Apigee,
                "IP" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct::Ip,
                "SECURITY" => {
                    EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct::Security
                }
                "UNSPECIFIED_PRODUCT" => {
                    EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct::UnspecifiedProduct
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "APIGEE" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct::Apigee,
                "IP" => EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct::Ip,
                "SECURITY" => {
                    EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct::Security
                }
                "UNSPECIFIED_PRODUCT" => {
                    EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct::UnspecifiedProduct
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionInfoProduct
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoEventExecutionSnapshot { # [doc = "Indicates â€œright after which checkpoint taskâ€™s executionâ€ this snapshot is taken."] # [serde (rename = "checkpointTaskNumber" , default , skip_serializing_if = "std::option::Option::is_none")] pub checkpoint_task_number : :: std :: option :: Option < String > , # [doc = "All of the computed conditions that been calculated."] # [serde (rename = "conditionResults" , default , skip_serializing_if = "std::option::Option::is_none")] pub condition_results : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmEventbusProtoConditionResult > > , # [doc = "The parameters in Event object that differs from last snapshot."] # [serde (rename = "diffParams" , default , skip_serializing_if = "std::option::Option::is_none")] pub diff_params : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoEventParameters > , # [doc = "Points to the event execution info this snapshot belongs to."] # [serde (rename = "eventExecutionInfoId" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_execution_info_id : :: std :: option :: Option < String > , # [doc = "Auto-generated. Used as primary key for EventExecutionSnapshots table."] # [serde (rename = "eventExecutionSnapshotId" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_execution_snapshot_id : :: std :: option :: Option < String > , # [serde (rename = "eventExecutionSnapshotMetadata" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_execution_snapshot_metadata : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoEventExecutionSnapshotEventExecutionSnapshotMetadata > , # [doc = "The parameters in Event object."] # [serde (rename = "eventParams" , default , skip_serializing_if = "std::option::Option::is_none")] pub event_params : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoEventParameters > , # [doc = "Indicates when this snapshot is taken."] # [serde (rename = "snapshotTime" , default , skip_serializing_if = "std::option::Option::is_none")] # [serde (with = "crate::parsed_string")] pub snapshot_time : :: std :: option :: Option < i64 > , # [doc = "All of the task execution details at the given point of time."] # [serde (rename = "taskExecutionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub task_execution_details : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmEventbusProtoTaskExecutionDetails > > , # [doc = "The task name associated with this snapshot. Could be empty."] # [serde (rename = "taskName" , default , skip_serializing_if = "std::option::Option::is_none")] pub task_name : :: std :: option :: Option < String > , }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionSnapshot
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoEventExecutionSnapshot
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoEventParameters {
        #[doc = "Parameters are a part of Event and can be used to communicate between different tasks that are part of the same workflow execution."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterEntry>,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmFrontendsEventbusProtoEventParameters {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoEventParameters {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmFrontendsEventbusProtoIntParameterArray {
        #[serde(
            rename = "intValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_values: ::std::option::Option<Vec<i64>>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoIntParameterArray
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoIntParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoParamSpecEntry {
        #[doc = "The FQCN of the Java object this represents. A string, for example, would be â€œjava.lang.Stringâ€. If this is â€œjava.lang.Objectâ€, the parameter can be of any type."]
        #[serde(
            rename = "className",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub class_name: ::std::option::Option<String>,
        #[doc = "If it is a collection of objects, this would be the FCQN of every individual element in the collection. If this is â€œjava.lang.Objectâ€, the parameter is a collection of any type."]
        #[serde(
            rename = "collectionElementClassName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub collection_element_class_name: ::std::option::Option<String>,
        #[doc = "Optional fields, such as help text and other useful info."]
        #[serde(
            rename = "config",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub config:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoParamSpecEntryConfig>,
        #[doc = "The data type of the parameter."]
        #[serde(
            rename = "dataType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType,
        >,
        #[doc = "Default values for the defined keys. Each value can either be string, int, double or any proto message or a serialized object."]
        #[serde(
            rename = "defaultValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_value: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterValueType,
        >,
        #[doc = "If set, this entry is deprecated, so further use of this parameter should be prohibited."]
        #[serde(
            rename = "isDeprecated",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_deprecated: ::std::option::Option<bool>,
        #[serde(
            rename = "isOutput",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_output: ::std::option::Option<bool>,
        #[doc = "If the data_type is JSON_VALUE, then this will define its schema."]
        #[serde(
            rename = "jsonSchema",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub json_schema: ::std::option::Option<String>,
        #[doc = "Key is used to retrieve the corresponding parameter value. This should be unique for a given task. These parameters must be predefined in the workflow definition."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "Populated if this represents a proto or proto array."]
        #[serde(
            rename = "protoDef",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_def: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoParamSpecEntryProtoDefinition,
        >,
        #[doc = "If set, the user must provide an input value for this parameter."]
        #[serde(
            rename = "required",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub required: ::std::option::Option<bool>,
        #[doc = "Rule used to validate inputs (individual values and collection elements) for this parameter."]
        #[serde(
            rename = "validationRule",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub validation_rule: ::std::option::Option<
            crate::schemas::EnterpriseCrmEventbusProtoParamSpecEntryValidationRule,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmFrontendsEventbusProtoParamSpecEntry {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoParamSpecEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType {
        BooleanArray,
        BooleanValue,
        #[doc = "BYTES and BYTES_ARRAY data types are not allowed for top-level params. Theyâ€™re only meant to support protobufs with BYTES (sub)fields."]
        Bytes,
        BytesArray,
        DataTypeUnspecified,
        DoubleArray,
        DoubleValue,
        IntArray,
        IntValue,
        JsonValue,
        NonSerializableObject,
        ProtoArray,
        ProtoEnum,
        ProtoEnumArray,
        ProtoValue,
        SerializedObjectValue,
        StringArray,
        StringValue,
    }
    impl EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: BooleanArray => "BOOLEAN_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: BooleanValue => "BOOLEAN_VALUE" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: Bytes => "BYTES" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: BytesArray => "BYTES_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: DataTypeUnspecified => "DATA_TYPE_UNSPECIFIED" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: DoubleArray => "DOUBLE_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: DoubleValue => "DOUBLE_VALUE" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: IntArray => "INT_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: IntValue => "INT_VALUE" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: JsonValue => "JSON_VALUE" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: NonSerializableObject => "NON_SERIALIZABLE_OBJECT" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: ProtoArray => "PROTO_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: ProtoEnum => "PROTO_ENUM" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: ProtoEnumArray => "PROTO_ENUM_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: ProtoValue => "PROTO_VALUE" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: SerializedObjectValue => "SERIALIZED_OBJECT_VALUE" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: StringArray => "STRING_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType :: StringValue => "STRING_VALUE" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType, ()>
        {
            Ok(match s {
                "BOOLEAN_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::BooleanArray
                }
                "BOOLEAN_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::BooleanValue
                }
                "BYTES" => EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::Bytes,
                "BYTES_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::BytesArray
                }
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::DoubleArray
                }
                "DOUBLE_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::DoubleValue
                }
                "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::IntArray,
                "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::IntValue,
                "JSON_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::JsonValue
                }
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::NonSerializableObject
                }
                "PROTO_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::ProtoArray
                }
                "PROTO_ENUM" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::ProtoEnum
                }
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::ProtoEnumArray
                }
                "PROTO_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::ProtoValue
                }
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::SerializedObjectValue
                }
                "STRING_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::StringArray
                }
                "STRING_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::StringValue
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOOLEAN_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::BooleanArray
                }
                "BOOLEAN_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::BooleanValue
                }
                "BYTES" => EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::Bytes,
                "BYTES_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::BytesArray
                }
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::DoubleArray
                }
                "DOUBLE_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::DoubleValue
                }
                "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::IntArray,
                "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::IntValue,
                "JSON_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::JsonValue
                }
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::NonSerializableObject
                }
                "PROTO_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::ProtoArray
                }
                "PROTO_ENUM" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::ProtoEnum
                }
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::ProtoEnumArray
                }
                "PROTO_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::ProtoValue
                }
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::SerializedObjectValue
                }
                "STRING_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::StringArray
                }
                "STRING_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType::StringValue
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoParamSpecEntryDataType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoParamSpecsMessage {
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoParamSpecEntry>,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoParamSpecsMessage
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoParamSpecsMessage {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoParameterEntry {
        #[doc = "Explicitly getting the type of the parameter."]
        #[serde(
            rename = "dataType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType,
        >,
        #[doc = "Key is used to retrieve the corresponding parameter value. This should be unique for a given fired event. These parameters must be predefined in the workflow definition."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "Values for the defined keys. Each value can either be string, int, double or any proto message."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterValueType,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmFrontendsEventbusProtoParameterEntry {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoParameterEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType {
        BooleanArray,
        BooleanValue,
        #[doc = "BYTES and BYTES_ARRAY data types are not allowed for top-level params. Theyâ€™re only meant to support protobufs with BYTES (sub)fields."]
        Bytes,
        BytesArray,
        DataTypeUnspecified,
        DoubleArray,
        DoubleValue,
        IntArray,
        IntValue,
        JsonValue,
        NonSerializableObject,
        ProtoArray,
        ProtoEnum,
        ProtoEnumArray,
        ProtoValue,
        SerializedObjectValue,
        StringArray,
        StringValue,
    }
    impl EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: BooleanArray => "BOOLEAN_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: BooleanValue => "BOOLEAN_VALUE" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: Bytes => "BYTES" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: BytesArray => "BYTES_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: DataTypeUnspecified => "DATA_TYPE_UNSPECIFIED" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: DoubleArray => "DOUBLE_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: DoubleValue => "DOUBLE_VALUE" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: IntArray => "INT_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: IntValue => "INT_VALUE" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: JsonValue => "JSON_VALUE" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: NonSerializableObject => "NON_SERIALIZABLE_OBJECT" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: ProtoArray => "PROTO_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: ProtoEnum => "PROTO_ENUM" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: ProtoEnumArray => "PROTO_ENUM_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: ProtoValue => "PROTO_VALUE" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: SerializedObjectValue => "SERIALIZED_OBJECT_VALUE" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: StringArray => "STRING_ARRAY" , EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType :: StringValue => "STRING_VALUE" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType, ()>
        {
            Ok(match s {
                "BOOLEAN_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::BooleanArray
                }
                "BOOLEAN_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::BooleanValue
                }
                "BYTES" => EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::Bytes,
                "BYTES_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::BytesArray
                }
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::DoubleArray
                }
                "DOUBLE_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::DoubleValue
                }
                "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::IntArray,
                "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::IntValue,
                "JSON_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::JsonValue
                }
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::NonSerializableObject
                }
                "PROTO_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::ProtoArray
                }
                "PROTO_ENUM" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::ProtoEnum
                }
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::ProtoEnumArray
                }
                "PROTO_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::ProtoValue
                }
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::SerializedObjectValue
                }
                "STRING_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::StringArray
                }
                "STRING_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::StringValue
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOOLEAN_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::BooleanArray
                }
                "BOOLEAN_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::BooleanValue
                }
                "BYTES" => EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::Bytes,
                "BYTES_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::BytesArray
                }
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::DoubleArray
                }
                "DOUBLE_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::DoubleValue
                }
                "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::IntArray,
                "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::IntValue,
                "JSON_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::JsonValue
                }
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::NonSerializableObject
                }
                "PROTO_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::ProtoArray
                }
                "PROTO_ENUM" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::ProtoEnum
                }
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::ProtoEnumArray
                }
                "PROTO_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::ProtoValue
                }
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::SerializedObjectValue
                }
                "STRING_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::StringArray
                }
                "STRING_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType::StringValue
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoParameterEntryDataType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoParameterMap {
        #[serde(
            rename = "entries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub entries: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterMapEntry>,
        >,
        #[doc = "Option to specify key value type for all entries of the map. If provided then field types for all entries must conform to this."]
        #[serde(
            rename = "keyType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType,
        >,
        #[serde(
            rename = "valueType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterMapValueType,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmFrontendsEventbusProtoParameterMap {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoParameterMap {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType {
        BooleanArray,
        BooleanValue,
        #[doc = "BYTES and BYTES_ARRAY data types are not allowed for top-level params. Theyâ€™re only meant to support protobufs with BYTES (sub)fields."]
        Bytes,
        BytesArray,
        DataTypeUnspecified,
        DoubleArray,
        DoubleValue,
        IntArray,
        IntValue,
        JsonValue,
        NonSerializableObject,
        ProtoArray,
        ProtoEnum,
        ProtoEnumArray,
        ProtoValue,
        SerializedObjectValue,
        StringArray,
        StringValue,
    }
    impl EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BooleanArray => {
                    "BOOLEAN_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BooleanValue => {
                    "BOOLEAN_VALUE"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::Bytes => "BYTES",
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BytesArray => "BYTES_ARRAY",
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DataTypeUnspecified => {
                    "DATA_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DoubleArray => {
                    "DOUBLE_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DoubleValue => {
                    "DOUBLE_VALUE"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::IntArray => "INT_ARRAY",
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::IntValue => "INT_VALUE",
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::JsonValue => "JSON_VALUE",
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::NonSerializableObject => {
                    "NON_SERIALIZABLE_OBJECT"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoArray => "PROTO_ARRAY",
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoEnum => "PROTO_ENUM",
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoEnumArray => {
                    "PROTO_ENUM_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoValue => "PROTO_VALUE",
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::SerializedObjectValue => {
                    "SERIALIZED_OBJECT_VALUE"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::StringArray => {
                    "STRING_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::StringValue => {
                    "STRING_VALUE"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType, ()>
        {
            Ok(match s {
                "BOOLEAN_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BooleanArray
                }
                "BOOLEAN_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BooleanValue
                }
                "BYTES" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::Bytes,
                "BYTES_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BytesArray,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DoubleArray
                }
                "DOUBLE_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DoubleValue
                }
                "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::IntArray,
                "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::IntValue,
                "JSON_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::NonSerializableObject
                }
                "PROTO_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoArray,
                "PROTO_ENUM" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoEnumArray
                }
                "PROTO_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoValue,
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::SerializedObjectValue
                }
                "STRING_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::StringArray
                }
                "STRING_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::StringValue
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOOLEAN_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BooleanArray
                }
                "BOOLEAN_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BooleanValue
                }
                "BYTES" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::Bytes,
                "BYTES_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::BytesArray,
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DoubleArray
                }
                "DOUBLE_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::DoubleValue
                }
                "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::IntArray,
                "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::IntValue,
                "JSON_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::NonSerializableObject
                }
                "PROTO_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoArray,
                "PROTO_ENUM" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoEnumArray
                }
                "PROTO_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::ProtoValue,
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::SerializedObjectValue
                }
                "STRING_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::StringArray
                }
                "STRING_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType::StringValue
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoParameterMapKeyType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoParameterMapValueType {
        BooleanArray,
        BooleanValue,
        #[doc = "BYTES and BYTES_ARRAY data types are not allowed for top-level params. Theyâ€™re only meant to support protobufs with BYTES (sub)fields."]
        Bytes,
        BytesArray,
        DataTypeUnspecified,
        DoubleArray,
        DoubleValue,
        IntArray,
        IntValue,
        JsonValue,
        NonSerializableObject,
        ProtoArray,
        ProtoEnum,
        ProtoEnumArray,
        ProtoValue,
        SerializedObjectValue,
        StringArray,
        StringValue,
    }
    impl EnterpriseCrmFrontendsEventbusProtoParameterMapValueType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BooleanArray => {
                    "BOOLEAN_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BooleanValue => {
                    "BOOLEAN_VALUE"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::Bytes => "BYTES",
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BytesArray => {
                    "BYTES_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DataTypeUnspecified => {
                    "DATA_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DoubleArray => {
                    "DOUBLE_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DoubleValue => {
                    "DOUBLE_VALUE"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::IntArray => "INT_ARRAY",
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::IntValue => "INT_VALUE",
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::JsonValue => "JSON_VALUE",
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::NonSerializableObject => {
                    "NON_SERIALIZABLE_OBJECT"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoArray => {
                    "PROTO_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoEnum => "PROTO_ENUM",
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoEnumArray => {
                    "PROTO_ENUM_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoValue => {
                    "PROTO_VALUE"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::SerializedObjectValue => {
                    "SERIALIZED_OBJECT_VALUE"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::StringArray => {
                    "STRING_ARRAY"
                }
                EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::StringValue => {
                    "STRING_VALUE"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmFrontendsEventbusProtoParameterMapValueType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoParameterMapValueType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmFrontendsEventbusProtoParameterMapValueType, ()>
        {
            Ok(match s {
                "BOOLEAN_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BooleanArray
                }
                "BOOLEAN_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BooleanValue
                }
                "BYTES" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::Bytes,
                "BYTES_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BytesArray
                }
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DoubleArray
                }
                "DOUBLE_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DoubleValue
                }
                "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::IntArray,
                "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::IntValue,
                "JSON_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::NonSerializableObject
                }
                "PROTO_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoArray
                }
                "PROTO_ENUM" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoEnumArray
                }
                "PROTO_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoValue
                }
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::SerializedObjectValue
                }
                "STRING_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::StringArray
                }
                "STRING_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::StringValue
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoParameterMapValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoParameterMapValueType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmFrontendsEventbusProtoParameterMapValueType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BOOLEAN_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BooleanArray
                }
                "BOOLEAN_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BooleanValue
                }
                "BYTES" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::Bytes,
                "BYTES_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::BytesArray
                }
                "DATA_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DataTypeUnspecified
                }
                "DOUBLE_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DoubleArray
                }
                "DOUBLE_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::DoubleValue
                }
                "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::IntArray,
                "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::IntValue,
                "JSON_VALUE" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::JsonValue,
                "NON_SERIALIZABLE_OBJECT" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::NonSerializableObject
                }
                "PROTO_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoArray
                }
                "PROTO_ENUM" => EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoEnum,
                "PROTO_ENUM_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoEnumArray
                }
                "PROTO_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::ProtoValue
                }
                "SERIALIZED_OBJECT_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::SerializedObjectValue
                }
                "STRING_ARRAY" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::StringArray
                }
                "STRING_VALUE" => {
                    EnterpriseCrmFrontendsEventbusProtoParameterMapValueType::StringValue
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoParameterMapValueType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoParameterMapValueType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoParameterMapEntry {
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterMapField,
        >,
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterMapField,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoParameterMapEntry
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoParameterMapEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoParameterMapField {
        #[doc = "Passing a literal value."]
        #[serde(
            rename = "literalValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub literal_value: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterValueType,
        >,
        #[doc = "Referencing one of the WF variables."]
        #[serde(
            rename = "referenceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reference_key: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoParameterMapField
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoParameterMapField {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoParameterValueType {
        #[serde(
            rename = "booleanArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_array: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoBooleanParameterArray,
        >,
        #[serde(
            rename = "booleanValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_value: ::std::option::Option<bool>,
        #[serde(
            rename = "doubleArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_array: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoDoubleParameterArray,
        >,
        #[serde(
            rename = "doubleValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_value: ::std::option::Option<f64>,
        #[serde(
            rename = "intArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_array: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoIntParameterArray,
        >,
        #[serde(
            rename = "intValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub int_value: ::std::option::Option<i64>,
        #[serde(
            rename = "jsonValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub json_value: ::std::option::Option<String>,
        #[serde(
            rename = "protoArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_array: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoProtoParameterArray,
        >,
        #[serde(
            rename = "protoValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_value:
            ::std::option::Option<::std::collections::BTreeMap<String, ::serde_json::Value>>,
        #[serde(
            rename = "serializedObjectValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub serialized_object_value: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoSerializedObjectParameter,
        >,
        #[serde(
            rename = "stringArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_array: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoStringParameterArray,
        >,
        #[serde(
            rename = "stringValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoParameterValueType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoParameterValueType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoProtoParameterArray {
        #[serde(
            rename = "protoValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_values:
            ::std::option::Option<Vec<::std::collections::BTreeMap<String, ::serde_json::Value>>>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoProtoParameterArray
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoProtoParameterArray
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoRollbackStrategy {
        #[doc = "Optional. The customized parameters the user can pass to this task."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventParameters,
        >,
        #[doc = "Required. This is the name of the task that needs to be executed upon rollback of this task."]
        #[serde(
            rename = "rollbackTaskImplementationClassName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rollback_task_implementation_class_name: ::std::option::Option<String>,
        #[doc = "Required. These are the tasks numbers of the tasks whose `rollback_strategy.rollback_task_implementation_class_name` needs to be executed upon failure of this task."]
        #[serde(
            rename = "taskNumbersToRollback",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_numbers_to_rollback: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoRollbackStrategy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoRollbackStrategy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmFrontendsEventbusProtoSerializedObjectParameter {
        #[serde(
            rename = "objectValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub object_value: ::std::option::Option<::google_api_bytes::Bytes>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoSerializedObjectParameter
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoSerializedObjectParameter
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmFrontendsEventbusProtoStringParameterArray {
        #[serde(
            rename = "stringValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoStringParameterArray
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoStringParameterArray
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoTaskConfig {
        #[doc = "Alert configurations on error rate, warning rate, number of runs, durations, etc."]
        #[serde(
            rename = "alertConfigs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alert_configs:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoTaskAlertConfig>>,
        #[doc = "Auto-generated."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "The creatorâ€™s email address. Auto-generated from the userâ€™s email."]
        #[serde(
            rename = "creatorEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub creator_email: ::std::option::Option<String>,
        #[doc = "User-provided description intended to give more business context about the task."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "If this config contains a TypedTask, allow validation to succeed if an input is read from the output of another TypedTask whose output type is declared as a superclass of the requested input type. For instance, if the previous task declares an output of type Message, any task with this flag enabled will pass validation when attempting to read any proto Message type from the resultant Event parameter."]
        #[serde(
            rename = "disableStrictTypeValidation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disable_strict_type_validation: ::std::option::Option<bool>,
        #[doc = "Optional. Determines the number of times the task will be retried on failure and with what retry strategy. This is applicable for asynchronous calls to Eventbus alone (Post To Queue, Schedule etc.)."]
        #[serde(
            rename = "failurePolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub failure_policy:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoFailurePolicy>,
        #[doc = "The number of edges leading into this TaskConfig."]
        #[serde(
            rename = "incomingEdgeCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub incoming_edge_count: ::std::option::Option<i32>,
        #[doc = "If set, overrides the option configured in the Task implementation class."]
        #[serde(
            rename = "jsonValidationOption",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub json_validation_option: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption,
        >,
        #[doc = "User-provided label that is attached to this TaskConfig in the UI."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "Auto-generated."]
        #[serde(
            rename = "lastModifiedTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_modified_time: ::std::option::Option<String>,
        #[doc = "The set of tasks that are next in line to be executed as per the execution graph defined for the parent event, specified by `event_config_id`. Each of these next tasks are executed only if the condition associated with them evaluates to true."]
        #[serde(
            rename = "nextTasks",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_tasks:
            ::std::option::Option<Vec<crate::schemas::EnterpriseCrmEventbusProtoNextTask>>,
        #[doc = "The policy dictating the execution of the next set of tasks for the current task."]
        #[serde(
            rename = "nextTasksExecutionPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_tasks_execution_policy: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy,
        >,
        #[doc = "The customized parameters the user can pass to this task."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            ::std::collections::BTreeMap<
                String,
                crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterEntry,
            >,
        >,
        #[doc = "Optional. Informs the front-end application where to draw this task config on the UI."]
        #[serde(
            rename = "position",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub position: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoCoordinate>,
        #[doc = "Optional. Standard filter expression evaluated before execution. Independent of other conditions and tasks. Can be used to enable rollout. e.g. â€œrollout(5)â€ will only allow 5% of incoming traffic to task."]
        #[serde(
            rename = "precondition",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub precondition: ::std::option::Option<String>,
        #[doc = "Optional. User-provided label that is attached to precondition in the UI."]
        #[serde(
            rename = "preconditionLabel",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub precondition_label: ::std::option::Option<String>,
        #[doc = "Optional. Contains information about what needs to be done upon failure (either a permanent error or after it has been retried too many times)."]
        #[serde(
            rename = "rollbackStrategy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rollback_strategy: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoRollbackStrategy,
        >,
        #[doc = "Determines what action to take upon successful task completion."]
        #[serde(
            rename = "successPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub success_policy:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoSuccessPolicy>,
        #[doc = "Optional. Determines the number of times the task will be retried on failure and with what retry strategy. This is applicable for synchronous calls to Eventbus alone (Post)."]
        #[serde(
            rename = "synchronousCallFailurePolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub synchronous_call_failure_policy:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoFailurePolicy>,
        #[doc = "Copy of the task entity that this task config is an instance of."]
        #[serde(
            rename = "taskEntity",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_entity:
            ::std::option::Option<crate::schemas::EnterpriseCrmFrontendsEventbusProtoTaskEntity>,
        #[doc = "The policy dictating the execution strategy of this task."]
        #[serde(
            rename = "taskExecutionStrategy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_execution_strategy: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy,
        >,
        #[doc = "The name for the task."]
        #[serde(
            rename = "taskName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_name: ::std::option::Option<String>,
        #[doc = "REQUIRED: the identifier of this task within its parent event config, specified by the client. This should be unique among all the tasks belong to the same event config. We use this field as the identifier to find next tasks (via field `next_tasks.task_number`)."]
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<String>,
        #[doc = "A string template that allows user to configure task parameters (with either literal default values or tokens which will be resolved at execution time) for the task. It will eventually replace the old â€œparametersâ€ field."]
        #[serde(
            rename = "taskSpec",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_spec: ::std::option::Option<String>,
        #[doc = "Used to define task-template name if task is of type task-template"]
        #[serde(
            rename = "taskTemplateName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_template_name: ::std::option::Option<String>,
        #[doc = "Defines the type of the task"]
        #[serde(
            rename = "taskType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmFrontendsEventbusProtoTaskConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoTaskConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption {
        #[doc = "Validate all potential output JSON parameters against schemas specified in WorkflowParameters."]
        PostExecution,
        #[doc = "Validate all potential input JSON parameters against schemas specified in WorkflowParameters."]
        PreExecution,
        #[doc = "Perform both PRE_EXECUTION and POST_EXECUTION validations."]
        PrePostExecution,
        #[doc = "Do not run any validation against JSON schemas."]
        Skip,
        #[doc = "As per the default behavior, no validation will be run. Will not override any option set in a Task."]
        UnspecifiedJsonValidationOption,
    }
    impl EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PostExecution => "POST_EXECUTION" , EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PreExecution => "PRE_EXECUTION" , EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PrePostExecution => "PRE_POST_EXECUTION" , EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: Skip => "SKIP" , EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: UnspecifiedJsonValidationOption => "UNSPECIFIED_JSON_VALIDATION_OPTION" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption,
            (),
        > {
            Ok (match s { "POST_EXECUTION" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PostExecution , "PRE_EXECUTION" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PreExecution , "PRE_POST_EXECUTION" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PrePostExecution , "SKIP" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: Skip , "UNSPECIFIED_JSON_VALIDATION_OPTION" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: UnspecifiedJsonValidationOption , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "POST_EXECUTION" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PostExecution , "PRE_EXECUTION" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PreExecution , "PRE_POST_EXECUTION" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: PrePostExecution , "SKIP" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: Skip , "UNSPECIFIED_JSON_VALIDATION_OPTION" => EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption :: UnspecifiedJsonValidationOption , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigJsonValidationOption
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy {
        #[doc = "Execute all the tasks that satisfy their associated condition."]
        RunAllMatch,
        #[doc = "Execute the first task that satisfies the associated condition."]
        RunFirstMatch,
        #[doc = "Default"]
        Unspecified,
    }
    impl EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: RunAllMatch => "RUN_ALL_MATCH" , EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: RunFirstMatch => "RUN_FIRST_MATCH" , EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: Unspecified => "UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy,
            (),
        > {
            Ok (match s { "RUN_ALL_MATCH" => EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: RunAllMatch , "RUN_FIRST_MATCH" => EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: RunFirstMatch , "UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: Unspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "RUN_ALL_MATCH" => EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: RunAllMatch , "RUN_FIRST_MATCH" => EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: RunFirstMatch , "UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy :: Unspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigNextTasksExecutionPolicy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy {
        #[doc = "Wait until all of its previous tasks finished execution, then verify at least one of the edge conditions is met, and execute if possible. This should be considered as WHEN_ALL_TASKS_SUCCEED."]
        WhenAllSucceed,
        #[doc = "Wait until all of its previous tasks finished execution, then verify the all edge conditions are met and execute if possible."]
        WhenAllTasksAndConditionsSucceed,
        #[doc = "Start execution as long as any of its previous tasks finished execution and the corresponding edge condition is met (since we will execute if only that succeeding edge condition is met)."]
        WhenAnySucceed,
    }
    impl EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAllSucceed => "WHEN_ALL_SUCCEED" , EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAllTasksAndConditionsSucceed => "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED" , EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAnySucceed => "WHEN_ANY_SUCCEED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy,
            (),
        > {
            Ok (match s { "WHEN_ALL_SUCCEED" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAllSucceed , "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAllTasksAndConditionsSucceed , "WHEN_ANY_SUCCEED" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAnySucceed , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "WHEN_ALL_SUCCEED" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAllSucceed , "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAllTasksAndConditionsSucceed , "WHEN_ANY_SUCCEED" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy :: WhenAnySucceed , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskExecutionStrategy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType {
        #[doc = "Task is of As-Is Template type"]
        AsisTemplate,
        #[doc = "Task is of I/O template type with a different underlying task"]
        IoTemplate,
        #[doc = "Normal IP task"]
        Task,
    }
    impl EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::AsisTemplate => {
                    "ASIS_TEMPLATE"
                }
                EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::IoTemplate => "IO_TEMPLATE",
                EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::Task => "TASK",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType, ()>
        {
            Ok(match s {
                "ASIS_TEMPLATE" => {
                    EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::AsisTemplate
                }
                "IO_TEMPLATE" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::IoTemplate,
                "TASK" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::Task,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ASIS_TEMPLATE" => {
                    EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::AsisTemplate
                }
                "IO_TEMPLATE" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::IoTemplate,
                "TASK" => EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType::Task,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoTaskConfigTaskType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoTaskEntity {
        #[doc = "True if the task has conflict with vpcsc"]
        #[serde(
            rename = "disabledForVpcSc",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disabled_for_vpc_sc: ::std::option::Option<bool>,
        #[doc = "Metadata inclueds the task name, author and so on."]
        #[serde(
            rename = "metadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metadata: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoTaskMetadata>,
        #[doc = "Declarations for inputs/outputs for a TypedTask. This is also associated with the METADATA mask."]
        #[serde(
            rename = "paramSpecs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub param_specs: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParamSpecsMessage,
        >,
        #[doc = "Deprecated - statistics from the Monarch query."]
        #[serde(
            rename = "stats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stats: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusStats>,
        #[doc = "Defines the type of the task"]
        #[serde(
            rename = "taskType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType,
        >,
        #[doc = "UI configuration for this task Also associated with the METADATA mask."]
        #[serde(
            rename = "uiConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ui_config:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoTaskUiConfig>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmFrontendsEventbusProtoTaskEntity {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoTaskEntity {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType {
        #[doc = "Task is of As-Is Template type"]
        AsisTemplate,
        #[doc = "Task is of I/O template type with a different underlying task"]
        IoTemplate,
        #[doc = "Normal IP task"]
        Task,
    }
    impl EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::AsisTemplate => {
                    "ASIS_TEMPLATE"
                }
                EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::IoTemplate => "IO_TEMPLATE",
                EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::Task => "TASK",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType, ()>
        {
            Ok(match s {
                "ASIS_TEMPLATE" => {
                    EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::AsisTemplate
                }
                "IO_TEMPLATE" => EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::IoTemplate,
                "TASK" => EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::Task,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ASIS_TEMPLATE" => {
                    EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::AsisTemplate
                }
                "IO_TEMPLATE" => EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::IoTemplate,
                "TASK" => EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType::Task,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoTaskEntityTaskType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoTriggerConfig { # [doc = "An alert threshold configuration for the \\[trigger + client + workflow\\] tuple. If these values are not specified in the trigger config, default values will be populated by the system. Note that there must be exactly one alert threshold configured per \\[client + trigger + workflow\\] when published."] # [serde (rename = "alertConfig" , default , skip_serializing_if = "std::option::Option::is_none")] pub alert_config : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmEventbusProtoWorkflowAlertConfig > > , # [serde (rename = "cloudSchedulerConfig" , default , skip_serializing_if = "std::option::Option::is_none")] pub cloud_scheduler_config : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoCloudSchedulerConfig > , # [doc = "User-provided description intended to give more business context about the task."] # [serde (rename = "description" , default , skip_serializing_if = "std::option::Option::is_none")] pub description : :: std :: option :: Option < String > , # [doc = "Required. The list of client ids which are enabled to execute the workflow using this trigger. In other words, these clients have the workflow execution privledges for this trigger. For API trigger, the client id in the incoming request is validated against the list of enabled clients. For non-API triggers, one workflow execution is triggered on behalf of each enabled client."] # [serde (rename = "enabledClients" , default , skip_serializing_if = "std::option::Option::is_none")] pub enabled_clients : :: std :: option :: Option < Vec < String > > , # [doc = "The user created label for a particular trigger."] # [serde (rename = "label" , default , skip_serializing_if = "std::option::Option::is_none")] pub label : :: std :: option :: Option < String > , # [doc = "Dictates how next tasks will be executed."] # [serde (rename = "nextTasksExecutionPolicy" , default , skip_serializing_if = "std::option::Option::is_none")] pub next_tasks_execution_policy : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy > , # [doc = "Optional. If set to true, any upcoming requests for this trigger config will be paused and the executions will be resumed later when the flag is reset. The workflow to which this trigger config belongs has to be in ACTIVE status for the executions to be paused or resumed."] # [serde (rename = "pauseWorkflowExecutions" , default , skip_serializing_if = "std::option::Option::is_none")] pub pause_workflow_executions : :: std :: option :: Option < bool > , # [doc = "Optional. Informs the front-end application where to draw this trigger config on the UI."] # [serde (rename = "position" , default , skip_serializing_if = "std::option::Option::is_none")] pub position : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoCoordinate > , # [doc = "Configurable properties of the trigger, not to be confused with workflow parameters. E.g. â€œnameâ€ is a property for API triggers and â€œsubscriptionâ€ is a property for Cloud Pubsub triggers."] # [serde (rename = "properties" , default , skip_serializing_if = "std::option::Option::is_none")] pub properties : :: std :: option :: Option < :: std :: collections :: BTreeMap < String , String > > , # [doc = "Set of tasks numbers from where the workflow execution is started by this trigger. If this is empty, then workflow is executed with default start tasks. In the list of start tasks, none of two tasks can have direct ancestor-descendant relationships (i.e. in a same workflow execution graph)."] # [serde (rename = "startTasks" , default , skip_serializing_if = "std::option::Option::is_none")] pub start_tasks : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmEventbusProtoNextTask > > , # [doc = "Optional. When set, Eventbus will run the task specified in the trigger_criteria and validate the result using the trigger_criteria.condition, and only execute the workflow when result is true."] # [serde (rename = "triggerCriteria" , default , skip_serializing_if = "std::option::Option::is_none")] pub trigger_criteria : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoTriggerCriteria > , # [doc = "The backend trigger ID."] # [serde (rename = "triggerId" , default , skip_serializing_if = "std::option::Option::is_none")] pub trigger_id : :: std :: option :: Option < String > , # [doc = "Required. A number to uniquely identify each trigger config within the workflow on UI."] # [serde (rename = "triggerNumber" , default , skip_serializing_if = "std::option::Option::is_none")] pub trigger_number : :: std :: option :: Option < String > , # [serde (rename = "triggerType" , default , skip_serializing_if = "std::option::Option::is_none")] pub trigger_type : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType > , }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmFrontendsEventbusProtoTriggerConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmFrontendsEventbusProtoTriggerConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy {
        #[doc = "Execute all the tasks that satisfy their associated condition."]
        RunAllMatch,
        #[doc = "Execute the first task that satisfies the associated condition."]
        RunFirstMatch,
        #[doc = "Default"]
        Unspecified,
    }
    impl EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: RunAllMatch => "RUN_ALL_MATCH" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: RunFirstMatch => "RUN_FIRST_MATCH" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: Unspecified => "UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy,
            (),
        > {
            Ok (match s { "RUN_ALL_MATCH" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: RunAllMatch , "RUN_FIRST_MATCH" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: RunFirstMatch , "UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: Unspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "RUN_ALL_MATCH" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: RunAllMatch , "RUN_FIRST_MATCH" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: RunFirstMatch , "UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy :: Unspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigNextTasksExecutionPolicy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType {
        Api,
        CloudPubsub,
        CloudPubsubExternal,
        CloudScheduler,
        Cron,
        DatalayerDataChange,
        Goops,
        ManifoldTrigger,
        SfdcCdcChannel,
        SfdcChannel,
        SfdcPlatformEventsChannel,
        SfdcSync,
        Unknown,
    }
    impl EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Api => "API" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudPubsub => "CLOUD_PUBSUB" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudPubsubExternal => "CLOUD_PUBSUB_EXTERNAL" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudScheduler => "CLOUD_SCHEDULER" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Cron => "CRON" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: DatalayerDataChange => "DATALAYER_DATA_CHANGE" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Goops => "GOOPS" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: ManifoldTrigger => "MANIFOLD_TRIGGER" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcCdcChannel => "SFDC_CDC_CHANNEL" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcChannel => "SFDC_CHANNEL" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcPlatformEventsChannel => "SFDC_PLATFORM_EVENTS_CHANNEL" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcSync => "SFDC_SYNC" , EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Unknown => "UNKNOWN" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType, ()>
        {
            Ok (match s { "API" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Api , "CLOUD_PUBSUB" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudPubsub , "CLOUD_PUBSUB_EXTERNAL" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudPubsubExternal , "CLOUD_SCHEDULER" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudScheduler , "CRON" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Cron , "DATALAYER_DATA_CHANGE" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: DatalayerDataChange , "GOOPS" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Goops , "MANIFOLD_TRIGGER" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: ManifoldTrigger , "SFDC_CDC_CHANNEL" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcCdcChannel , "SFDC_CHANNEL" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcChannel , "SFDC_PLATFORM_EVENTS_CHANNEL" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcPlatformEventsChannel , "SFDC_SYNC" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcSync , "UNKNOWN" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Unknown , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "API" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Api , "CLOUD_PUBSUB" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudPubsub , "CLOUD_PUBSUB_EXTERNAL" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudPubsubExternal , "CLOUD_SCHEDULER" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: CloudScheduler , "CRON" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Cron , "DATALAYER_DATA_CHANGE" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: DatalayerDataChange , "GOOPS" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Goops , "MANIFOLD_TRIGGER" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: ManifoldTrigger , "SFDC_CDC_CHANNEL" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcCdcChannel , "SFDC_CHANNEL" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcChannel , "SFDC_PLATFORM_EVENTS_CHANNEL" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcPlatformEventsChannel , "SFDC_SYNC" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: SfdcSync , "UNKNOWN" => EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType :: Unknown , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoTriggerConfigTriggerType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntry {
        #[doc = "Metadata information about the parameters."]
        #[serde(
            rename = "attributes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attributes: ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoAttributes>,
        #[doc = "Child parameters nested within this parameter. This field only applies to protobuf parameters"]
        #[serde(
            rename = "children",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub children: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntry>,
        >,
        #[doc = "The data type of the parameter."]
        #[serde(
            rename = "dataType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType,
        >,
        #[doc = "Default values for the defined keys. Each value can either be string, int, double or any proto message or a serialized object."]
        #[serde(
            rename = "defaultValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_value: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterValueType,
        >,
        #[doc = "Specifies the input/output type for the parameter."]
        #[serde(
            rename = "inOutType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub in_out_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType,
        >,
        #[doc = "Whether this parameter is a transient parameter."]
        #[serde(
            rename = "isTransient",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_transient: ::std::option::Option<bool>,
        #[doc = "This schema will be used to validate runtime JSON-typed values of this parameter."]
        #[serde(
            rename = "jsonSchema",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub json_schema: ::std::option::Option<String>,
        #[doc = "Key is used to retrieve the corresponding parameter value. This should be unique for a given fired event. These parameters must be predefined in the workflow definition."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "The name (without prefix) to be displayed in the UI for this parameter. E.g. if the key is â€œfoo.bar.myNameâ€, then the name would be â€œmyNameâ€."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "The identifier of the node (TaskConfig/TriggerConfig) this parameter was produced by, if it is a transient param or a copy of an input param."]
        #[serde(
            rename = "producedBy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub produced_by:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoNodeIdentifier>,
        #[serde(
            rename = "producer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub producer: ::std::option::Option<String>,
        #[doc = "The name of the protobuf type if the parameter has a protobuf data type."]
        #[serde(
            rename = "protoDefName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_def_name: ::std::option::Option<String>,
        #[doc = "If the data type is of type proto or proto array, this field needs to be populated with the fully qualified proto name. This message, for example, would be â€œenterprise.crm.frontends.eventbus.proto.WorkflowParameterEntryâ€."]
        #[serde(
            rename = "protoDefPath",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub proto_def_path: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntry
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntry
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType {
        BooleanArray,
        BooleanValue,
        #[doc = "BYTES and BYTES_ARRAY data types are not allowed for top-level params. Theyâ€™re only meant to support protobufs with BYTES (sub)fields."]
        Bytes,
        BytesArray,
        DataTypeUnspecified,
        DoubleArray,
        DoubleValue,
        IntArray,
        IntValue,
        JsonValue,
        NonSerializableObject,
        ProtoArray,
        ProtoEnum,
        ProtoEnumArray,
        ProtoValue,
        SerializedObjectValue,
        StringArray,
        StringValue,
    }
    impl EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BooleanArray => "BOOLEAN_ARRAY" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BooleanValue => "BOOLEAN_VALUE" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: Bytes => "BYTES" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BytesArray => "BYTES_ARRAY" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DataTypeUnspecified => "DATA_TYPE_UNSPECIFIED" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DoubleArray => "DOUBLE_ARRAY" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DoubleValue => "DOUBLE_VALUE" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: IntArray => "INT_ARRAY" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: IntValue => "INT_VALUE" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: JsonValue => "JSON_VALUE" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: NonSerializableObject => "NON_SERIALIZABLE_OBJECT" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoArray => "PROTO_ARRAY" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoEnum => "PROTO_ENUM" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoEnumArray => "PROTO_ENUM_ARRAY" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoValue => "PROTO_VALUE" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: SerializedObjectValue => "SERIALIZED_OBJECT_VALUE" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: StringArray => "STRING_ARRAY" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: StringValue => "STRING_VALUE" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType,
            (),
        > {
            Ok (match s { "BOOLEAN_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BooleanArray , "BOOLEAN_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BooleanValue , "BYTES" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: Bytes , "BYTES_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BytesArray , "DATA_TYPE_UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DataTypeUnspecified , "DOUBLE_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DoubleArray , "DOUBLE_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DoubleValue , "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: IntArray , "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: IntValue , "JSON_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: JsonValue , "NON_SERIALIZABLE_OBJECT" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: NonSerializableObject , "PROTO_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoArray , "PROTO_ENUM" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoEnum , "PROTO_ENUM_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoEnumArray , "PROTO_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoValue , "SERIALIZED_OBJECT_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: SerializedObjectValue , "STRING_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: StringArray , "STRING_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: StringValue , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "BOOLEAN_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BooleanArray , "BOOLEAN_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BooleanValue , "BYTES" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: Bytes , "BYTES_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: BytesArray , "DATA_TYPE_UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DataTypeUnspecified , "DOUBLE_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DoubleArray , "DOUBLE_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: DoubleValue , "INT_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: IntArray , "INT_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: IntValue , "JSON_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: JsonValue , "NON_SERIALIZABLE_OBJECT" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: NonSerializableObject , "PROTO_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoArray , "PROTO_ENUM" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoEnum , "PROTO_ENUM_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoEnumArray , "PROTO_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: ProtoValue , "SERIALIZED_OBJECT_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: SerializedObjectValue , "STRING_ARRAY" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: StringArray , "STRING_VALUE" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType :: StringValue , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryDataType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType {
        #[doc = "Input parameters for the workflow. EventBus validates that these parameters exist in the workflows before execution."]
        In,
        #[doc = "Input or Output Parameters. These can be used as both input and output. EventBus will validate for the existence of these parameters before execution and will also return this parameter back in the response."]
        InOut,
        InOutTypeUnspecified,
        #[doc = "Output Parameters for the workflow. EventBus will only return the workflow parameters tagged with OUT in the response back."]
        Out,
    }
    impl EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType {
        pub fn as_str(self) -> &'static str {
            match self { EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: In => "IN" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: InOut => "IN_OUT" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: InOutTypeUnspecified => "IN_OUT_TYPE_UNSPECIFIED" , EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: Out => "OUT" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType,
            (),
        > {
            Ok (match s { "IN" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: In , "IN_OUT" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: InOut , "IN_OUT_TYPE_UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: InOutTypeUnspecified , "OUT" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: Out , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "IN" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: In , "IN_OUT" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: InOut , "IN_OUT_TYPE_UNSPECIFIED" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: InOutTypeUnspecified , "OUT" => EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType :: Out , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntryInOutType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct EnterpriseCrmFrontendsEventbusProtoWorkflowParameters {
        #[doc = "Parameters are a part of Event and can be used to communiticate between different tasks that are part of the same workflow execution."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoWorkflowParameterEntry>,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameters
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnterpriseCrmFrontendsEventbusProtoWorkflowParameters
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmLoggingGwsFieldLimits {
        #[serde(
            rename = "logAction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_action:
            ::std::option::Option<crate::schemas::EnterpriseCrmLoggingGwsFieldLimitsLogAction>,
        #[doc = "To which type(s) of logs the limits apply."]
        #[serde(
            rename = "logType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_type: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems>,
        >,
        #[doc = "maximum array size. If the array exceds this size, the field (list) is truncated."]
        #[serde(
            rename = "maxArraySize",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_array_size: ::std::option::Option<i32>,
        #[doc = "maximum string length. If the field exceeds this amount the field is shortened."]
        #[serde(
            rename = "maxStringLength",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_string_length: ::std::option::Option<i32>,
        #[serde(
            rename = "shortenerType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shortener_type:
            ::std::option::Option<crate::schemas::EnterpriseCrmLoggingGwsFieldLimitsShortenerType>,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmLoggingGwsFieldLimits {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmLoggingGwsFieldLimits {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        DontLog,
        Log,
        LogActionUnspecified,
    }
    impl EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmLoggingGwsFieldLimitsLogAction::DontLog => "DONT_LOG",
                EnterpriseCrmLoggingGwsFieldLimitsLogAction::Log => "LOG",
                EnterpriseCrmLoggingGwsFieldLimitsLogAction::LogActionUnspecified => {
                    "LOG_ACTION_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmLoggingGwsFieldLimitsLogAction, ()> {
            Ok(match s {
                "DONT_LOG" => EnterpriseCrmLoggingGwsFieldLimitsLogAction::DontLog,
                "LOG" => EnterpriseCrmLoggingGwsFieldLimitsLogAction::Log,
                "LOG_ACTION_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsFieldLimitsLogAction::LogActionUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DONT_LOG" => EnterpriseCrmLoggingGwsFieldLimitsLogAction::DontLog,
                "LOG" => EnterpriseCrmLoggingGwsFieldLimitsLogAction::Log,
                "LOG_ACTION_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsFieldLimitsLogAction::LogActionUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmLoggingGwsFieldLimitsLogAction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        #[doc = "Limits apply to *all* output log types."]
        All,
        #[doc = "Limits apply when log detail records are written to GTS (e.g., RecordIO files)."]
        Gts,
        #[doc = "Limits apply when log detail records are written to GWS."]
        Gws,
        LogTypeUnspecified,
    }
    impl EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::All => "ALL",
                EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::Gts => "GTS",
                EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::Gws => "GWS",
                EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::LogTypeUnspecified => {
                    "LOG_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems, ()> {
            Ok(match s {
                "ALL" => EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::All,
                "GTS" => EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::Gts,
                "GWS" => EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::Gws,
                "LOG_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::LogTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ALL" => EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::All,
                "GTS" => EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::Gts,
                "GWS" => EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::Gws,
                "LOG_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems::LogTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmLoggingGwsFieldLimitsLogTypeItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        #[doc = "String is replaced by its hex-string hash."]
        Hash,
        #[doc = "String is shortened to max_string_length."]
        Shorten,
        #[doc = "Shortens a domain name (e.g., as part of an email address or URL)."]
        ShortenDomain,
        #[doc = "String shortening for email addresses. Shortening may be done on the user and/or domain portion of the email address."]
        ShortenEmail,
        #[doc = "String is replaced by a combination of string shortening and a hex-string hash for an email address."]
        ShortenEmailWithHash,
        #[doc = "String is replaced by a combination of string shortening and a hex-string hash."]
        ShortenWithHash,
        ShortenerTypeUnspecified,
    }
    impl EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmLoggingGwsFieldLimitsShortenerType::Hash => "HASH",
                EnterpriseCrmLoggingGwsFieldLimitsShortenerType::Shorten => "SHORTEN",
                EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenDomain => "SHORTEN_DOMAIN",
                EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenEmail => "SHORTEN_EMAIL",
                EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenEmailWithHash => {
                    "SHORTEN_EMAIL_WITH_HASH"
                }
                EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenWithHash => {
                    "SHORTEN_WITH_HASH"
                }
                EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenerTypeUnspecified => {
                    "SHORTENER_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmLoggingGwsFieldLimitsShortenerType, ()> {
            Ok(match s {
                "HASH" => EnterpriseCrmLoggingGwsFieldLimitsShortenerType::Hash,
                "SHORTEN" => EnterpriseCrmLoggingGwsFieldLimitsShortenerType::Shorten,
                "SHORTEN_DOMAIN" => EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenDomain,
                "SHORTEN_EMAIL" => EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenEmail,
                "SHORTEN_EMAIL_WITH_HASH" => {
                    EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenEmailWithHash
                }
                "SHORTEN_WITH_HASH" => {
                    EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenWithHash
                }
                "SHORTENER_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenerTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "HASH" => EnterpriseCrmLoggingGwsFieldLimitsShortenerType::Hash,
                "SHORTEN" => EnterpriseCrmLoggingGwsFieldLimitsShortenerType::Shorten,
                "SHORTEN_DOMAIN" => EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenDomain,
                "SHORTEN_EMAIL" => EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenEmail,
                "SHORTEN_EMAIL_WITH_HASH" => {
                    EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenEmailWithHash
                }
                "SHORTEN_WITH_HASH" => {
                    EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenWithHash
                }
                "SHORTENER_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsFieldLimitsShortenerType::ShortenerTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmLoggingGwsFieldLimitsShortenerType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnterpriseCrmLoggingGwsSanitizeOptions {
        #[doc = "If true, the value has already been sanitized and needs no further sanitization. For instance, a D3 customer id is already an obfuscated entity and *might not* need further sanitization."]
        #[serde(
            rename = "isAlreadySanitized",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_already_sanitized: ::std::option::Option<bool>,
        #[doc = "To which type(s) of logs the sanitize options apply."]
        #[serde(
            rename = "logType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub log_type: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems>,
        >,
        #[serde(
            rename = "privacy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub privacy:
            ::std::option::Option<crate::schemas::EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy>,
        #[serde(
            rename = "sanitizeType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sanitize_type: ::std::option::Option<
            crate::schemas::EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmLoggingGwsSanitizeOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmLoggingGwsSanitizeOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        #[doc = "Limits apply to *all* output log types."]
        All,
        #[doc = "Limits apply when log detail records are written to GTS (e.g., RecordIO files)."]
        Gts,
        #[doc = "Limits apply when log detail records are written to GWS."]
        Gws,
        LogTypeUnspecified,
    }
    impl EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::All => "ALL",
                EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::Gts => "GTS",
                EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::Gws => "GWS",
                EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::LogTypeUnspecified => {
                    "LOG_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems, ()> {
            Ok(match s {
                "ALL" => EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::All,
                "GTS" => EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::Gts,
                "GWS" => EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::Gws,
                "LOG_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::LogTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ALL" => EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::All,
                "GTS" => EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::Gts,
                "GWS" => EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::Gws,
                "LOG_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems::LogTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeItems {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        #[doc = "Field does *NOT* contain PII or sensitive data."]
        NotPii,
        #[doc = "Field contains PII."]
        Pii,
        PrivacyTypeUnspecified,
        #[doc = "Field contains Sensitive PII."]
        Spii,
        #[doc = "Unsure if field contains PII."]
        Unsure,
    }
    impl EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::NotPii => "NOT_PII",
                EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Pii => "PII",
                EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::PrivacyTypeUnspecified => {
                    "PRIVACY_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Spii => "SPII",
                EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Unsure => "UNSURE",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy, ()> {
            Ok(match s {
                "NOT_PII" => EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::NotPii,
                "PII" => EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Pii,
                "PRIVACY_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::PrivacyTypeUnspecified
                }
                "SPII" => EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Spii,
                "UNSURE" => EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Unsure,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "NOT_PII" => EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::NotPii,
                "PII" => EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Pii,
                "PRIVACY_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::PrivacyTypeUnspecified
                }
                "SPII" => EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Spii,
                "UNSURE" => EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy::Unsure,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmLoggingGwsSanitizeOptionsPrivacy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        #[doc = "Transform a value so that it cannot be tracked across events. However, a given value, is transformed to the same value *within* an event. E.g., â€œfoo.comâ€ is transformed to â€œ0xabcdefâ€ for event 1001, and to â€œ0xfedcbaâ€ for event 1002."]
        Anonymize,
        #[doc = "Transform values as with ANONYMIZER, but the same transformation is repeated for a limited time (e.g., 1 day)."]
        AnonymizeLimitedRepeatable,
        #[doc = "No sanitization is required."]
        DoNotSanitize,
        #[doc = "The value is encrypted."]
        Encrypt,
        #[doc = "The value is transformed using a well-defined obfuscator (e.g., D3_CUSTOMER_ID)."]
        Obfuscate,
        SanitizeTypeUnspecified,
        #[doc = "Replace value with a scrubbed value (usu. a constant)."]
        Scrub,
    }
    impl EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        pub fn as_str(self) -> &'static str {
            match self {
                EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Anonymize => "ANONYMIZE",
                EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::AnonymizeLimitedRepeatable => {
                    "ANONYMIZE_LIMITED_REPEATABLE"
                }
                EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::DoNotSanitize => {
                    "DO_NOT_SANITIZE"
                }
                EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Encrypt => "ENCRYPT",
                EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Obfuscate => "OBFUSCATE",
                EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::SanitizeTypeUnspecified => {
                    "SANITIZE_TYPE_UNSPECIFIED"
                }
                EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Scrub => "SCRUB",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType, ()> {
            Ok(match s {
                "ANONYMIZE" => EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Anonymize,
                "ANONYMIZE_LIMITED_REPEATABLE" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::AnonymizeLimitedRepeatable
                }
                "DO_NOT_SANITIZE" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::DoNotSanitize
                }
                "ENCRYPT" => EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Encrypt,
                "OBFUSCATE" => EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Obfuscate,
                "SANITIZE_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::SanitizeTypeUnspecified
                }
                "SCRUB" => EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Scrub,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ANONYMIZE" => EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Anonymize,
                "ANONYMIZE_LIMITED_REPEATABLE" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::AnonymizeLimitedRepeatable
                }
                "DO_NOT_SANITIZE" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::DoNotSanitize
                }
                "ENCRYPT" => EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Encrypt,
                "OBFUSCATE" => EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Obfuscate,
                "SANITIZE_TYPE_UNSPECIFIED" => {
                    EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::SanitizeTypeUnspecified
                }
                "SCRUB" => EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType::Scrub,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1AuthConfig {
        #[doc = "List containing additional auth configs."]
        #[serde(
            rename = "additionalVariables",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub additional_variables:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudConnectorsV1ConfigVariable>>,
        #[doc = "The type of authentication configured."]
        #[serde(
            rename = "authType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_type:
            ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1AuthConfigAuthType>,
        #[doc = "Oauth2ClientCredentials."]
        #[serde(
            rename = "oauth2ClientCredentials",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oauth_2_client_credentials: ::std::option::Option<
            crate::schemas::GoogleCloudConnectorsV1AuthConfigOauth2ClientCredentials,
        >,
        #[doc = "Oauth2JwtBearer."]
        #[serde(
            rename = "oauth2JwtBearer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oauth_2_jwt_bearer:
            ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1AuthConfigOauth2JwtBearer>,
        #[doc = "SSH Public Key."]
        #[serde(
            rename = "sshPublicKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ssh_public_key:
            ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1AuthConfigSshPublicKey>,
        #[doc = "UserPassword."]
        #[serde(
            rename = "userPassword",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub user_password:
            ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1AuthConfigUserPassword>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1AuthConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1AuthConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudConnectorsV1AuthConfigAuthType {
        #[doc = "Authentication type not specified."]
        AuthTypeUnspecified,
        #[doc = "Oauth 2.0 Authorization Code Flow"]
        Oauth2AuthCodeFlow,
        #[doc = "Oauth 2.0 Client Credentials Grant Authentication"]
        Oauth2ClientCredentials,
        #[doc = "JSON Web Token (JWT) Profile for Oauth 2.0 Authorization Grant based authentication"]
        Oauth2JwtBearer,
        #[doc = "SSH Public Key Authentication"]
        SshPublicKey,
        #[doc = "Username and Password Authentication."]
        UserPassword,
    }
    impl GoogleCloudConnectorsV1AuthConfigAuthType {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudConnectorsV1AuthConfigAuthType::AuthTypeUnspecified => {
                    "AUTH_TYPE_UNSPECIFIED"
                }
                GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2AuthCodeFlow => {
                    "OAUTH2_AUTH_CODE_FLOW"
                }
                GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2ClientCredentials => {
                    "OAUTH2_CLIENT_CREDENTIALS"
                }
                GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2JwtBearer => "OAUTH2_JWT_BEARER",
                GoogleCloudConnectorsV1AuthConfigAuthType::SshPublicKey => "SSH_PUBLIC_KEY",
                GoogleCloudConnectorsV1AuthConfigAuthType::UserPassword => "USER_PASSWORD",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudConnectorsV1AuthConfigAuthType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudConnectorsV1AuthConfigAuthType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudConnectorsV1AuthConfigAuthType, ()> {
            Ok(match s {
                "AUTH_TYPE_UNSPECIFIED" => {
                    GoogleCloudConnectorsV1AuthConfigAuthType::AuthTypeUnspecified
                }
                "OAUTH2_AUTH_CODE_FLOW" => {
                    GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2AuthCodeFlow
                }
                "OAUTH2_CLIENT_CREDENTIALS" => {
                    GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2ClientCredentials
                }
                "OAUTH2_JWT_BEARER" => GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2JwtBearer,
                "SSH_PUBLIC_KEY" => GoogleCloudConnectorsV1AuthConfigAuthType::SshPublicKey,
                "USER_PASSWORD" => GoogleCloudConnectorsV1AuthConfigAuthType::UserPassword,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudConnectorsV1AuthConfigAuthType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudConnectorsV1AuthConfigAuthType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudConnectorsV1AuthConfigAuthType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "AUTH_TYPE_UNSPECIFIED" => {
                    GoogleCloudConnectorsV1AuthConfigAuthType::AuthTypeUnspecified
                }
                "OAUTH2_AUTH_CODE_FLOW" => {
                    GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2AuthCodeFlow
                }
                "OAUTH2_CLIENT_CREDENTIALS" => {
                    GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2ClientCredentials
                }
                "OAUTH2_JWT_BEARER" => GoogleCloudConnectorsV1AuthConfigAuthType::Oauth2JwtBearer,
                "SSH_PUBLIC_KEY" => GoogleCloudConnectorsV1AuthConfigAuthType::SshPublicKey,
                "USER_PASSWORD" => GoogleCloudConnectorsV1AuthConfigAuthType::UserPassword,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1AuthConfigAuthType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1AuthConfigAuthType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1AuthConfigOauth2ClientCredentials {
        #[doc = "The client identifier."]
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "Secret version reference containing the client secret."]
        #[serde(
            rename = "clientSecret",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_secret: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1Secret>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudConnectorsV1AuthConfigOauth2ClientCredentials
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudConnectorsV1AuthConfigOauth2ClientCredentials
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1AuthConfigOauth2JwtBearer {
        #[doc = "Secret version reference containing a PKCS#8 PEM-encoded private key associated with the Client Certificate. This private key will be used to sign JWTs used for the jwt-bearer authorization grant. Specified in the form as: `projects/*/secrets/*/versions/*`."]
        #[serde(
            rename = "clientKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_key: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1Secret>,
        #[doc = "JwtClaims providers fields to generate the token."]
        #[serde(
            rename = "jwtClaims",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub jwt_claims: ::std::option::Option<
            crate::schemas::GoogleCloudConnectorsV1AuthConfigOauth2JwtBearerJwtClaims,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1AuthConfigOauth2JwtBearer {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1AuthConfigOauth2JwtBearer {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1AuthConfigOauth2JwtBearerJwtClaims {
        #[doc = "Value for the â€œaudâ€ claim."]
        #[serde(
            rename = "audience",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub audience: ::std::option::Option<String>,
        #[doc = "Value for the â€œissâ€ claim."]
        #[serde(
            rename = "issuer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub issuer: ::std::option::Option<String>,
        #[doc = "Value for the â€œsubâ€ claim."]
        #[serde(
            rename = "subject",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub subject: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudConnectorsV1AuthConfigOauth2JwtBearerJwtClaims
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudConnectorsV1AuthConfigOauth2JwtBearerJwtClaims
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1AuthConfigSshPublicKey {
        #[doc = "Format of SSH Client cert."]
        #[serde(
            rename = "certType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cert_type: ::std::option::Option<String>,
        #[doc = "SSH Client Cert. It should contain both public and private key."]
        #[serde(
            rename = "sshClientCert",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ssh_client_cert: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1Secret>,
        #[doc = "Password (passphrase) for ssh client certificate if it has one."]
        #[serde(
            rename = "sshClientCertPass",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ssh_client_cert_pass:
            ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1Secret>,
        #[doc = "The user account used to authenticate."]
        #[serde(
            rename = "username",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub username: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1AuthConfigSshPublicKey {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1AuthConfigSshPublicKey {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1AuthConfigUserPassword {
        #[doc = "Secret version reference containing the password."]
        #[serde(
            rename = "password",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub password: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1Secret>,
        #[doc = "Username."]
        #[serde(
            rename = "username",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub username: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1AuthConfigUserPassword {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1AuthConfigUserPassword {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1ConfigVariable {
        #[doc = "Value is a bool."]
        #[serde(
            rename = "boolValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bool_value: ::std::option::Option<bool>,
        #[doc = "Value is an integer"]
        #[serde(
            rename = "intValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub int_value: ::std::option::Option<i64>,
        #[doc = "Key of the config variable."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "Value is a secret."]
        #[serde(
            rename = "secretValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub secret_value: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1Secret>,
        #[doc = "Value is a string."]
        #[serde(
            rename = "stringValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1ConfigVariable {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1ConfigVariable {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1Connection {
        #[doc = "Optional. Configuration for establishing the connectionâ€™s authentication with an external system."]
        #[serde(
            rename = "authConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_config: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1AuthConfig>,
        #[doc = "Optional. Configuration for configuring the connection with an external system."]
        #[serde(
            rename = "configVariables",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub config_variables:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudConnectorsV1ConfigVariable>>,
        #[doc = "Required. Connector version on which the connection is created. The format is: projects/*/locations/*/providers/*/connectors/*/versions/\\* Only global location is supported for ConnectorVersion resource."]
        #[serde(
            rename = "connectorVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connector_version: ::std::option::Option<String>,
        #[doc = "Output only. Created time."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Optional. Description of the resource."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Optional. Configuration of the Connectorâ€™s destination. Only accepted for Connectors that accepts user defined destination(s)."]
        #[serde(
            rename = "destinationConfigs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub destination_configs:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudConnectorsV1DestinationConfig>>,
        #[doc = "Output only. GCR location where the envoy image is stored. formatted like: gcr.io/{bucketName}/{imageName}"]
        #[serde(
            rename = "envoyImageLocation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub envoy_image_location: ::std::option::Option<String>,
        #[doc = "Output only. GCR location where the runtime image is stored. formatted like: gcr.io/{bucketName}/{imageName}"]
        #[serde(
            rename = "imageLocation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub image_location: ::std::option::Option<String>,
        #[doc = "Optional. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources"]
        #[serde(
            rename = "labels",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub labels: ::std::option::Option<::std::collections::BTreeMap<String, String>>,
        #[doc = "Optional. Configuration that indicates whether or not the Connection can be edited."]
        #[serde(
            rename = "lockConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lock_config: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1LockConfig>,
        #[doc = "Output only. Resource name of the Connection. Format: projects/{project}/locations/{location}/connections/{connection}"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Optional. Node configuration for the connection."]
        #[serde(
            rename = "nodeConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub node_config: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1NodeConfig>,
        #[doc = "Optional. Service account needed for runtime plane to access GCP resources."]
        #[serde(
            rename = "serviceAccount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_account: ::std::option::Option<String>,
        #[doc = "Output only. The name of the Service Directory service name. Used for Private Harpoon to resolve the ILB address. e.g. â€œprojects/cloud-connectors-e2e-testing/locations/us-central1/namespaces/istio-system/services/istio-ingressgateway-connectorsâ€"]
        #[serde(
            rename = "serviceDirectory",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_directory: ::std::option::Option<String>,
        #[doc = "Output only. Current status of the connection."]
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status: ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1ConnectionStatus>,
        #[doc = "Optional. Suspended indicates if a user has suspended a connection or not."]
        #[serde(
            rename = "suspended",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspended: ::std::option::Option<bool>,
        #[doc = "Output only. Updated time."]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1Connection {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1Connection {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1ConnectionStatus {
        #[doc = "Description."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "State."]
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state:
            ::std::option::Option<crate::schemas::GoogleCloudConnectorsV1ConnectionStatusState>,
        #[doc = "Status provides detailed information for the state."]
        #[serde(
            rename = "status",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub status: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1ConnectionStatus {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1ConnectionStatus {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudConnectorsV1ConnectionStatusState {
        #[doc = "Connection is running and ready for requests."]
        Active,
        #[doc = "Connection is being created."]
        Creating,
        #[doc = "Connection is being deleted."]
        Deleting,
        #[doc = "Connection is not running due to an error."]
        Error,
        #[doc = "Connection is stopped."]
        Inactive,
        #[doc = "Connection does not have a state yet."]
        StateUnspecified,
        #[doc = "Connection is being updated."]
        Updating,
    }
    impl GoogleCloudConnectorsV1ConnectionStatusState {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudConnectorsV1ConnectionStatusState::Active => "ACTIVE",
                GoogleCloudConnectorsV1ConnectionStatusState::Creating => "CREATING",
                GoogleCloudConnectorsV1ConnectionStatusState::Deleting => "DELETING",
                GoogleCloudConnectorsV1ConnectionStatusState::Error => "ERROR",
                GoogleCloudConnectorsV1ConnectionStatusState::Inactive => "INACTIVE",
                GoogleCloudConnectorsV1ConnectionStatusState::StateUnspecified => {
                    "STATE_UNSPECIFIED"
                }
                GoogleCloudConnectorsV1ConnectionStatusState::Updating => "UPDATING",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudConnectorsV1ConnectionStatusState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudConnectorsV1ConnectionStatusState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudConnectorsV1ConnectionStatusState, ()> {
            Ok(match s {
                "ACTIVE" => GoogleCloudConnectorsV1ConnectionStatusState::Active,
                "CREATING" => GoogleCloudConnectorsV1ConnectionStatusState::Creating,
                "DELETING" => GoogleCloudConnectorsV1ConnectionStatusState::Deleting,
                "ERROR" => GoogleCloudConnectorsV1ConnectionStatusState::Error,
                "INACTIVE" => GoogleCloudConnectorsV1ConnectionStatusState::Inactive,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudConnectorsV1ConnectionStatusState::StateUnspecified
                }
                "UPDATING" => GoogleCloudConnectorsV1ConnectionStatusState::Updating,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudConnectorsV1ConnectionStatusState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudConnectorsV1ConnectionStatusState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudConnectorsV1ConnectionStatusState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVE" => GoogleCloudConnectorsV1ConnectionStatusState::Active,
                "CREATING" => GoogleCloudConnectorsV1ConnectionStatusState::Creating,
                "DELETING" => GoogleCloudConnectorsV1ConnectionStatusState::Deleting,
                "ERROR" => GoogleCloudConnectorsV1ConnectionStatusState::Error,
                "INACTIVE" => GoogleCloudConnectorsV1ConnectionStatusState::Inactive,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudConnectorsV1ConnectionStatusState::StateUnspecified
                }
                "UPDATING" => GoogleCloudConnectorsV1ConnectionStatusState::Updating,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1ConnectionStatusState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1ConnectionStatusState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1Destination {
        #[doc = "For publicly routable host."]
        #[serde(
            rename = "host",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub host: ::std::option::Option<String>,
        #[doc = "The port is the target port number that is accepted by the destination."]
        #[serde(
            rename = "port",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub port: ::std::option::Option<i32>,
        #[doc = "PSC service attachments. Format: projects/*/regions/*/serviceAttachments/\\*"]
        #[serde(
            rename = "serviceAttachment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_attachment: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1Destination {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1Destination {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1DestinationConfig {
        #[doc = "The destinations for the key."]
        #[serde(
            rename = "destinations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub destinations:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudConnectorsV1Destination>>,
        #[doc = "The key is the destination identifier that is supported by the Connector."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1DestinationConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1DestinationConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1LockConfig {
        #[doc = "Indicates whether or not the connection is locked."]
        #[serde(
            rename = "locked",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub locked: ::std::option::Option<bool>,
        #[doc = "Describes why a connection is locked."]
        #[serde(
            rename = "reason",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reason: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1LockConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1LockConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1NodeConfig {
        #[doc = "Maximum number of nodes in the runtime nodes."]
        #[serde(
            rename = "maxNodeCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_node_count: ::std::option::Option<i32>,
        #[doc = "Minimum number of nodes in the runtime nodes."]
        #[serde(
            rename = "minNodeCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub min_node_count: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1NodeConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1NodeConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudConnectorsV1Secret {
        #[doc = "The resource name of the secret version in the format, format as: `projects/*/secrets/*/versions/*`."]
        #[serde(
            rename = "secretVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub secret_version: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudConnectorsV1Secret {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudConnectorsV1Secret {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaAccessToken {
        #[doc = "The access token encapsulating the security identity of a process or thread."]
        #[serde(
            rename = "accessToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_token: ::std::option::Option<String>,
        #[doc = "Required. The approximate time until the access token retrieved is valid."]
        #[serde(
            rename = "accessTokenExpireTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_token_expire_time: ::std::option::Option<String>,
        #[doc = "If the access token will expire, use the refresh token to obtain another access token."]
        #[serde(
            rename = "refreshToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub refresh_token: ::std::option::Option<String>,
        #[doc = "The approximate time until the refresh token retrieved is valid."]
        #[serde(
            rename = "refreshTokenExpireTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub refresh_token_expire_time: ::std::option::Option<String>,
        #[doc = "Only support â€œbearerâ€ token in v1 as bearer token is the predominant type used with OAuth 2.0."]
        #[serde(
            rename = "tokenType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_type: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaAccessToken {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaAccessToken {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaAttemptStats {
        #[doc = "The end time of the event execution for current attempt."]
        #[serde(
            rename = "endTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub end_time: ::std::option::Option<String>,
        #[doc = "The start time of the event execution for current attempt. This could be in the future if itâ€™s been scheduled."]
        #[serde(
            rename = "startTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaAttemptStats {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaAttemptStats {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaAuthConfig {
        #[doc = "Certificate id for client certificate"]
        #[serde(
            rename = "certificateId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub certificate_id: ::std::option::Option<String>,
        #[doc = "Output only. The timestamp when the auth config is created."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "The creatorâ€™s email address. Generated based on the End User Credentials/LOAS role of the user making the call."]
        #[serde(
            rename = "creatorEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub creator_email: ::std::option::Option<String>,
        #[doc = "Credential type of the encrypted credential."]
        #[serde(
            rename = "credentialType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub credential_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType,
        >,
        #[doc = "Raw auth credentials."]
        #[serde(
            rename = "decryptedCredential",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub decrypted_credential:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaCredential>,
        #[doc = "A description of the auth config."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "The name of the auth config."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Auth credential encrypted by Cloud KMS. Can be decrypted as Credential with proper KMS key."]
        #[serde(
            rename = "encryptedCredential",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub encrypted_credential: ::std::option::Option<::google_api_bytes::Bytes>,
        #[doc = "User can define the time to receive notification after which the auth config becomes invalid. Support up to 30 days. Support granularity in hours."]
        #[serde(
            rename = "expiryNotificationDuration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub expiry_notification_duration: ::std::option::Option<Vec<String>>,
        #[doc = "The last modifierâ€™s email address. Generated based on the End User Credentials/LOAS role of the user making the call."]
        #[serde(
            rename = "lastModifierEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_modifier_email: ::std::option::Option<String>,
        #[doc = "Resource name of the SFDC instance projects/{project}/locations/{location}/authConfigs/{authConfig}."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "User provided expiry time to override. For the example of Salesforce, username/password credentials can be valid for 6 months depending on the instance settings."]
        #[serde(
            rename = "overrideValidTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub override_valid_time: ::std::option::Option<String>,
        #[doc = "The reason / details of the current status."]
        #[serde(
            rename = "reason",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reason: ::std::option::Option<String>,
        #[doc = "The status of the auth config."]
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfigState>,
        #[doc = "Output only. The timestamp when the auth config is modified."]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
        #[doc = "The time until the auth config is valid. Empty or max value is considered the auth config wonâ€™t expire."]
        #[serde(
            rename = "validTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub valid_time: ::std::option::Option<String>,
        #[doc = "The visibility of the auth config."]
        #[serde(
            rename = "visibility",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub visibility: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfigVisibility,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaAuthConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaAuthConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType {
        #[doc = "API key."]
        ApiKey,
        #[doc = "Auth Token, e.g. bearer token."]
        AuthToken,
        #[doc = "Client Certificate only."]
        ClientCertificateOnly,
        #[doc = "Unspecified credential type"]
        CredentialTypeUnspecified,
        #[doc = "JWT Token."]
        Jwt,
        #[doc = "OAuth 2.0 Authorization Code Grant Type."]
        Oauth2AuthorizationCode,
        #[doc = "OAuth 2.0 Client Credentials Grant Type."]
        Oauth2ClientCredentials,
        #[doc = "OAuth 2.0 Implicit Grant Type."]
        Oauth2Implicit,
        #[doc = "OAuth 2.0 Resource Owner Credentials Grant Type."]
        Oauth2ResourceOwnerCredentials,
        #[doc = "Google OIDC ID Token"]
        OidcToken,
        #[doc = "Service Account which can be used to generate token for authentication."]
        ServiceAccount,
        #[doc = "Regular username/password pair."]
        UsernameAndPassword,
    }
    impl GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ApiKey => "API_KEY" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: AuthToken => "AUTH_TOKEN" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ClientCertificateOnly => "CLIENT_CERTIFICATE_ONLY" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: CredentialTypeUnspecified => "CREDENTIAL_TYPE_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Jwt => "JWT" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2AuthorizationCode => "OAUTH2_AUTHORIZATION_CODE" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2ClientCredentials => "OAUTH2_CLIENT_CREDENTIALS" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2Implicit => "OAUTH2_IMPLICIT" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2ResourceOwnerCredentials => "OAUTH2_RESOURCE_OWNER_CREDENTIALS" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: OidcToken => "OIDC_TOKEN" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ServiceAccount => "SERVICE_ACCOUNT" , GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: UsernameAndPassword => "USERNAME_AND_PASSWORD" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType, ()>
        {
            Ok (match s { "API_KEY" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ApiKey , "AUTH_TOKEN" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: AuthToken , "CLIENT_CERTIFICATE_ONLY" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ClientCertificateOnly , "CREDENTIAL_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: CredentialTypeUnspecified , "JWT" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Jwt , "OAUTH2_AUTHORIZATION_CODE" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2AuthorizationCode , "OAUTH2_CLIENT_CREDENTIALS" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2ClientCredentials , "OAUTH2_IMPLICIT" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2Implicit , "OAUTH2_RESOURCE_OWNER_CREDENTIALS" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2ResourceOwnerCredentials , "OIDC_TOKEN" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: OidcToken , "SERVICE_ACCOUNT" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ServiceAccount , "USERNAME_AND_PASSWORD" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: UsernameAndPassword , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "API_KEY" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ApiKey , "AUTH_TOKEN" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: AuthToken , "CLIENT_CERTIFICATE_ONLY" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ClientCertificateOnly , "CREDENTIAL_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: CredentialTypeUnspecified , "JWT" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Jwt , "OAUTH2_AUTHORIZATION_CODE" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2AuthorizationCode , "OAUTH2_CLIENT_CREDENTIALS" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2ClientCredentials , "OAUTH2_IMPLICIT" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2Implicit , "OAUTH2_RESOURCE_OWNER_CREDENTIALS" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: Oauth2ResourceOwnerCredentials , "OIDC_TOKEN" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: OidcToken , "SERVICE_ACCOUNT" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: ServiceAccount , "USERNAME_AND_PASSWORD" => GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType :: UsernameAndPassword , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaAuthConfigCredentialType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaAuthConfigState {
        #[doc = "Auth config expired."]
        Expired,
        #[doc = "General invalidity, if it doesnâ€™t fits in the detailed issue below."]
        Invalid,
        #[doc = "Auth config soft deleted."]
        SoftDeleted,
        #[doc = "Status not specified."]
        StateUnspecified,
        #[doc = "Auth config unauthorized."]
        Unauthorized,
        #[doc = "Auth config not supported."]
        Unsupported,
        #[doc = "Valid Auth config."]
        Valid,
    }
    impl GoogleCloudIntegrationsV1AlphaAuthConfigState {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudIntegrationsV1AlphaAuthConfigState::Expired => "EXPIRED",
                GoogleCloudIntegrationsV1AlphaAuthConfigState::Invalid => "INVALID",
                GoogleCloudIntegrationsV1AlphaAuthConfigState::SoftDeleted => "SOFT_DELETED",
                GoogleCloudIntegrationsV1AlphaAuthConfigState::StateUnspecified => {
                    "STATE_UNSPECIFIED"
                }
                GoogleCloudIntegrationsV1AlphaAuthConfigState::Unauthorized => "UNAUTHORIZED",
                GoogleCloudIntegrationsV1AlphaAuthConfigState::Unsupported => "UNSUPPORTED",
                GoogleCloudIntegrationsV1AlphaAuthConfigState::Valid => "VALID",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaAuthConfigState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaAuthConfigState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaAuthConfigState, ()> {
            Ok(match s {
                "EXPIRED" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Expired,
                "INVALID" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Invalid,
                "SOFT_DELETED" => GoogleCloudIntegrationsV1AlphaAuthConfigState::SoftDeleted,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaAuthConfigState::StateUnspecified
                }
                "UNAUTHORIZED" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Unauthorized,
                "UNSUPPORTED" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Unsupported,
                "VALID" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Valid,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaAuthConfigState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaAuthConfigState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaAuthConfigState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "EXPIRED" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Expired,
                "INVALID" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Invalid,
                "SOFT_DELETED" => GoogleCloudIntegrationsV1AlphaAuthConfigState::SoftDeleted,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaAuthConfigState::StateUnspecified
                }
                "UNAUTHORIZED" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Unauthorized,
                "UNSUPPORTED" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Unsupported,
                "VALID" => GoogleCloudIntegrationsV1AlphaAuthConfigState::Valid,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaAuthConfigState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaAuthConfigState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        #[doc = "Visibility not specified."]
        AuthConfigVisibilityUnspecified,
        #[doc = "Profile visible within the client."]
        ClientVisible,
        #[doc = "Profile visible to the creator only."]
        Private,
    }
    impl GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: AuthConfigVisibilityUnspecified => "AUTH_CONFIG_VISIBILITY_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: ClientVisible => "CLIENT_VISIBLE" , GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: Private => "PRIVATE" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaAuthConfigVisibility, ()> {
            Ok (match s { "AUTH_CONFIG_VISIBILITY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: AuthConfigVisibilityUnspecified , "CLIENT_VISIBLE" => GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: ClientVisible , "PRIVATE" => GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: Private , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "AUTH_CONFIG_VISIBILITY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: AuthConfigVisibilityUnspecified , "CLIENT_VISIBLE" => GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: ClientVisible , "PRIVATE" => GoogleCloudIntegrationsV1AlphaAuthConfigVisibility :: Private , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaAuthConfigVisibility {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaAuthToken {
        #[doc = "Authentication type, e.g. â€œBasicâ€, â€œBearerâ€, etc."]
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub r#type: ::std::option::Option<String>,
        #[doc = "The token for the auth type."]
        #[serde(
            rename = "token",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaAuthToken {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaAuthToken {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaBooleanParameterArray {
        #[doc = "Boolean array."]
        #[serde(
            rename = "booleanValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_values: ::std::option::Option<Vec<bool>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaBooleanParameterArray
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaBooleanParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaCancelExecutionRequest {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaCancelExecutionRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaCancelExecutionRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaCancelExecutionResponse {
        #[doc = "True if cancellation performed successfully"]
        #[serde(
            rename = "isCanceled",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_canceled: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaCancelExecutionResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaCancelExecutionResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaCertificate {
        #[doc = "Status of the certificate"]
        #[serde(
            rename = "certificateStatus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub certificate_status: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus,
        >,
        #[doc = "Immutable. Credential id that will be used to register with trawler INTERNAL_ONLY"]
        #[serde(
            rename = "credentialId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub credential_id: ::std::option::Option<String>,
        #[doc = "Description of the certificate"]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Name of the certificate"]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Output only. Auto generated primary key"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Input only. Raw client certificate which would be registered with trawler"]
        #[serde(
            rename = "rawCertificate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub raw_certificate:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaClientCertificate>,
        #[doc = "Immutable. Requestor ID to be used to register certificate with trawler"]
        #[serde(
            rename = "requestorId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub requestor_id: ::std::option::Option<String>,
        #[doc = "Output only. The timestamp after which certificate will expire"]
        #[serde(
            rename = "validEndTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub valid_end_time: ::std::option::Option<String>,
        #[doc = "Output only. The timestamp after which certificate will be valid"]
        #[serde(
            rename = "validStartTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub valid_start_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaCertificate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaCertificate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus {
        #[doc = "Certificate in active state will be able to use"]
        Active,
        #[doc = "Certificate in expired state needs to be updated"]
        Expired,
        #[doc = "Unspecified certificate status"]
        StateUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::Active => "ACTIVE",
                GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::Expired => "EXPIRED",
                GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::StateUnspecified => {
                    "STATE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus, ()>
        {
            Ok(match s {
                "ACTIVE" => GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::Active,
                "EXPIRED" => GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::Expired,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::StateUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVE" => GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::Active,
                "EXPIRED" => GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::Expired,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus::StateUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaCertificateCertificateStatus
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaClientCertificate {
        #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
        #[serde(
            rename = "encryptedPrivateKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub encrypted_private_key: ::std::option::Option<String>,
        #[doc = "â€˜passphraseâ€™ should be left unset if private key is not encrypted. Note that â€˜passphraseâ€™ is not the password for web server, but an extra layer of security to protected private key."]
        #[serde(
            rename = "passphrase",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub passphrase: ::std::option::Option<String>,
        #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
        #[serde(
            rename = "sslCertificate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ssl_certificate: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaClientCertificate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaClientCertificate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaCloudSchedulerConfig {
        #[doc = "Required. The cron tab of cloud scheduler trigger."]
        #[serde(
            rename = "cronTab",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cron_tab: ::std::option::Option<String>,
        #[doc = "Optional. When the job was deleted from Pantheon UI, error_message will be populated when Get/List integrations"]
        #[serde(
            rename = "errorMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub error_message: ::std::option::Option<String>,
        #[doc = "Required. The location where associated cloud scheduler job will be created"]
        #[serde(
            rename = "location",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub location: ::std::option::Option<String>,
        #[doc = "Required. Service account used by Cloud Scheduler to trigger the integration at scheduled time"]
        #[serde(
            rename = "serviceAccountEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_account_email: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaCloudSchedulerConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaCloudSchedulerConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaConnectionSchemaMetadata {
        #[doc = "List of actions."]
        #[serde(
            rename = "actions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub actions: ::std::option::Option<Vec<String>>,
        #[doc = "List of entity names."]
        #[serde(
            rename = "entities",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub entities: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaConnectionSchemaMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaConnectionSchemaMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectRequest {
        #[doc = "The name of the Apps Script project to be created."]
        #[serde(
            rename = "appsScriptProject",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub apps_script_project: ::std::option::Option<String>,
        #[doc = "The auth config id necessary to fetch the necessary credentials to create the project for external clients"]
        #[serde(
            rename = "authConfigId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_config_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectResponse {
        #[doc = "The created AppsScriptProject ID."]
        #[serde(
            rename = "projectId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub project_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaCredential {
        #[doc = "Auth token credential"]
        #[serde(
            rename = "authToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_token:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaAuthToken>,
        #[doc = "Credential type associated with auth config."]
        #[serde(
            rename = "credentialType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub credential_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaCredentialCredentialType,
        >,
        #[doc = "JWT credential"]
        #[serde(
            rename = "jwt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub jwt: ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaJwt>,
        #[doc = "The api_key and oauth2_implicit are not covered in v1 and will be picked up once v1 is implemented. ApiKey api_key = 3; OAuth2 authorization code credential"]
        #[serde(
            rename = "oauth2AuthorizationCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oauth_2_authorization_code: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCode,
        >,
        #[doc = "OAuth2Implicit oauth2_implicit = 5; OAuth2 client credentials"]
        #[serde(
            rename = "oauth2ClientCredentials",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oauth_2_client_credentials: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentials,
        >,
        #[doc = "OAuth2 resource owner credentials"]
        #[serde(
            rename = "oauth2ResourceOwnerCredentials",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oauth_2_resource_owner_credentials: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentials,
        >,
        #[doc = "Google OIDC ID Token"]
        #[serde(
            rename = "oidcToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oidc_token:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaOidcToken>,
        #[doc = "Service account credential"]
        #[serde(
            rename = "serviceAccountCredentials",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_account_credentials: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaServiceAccountCredentials,
        >,
        #[doc = "Username and password credential"]
        #[serde(
            rename = "usernameAndPassword",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub username_and_password: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaUsernameAndPassword,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaCredential {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaCredential {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaCredentialCredentialType {
        #[doc = "API key."]
        ApiKey,
        #[doc = "Auth Token, e.g. bearer token."]
        AuthToken,
        #[doc = "Client Certificate only."]
        ClientCertificateOnly,
        #[doc = "Unspecified credential type"]
        CredentialTypeUnspecified,
        #[doc = "JWT Token."]
        Jwt,
        #[doc = "OAuth 2.0 Authorization Code Grant Type."]
        Oauth2AuthorizationCode,
        #[doc = "OAuth 2.0 Client Credentials Grant Type."]
        Oauth2ClientCredentials,
        #[doc = "OAuth 2.0 Implicit Grant Type."]
        Oauth2Implicit,
        #[doc = "OAuth 2.0 Resource Owner Credentials Grant Type."]
        Oauth2ResourceOwnerCredentials,
        #[doc = "Google OIDC ID Token"]
        OidcToken,
        #[doc = "Service Account which can be used to generate token for authentication."]
        ServiceAccount,
        #[doc = "Regular username/password pair."]
        UsernameAndPassword,
    }
    impl GoogleCloudIntegrationsV1AlphaCredentialCredentialType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ApiKey => "API_KEY" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: AuthToken => "AUTH_TOKEN" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ClientCertificateOnly => "CLIENT_CERTIFICATE_ONLY" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: CredentialTypeUnspecified => "CREDENTIAL_TYPE_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Jwt => "JWT" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2AuthorizationCode => "OAUTH2_AUTHORIZATION_CODE" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2ClientCredentials => "OAUTH2_CLIENT_CREDENTIALS" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2Implicit => "OAUTH2_IMPLICIT" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2ResourceOwnerCredentials => "OAUTH2_RESOURCE_OWNER_CREDENTIALS" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: OidcToken => "OIDC_TOKEN" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ServiceAccount => "SERVICE_ACCOUNT" , GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: UsernameAndPassword => "USERNAME_AND_PASSWORD" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaCredentialCredentialType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaCredentialCredentialType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaCredentialCredentialType, ()>
        {
            Ok (match s { "API_KEY" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ApiKey , "AUTH_TOKEN" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: AuthToken , "CLIENT_CERTIFICATE_ONLY" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ClientCertificateOnly , "CREDENTIAL_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: CredentialTypeUnspecified , "JWT" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Jwt , "OAUTH2_AUTHORIZATION_CODE" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2AuthorizationCode , "OAUTH2_CLIENT_CREDENTIALS" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2ClientCredentials , "OAUTH2_IMPLICIT" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2Implicit , "OAUTH2_RESOURCE_OWNER_CREDENTIALS" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2ResourceOwnerCredentials , "OIDC_TOKEN" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: OidcToken , "SERVICE_ACCOUNT" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ServiceAccount , "USERNAME_AND_PASSWORD" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: UsernameAndPassword , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaCredentialCredentialType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaCredentialCredentialType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaCredentialCredentialType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "API_KEY" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ApiKey , "AUTH_TOKEN" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: AuthToken , "CLIENT_CERTIFICATE_ONLY" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ClientCertificateOnly , "CREDENTIAL_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: CredentialTypeUnspecified , "JWT" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Jwt , "OAUTH2_AUTHORIZATION_CODE" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2AuthorizationCode , "OAUTH2_CLIENT_CREDENTIALS" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2ClientCredentials , "OAUTH2_IMPLICIT" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2Implicit , "OAUTH2_RESOURCE_OWNER_CREDENTIALS" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: Oauth2ResourceOwnerCredentials , "OIDC_TOKEN" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: OidcToken , "SERVICE_ACCOUNT" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: ServiceAccount , "USERNAME_AND_PASSWORD" => GoogleCloudIntegrationsV1AlphaCredentialCredentialType :: UsernameAndPassword , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaCredentialCredentialType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaCredentialCredentialType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaDoubleParameterArray {
        #[doc = "Double number array."]
        #[serde(
            rename = "doubleValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_values: ::std::option::Option<Vec<f64>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaDoubleParameterArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaDoubleParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaDownloadIntegrationVersionResponse {
        #[doc = "String representation of the integration version."]
        #[serde(
            rename = "content",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaDownloadIntegrationVersionResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaDownloadIntegrationVersionResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaEnumerateConnectorPlatformRegionsResponse {
        #[doc = "All regions where Connector Platform is provisioned."]
        #[serde(
            rename = "regions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub regions: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaEnumerateConnectorPlatformRegionsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaEnumerateConnectorPlatformRegionsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaEventParameter {
        #[doc = "Key is used to retrieve the corresponding parameter value. This should be unique for a given fired event. These parameters must be predefined in the integration definition."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "Values for the defined keys. Each value can either be string, int, double or any proto message."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value: ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaValueType>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaEventParameter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaEventParameter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaExecuteIntegrationsRequest {
        #[doc = "Optional. Flag to determine how to should propagate errors. If this flag is set to be true, it will not throw an exception. Instead, it will return a {@link ExecuteIntegrationsResponse} with an execution id and error messages as PostWithTriggerIdExecutionException in {@link EventParameters}. The flag is set to be false by default."]
        #[serde(
            rename = "doNotPropagateError",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub do_not_propagate_error: ::std::option::Option<bool>,
        #[doc = "Optional. The id of the ON_HOLD execution to be resumed."]
        #[serde(
            rename = "executionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_id: ::std::option::Option<String>,
        #[doc = "Optional. Input parameters used by integration execution."]
        #[serde(
            rename = "inputParameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_parameters: ::std::option::Option<
            ::std::collections::BTreeMap<
                String,
                crate::schemas::GoogleCloudIntegrationsV1AlphaValueType,
            >,
        >,
        #[doc = "Optional. Parameters are a part of Event and can be used to communicate between different tasks that are part of the same integration execution."]
        #[serde(
            rename = "parameterEntries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameter_entries: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterEntry>,
        >,
        #[doc = "Optional. Passed in as parameters to each integration execution. Redacted"]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventParameters,
        >,
        #[doc = "Optional. This is used to de-dup incoming request: if the duplicate request was detected, the response from the previous execution is returned."]
        #[serde(
            rename = "requestId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_id: ::std::option::Option<String>,
        #[doc = "Required. Matched against all {@link TriggerConfig}s across all integrations. i.e. TriggerConfig.trigger_id.equals(trigger_id). The trigger_id is in the format of `api_trigger/TRIGGER_NAME`."]
        #[serde(
            rename = "triggerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaExecuteIntegrationsRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaExecuteIntegrationsRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaExecuteIntegrationsResponse {
        #[doc = "Details for the integration that were executed."]
        #[serde(
            rename = "eventParameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_parameters: ::std::option::Option<
            crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventParameters,
        >,
        #[doc = "Is true if any execution in the integration failed. False otherwise."]
        #[serde(
            rename = "executionFailed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_failed: ::std::option::Option<bool>,
        #[doc = "The id of the execution corresponding to this run of integration."]
        #[serde(
            rename = "executionId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_id: ::std::option::Option<String>,
        #[doc = "OUTPUT parameters in format of Map. Where Key is the name of the parameter. Note: Name of the system generated parameters are wrapped by backtick(\\`) to distinguish them from the user defined parameters."]
        #[serde(
            rename = "outputParameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_parameters:
            ::std::option::Option<::std::collections::BTreeMap<String, ::serde_json::Value>>,
        #[doc = "Parameters are a part of Event and can be used to communicate between different tasks that are part of the same integration execution."]
        #[serde(
            rename = "parameterEntries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameter_entries: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterEntry>,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaExecuteIntegrationsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaExecuteIntegrationsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaExecution {
        #[doc = "Output only. Created time of the execution."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Direct sub executions of the following Execution."]
        #[serde(
            rename = "directSubExecutions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub direct_sub_executions:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaExecution>>,
        #[doc = "The execution info about this event."]
        #[serde(
            rename = "eventExecutionDetails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_execution_details:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoEventExecutionDetails>,
        #[doc = "Detailed info of this execution."]
        #[serde(
            rename = "executionDetails",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_details:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaExecutionDetails>,
        #[doc = "The ways user posts this event."]
        #[serde(
            rename = "executionMethod",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_method: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod,
        >,
        #[doc = "Auto-generated primary key."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Event parameters come in as part of the request."]
        #[serde(
            rename = "requestParameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_parameters: ::std::option::Option<
            ::std::collections::BTreeMap<
                String,
                crate::schemas::GoogleCloudIntegrationsV1AlphaValueType,
            >,
        >,
        #[doc = "Event parameters come in as part of the request."]
        #[serde(
            rename = "requestParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_params: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterEntry>,
        >,
        #[doc = "Event parameters returned as part of the response."]
        #[serde(
            rename = "responseParameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub response_parameters: ::std::option::Option<
            ::std::collections::BTreeMap<
                String,
                crate::schemas::GoogleCloudIntegrationsV1AlphaValueType,
            >,
        >,
        #[doc = "Event parameters come out as part of the response."]
        #[serde(
            rename = "responseParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub response_params: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterEntry>,
        >,
        #[doc = "The trigger id of the integration trigger config. If both trigger_id and client_id is present, the integration is executed from the start tasks provided by the matching trigger config otherwise it is executed from the default start tasks."]
        #[serde(
            rename = "triggerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_id: ::std::option::Option<String>,
        #[doc = "Output only. Last modified time of the execution."]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaExecution {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaExecution {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod {
        #[doc = "Default value."]
        ExecutionMethodUnspecified,
        #[doc = "Sync post."]
        Post,
        #[doc = "Async post."]
        PostToQueue,
        #[doc = "Async post with schedule time."]
        Schedule,
    }
    impl GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: ExecutionMethodUnspecified => "EXECUTION_METHOD_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: Post => "POST" , GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: PostToQueue => "POST_TO_QUEUE" , GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: Schedule => "SCHEDULE" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod, ()>
        {
            Ok (match s { "EXECUTION_METHOD_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: ExecutionMethodUnspecified , "POST" => GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: Post , "POST_TO_QUEUE" => GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: PostToQueue , "SCHEDULE" => GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: Schedule , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "EXECUTION_METHOD_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: ExecutionMethodUnspecified , "POST" => GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: Post , "POST_TO_QUEUE" => GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: PostToQueue , "SCHEDULE" => GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod :: Schedule , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaExecutionExecutionMethod
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaExecutionDetails {
        #[doc = "List of Start and end time of the execution attempts."]
        #[serde(
            rename = "attemptStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub attempt_stats:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaAttemptStats>>,
        #[doc = "List of snapshots taken during the execution."]
        #[serde(
            rename = "executionSnapshots",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_snapshots: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaExecutionSnapshot>,
        >,
        #[doc = "Status of the execution."]
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaExecutionDetailsState,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaExecutionDetails {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaExecutionDetails {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaExecutionDetailsState {
        #[doc = "Execution canceled by user. Thereâ€™s no more change after this state."]
        Cancelled,
        #[doc = "Execution failed. Thereâ€™s no more change after this state."]
        Failed,
        #[doc = "Execution is scheduled and awaiting to be triggered."]
        Pending,
        #[doc = "Execution is processing."]
        Processing,
        #[doc = "Execution failed and waiting for retry."]
        RetryOnHold,
        #[doc = "Default."]
        StateUnspecified,
        #[doc = "Execution successfully finished. Thereâ€™s no more change after this state."]
        Succeeded,
        #[doc = "Execution suspended and waiting for manual intervention."]
        Suspended,
    }
    impl GoogleCloudIntegrationsV1AlphaExecutionDetailsState {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Cancelled => "CANCELLED",
                GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Failed => "FAILED",
                GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Pending => "PENDING",
                GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Processing => "PROCESSING",
                GoogleCloudIntegrationsV1AlphaExecutionDetailsState::RetryOnHold => "RETRY_ON_HOLD",
                GoogleCloudIntegrationsV1AlphaExecutionDetailsState::StateUnspecified => {
                    "STATE_UNSPECIFIED"
                }
                GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Succeeded => "SUCCEEDED",
                GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Suspended => "SUSPENDED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaExecutionDetailsState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaExecutionDetailsState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaExecutionDetailsState, ()>
        {
            Ok(match s {
                "CANCELLED" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Cancelled,
                "FAILED" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Failed,
                "PENDING" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Pending,
                "PROCESSING" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Processing,
                "RETRY_ON_HOLD" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::RetryOnHold,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaExecutionDetailsState::StateUnspecified
                }
                "SUCCEEDED" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Succeeded,
                "SUSPENDED" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Suspended,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaExecutionDetailsState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaExecutionDetailsState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaExecutionDetailsState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "CANCELLED" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Cancelled,
                "FAILED" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Failed,
                "PENDING" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Pending,
                "PROCESSING" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Processing,
                "RETRY_ON_HOLD" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::RetryOnHold,
                "STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaExecutionDetailsState::StateUnspecified
                }
                "SUCCEEDED" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Succeeded,
                "SUSPENDED" => GoogleCloudIntegrationsV1AlphaExecutionDetailsState::Suspended,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaExecutionDetailsState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaExecutionDetailsState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaExecutionSnapshot { # [doc = "Indicates â€œafter which checkpoint taskâ€™s executionâ€ this snapshot is taken."] # [serde (rename = "checkpointTaskNumber" , default , skip_serializing_if = "std::option::Option::is_none")] pub checkpoint_task_number : :: std :: option :: Option < String > , # [doc = "Metadata of the execution snapshot."] # [serde (rename = "executionSnapshotMetadata" , default , skip_serializing_if = "std::option::Option::is_none")] pub execution_snapshot_metadata : :: std :: option :: Option < crate :: schemas :: GoogleCloudIntegrationsV1AlphaExecutionSnapshotExecutionSnapshotMetadata > , # [doc = "Parameters used during the execution."] # [serde (rename = "params" , default , skip_serializing_if = "std::option::Option::is_none")] pub params : :: std :: option :: Option < :: std :: collections :: BTreeMap < String , crate :: schemas :: GoogleCloudIntegrationsV1AlphaValueType > > , # [doc = "All of the task execution details at the given point of time."] # [serde (rename = "taskExecutionDetails" , default , skip_serializing_if = "std::option::Option::is_none")] pub task_execution_details : :: std :: option :: Option < Vec < crate :: schemas :: GoogleCloudIntegrationsV1AlphaTaskExecutionDetails > > , }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaExecutionSnapshot {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaExecutionSnapshot {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaExecutionSnapshotExecutionSnapshotMetadata {
        #[doc = "the execution attempt number this snapshot belongs to."]
        #[serde(
            rename = "executionAttempt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_attempt: ::std::option::Option<i32>,
        #[doc = "the task name associated with this snapshot."]
        #[serde(
            rename = "task",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task: ::std::option::Option<String>,
        #[doc = "the task attempt number this snapshot belongs to."]
        #[serde(
            rename = "taskAttempt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_attempt: ::std::option::Option<i32>,
        #[doc = "The task number associated with this snapshot."]
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaExecutionSnapshotExecutionSnapshotMetadata
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaExecutionSnapshotExecutionSnapshotMetadata
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaFailurePolicy {
        #[doc = "Required if retry_strategy is FIXED_INTERVAL or LINEAR/EXPONENTIAL_BACKOFF/RESTART_INTEGRATION_WITH_BACKOFF. Defines the initial interval in seconds for backoff."]
        #[serde(
            rename = "intervalTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub interval_time: ::std::option::Option<String>,
        #[doc = "Required if retry_strategy is FIXED_INTERVAL or LINEAR/EXPONENTIAL_BACKOFF/RESTART_INTEGRATION_WITH_BACKOFF. Defines the number of times the task will be retried if failed."]
        #[serde(
            rename = "maxRetries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_retries: ::std::option::Option<i32>,
        #[doc = "Defines what happens to the task upon failure."]
        #[serde(
            rename = "retryStrategy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub retry_strategy: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaFailurePolicy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaFailurePolicy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy {
        #[doc = "The task will be retried after an exponentially increasing period of time with each failure. A jitter is added to each exponential interval so that concurrently failing tasks of the same type do not end up retrying after the exact same exponential interval. A max-retry count is required to be specified with this strategy. `max_retries` and `interval_in_seconds` must be specified."]
        ExponentialBackoff,
        #[doc = "Causes a permanent failure of the event. It is different from NONE because this will mark the event as FAILED by shutting down the event execution."]
        Fatal,
        #[doc = "The task will be retried from the failed task onwards after a fixed delay. A max-retry count is required to be specified with this strategy. A jitter is added to each exponential interval so that concurrently failing tasks of the same type do not end up retrying after the exact same exponential interval. max_retries and interval_in_seconds must be specified."]
        FixedInterval,
        #[doc = "Ignores the failure of this task. The rest of the integration will be executed Assuming this task succeeded."]
        Ignore,
        #[doc = "The task will be retried from the failed task onwards after a fixed delay that linearly increases with each retry attempt. A jitter is added to each exponential interval so that concurrently failing tasks of the same type do not end up retrying after the exact same exponential interval. A max-retry count is required to be specified with this strategy. max_retries and interval_in_seconds must be specified."]
        LinearBackoff,
        #[doc = "Causes a permanent failure of the task. However, if the last task(s) of event was successfully completed despite the failure of this task, it has no impact on the integration."]
        None,
        #[doc = "The entire integration will be restarted with the initial parameters that were set when the event was fired. A max-retry count is required to be specified with this strategy. `max_retries` and `interval_in_seconds` must be specified."]
        RestartIntegrationWithBackoff,
        #[doc = "UNSPECIFIED."]
        RetryStrategyUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: ExponentialBackoff => "EXPONENTIAL_BACKOFF" , GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: Fatal => "FATAL" , GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: FixedInterval => "FIXED_INTERVAL" , GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: Ignore => "IGNORE" , GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: LinearBackoff => "LINEAR_BACKOFF" , GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: None => "NONE" , GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: RestartIntegrationWithBackoff => "RESTART_INTEGRATION_WITH_BACKOFF" , GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: RetryStrategyUnspecified => "RETRY_STRATEGY_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy, ()>
        {
            Ok (match s { "EXPONENTIAL_BACKOFF" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: ExponentialBackoff , "FATAL" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: Fatal , "FIXED_INTERVAL" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: FixedInterval , "IGNORE" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: Ignore , "LINEAR_BACKOFF" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: LinearBackoff , "NONE" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: None , "RESTART_INTEGRATION_WITH_BACKOFF" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: RestartIntegrationWithBackoff , "RETRY_STRATEGY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: RetryStrategyUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "EXPONENTIAL_BACKOFF" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: ExponentialBackoff , "FATAL" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: Fatal , "FIXED_INTERVAL" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: FixedInterval , "IGNORE" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: Ignore , "LINEAR_BACKOFF" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: LinearBackoff , "NONE" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: None , "RESTART_INTEGRATION_WITH_BACKOFF" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: RestartIntegrationWithBackoff , "RETRY_STRATEGY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy :: RetryStrategyUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaFailurePolicyRetryStrategy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaGenerateTokenResponse {
        #[doc = "The message that notifies the user if the request succeeded or not."]
        #[serde(
            rename = "message",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub message: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaGenerateTokenResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaGenerateTokenResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaIntParameterArray {
        #[doc = "Integer array."]
        #[serde(
            rename = "intValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_values: ::std::option::Option<Vec<i64>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaIntParameterArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaIntParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaIntegration {
        #[doc = "Required. If any integration version is published."]
        #[serde(
            rename = "active",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub active: ::std::option::Option<bool>,
        #[doc = "Optional."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Required. The resource name of the integration."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Output only. Auto-generated."]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaIntegration {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaIntegration {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaIntegrationAlertConfig {
        #[doc = "The period over which the metric value should be aggregated and evaluated. Format is , where integer should be a positive integer and unit should be one of (s,m,h,d,w) meaning (second, minute, hour, day, week). For an EXPECTED_MIN threshold, this aggregation_period must be lesser than 24 hours."]
        #[serde(
            rename = "aggregationPeriod",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub aggregation_period: ::std::option::Option<String>,
        #[doc = "For how many contiguous aggregation periods should the expected min or max be violated for the alert to be fired."]
        #[serde(
            rename = "alertThreshold",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alert_threshold: ::std::option::Option<i32>,
        #[doc = "Set to false by default. When set to true, the metrics are not aggregated or pushed to Monarch for this integration alert."]
        #[serde(
            rename = "disableAlert",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disable_alert: ::std::option::Option<bool>,
        #[doc = "Name of the alert. This will be displayed in the alert subject. If set, this name should be unique within the scope of the integration."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Should be specified only for \\*AVERAGE_DURATION and \\*PERCENTILE_DURATION metrics. This member should be used to specify what duration value the metrics should exceed for the alert to trigger."]
        #[serde(
            rename = "durationThreshold",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub duration_threshold: ::std::option::Option<String>,
        #[doc = "The type of metric."]
        #[serde(
            rename = "metricType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metric_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType,
        >,
        #[doc = "For either events or tasks, depending on the type of alert, count only final attempts, not retries."]
        #[serde(
            rename = "onlyFinalAttempt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub only_final_attempt: ::std::option::Option<bool>,
        #[doc = "The threshold type, whether lower(expected_min) or upper(expected_max), for which this alert is being configured. If value falls below expected_min or exceeds expected_max, an alert will be fired."]
        #[serde(
            rename = "thresholdType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub threshold_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType,
        >,
        #[doc = "The metric value, above or below which the alert should be triggered."]
        #[serde(
            rename = "thresholdValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub threshold_value: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdValue,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType {
        #[doc = "Specifies alerting on the average duration of executions for this integration."]
        EventAverageDuration,
        #[doc = "Specifies alerting on the rate of errors for the enclosing integration."]
        EventErrorRate,
        #[doc = "Specifies alerting on the duration value of a particular percentile of integration executions. E.g. If 10% or more of the integration executions have durations above 5 seconds, alert."]
        EventPercentileDuration,
        #[doc = "Specifies alerting on the number of events executed in the given aggregation_period."]
        EventRate,
        #[doc = "Specifies alerting on the rate of warnings for the enclosing integration. Warnings use the same enum values as errors."]
        EventWarningRate,
        #[doc = "The default value. Metric type should always be set to one of the other non-default values, otherwise it will result in an INVALID_ARGUMENT error."]
        MetricTypeUnspecified,
        #[doc = "Specifies alerting on the average duration of any task in the enclosing integration,"]
        TaskAverageDuration,
        #[doc = "Specifies alerting on the rate of errors for any task in the enclosing integration."]
        TaskErrorRate,
        #[doc = "Specifies alerting on the duration value of a particular percentile of any task executions within the enclosing integration. E.g. If 10% or more of the task executions in the integration have durations above 5 seconds, alert."]
        TaskPercentileDuration,
        #[doc = "Specifies alerting on the rate of executions over all tasks in the enclosing integration."]
        TaskRate,
        #[doc = "Specifies alerting on the rate of warnings for any task in the enclosing integration."]
        TaskWarningRate,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventAverageDuration => "EVENT_AVERAGE_DURATION" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventErrorRate => "EVENT_ERROR_RATE" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventPercentileDuration => "EVENT_PERCENTILE_DURATION" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventRate => "EVENT_RATE" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventWarningRate => "EVENT_WARNING_RATE" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: MetricTypeUnspecified => "METRIC_TYPE_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskAverageDuration => "TASK_AVERAGE_DURATION" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskErrorRate => "TASK_ERROR_RATE" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskPercentileDuration => "TASK_PERCENTILE_DURATION" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskRate => "TASK_RATE" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskWarningRate => "TASK_WARNING_RATE" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType, ()>
        {
            Ok (match s { "EVENT_AVERAGE_DURATION" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventAverageDuration , "EVENT_ERROR_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventErrorRate , "EVENT_PERCENTILE_DURATION" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventPercentileDuration , "EVENT_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventRate , "EVENT_WARNING_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventWarningRate , "METRIC_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: MetricTypeUnspecified , "TASK_AVERAGE_DURATION" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskAverageDuration , "TASK_ERROR_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskErrorRate , "TASK_PERCENTILE_DURATION" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskPercentileDuration , "TASK_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskRate , "TASK_WARNING_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskWarningRate , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "EVENT_AVERAGE_DURATION" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventAverageDuration , "EVENT_ERROR_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventErrorRate , "EVENT_PERCENTILE_DURATION" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventPercentileDuration , "EVENT_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventRate , "EVENT_WARNING_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: EventWarningRate , "METRIC_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: MetricTypeUnspecified , "TASK_AVERAGE_DURATION" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskAverageDuration , "TASK_ERROR_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskErrorRate , "TASK_PERCENTILE_DURATION" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskPercentileDuration , "TASK_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskRate , "TASK_WARNING_RATE" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType :: TaskWarningRate , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigMetricType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType {
        #[doc = "Max value threshold."]
        ExpectedMax,
        #[doc = "Note that this field will only trigger alerts if the integration specifying it runs at least once in 24 hours (which is our in-memory retention period for monarch streams). Also note that `aggregation_period` for this alert configuration must be less than 24 hours. Min value threshold."]
        ExpectedMin,
        #[doc = "Default."]
        ThresholdTypeUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ExpectedMax => "EXPECTED_MAX" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ExpectedMin => "EXPECTED_MIN" , GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ThresholdTypeUnspecified => "THRESHOLD_TYPE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType,
            (),
        > {
            Ok (match s { "EXPECTED_MAX" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ExpectedMax , "EXPECTED_MIN" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ExpectedMin , "THRESHOLD_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ThresholdTypeUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "EXPECTED_MAX" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ExpectedMax , "EXPECTED_MIN" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ExpectedMin , "THRESHOLD_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType :: ThresholdTypeUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdValue {
        #[doc = "Absolute value threshold."]
        #[serde(
            rename = "absolute",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub absolute: ::std::option::Option<i64>,
        #[doc = "Percentage threshold."]
        #[serde(
            rename = "percentage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub percentage: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdValue
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationAlertConfigThresholdValue
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaIntegrationParameter {
        #[doc = "Type of the parameter."]
        #[serde(
            rename = "dataType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub data_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType,
        >,
        #[doc = "Default values for the defined keys. Each value can either be string, int, double or any proto message or a serialized object."]
        #[serde(
            rename = "defaultValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub default_value:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaValueType>,
        #[doc = "The name (without prefix) to be displayed in the UI for this parameter. E.g. if the key is â€œfoo.bar.myNameâ€, then the name would be â€œmyNameâ€."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Specifies the input/output type for the parameter."]
        #[serde(
            rename = "inputOutputType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_output_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType,
        >,
        #[doc = "Whether this parameter is a transient parameter."]
        #[serde(
            rename = "isTransient",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_transient: ::std::option::Option<bool>,
        #[doc = "This schema will be used to validate runtime JSON-typed values of this parameter."]
        #[serde(
            rename = "jsonSchema",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub json_schema: ::std::option::Option<String>,
        #[doc = "Key is used to retrieve the corresponding parameter value. This should be unique for a given fired event. These parameters must be predefined in the integration definition."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key: ::std::option::Option<String>,
        #[doc = "The identifier of the node (TaskConfig/TriggerConfig) this parameter was produced by, if it is a transient param or a copy of an input param."]
        #[serde(
            rename = "producer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub producer: ::std::option::Option<String>,
        #[doc = "Searchable in the execution log or not."]
        #[serde(
            rename = "searchable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub searchable: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaIntegrationParameter {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaIntegrationParameter {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType {
        #[doc = "Boolean Array."]
        BooleanArray,
        #[doc = "Boolean."]
        BooleanValue,
        #[doc = "Double Number Array."]
        DoubleArray,
        #[doc = "Double Number."]
        DoubleValue,
        #[doc = "Integer Array."]
        IntArray,
        #[doc = "Integer."]
        IntValue,
        #[doc = "Unspecified."]
        IntegrationParameterDataTypeUnspecified,
        #[doc = "Json."]
        JsonValue,
        #[doc = "Proto Array (Internal use only)."]
        ProtoArray,
        #[doc = "Proto Value (Internal use only)."]
        ProtoValue,
        #[doc = "String Array."]
        StringArray,
        #[doc = "String."]
        StringValue,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: BooleanArray => "BOOLEAN_ARRAY" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: BooleanValue => "BOOLEAN_VALUE" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: DoubleArray => "DOUBLE_ARRAY" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: DoubleValue => "DOUBLE_VALUE" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntArray => "INT_ARRAY" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntValue => "INT_VALUE" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntegrationParameterDataTypeUnspecified => "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: JsonValue => "JSON_VALUE" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: ProtoArray => "PROTO_ARRAY" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: ProtoValue => "PROTO_VALUE" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: StringArray => "STRING_ARRAY" , GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: StringValue => "STRING_VALUE" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType, ()>
        {
            Ok (match s { "BOOLEAN_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: BooleanArray , "BOOLEAN_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: BooleanValue , "DOUBLE_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: DoubleArray , "DOUBLE_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: DoubleValue , "INT_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntArray , "INT_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntValue , "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntegrationParameterDataTypeUnspecified , "JSON_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: JsonValue , "PROTO_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: ProtoArray , "PROTO_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: ProtoValue , "STRING_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: StringArray , "STRING_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: StringValue , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "BOOLEAN_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: BooleanArray , "BOOLEAN_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: BooleanValue , "DOUBLE_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: DoubleArray , "DOUBLE_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: DoubleValue , "INT_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntArray , "INT_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntValue , "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: IntegrationParameterDataTypeUnspecified , "JSON_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: JsonValue , "PROTO_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: ProtoArray , "PROTO_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: ProtoValue , "STRING_ARRAY" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: StringArray , "STRING_VALUE" => GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType :: StringValue , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationParameterDataType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType {
        #[doc = "Input parameters for the integration. EventBus validates that these parameters exist in the integrations before execution."]
        In,
        #[doc = "Input and Output Parameters. These can be used as both input and output. EventBus will validate for the existence of these parameters before execution and will also return this parameter back in the response."]
        InOut,
        #[doc = "Default."]
        InOutTypeUnspecified,
        #[doc = "Output Parameters for the integration. EventBus will only return the integration parameters tagged with OUT in the response back."]
        Out,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: In => "IN" , GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: InOut => "IN_OUT" , GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: InOutTypeUnspecified => "IN_OUT_TYPE_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: Out => "OUT" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType,
            (),
        > {
            Ok (match s { "IN" => GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: In , "IN_OUT" => GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: InOut , "IN_OUT_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: InOutTypeUnspecified , "OUT" => GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: Out , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "IN" => GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: In , "IN_OUT" => GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: InOut , "IN_OUT_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: InOutTypeUnspecified , "OUT" => GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType :: Out , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationParameterInputOutputType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion { # [doc = "Output only. Auto-generated."] # [serde (rename = "createTime" , default , skip_serializing_if = "std::option::Option::is_none")] pub create_time : :: std :: option :: Option < String > , # [doc = "Optional. Flag to disable database persistence for execution data, including event execution info, execution export info, execution metadata index and execution param index."] # [serde (rename = "databasePersistencePolicy" , default , skip_serializing_if = "std::option::Option::is_none")] pub database_persistence_policy : :: std :: option :: Option < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy > , # [doc = "Optional. The templateversion description. Permitted format is alphanumeric with underscores and no spaces."] # [serde (rename = "description" , default , skip_serializing_if = "std::option::Option::is_none")] pub description : :: std :: option :: Option < String > , # [doc = "Optional. The last modifierâ€™s email address. Generated based on the End User Credentials/LOAS role of the user making the call."] # [serde (rename = "lastModifierEmail" , default , skip_serializing_if = "std::option::Option::is_none")] pub last_modifier_email : :: std :: option :: Option < String > , # [doc = "Output only. Auto-generated primary key. Format: projects/{project}/locations/{location}/products/{product}/integrationtemplates/{integrationtemplate}/versions/{version}"] # [serde (rename = "name" , default , skip_serializing_if = "std::option::Option::is_none")] pub name : :: std :: option :: Option < String > , # [doc = "Optional. ID of the IntegrationVersion that was used to create this IntegrationTemplateVersion"] # [serde (rename = "parentIntegrationVersionId" , default , skip_serializing_if = "std::option::Option::is_none")] pub parent_integration_version_id : :: std :: option :: Option < String > , # [doc = "Output only. An increasing sequence that is set when a new snapshot is created."] # [serde (rename = "snapshotNumber" , default , skip_serializing_if = "std::option::Option::is_none")] # [serde (with = "crate::parsed_string")] pub snapshot_number : :: std :: option :: Option < i64 > , # [doc = "Optional. Generated by eventbus. User should not set it as an input."] # [serde (rename = "status" , default , skip_serializing_if = "std::option::Option::is_none")] pub status : :: std :: option :: Option < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus > , # [doc = "Optional. Task configuration for the IntegrationTemplateVersion. Itâ€™s optional, but the IntegrationTemplateVersion doesnâ€™t do anything without task_configs."] # [serde (rename = "taskConfigs" , default , skip_serializing_if = "std::option::Option::is_none")] pub task_configs : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoTaskConfig > > , # [doc = "Optional. Contains a graph of tasks that will be executed before putting the event in a terminal state (SUCCEEDED/FAILED/FATAL), regardless of success or failure, similar to â€œfinallyâ€ in code."] # [serde (rename = "teardown" , default , skip_serializing_if = "std::option::Option::is_none")] pub teardown : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoTeardown > , # [doc = "Optional. Parameters that are expected to be passed to the IntegrationTemplateVersion when an event is triggered. This consists of all the parameters that are expected in the IntegrationTemplateVersion execution. This gives the user the ability to provide default values, add information like PII and also provide data types of each parameter."] # [serde (rename = "templateParameters" , default , skip_serializing_if = "std::option::Option::is_none")] pub template_parameters : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoWorkflowParameters > , # [doc = "Optional. Trigger configurations."] # [serde (rename = "triggerConfigs" , default , skip_serializing_if = "std::option::Option::is_none")] pub trigger_configs : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoTriggerConfig > > , # [doc = "Output only. Auto-generated."] # [serde (rename = "updateTime" , default , skip_serializing_if = "std::option::Option::is_none")] pub update_time : :: std :: option :: Option < String > , # [doc = "Optional. A user-defined label that annotates an integration version. Typically, this is only set when the integration version is created."] # [serde (rename = "userLabel" , default , skip_serializing_if = "std::option::Option::is_none")] pub user_label : :: std :: option :: Option < String > , }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy {
        #[doc = "Disables persistence for all execution data."]
        DatabasePersistenceDisabled,
        #[doc = "Enables persistence for all execution data."]
        DatabasePersistencePolicyUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy :: DatabasePersistenceDisabled => "DATABASE_PERSISTENCE_DISABLED" , GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy :: DatabasePersistencePolicyUnspecified => "DATABASE_PERSISTENCE_POLICY_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy,
            (),
        > {
            Ok (match s { "DATABASE_PERSISTENCE_DISABLED" => GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy :: DatabasePersistenceDisabled , "DATABASE_PERSISTENCE_POLICY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy :: DatabasePersistencePolicyUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DATABASE_PERSISTENCE_DISABLED" => GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy :: DatabasePersistenceDisabled , "DATABASE_PERSISTENCE_POLICY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy :: DatabasePersistencePolicyUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionDatabasePersistencePolicy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus {
        Active,
        Archived,
        Draft,
        Snapshot,
        Unknown,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Active => "ACTIVE",
                GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Archived => {
                    "ARCHIVED"
                }
                GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Draft => "DRAFT",
                GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Snapshot => {
                    "SNAPSHOT"
                }
                GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Unknown => {
                    "UNKNOWN"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus, ()>
        {
            Ok(match s {
                "ACTIVE" => GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Active,
                "ARCHIVED" => {
                    GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Archived
                }
                "DRAFT" => GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Draft,
                "SNAPSHOT" => {
                    GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Snapshot
                }
                "UNKNOWN" => {
                    GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Unknown
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVE" => GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Active,
                "ARCHIVED" => {
                    GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Archived
                }
                "DRAFT" => GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Draft,
                "SNAPSHOT" => {
                    GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Snapshot
                }
                "UNKNOWN" => {
                    GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus::Unknown
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersionStatus
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaIntegrationVersion { # [doc = "Output only. Auto-generated."] # [serde (rename = "createTime" , default , skip_serializing_if = "std::option::Option::is_none")] pub create_time : :: std :: option :: Option < String > , # [doc = "Optional. Flag to disable database persistence for execution data, including event execution info, execution export info, execution metadata index and execution param index."] # [serde (rename = "databasePersistencePolicy" , default , skip_serializing_if = "std::option::Option::is_none")] pub database_persistence_policy : :: std :: option :: Option < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy > , # [doc = "Optional. The integration description."] # [serde (rename = "description" , default , skip_serializing_if = "std::option::Option::is_none")] pub description : :: std :: option :: Option < String > , # [doc = "Optional. Parameters that are expected to be passed to the integration when an event is triggered. This consists of all the parameters that are expected in the integration execution. This gives the user the ability to provide default values, add information like PII and also provide data types of each parameter."] # [serde (rename = "integrationParameters" , default , skip_serializing_if = "std::option::Option::is_none")] pub integration_parameters : :: std :: option :: Option < Vec < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationParameter > > , # [doc = "Optional. Parameters that are expected to be passed to the integration when an event is triggered. This consists of all the parameters that are expected in the integration execution. This gives the user the ability to provide default values, add information like PII and also provide data types of each parameter."] # [serde (rename = "integrationParametersInternal" , default , skip_serializing_if = "std::option::Option::is_none")] pub integration_parameters_internal : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoWorkflowParameters > , # [doc = "Optional. The last modifierâ€™s email address. Generated based on the End User Credentials/LOAS role of the user making the call."] # [serde (rename = "lastModifierEmail" , default , skip_serializing_if = "std::option::Option::is_none")] pub last_modifier_email : :: std :: option :: Option < String > , # [doc = "Optional. The edit lock holderâ€™s email address. Generated based on the End User Credentials/LOAS role of the user making the call."] # [serde (rename = "lockHolder" , default , skip_serializing_if = "std::option::Option::is_none")] pub lock_holder : :: std :: option :: Option < String > , # [doc = "Output only. Auto-generated primary key."] # [serde (rename = "name" , default , skip_serializing_if = "std::option::Option::is_none")] pub name : :: std :: option :: Option < String > , # [doc = "Optional. The origin that indicates where this integration is coming from."] # [serde (rename = "origin" , default , skip_serializing_if = "std::option::Option::is_none")] pub origin : :: std :: option :: Option < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin > , # [doc = "Optional. The id of the template which was used to create this integration_version."] # [serde (rename = "parentTemplateId" , default , skip_serializing_if = "std::option::Option::is_none")] pub parent_template_id : :: std :: option :: Option < String > , # [doc = "Optional. An increasing sequence that is set when a new snapshot is created. The last created snapshot can be identified by \\[workflow_name, org_id latest(snapshot_number)\\]. However, last created snapshot need not be same as the HEAD. So users should always use â€œHEADâ€ tag to identify the head."] # [serde (rename = "snapshotNumber" , default , skip_serializing_if = "std::option::Option::is_none")] # [serde (with = "crate::parsed_string")] pub snapshot_number : :: std :: option :: Option < i64 > , # [doc = "Output only. User should not set it as an input."] # [serde (rename = "state" , default , skip_serializing_if = "std::option::Option::is_none")] pub state : :: std :: option :: Option < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersionState > , # [doc = "Output only. Generated by eventbus. User should not set it as an input."] # [serde (rename = "status" , default , skip_serializing_if = "std::option::Option::is_none")] pub status : :: std :: option :: Option < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus > , # [doc = "Optional. Task configuration for the integration. Itâ€™s optional, but the integration doesnâ€™t do anything without task_configs."] # [serde (rename = "taskConfigs" , default , skip_serializing_if = "std::option::Option::is_none")] pub task_configs : :: std :: option :: Option < Vec < crate :: schemas :: GoogleCloudIntegrationsV1AlphaTaskConfig > > , # [doc = "Optional. Task configuration for the integration. Itâ€™s optional, but the integration doesnâ€™t do anything without task_configs."] # [serde (rename = "taskConfigsInternal" , default , skip_serializing_if = "std::option::Option::is_none")] pub task_configs_internal : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoTaskConfig > > , # [doc = "Optional. Contains a graph of tasks that will be executed before putting the event in a terminal state (SUCCEEDED/FAILED/FATAL), regardless of success or failure, similar to â€œfinallyâ€ in code."] # [serde (rename = "teardown" , default , skip_serializing_if = "std::option::Option::is_none")] pub teardown : :: std :: option :: Option < crate :: schemas :: EnterpriseCrmEventbusProtoTeardown > , # [doc = "Optional. Trigger configurations."] # [serde (rename = "triggerConfigs" , default , skip_serializing_if = "std::option::Option::is_none")] pub trigger_configs : :: std :: option :: Option < Vec < crate :: schemas :: GoogleCloudIntegrationsV1AlphaTriggerConfig > > , # [doc = "Optional. Trigger configurations."] # [serde (rename = "triggerConfigsInternal" , default , skip_serializing_if = "std::option::Option::is_none")] pub trigger_configs_internal : :: std :: option :: Option < Vec < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoTriggerConfig > > , # [doc = "Output only. Auto-generated."] # [serde (rename = "updateTime" , default , skip_serializing_if = "std::option::Option::is_none")] pub update_time : :: std :: option :: Option < String > , # [doc = "Optional. A user-defined label that annotates an integration version. Typically, this is only set when the integration version is created."] # [serde (rename = "userLabel" , default , skip_serializing_if = "std::option::Option::is_none")] pub user_label : :: std :: option :: Option < String > , }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaIntegrationVersion {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaIntegrationVersion {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy {
        #[doc = "Disables persistence for all execution data."]
        DatabasePersistenceDisabled,
        #[doc = "Enables persistence for all execution data."]
        DatabasePersistencePolicyUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy :: DatabasePersistenceDisabled => "DATABASE_PERSISTENCE_DISABLED" , GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy :: DatabasePersistencePolicyUnspecified => "DATABASE_PERSISTENCE_POLICY_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy,
            (),
        > {
            Ok (match s { "DATABASE_PERSISTENCE_DISABLED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy :: DatabasePersistenceDisabled , "DATABASE_PERSISTENCE_POLICY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy :: DatabasePersistencePolicyUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DATABASE_PERSISTENCE_DISABLED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy :: DatabasePersistenceDisabled , "DATABASE_PERSISTENCE_POLICY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy :: DatabasePersistencePolicyUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionDatabasePersistencePolicy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin {
        #[doc = "Workflow is being created via Standalone IP Provisioning"]
        ApplicationIpProvisioning,
        #[doc = "User checked in this workflow in Piper as v2 textproto format and we synced it into spanner."]
        PiperV2,
        #[doc = "User checked in this workflow in piper as v3 textproto format and we synced it into spanner."]
        PiperV3,
        #[doc = "Workflow is being created via event bus UI."]
        Ui,
        Unspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: ApplicationIpProvisioning => "APPLICATION_IP_PROVISIONING" , GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: PiperV2 => "PIPER_V2" , GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: PiperV3 => "PIPER_V3" , GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: Ui => "UI" , GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: Unspecified => "UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin, ()>
        {
            Ok (match s { "APPLICATION_IP_PROVISIONING" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: ApplicationIpProvisioning , "PIPER_V2" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: PiperV2 , "PIPER_V3" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: PiperV3 , "UI" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: Ui , "UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: Unspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "APPLICATION_IP_PROVISIONING" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: ApplicationIpProvisioning , "PIPER_V2" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: PiperV2 , "PIPER_V3" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: PiperV3 , "UI" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: Ui , "UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin :: Unspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionOrigin
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationVersionState {
        #[doc = "Active."]
        Active,
        #[doc = "Archived."]
        Archived,
        #[doc = "Draft."]
        Draft,
        #[doc = "Default."]
        IntegrationStateUnspecified,
        #[doc = "Snapshot."]
        Snapshot,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationVersionState {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Active => "ACTIVE" , GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Archived => "ARCHIVED" , GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Draft => "DRAFT" , GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: IntegrationStateUnspecified => "INTEGRATION_STATE_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Snapshot => "SNAPSHOT" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaIntegrationVersionState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaIntegrationVersionState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaIntegrationVersionState, ()>
        {
            Ok (match s { "ACTIVE" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Active , "ARCHIVED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Archived , "DRAFT" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Draft , "INTEGRATION_STATE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: IntegrationStateUnspecified , "SNAPSHOT" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Snapshot , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaIntegrationVersionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaIntegrationVersionState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaIntegrationVersionState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ACTIVE" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Active , "ARCHIVED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Archived , "DRAFT" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Draft , "INTEGRATION_STATE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: IntegrationStateUnspecified , "SNAPSHOT" => GoogleCloudIntegrationsV1AlphaIntegrationVersionState :: Snapshot , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionState
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus {
        Active,
        Archived,
        Draft,
        Snapshot,
        Unknown,
    }
    impl GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Active => "ACTIVE",
                GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Archived => "ARCHIVED",
                GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Draft => "DRAFT",
                GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Snapshot => "SNAPSHOT",
                GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Unknown => "UNKNOWN",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus, ()>
        {
            Ok(match s {
                "ACTIVE" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Active,
                "ARCHIVED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Archived,
                "DRAFT" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Draft,
                "SNAPSHOT" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Snapshot,
                "UNKNOWN" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Unknown,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ACTIVE" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Active,
                "ARCHIVED" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Archived,
                "DRAFT" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Draft,
                "SNAPSHOT" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Snapshot,
                "UNKNOWN" => GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus::Unknown,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaIntegrationVersionStatus
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaJwt {
        #[doc = "The token calculated by the header, payload and signature."]
        #[serde(
            rename = "jwt",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub jwt: ::std::option::Option<String>,
        #[doc = "Identifies which algorithm is used to generate the signature."]
        #[serde(
            rename = "jwtHeader",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub jwt_header: ::std::option::Option<String>,
        #[doc = "Contains a set of claims. The JWT specification defines seven Registered Claim Names which are the standard fields commonly included in tokens. Custom claims are usually also included, depending on the purpose of the token."]
        #[serde(
            rename = "jwtPayload",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub jwt_payload: ::std::option::Option<String>,
        #[doc = "Userâ€™s pre-shared secret to sign the token."]
        #[serde(
            rename = "secret",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub secret: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaJwt {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaJwt {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaLiftSuspensionRequest {
        #[doc = "User passed in suspension result and will be used to control workflow execution branching behavior by setting up corresponnding edge condition with suspension result. For example, if you want to lift the suspension, you can pass â€œApprovedâ€, or if you want to reject the suspension and terminate workfloe execution, you can pass â€œRejectedâ€ and terminate the workflow execution with configuring the edge condition."]
        #[serde(
            rename = "suspensionResult",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspension_result: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaLiftSuspensionRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaLiftSuspensionRequest {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaLiftSuspensionResponse {
        #[doc = "Execution Id that will be returned"]
        #[serde(
            rename = "eventExecutionInfoId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_execution_info_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaLiftSuspensionResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaLiftSuspensionResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectRequest {
        #[doc = "The id of the Apps Script project to be linked."]
        #[serde(
            rename = "scriptId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub script_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectResponse {
        #[doc = "The id of the linked Apps Script project."]
        #[serde(
            rename = "scriptId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub script_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse {
        #[doc = "The list of AuthConfigs retrieved."]
        #[serde(
            rename = "authConfigs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_configs:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig>>,
        #[doc = "The token used to retrieve the next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaListCertificatesResponse {
        #[doc = "The list of Certificates retrieved."]
        #[serde(
            rename = "certificates",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub certificates:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate>>,
        #[doc = "The token used to retrieve the next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListCertificatesResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListCertificatesResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for GoogleCloudIntegrationsV1AlphaListCertificatesResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaListConnectionsResponse {
        #[doc = "Connections."]
        #[serde(
            rename = "connections",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connections:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudConnectorsV1Connection>>,
        #[doc = "Next page token."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListConnectionsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListConnectionsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for GoogleCloudIntegrationsV1AlphaListConnectionsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaListExecutionsResponse {
        #[doc = "Required. The detailed information of requested executions."]
        #[serde(
            rename = "executionInfos",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_infos: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoEventExecutionInfo>,
        >,
        #[doc = "The detailed information of requested executions"]
        #[serde(
            rename = "executions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub executions:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaExecution>>,
        #[doc = "The token used to retrieve the next page results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListExecutionsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaListExecutionsResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for GoogleCloudIntegrationsV1AlphaListExecutionsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaListIntegrationTemplateVersionsResponse {
        #[doc = "The IntegrationTemplateVersions which match the request."]
        #[serde(
            rename = "integrationTemplateVersions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integration_template_versions: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion>,
        >,
        #[doc = "A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListIntegrationTemplateVersionsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListIntegrationTemplateVersionsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String>
        for GoogleCloudIntegrationsV1AlphaListIntegrationTemplateVersionsResponse
    {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse {
        #[doc = "The integrations which match the request."]
        #[serde(
            rename = "integrationVersions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integration_versions: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion>,
        >,
        #[doc = "A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "Whether the user has no permission on the version or not."]
        #[serde(
            rename = "noPermission",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_permission: ::std::option::Option<bool>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String>
        for GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse
    {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaListIntegrationsResponse {
        #[doc = "The integrations which match the request."]
        #[serde(
            rename = "integrations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integrations:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaIntegration>>,
        #[doc = "The next page token for the response."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListIntegrationsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListIntegrationsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for GoogleCloudIntegrationsV1AlphaListIntegrationsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaListRuntimeActionSchemasResponse {
        #[doc = "Next page token."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "Runtime action schemas."]
        #[serde(
            rename = "runtimeActionSchemas",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub runtime_action_schemas: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaRuntimeActionSchema>,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListRuntimeActionSchemasResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListRuntimeActionSchemasResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String>
        for GoogleCloudIntegrationsV1AlphaListRuntimeActionSchemasResponse
    {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaListRuntimeEntitySchemasResponse {
        #[doc = "Next page token."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "Runtime entity schemas."]
        #[serde(
            rename = "runtimeEntitySchemas",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub runtime_entity_schemas: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaRuntimeEntitySchema>,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListRuntimeEntitySchemasResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListRuntimeEntitySchemasResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String>
        for GoogleCloudIntegrationsV1AlphaListRuntimeEntitySchemasResponse
    {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse {
        #[doc = "The token used to retrieve the next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "The list of SfdcChannels retrieved."]
        #[serde(
            rename = "sfdcChannels",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sfdc_channels:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse {
        #[doc = "The token used to retrieve the next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "The list of SfdcInstances retrieved."]
        #[serde(
            rename = "sfdcInstances",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sfdc_instances:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaListSuspensionsResponse {
        #[doc = "Token to retrieve the next page of results."]
        #[serde(
            rename = "nextPageToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "The suspensions for the relevant execution which the caller has permissions to view and resolve."]
        #[serde(
            rename = "suspensions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspensions:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaSuspension>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaListSuspensionsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaListSuspensionsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    impl crate::GetNextPageToken<String> for GoogleCloudIntegrationsV1AlphaListSuspensionsResponse {
        fn next_page_token(&self) -> ::std::option::Option<String> {
            self.next_page_token.to_owned()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaNextTask {
        #[doc = "Standard filter expression for this task to become an eligible next task."]
        #[serde(
            rename = "condition",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub condition: ::std::option::Option<String>,
        #[doc = "User-provided description intended to give additional business context about the task."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "User-provided label that is attached to this edge in the UI."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "ID of the next task."]
        #[serde(
            rename = "taskConfigId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_config_id: ::std::option::Option<String>,
        #[doc = "Task number of the next task."]
        #[serde(
            rename = "taskId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaNextTask {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaNextTask {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCode {
        #[doc = "The access token received from the token endpoint."]
        #[serde(
            rename = "accessToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_token:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaAccessToken>,
        #[doc = "Indicates if the user has opted in Google Reauth Policy. If opted in, the refresh token will be valid for 20 hours, after which time users must re-authenticate in order to obtain a new one."]
        #[serde(
            rename = "applyReauthPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub apply_reauth_policy: ::std::option::Option<bool>,
        #[doc = "The Auth Code that is used to initially retrieve the access token."]
        #[serde(
            rename = "authCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_code: ::std::option::Option<String>,
        #[doc = "The auth url endpoint to send the auth code request to."]
        #[serde(
            rename = "authEndpoint",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_endpoint: ::std::option::Option<String>,
        #[doc = "The auth parameters sent along with the auth code request."]
        #[serde(
            rename = "authParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_params:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMap>,
        #[doc = "The clientâ€™s id."]
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "The clientâ€™s secret."]
        #[serde(
            rename = "clientSecret",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_secret: ::std::option::Option<String>,
        #[doc = "Represent how to pass parameters to fetch access token"]
        #[serde(
            rename = "requestType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType,
        >,
        #[doc = "A space-delimited list of requested scope permissions."]
        #[serde(
            rename = "scope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scope: ::std::option::Option<String>,
        #[doc = "The token url endpoint to send the token request to."]
        #[serde(
            rename = "tokenEndpoint",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_endpoint: ::std::option::Option<String>,
        #[doc = "The token parameters sent along with the token request."]
        #[serde(
            rename = "tokenParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_params:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMap>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCode
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCode
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType {
        #[doc = "To pass client id and client secret as base 64 encoding of client_id:client_password and rest parameters in post body."]
        EncodedHeader,
        #[doc = "To pass all the parameters as a part of query parameter."]
        QueryParameters,
        #[doc = "To pass all the parameters in post body."]
        RequestBody,
        #[doc = "Unspecified request type"]
        RequestTypeUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: EncodedHeader => "ENCODED_HEADER" , GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: QueryParameters => "QUERY_PARAMETERS" , GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: RequestBody => "REQUEST_BODY" , GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: RequestTypeUnspecified => "REQUEST_TYPE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType,
            (),
        > {
            Ok (match s { "ENCODED_HEADER" => GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: EncodedHeader , "QUERY_PARAMETERS" => GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: QueryParameters , "REQUEST_BODY" => GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: RequestBody , "REQUEST_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: RequestTypeUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ENCODED_HEADER" => GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: EncodedHeader , "QUERY_PARAMETERS" => GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: QueryParameters , "REQUEST_BODY" => GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: RequestBody , "REQUEST_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType :: RequestTypeUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaOAuth2AuthorizationCodeRequestType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentials {
        #[doc = "Access token fetched from the authorization server."]
        #[serde(
            rename = "accessToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_token:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaAccessToken>,
        #[doc = "The clientâ€™s ID."]
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "The clientâ€™s secret."]
        #[serde(
            rename = "clientSecret",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_secret: ::std::option::Option<String>,
        #[doc = "Represent how to pass parameters to fetch access token"]
        #[serde(
            rename = "requestType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType,
        >,
        #[doc = "A space-delimited list of requested scope permissions."]
        #[serde(
            rename = "scope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scope: ::std::option::Option<String>,
        #[doc = "The token endpoint is used by the client to obtain an access token by presenting its authorization grant or refresh token."]
        #[serde(
            rename = "tokenEndpoint",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_endpoint: ::std::option::Option<String>,
        #[doc = "Token parameters for the auth request."]
        #[serde(
            rename = "tokenParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_params:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMap>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentials
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentials
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType {
        #[doc = "To pass client id and client secret as base 64 encoding of client_id:client_password and rest parameters in post body."]
        EncodedHeader,
        #[doc = "To pass all the parameters as a part of query parameter."]
        QueryParameters,
        #[doc = "To pass all the parameters in post body."]
        RequestBody,
        #[doc = "Unspecified request type"]
        RequestTypeUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: EncodedHeader => "ENCODED_HEADER" , GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: QueryParameters => "QUERY_PARAMETERS" , GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: RequestBody => "REQUEST_BODY" , GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: RequestTypeUnspecified => "REQUEST_TYPE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType,
            (),
        > {
            Ok (match s { "ENCODED_HEADER" => GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: EncodedHeader , "QUERY_PARAMETERS" => GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: QueryParameters , "REQUEST_BODY" => GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: RequestBody , "REQUEST_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: RequestTypeUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ENCODED_HEADER" => GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: EncodedHeader , "QUERY_PARAMETERS" => GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: QueryParameters , "REQUEST_BODY" => GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: RequestBody , "REQUEST_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType :: RequestTypeUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaOAuth2ClientCredentialsRequestType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentials {
        #[doc = "Access token fetched from the authorization server."]
        #[serde(
            rename = "accessToken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub access_token:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaAccessToken>,
        #[doc = "The clientâ€™s ID."]
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "The clientâ€™s secret."]
        #[serde(
            rename = "clientSecret",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_secret: ::std::option::Option<String>,
        #[doc = "The userâ€™s password."]
        #[serde(
            rename = "password",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub password: ::std::option::Option<String>,
        #[doc = "Represent how to pass parameters to fetch access token"]
        #[serde(
            rename = "requestType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType,
        >,
        #[doc = "A space-delimited list of requested scope permissions."]
        #[serde(
            rename = "scope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scope: ::std::option::Option<String>,
        #[doc = "The token endpoint is used by the client to obtain an access token by presenting its authorization grant or refresh token."]
        #[serde(
            rename = "tokenEndpoint",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_endpoint: ::std::option::Option<String>,
        #[doc = "Token parameters for the auth request."]
        #[serde(
            rename = "tokenParams",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_params:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMap>,
        #[doc = "The userâ€™s username."]
        #[serde(
            rename = "username",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub username: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentials
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentials
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType {
        #[doc = "To pass client id and client secret as base 64 encoding of client_id:client_password and rest parameters in post body."]
        EncodedHeader,
        #[doc = "To pass all the parameters as a part of query parameter."]
        QueryParameters,
        #[doc = "To pass all the parameters in post body."]
        RequestBody,
        #[doc = "Unspecified request type"]
        RequestTypeUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: EncodedHeader => "ENCODED_HEADER" , GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: QueryParameters => "QUERY_PARAMETERS" , GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: RequestBody => "REQUEST_BODY" , GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: RequestTypeUnspecified => "REQUEST_TYPE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType,
            (),
        > {
            Ok (match s { "ENCODED_HEADER" => GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: EncodedHeader , "QUERY_PARAMETERS" => GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: QueryParameters , "REQUEST_BODY" => GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: RequestBody , "REQUEST_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: RequestTypeUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "ENCODED_HEADER" => GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: EncodedHeader , "QUERY_PARAMETERS" => GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: QueryParameters , "REQUEST_BODY" => GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: RequestBody , "REQUEST_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType :: RequestTypeUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaOAuth2ResourceOwnerCredentialsRequestType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaOidcToken {
        #[doc = "Audience to be used when generating OIDC token. The audience claim identifies the recipients that the JWT is intended for."]
        #[serde(
            rename = "audience",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub audience: ::std::option::Option<String>,
        #[doc = "The service account email to be used as the identity for the token."]
        #[serde(
            rename = "serviceAccountEmail",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_account_email: ::std::option::Option<String>,
        #[doc = "ID token obtained for the service account"]
        #[serde(
            rename = "token",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token: ::std::option::Option<String>,
        #[doc = "The approximate time until the token retrieved is valid."]
        #[serde(
            rename = "tokenExpireTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub token_expire_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaOidcToken {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaOidcToken {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaParameterMap {
        #[doc = "A list of parameter map entries."]
        #[serde(
            rename = "entries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub entries: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMapEntry>,
        >,
        #[doc = "Option to specify key type for all entries of the map. If provided then field types for all entries must conform to this."]
        #[serde(
            rename = "keyType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMapKeyType,
        >,
        #[doc = "Option to specify value type for all entries of the map. If provided then field types for all entries must conform to this."]
        #[serde(
            rename = "valueType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMapValueType,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaParameterMap {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaParameterMap {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        #[doc = "Boolean Array."]
        BooleanArray,
        #[doc = "Boolean."]
        BooleanValue,
        #[doc = "Double Number Array."]
        DoubleArray,
        #[doc = "Double Number."]
        DoubleValue,
        #[doc = "Integer Array."]
        IntArray,
        #[doc = "Integer."]
        IntValue,
        #[doc = "Unspecified."]
        IntegrationParameterDataTypeUnspecified,
        #[doc = "Json."]
        JsonValue,
        #[doc = "Proto Array (Internal use only)."]
        ProtoArray,
        #[doc = "Proto Value (Internal use only)."]
        ProtoValue,
        #[doc = "String Array."]
        StringArray,
        #[doc = "String."]
        StringValue,
    }
    impl GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: BooleanArray => "BOOLEAN_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: BooleanValue => "BOOLEAN_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: DoubleArray => "DOUBLE_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: DoubleValue => "DOUBLE_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntArray => "INT_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntValue => "INT_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntegrationParameterDataTypeUnspecified => "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: JsonValue => "JSON_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: ProtoArray => "PROTO_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: ProtoValue => "PROTO_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: StringArray => "STRING_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: StringValue => "STRING_VALUE" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaParameterMapKeyType, ()> {
            Ok (match s { "BOOLEAN_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: BooleanArray , "BOOLEAN_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: BooleanValue , "DOUBLE_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: DoubleArray , "DOUBLE_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: DoubleValue , "INT_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntArray , "INT_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntValue , "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntegrationParameterDataTypeUnspecified , "JSON_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: JsonValue , "PROTO_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: ProtoArray , "PROTO_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: ProtoValue , "STRING_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: StringArray , "STRING_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: StringValue , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "BOOLEAN_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: BooleanArray , "BOOLEAN_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: BooleanValue , "DOUBLE_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: DoubleArray , "DOUBLE_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: DoubleValue , "INT_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntArray , "INT_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntValue , "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: IntegrationParameterDataTypeUnspecified , "JSON_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: JsonValue , "PROTO_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: ProtoArray , "PROTO_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: ProtoValue , "STRING_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: StringArray , "STRING_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapKeyType :: StringValue , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaParameterMapKeyType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaParameterMapValueType {
        #[doc = "Boolean Array."]
        BooleanArray,
        #[doc = "Boolean."]
        BooleanValue,
        #[doc = "Double Number Array."]
        DoubleArray,
        #[doc = "Double Number."]
        DoubleValue,
        #[doc = "Integer Array."]
        IntArray,
        #[doc = "Integer."]
        IntValue,
        #[doc = "Unspecified."]
        IntegrationParameterDataTypeUnspecified,
        #[doc = "Json."]
        JsonValue,
        #[doc = "Proto Array (Internal use only)."]
        ProtoArray,
        #[doc = "Proto Value (Internal use only)."]
        ProtoValue,
        #[doc = "String Array."]
        StringArray,
        #[doc = "String."]
        StringValue,
    }
    impl GoogleCloudIntegrationsV1AlphaParameterMapValueType {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaParameterMapValueType :: BooleanArray => "BOOLEAN_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: BooleanValue => "BOOLEAN_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: DoubleArray => "DOUBLE_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: DoubleValue => "DOUBLE_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntArray => "INT_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntValue => "INT_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntegrationParameterDataTypeUnspecified => "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: JsonValue => "JSON_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: ProtoArray => "PROTO_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: ProtoValue => "PROTO_VALUE" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: StringArray => "STRING_ARRAY" , GoogleCloudIntegrationsV1AlphaParameterMapValueType :: StringValue => "STRING_VALUE" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaParameterMapValueType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaParameterMapValueType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaParameterMapValueType, ()>
        {
            Ok (match s { "BOOLEAN_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: BooleanArray , "BOOLEAN_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: BooleanValue , "DOUBLE_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: DoubleArray , "DOUBLE_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: DoubleValue , "INT_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntArray , "INT_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntValue , "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntegrationParameterDataTypeUnspecified , "JSON_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: JsonValue , "PROTO_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: ProtoArray , "PROTO_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: ProtoValue , "STRING_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: StringArray , "STRING_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: StringValue , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaParameterMapValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaParameterMapValueType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaParameterMapValueType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "BOOLEAN_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: BooleanArray , "BOOLEAN_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: BooleanValue , "DOUBLE_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: DoubleArray , "DOUBLE_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: DoubleValue , "INT_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntArray , "INT_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntValue , "INTEGRATION_PARAMETER_DATA_TYPE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: IntegrationParameterDataTypeUnspecified , "JSON_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: JsonValue , "PROTO_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: ProtoArray , "PROTO_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: ProtoValue , "STRING_ARRAY" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: StringArray , "STRING_VALUE" => GoogleCloudIntegrationsV1AlphaParameterMapValueType :: StringValue , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaParameterMapValueType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaParameterMapValueType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaParameterMapEntry {
        #[doc = "Key of the map entry."]
        #[serde(
            rename = "key",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub key:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMapField>,
        #[doc = "Value of the map entry."]
        #[serde(
            rename = "value",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub value:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaParameterMapField>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaParameterMapEntry {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaParameterMapEntry {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaParameterMapField {
        #[doc = "Passing a literal value."]
        #[serde(
            rename = "literalValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub literal_value:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaValueType>,
        #[doc = "Referencing one of the Integration variables."]
        #[serde(
            rename = "referenceKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub reference_key: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaParameterMapField {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaParameterMapField {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionRequest {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionResponse {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaResolveSuspensionRequest {
        #[doc = "Suspension, containing the event_execution_info_id, task_id, and state to set on the corresponding suspension record."]
        #[serde(
            rename = "suspension",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspension:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaSuspension>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaResolveSuspensionRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaResolveSuspensionRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaResolveSuspensionResponse {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaResolveSuspensionResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaResolveSuspensionResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaRuntimeActionSchema {
        #[doc = "Name of the action."]
        #[serde(
            rename = "action",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub action: ::std::option::Option<String>,
        #[doc = "Input parameter schema for the action."]
        #[serde(
            rename = "inputSchema",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_schema: ::std::option::Option<String>,
        #[doc = "Output parameter schema for the action."]
        #[serde(
            rename = "outputSchema",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub output_schema: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaRuntimeActionSchema {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaRuntimeActionSchema {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaRuntimeEntitySchema {
        #[doc = "The above schema, but for an array of the associated entity."]
        #[serde(
            rename = "arrayFieldSchema",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub array_field_schema: ::std::option::Option<String>,
        #[doc = "Name of the entity."]
        #[serde(
            rename = "entity",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub entity: ::std::option::Option<String>,
        #[doc = "List of fields in the entity."]
        #[serde(
            rename = "fieldSchema",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub field_schema: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaRuntimeEntitySchema {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaRuntimeEntitySchema {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaScheduleIntegrationsRequest {
        #[doc = "Optional. Input parameters used by integration execution."]
        #[serde(
            rename = "inputParameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub input_parameters: ::std::option::Option<
            ::std::collections::BTreeMap<
                String,
                crate::schemas::GoogleCloudIntegrationsV1AlphaValueType,
            >,
        >,
        #[doc = "Parameters are a part of Event and can be used to communicate between different tasks that are part of the same integration execution."]
        #[serde(
            rename = "parameterEntries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameter_entries: ::std::option::Option<
            Vec<crate::schemas::EnterpriseCrmFrontendsEventbusProtoParameterEntry>,
        >,
        #[doc = "Passed in as parameters to each integration execution."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoEventParameters>,
        #[doc = "This is used to de-dup incoming request: if the duplicate request was detected, the response from the previous execution is returned."]
        #[serde(
            rename = "requestId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_id: ::std::option::Option<String>,
        #[doc = "The time that the integration should be executed. If the time is less or equal to the current time, the integration is executed immediately."]
        #[serde(
            rename = "scheduleTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub schedule_time: ::std::option::Option<String>,
        #[doc = "Matched against all {@link TriggerConfig}s across all integrations. i.e. TriggerConfig.trigger_id.equals(trigger_id)"]
        #[serde(
            rename = "triggerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaScheduleIntegrationsRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaScheduleIntegrationsRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaScheduleIntegrationsResponse {
        #[doc = "The execution info id for the executed integrations."]
        #[serde(
            rename = "executionInfoIds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub execution_info_ids: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaScheduleIntegrationsResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaScheduleIntegrationsResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaServiceAccountCredentials {
        #[doc = "A space-delimited list of requested scope permissions."]
        #[serde(
            rename = "scope",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scope: ::std::option::Option<String>,
        #[doc = "Name of the service account that has the permission to make the request."]
        #[serde(
            rename = "serviceAccount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_account: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaServiceAccountCredentials
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaServiceAccountCredentials
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaSfdcChannel {
        #[doc = "The Channel topic defined by salesforce once an channel is opened"]
        #[serde(
            rename = "channelTopic",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub channel_topic: ::std::option::Option<String>,
        #[doc = "Output only. Time when the channel is created"]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. Time when the channel was deleted. Empty if not deleted."]
        #[serde(
            rename = "deleteTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub delete_time: ::std::option::Option<String>,
        #[doc = "The description for this channel"]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Client level unique name/alias to easily reference a channel."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Indicated if a channel has any active integrations referencing it. Set to false when the channel is created, and set to true if there is any integration published with the channel configured in it."]
        #[serde(
            rename = "isActive",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub is_active: ::std::option::Option<bool>,
        #[doc = "Last sfdc messsage replay id for channel"]
        #[serde(
            rename = "lastReplayId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_replay_id: ::std::option::Option<String>,
        #[doc = "Resource name of the SFDC channel projects/{project}/locations/{location}/sfdcInstances/{sfdc_instance}/sfdcChannels/{sfdc_channel}."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Output only. Time when the channel was last updated"]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaSfdcChannel {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaSfdcChannel {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaSfdcInstance {
        #[doc = "A list of AuthConfigs that can be tried to open the channel to SFDC"]
        #[serde(
            rename = "authConfigId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub auth_config_id: ::std::option::Option<Vec<String>>,
        #[doc = "Output only. Time when the instance is created"]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Output only. Time when the instance was deleted. Empty if not deleted."]
        #[serde(
            rename = "deleteTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub delete_time: ::std::option::Option<String>,
        #[doc = "A description of the sfdc instance."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "User selected unique name/alias to easily reference an instance."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Resource name of the SFDC instance projects/{project}/locations/{location}/sfdcInstances/{sfdcInstance}."]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "URL used for API calls after authentication (the login authority is configured within the referenced AuthConfig)."]
        #[serde(
            rename = "serviceAuthority",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub service_authority: ::std::option::Option<String>,
        #[doc = "The SFDC Org Id. This is defined in salesforce."]
        #[serde(
            rename = "sfdcOrgId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sfdc_org_id: ::std::option::Option<String>,
        #[doc = "Output only. Time when the instance was last updated"]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaSfdcInstance {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaSfdcInstance {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaStringParameterArray {
        #[doc = "String array."]
        #[serde(
            rename = "stringValues",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_values: ::std::option::Option<Vec<String>>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaStringParameterArray {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaStringParameterArray {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaSuccessPolicy {
        #[doc = "State to which the execution snapshot status will be set if the task succeeds."]
        #[serde(
            rename = "finalState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub final_state: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaSuccessPolicy {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaSuccessPolicy {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState {
        #[doc = "UNSPECIFIED."]
        FinalStateUnspecified,
        #[doc = "The default behavior, where successful tasks will be marked as SUCCEEDED."]
        Succeeded,
        #[doc = "Sets the state to SUSPENDED after executing. This is required for SuspensionTask; event execution will continue once the user calls ResolveSuspensions with the event_execution_info_id and the task number."]
        Suspended,
    }
    impl GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::FinalStateUnspecified => {
                    "FINAL_STATE_UNSPECIFIED"
                }
                GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::Succeeded => "SUCCEEDED",
                GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::Suspended => "SUSPENDED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState, ()>
        {
            Ok(match s {
                "FINAL_STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::FinalStateUnspecified
                }
                "SUCCEEDED" => GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::Succeeded,
                "SUSPENDED" => GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::Suspended,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "FINAL_STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::FinalStateUnspecified
                }
                "SUCCEEDED" => GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::Succeeded,
                "SUSPENDED" => GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState::Suspended,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaSuccessPolicyFinalState
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaSuspension {
        #[doc = "Controls the notifications and approval permissions for this suspension."]
        #[serde(
            rename = "approvalConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub approval_config: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaSuspensionApprovalConfig,
        >,
        #[doc = "Metadata pertaining to the resolution of this suspension."]
        #[serde(
            rename = "audit",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub audit:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaSuspensionAudit>,
        #[doc = "Output only. Auto-generated."]
        #[serde(
            rename = "createTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub create_time: ::std::option::Option<String>,
        #[doc = "Required. ID of the associated execution."]
        #[serde(
            rename = "eventExecutionInfoId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub event_execution_info_id: ::std::option::Option<String>,
        #[doc = "Required. The name of the originating integration."]
        #[serde(
            rename = "integration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integration: ::std::option::Option<String>,
        #[doc = "Output only. Auto-generated."]
        #[serde(
            rename = "lastModifyTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_modify_time: ::std::option::Option<String>,
        #[doc = "Resource name for suspensions suspension/{suspension_id}"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Required. State of this suspension, indicating what action a resolver has taken."]
        #[serde(
            rename = "state",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub state:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaSuspensionState>,
        #[doc = "Controls the notifications and resolver permissions for this suspension."]
        #[serde(
            rename = "suspensionConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suspension_config:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoSuspensionConfig>,
        #[doc = "Required. Task id of the associated SuspensionTask."]
        #[serde(
            rename = "taskId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_id: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaSuspension {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaSuspension {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaSuspensionState {
        #[doc = "The resolver has lifted the suspension."]
        Lifted,
        #[doc = "The suspension has not yet been resolved."]
        Pending,
        #[doc = "The resolver has rejected the suspension."]
        Rejected,
        #[doc = "Unset state."]
        ResolutionStateUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaSuspensionState {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudIntegrationsV1AlphaSuspensionState::Lifted => "LIFTED",
                GoogleCloudIntegrationsV1AlphaSuspensionState::Pending => "PENDING",
                GoogleCloudIntegrationsV1AlphaSuspensionState::Rejected => "REJECTED",
                GoogleCloudIntegrationsV1AlphaSuspensionState::ResolutionStateUnspecified => {
                    "RESOLUTION_STATE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaSuspensionState {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaSuspensionState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaSuspensionState, ()> {
            Ok(match s {
                "LIFTED" => GoogleCloudIntegrationsV1AlphaSuspensionState::Lifted,
                "PENDING" => GoogleCloudIntegrationsV1AlphaSuspensionState::Pending,
                "REJECTED" => GoogleCloudIntegrationsV1AlphaSuspensionState::Rejected,
                "RESOLUTION_STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaSuspensionState::ResolutionStateUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaSuspensionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaSuspensionState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaSuspensionState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "LIFTED" => GoogleCloudIntegrationsV1AlphaSuspensionState::Lifted,
                "PENDING" => GoogleCloudIntegrationsV1AlphaSuspensionState::Pending,
                "REJECTED" => GoogleCloudIntegrationsV1AlphaSuspensionState::Rejected,
                "RESOLUTION_STATE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaSuspensionState::ResolutionStateUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaSuspensionState {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaSuspensionState {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaSuspensionApprovalConfig {
        #[doc = "Information to provide for recipients."]
        #[serde(
            rename = "customMessage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub custom_message: ::std::option::Option<String>,
        #[doc = "Email addresses to send approval request to."]
        #[serde(
            rename = "emailAddresses",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub email_addresses: ::std::option::Option<Vec<String>>,
        #[doc = "Indicates the next steps when no external actions happen on the suspension."]
        #[serde(
            rename = "expiration",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub expiration: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaSuspensionApprovalExpiration,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaSuspensionApprovalConfig
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaSuspensionApprovalConfig
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaSuspensionApprovalExpiration {
        #[doc = "Output only. Time after which the suspension expires, if no action taken."]
        #[serde(
            rename = "expireTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub expire_time: ::std::option::Option<String>,
        #[doc = "Whether the suspension will be REJECTED or LIFTED upon expiration. REJECTED is the default behavior."]
        #[serde(
            rename = "liftWhenExpired",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lift_when_expired: ::std::option::Option<bool>,
        #[doc = "Time after the previous suspension action reminder, if any, is sent using the selected notification option, for a suspension which is still PENDING_UNSPECIFIED."]
        #[serde(
            rename = "remindTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub remind_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaSuspensionApprovalExpiration
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaSuspensionApprovalExpiration
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaSuspensionAudit {
        #[doc = "Time at which this suspension was resolved."]
        #[serde(
            rename = "resolveTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resolve_time: ::std::option::Option<String>,
        #[doc = "Email address of the person who resolved this suspension."]
        #[serde(
            rename = "resolver",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub resolver: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaSuspensionAudit {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaSuspensionAudit {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaTakeoverEditLockRequest {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaTakeoverEditLockRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaTakeoverEditLockRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaTakeoverEditLockResponse {
        #[doc = "Version after the lock is acquired by the new user."]
        #[serde(
            rename = "integrationVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integration_version:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaTakeoverEditLockResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaTakeoverEditLockResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaTaskConfig {
        #[doc = "Optional. User-provided description intended to give additional business context about the task."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Optional. User-provided label that is attached to this TaskConfig in the UI."]
        #[serde(
            rename = "displayName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub display_name: ::std::option::Option<String>,
        #[doc = "Optional. Determines the number of times the task will be retried on failure and with what retry strategy. This is applicable for asynchronous calls to Eventbus alone (Post To Queue, Schedule etc.)."]
        #[serde(
            rename = "failurePolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub failure_policy:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaFailurePolicy>,
        #[doc = "Optional. If set, overrides the option configured in the Task implementation class."]
        #[serde(
            rename = "jsonValidationOption",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub json_validation_option: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption,
        >,
        #[doc = "Optional. The set of tasks that are next in line to be executed as per the execution graph defined for the parent event, specified by `event_config_id`. Each of these next tasks are executed only if the condition associated with them evaluates to true."]
        #[serde(
            rename = "nextTasks",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_tasks:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaNextTask>>,
        #[doc = "Optional. The policy dictating the execution of the next set of tasks for the current task."]
        #[serde(
            rename = "nextTasksExecutionPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_tasks_execution_policy: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy,
        >,
        #[doc = "Optional. The customized parameters the user can pass to this task."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters: ::std::option::Option<
            ::std::collections::BTreeMap<
                String,
                crate::schemas::GoogleCloudIntegrationsV1AlphaEventParameter,
            >,
        >,
        #[doc = "Optional. Determines what action to take upon successful task completion."]
        #[serde(
            rename = "successPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub success_policy:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaSuccessPolicy>,
        #[doc = "Optional. Determines the number of times the task will be retried on failure and with what retry strategy. This is applicable for synchronous calls to Eventbus alone (Post)."]
        #[serde(
            rename = "synchronousCallFailurePolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub synchronous_call_failure_policy:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaFailurePolicy>,
        #[doc = "Optional. The name for the task."]
        #[serde(
            rename = "task",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task: ::std::option::Option<String>,
        #[doc = "Optional. The policy dictating the execution strategy of this task."]
        #[serde(
            rename = "taskExecutionStrategy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_execution_strategy: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy,
        >,
        #[doc = "Required. The identifier of this task within its parent event config, specified by the client. This should be unique among all the tasks belong to the same event config. We use this field as the identifier to find next tasks (via field `next_tasks.task_id`)."]
        #[serde(
            rename = "taskId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_id: ::std::option::Option<String>,
        #[doc = "Optional. Used to define task-template name if task is of type task-template"]
        #[serde(
            rename = "taskTemplate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_template: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaTaskConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaTaskConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption {
        #[doc = "As per the default behavior, no validation will be run. Will not override any option set in a Task."]
        JsonValidationOptionUnspecified,
        #[doc = "Validate all potential output JSON parameters against schemas specified in IntegrationParameter."]
        PostExecution,
        #[doc = "Validate all potential input JSON parameters against schemas specified in IntegrationParameter."]
        PreExecution,
        #[doc = "Perform both PRE_EXECUTION and POST_EXECUTION validations."]
        PrePostExecution,
        #[doc = "Do not run any validation against JSON schemas."]
        Skip,
    }
    impl GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: JsonValidationOptionUnspecified => "JSON_VALIDATION_OPTION_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PostExecution => "POST_EXECUTION" , GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PreExecution => "PRE_EXECUTION" , GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PrePostExecution => "PRE_POST_EXECUTION" , GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: Skip => "SKIP" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption, ()>
        {
            Ok (match s { "JSON_VALIDATION_OPTION_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: JsonValidationOptionUnspecified , "POST_EXECUTION" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PostExecution , "PRE_EXECUTION" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PreExecution , "PRE_POST_EXECUTION" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PrePostExecution , "SKIP" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: Skip , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "JSON_VALIDATION_OPTION_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: JsonValidationOptionUnspecified , "POST_EXECUTION" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PostExecution , "PRE_EXECUTION" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PreExecution , "PRE_POST_EXECUTION" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: PrePostExecution , "SKIP" => GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption :: Skip , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaTaskConfigJsonValidationOption
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy {
        #[doc = "Default."]
        NextTasksExecutionPolicyUnspecified,
        #[doc = "Execute all the tasks that satisfy their associated condition."]
        RunAllMatch,
        #[doc = "Execute the first task that satisfies the associated condition."]
        RunFirstMatch,
    }
    impl GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: NextTasksExecutionPolicyUnspecified => "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: RunAllMatch => "RUN_ALL_MATCH" , GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: RunFirstMatch => "RUN_FIRST_MATCH" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy,
            (),
        > {
            Ok (match s { "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: NextTasksExecutionPolicyUnspecified , "RUN_ALL_MATCH" => GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: RunAllMatch , "RUN_FIRST_MATCH" => GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: RunFirstMatch , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: NextTasksExecutionPolicyUnspecified , "RUN_ALL_MATCH" => GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: RunAllMatch , "RUN_FIRST_MATCH" => GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy :: RunFirstMatch , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaTaskConfigNextTasksExecutionPolicy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy {
        #[doc = "Default. If the strategy is not set explicitly, it will default to `WHEN_ALL_SUCCEED`."]
        TaskExecutionStrategyUnspecified,
        #[doc = "Wait until all of its previous tasks finished execution, then verify at least one of the edge conditions is met, and execute if possible. This should be considered as WHEN_ALL_TASKS_SUCCEED."]
        WhenAllSucceed,
        #[doc = "Wait until all of its previous tasks finished execution, then verify the all edge conditions are met and execute if possible."]
        WhenAllTasksAndConditionsSucceed,
        #[doc = "Start execution as long as any of its previous tasks finished execution and the corresponding edge condition is met (since we will execute if only that succeeding edge condition is met)."]
        WhenAnySucceed,
    }
    impl GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: TaskExecutionStrategyUnspecified => "TASK_EXECUTION_STRATEGY_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAllSucceed => "WHEN_ALL_SUCCEED" , GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAllTasksAndConditionsSucceed => "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED" , GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAnySucceed => "WHEN_ANY_SUCCEED" , }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy, ()>
        {
            Ok (match s { "TASK_EXECUTION_STRATEGY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: TaskExecutionStrategyUnspecified , "WHEN_ALL_SUCCEED" => GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAllSucceed , "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED" => GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAllTasksAndConditionsSucceed , "WHEN_ANY_SUCCEED" => GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAnySucceed , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "TASK_EXECUTION_STRATEGY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: TaskExecutionStrategyUnspecified , "WHEN_ALL_SUCCEED" => GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAllSucceed , "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED" => GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAllTasksAndConditionsSucceed , "WHEN_ANY_SUCCEED" => GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy :: WhenAnySucceed , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaTaskConfigTaskExecutionStrategy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaTaskExecutionDetails {
        #[doc = "Status for the current task execution attempt."]
        #[serde(
            rename = "taskAttemptStats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_attempt_stats:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaAttemptStats>>,
        #[doc = "The execution state of this task."]
        #[serde(
            rename = "taskExecutionState",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_execution_state: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState,
        >,
        #[doc = "Pointer to the task config it used for execution."]
        #[serde(
            rename = "taskNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub task_number: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaTaskExecutionDetails {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaTaskExecutionDetails {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState {
        #[doc = "Task execution canceled when in progress. This happens when event execution been canceled or any other task fall in fatal state."]
        Cancelled,
        #[doc = "Task execution failed. Thereâ€™s no more change after this state."]
        Failed,
        #[doc = "Task execution failed and cause the whole event execution to fail immediately. Thereâ€™s no more change after this state."]
        Fatal,
        #[doc = "Task is under processing."]
        InProcess,
        #[doc = "Task is waiting for its precondition tasks to finish to start the execution."]
        PendingExecution,
        #[doc = "Task is waiting for its dependency tasksâ€™ rollback to finish to start its rollback."]
        PendingRollback,
        #[doc = "Task execution failed and waiting for retry."]
        RetryOnHold,
        #[doc = "Task is rolling back."]
        RollbackInProcess,
        #[doc = "Task is rolled back. This is the state we will set regardless of rollback succeeding or failing."]
        Rolledback,
        #[doc = "Task execution skipped. This happens when its precondition wasnâ€™t met, or the event execution been canceled before reach to the task. Thereâ€™s no more changes after this state."]
        Skipped,
        #[doc = "Task execution successfully finished. Thereâ€™s no more change after this state."]
        Succeed,
        #[doc = "Task is a SuspensionTask which has executed once, creating a pending suspension."]
        Suspended,
        #[doc = "Default value."]
        TaskExecutionStateUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Cancelled => "CANCELLED" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Failed => "FAILED" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Fatal => "FATAL" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: InProcess => "IN_PROCESS" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: PendingExecution => "PENDING_EXECUTION" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: PendingRollback => "PENDING_ROLLBACK" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: RetryOnHold => "RETRY_ON_HOLD" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: RollbackInProcess => "ROLLBACK_IN_PROCESS" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Rolledback => "ROLLEDBACK" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Skipped => "SKIPPED" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Succeed => "SUCCEED" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Suspended => "SUSPENDED" , GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: TaskExecutionStateUnspecified => "TASK_EXECUTION_STATE_UNSPECIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState,
            (),
        > {
            Ok (match s { "CANCELLED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Cancelled , "FAILED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Failed , "FATAL" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Fatal , "IN_PROCESS" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: InProcess , "PENDING_EXECUTION" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: PendingExecution , "PENDING_ROLLBACK" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: PendingRollback , "RETRY_ON_HOLD" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: RetryOnHold , "ROLLBACK_IN_PROCESS" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: RollbackInProcess , "ROLLEDBACK" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Rolledback , "SKIPPED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Skipped , "SUCCEED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Succeed , "SUSPENDED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Suspended , "TASK_EXECUTION_STATE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: TaskExecutionStateUnspecified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "CANCELLED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Cancelled , "FAILED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Failed , "FATAL" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Fatal , "IN_PROCESS" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: InProcess , "PENDING_EXECUTION" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: PendingExecution , "PENDING_ROLLBACK" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: PendingRollback , "RETRY_ON_HOLD" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: RetryOnHold , "ROLLBACK_IN_PROCESS" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: RollbackInProcess , "ROLLEDBACK" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Rolledback , "SKIPPED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Skipped , "SUCCEED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Succeed , "SUSPENDED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: Suspended , "TASK_EXECUTION_STATE_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState :: TaskExecutionStateUnspecified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaTaskExecutionDetailsTaskExecutionState
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaTriggerConfig {
        #[doc = "Optional. An alert threshold configuration for the \\[trigger + client + integration\\] tuple. If these values are not specified in the trigger config, default values will be populated by the system. Note that there must be exactly one alert threshold configured per \\[client + trigger + integration\\] when published."]
        #[serde(
            rename = "alertConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub alert_config: ::std::option::Option<
            Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationAlertConfig>,
        >,
        #[doc = "Optional. Cloud Scheduler Trigger related metadata"]
        #[serde(
            rename = "cloudSchedulerConfig",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cloud_scheduler_config: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaCloudSchedulerConfig,
        >,
        #[doc = "Optional. User-provided description intended to give additional business context about the task."]
        #[serde(
            rename = "description",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub description: ::std::option::Option<String>,
        #[doc = "Optional. The user created label for a particular trigger."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
        #[doc = "Optional. Dictates how next tasks will be executed."]
        #[serde(
            rename = "nextTasksExecutionPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub next_tasks_execution_policy: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy,
        >,
        #[doc = "Optional. Configurable properties of the trigger, not to be confused with integration parameters. E.g. â€œnameâ€ is a property for API triggers and â€œsubscriptionâ€ is a property for Pub/sub triggers."]
        #[serde(
            rename = "properties",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub properties: ::std::option::Option<::std::collections::BTreeMap<String, String>>,
        #[doc = "Optional. Set of tasks numbers from where the integration execution is started by this trigger. If this is empty, then integration is executed with default start tasks. In the list of start tasks, none of two tasks can have direct ancestor-descendant relationships (i.e. in a same integration execution graph)."]
        #[serde(
            rename = "startTasks",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub start_tasks:
            ::std::option::Option<Vec<crate::schemas::GoogleCloudIntegrationsV1AlphaNextTask>>,
        #[doc = "Optional. The backend trigger ID."]
        #[serde(
            rename = "triggerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_id: ::std::option::Option<String>,
        #[doc = "Required. A number to uniquely identify each trigger config within the integration on UI."]
        #[serde(
            rename = "triggerNumber",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_number: ::std::option::Option<String>,
        #[doc = "Optional. Type of trigger"]
        #[serde(
            rename = "triggerType",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_type: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType,
        >,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaTriggerConfig {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaTriggerConfig {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy {
        #[doc = "Default."]
        NextTasksExecutionPolicyUnspecified,
        #[doc = "Execute all the tasks that satisfy their associated condition."]
        RunAllMatch,
        #[doc = "Execute the first task that satisfies the associated condition."]
        RunFirstMatch,
    }
    impl GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: NextTasksExecutionPolicyUnspecified => "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: RunAllMatch => "RUN_ALL_MATCH" , GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: RunFirstMatch => "RUN_FIRST_MATCH" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy,
            (),
        > {
            Ok (match s { "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: NextTasksExecutionPolicyUnspecified , "RUN_ALL_MATCH" => GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: RunAllMatch , "RUN_FIRST_MATCH" => GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: RunFirstMatch , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: NextTasksExecutionPolicyUnspecified , "RUN_ALL_MATCH" => GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: RunAllMatch , "RUN_FIRST_MATCH" => GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy :: RunFirstMatch , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaTriggerConfigNextTasksExecutionPolicy
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType {
        #[doc = "Trigger by API call."]
        Api,
        #[doc = "Trigger by Pub/Sub external."]
        CloudPubsubExternal,
        #[doc = "Trigger by Cloud Scheduler job."]
        CloudScheduler,
        #[doc = "Trigger by scheduled time."]
        Cron,
        #[doc = "SFDC Channel Trigger for CDC."]
        SfdcCdcChannel,
        #[doc = "Trigger by Salesforce Channel."]
        SfdcChannel,
        #[doc = "Unknown."]
        TriggerTypeUnspecified,
    }
    impl GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType {
        pub fn as_str(self) -> &'static str {
            match self {
                GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::Api => "API",
                GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::CloudPubsubExternal => {
                    "CLOUD_PUBSUB_EXTERNAL"
                }
                GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::CloudScheduler => {
                    "CLOUD_SCHEDULER"
                }
                GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::Cron => "CRON",
                GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::SfdcCdcChannel => {
                    "SFDC_CDC_CHANNEL"
                }
                GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::SfdcChannel => {
                    "SFDC_CHANNEL"
                }
                GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::TriggerTypeUnspecified => {
                    "TRIGGER_TYPE_UNSPECIFIED"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType, ()>
        {
            Ok(match s {
                "API" => GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::Api,
                "CLOUD_PUBSUB_EXTERNAL" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::CloudPubsubExternal
                }
                "CLOUD_SCHEDULER" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::CloudScheduler
                }
                "CRON" => GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::Cron,
                "SFDC_CDC_CHANNEL" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::SfdcCdcChannel
                }
                "SFDC_CHANNEL" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::SfdcChannel
                }
                "TRIGGER_TYPE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::TriggerTypeUnspecified
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "API" => GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::Api,
                "CLOUD_PUBSUB_EXTERNAL" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::CloudPubsubExternal
                }
                "CLOUD_SCHEDULER" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::CloudScheduler
                }
                "CRON" => GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::Cron,
                "SFDC_CDC_CHANNEL" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::SfdcCdcChannel
                }
                "SFDC_CHANNEL" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::SfdcChannel
                }
                "TRIGGER_TYPE_UNSPECIFIED" => {
                    GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType::TriggerTypeUnspecified
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaTriggerConfigTriggerType
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaUnpublishIntegrationVersionRequest {}
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaUnpublishIntegrationVersionRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaUnpublishIntegrationVersionRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequest {
        #[doc = "The textproto of the integration_version."]
        #[serde(
            rename = "content",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub content: ::std::option::Option<String>,
        #[doc = "File format for upload request."]
        #[serde(
            rename = "fileFormat",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub file_format: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat,
        >,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat {
        #[doc = "Unspecified file format"]
        FileFormatUnspecified,
        #[doc = "JSON File Format"]
        Json,
        #[doc = "YAML File Format"]
        Yaml,
    }
    impl GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat {
        pub fn as_str(self) -> &'static str {
            match self { GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: FileFormatUnspecified => "FILE_FORMAT_UNSPECIFIED" , GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: Json => "JSON" , GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: Yaml => "YAML" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat,
            (),
        > {
            Ok (match s { "FILE_FORMAT_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: FileFormatUnspecified , "JSON" => GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: Json , "YAML" => GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: Yaml , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "FILE_FORMAT_UNSPECIFIED" => GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: FileFormatUnspecified , "JSON" => GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: Json , "YAML" => GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat :: Yaml , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequestFileFormat
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionResponse {
        #[doc = "The uploaded integration."]
        #[serde(
            rename = "integrationVersion",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub integration_version:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionResponse
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionResponse
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaUsernameAndPassword {
        #[doc = "Password to be used"]
        #[serde(
            rename = "password",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub password: ::std::option::Option<String>,
        #[doc = "Username to be used"]
        #[serde(
            rename = "username",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub username: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaUsernameAndPassword {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaUsernameAndPassword {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GoogleCloudIntegrationsV1AlphaValueType {
        #[doc = "Boolean Array."]
        #[serde(
            rename = "booleanArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_array: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaBooleanParameterArray,
        >,
        #[doc = "Boolean."]
        #[serde(
            rename = "booleanValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boolean_value: ::std::option::Option<bool>,
        #[doc = "Double Number Array."]
        #[serde(
            rename = "doubleArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_array: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaDoubleParameterArray,
        >,
        #[doc = "Double Number."]
        #[serde(
            rename = "doubleValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_value: ::std::option::Option<f64>,
        #[doc = "Integer Array."]
        #[serde(
            rename = "intArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub int_array:
            ::std::option::Option<crate::schemas::GoogleCloudIntegrationsV1AlphaIntParameterArray>,
        #[doc = "Integer."]
        #[serde(
            rename = "intValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub int_value: ::std::option::Option<i64>,
        #[doc = "Json."]
        #[serde(
            rename = "jsonValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub json_value: ::std::option::Option<String>,
        #[doc = "String Array."]
        #[serde(
            rename = "stringArray",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_array: ::std::option::Option<
            crate::schemas::GoogleCloudIntegrationsV1AlphaStringParameterArray,
        >,
        #[doc = "String."]
        #[serde(
            rename = "stringValue",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub string_value: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GoogleCloudIntegrationsV1AlphaValueType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleCloudIntegrationsV1AlphaValueType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequest {
        #[doc = "Optional. If the client id is provided, then the combination of trigger id and client id is matched across all the workflows. If the client id is not provided, then workflows with matching trigger id are executed for each client id in the {@link TriggerConfig}. For Api Trigger, the client id is required and will be validated against the allowed clients."]
        #[serde(
            rename = "clientId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub client_id: ::std::option::Option<String>,
        #[doc = "Optional. Flag to determine whether clients would suppress a warning when no ACTIVE workflows are not found. If this flag is set to be true, an error will not be thrown if the requested trigger_id or client_id is not found in any ACTIVE workflow. Otherwise, the error is always thrown. The flag is set to be false by default."]
        #[serde(
            rename = "ignoreErrorIfNoActiveWorkflow",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ignore_error_if_no_active_workflow: ::std::option::Option<bool>,
        #[doc = "Passed in as parameters to each workflow execution. Optional."]
        #[serde(
            rename = "parameters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parameters:
            ::std::option::Option<crate::schemas::EnterpriseCrmEventbusProtoEventParameters>,
        #[doc = "The request priority this request should be processed at. For internal users:"]
        #[serde(
            rename = "priority",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub priority: ::std::option::Option<
            crate::schemas::GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority,
        >,
        #[doc = "Optional. This is used to de-dup incoming request: if the duplicate request was detected, the response from the previous execution is returned. Must have no more than 36 characters and contain only alphanumeric characters and hyphens."]
        #[serde(
            rename = "requestId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub request_id: ::std::option::Option<String>,
        #[doc = "Optional. Time in milliseconds since epoch when the given event would be scheduled."]
        #[serde(
            rename = "scheduledTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        #[serde(with = "crate::parsed_string")]
        pub scheduled_time: ::std::option::Option<i64>,
        #[doc = "Optional. Sets test mode in {@link enterprise/crm/eventbus/event_message.proto}."]
        #[serde(
            rename = "testMode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub test_mode: ::std::option::Option<bool>,
        #[doc = "Matched against all {@link TriggerConfig}s across all workflows. i.e. TriggerConfig.trigger_id.equals(trigger_id) Required."]
        #[serde(
            rename = "triggerId",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub trigger_id: ::std::option::Option<String>,
        #[doc = "Optional. If provided, the workflow_name is used to filter all the matched workflows having same trigger_id+client_id. A combination of trigger_id, client_id and workflow_name identifies a unique workflow."]
        #[serde(
            rename = "workflowName",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub workflow_name: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequest
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequest
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority {
        #[doc = "Any outage is a pageable event. * During a production outage requests in this band will only be shed before CRITICAL_PLUS. * This is the default for sync calls sent from production jobs."]
        Critical,
        #[doc = "Any outage is a pageable event. * The guideline is for \\< 10% of requests to a service to be in this band. * During a production outage requests in this band will be prioritized above all others. * Opt-in to CRITICAL_PLUS when your workflow triggers by human."]
        CriticalPlus,
        #[doc = "Frequent partial and occasional full unavailability is expected and not pageable. * Requests to this band will be shed before all other requests. * This is the default for async calls sent from batch jobs."]
        Sheddable,
        #[doc = "Partial unavailability is expected and is not necessarily pageable. * Requests to this band will be shed before any critical traffic. * This is the default for async calls sent from production jobs."]
        SheddablePlus,
        #[doc = "Unspecified"]
        Unspcified,
    }
    impl GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority {
        pub fn as_str(self) -> &'static str {
            match self { GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Critical => "CRITICAL" , GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: CriticalPlus => "CRITICAL_PLUS" , GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Sheddable => "SHEDDABLE" , GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: SheddablePlus => "SHEDDABLE_PLUS" , GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Unspcified => "UNSPCIFIED" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority
    {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority,
            (),
        > {
            Ok (match s { "CRITICAL" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Critical , "CRITICAL_PLUS" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: CriticalPlus , "SHEDDABLE" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Sheddable , "SHEDDABLE_PLUS" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: SheddablePlus , "UNSPCIFIED" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Unspcified , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority
    {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "CRITICAL" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Critical , "CRITICAL_PLUS" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: CriticalPlus , "SHEDDABLE" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Sheddable , "SHEDDABLE_PLUS" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: SheddablePlus , "UNSPCIFIED" => GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority :: Unspcified , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for GoogleInternalCloudCrmEventbusV3PostToQueueWithTriggerIdRequestPriority
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Copy,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GoogleProtobufEmpty {}
    impl ::google_field_selector::FieldSelector for GoogleProtobufEmpty {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GoogleProtobufEmpty {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
}
pub mod params {
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Alt {
        #[doc = "Responses with Content-Type of application/json"]
        Json,
        #[doc = "Media download with context-dependent Content-Type"]
        Media,
        #[doc = "Responses with Content-Type of application/x-protobuf"]
        Proto,
    }
    impl Alt {
        pub fn as_str(self) -> &'static str {
            match self {
                Alt::Json => "json",
                Alt::Media => "media",
                Alt::Proto => "proto",
            }
        }
    }
    impl ::std::convert::AsRef<str> for Alt {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for Alt {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<Alt, ()> {
            Ok(match s {
                "json" => Alt::Json,
                "media" => Alt::Media,
                "proto" => Alt::Proto,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for Alt {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Alt {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Alt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "json" => Alt::Json,
                "media" => Alt::Media,
                "proto" => Alt::Proto,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for Alt {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Alt {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Xgafv {
        #[doc = "v1 error format"]
        _1,
        #[doc = "v2 error format"]
        _2,
    }
    impl Xgafv {
        pub fn as_str(self) -> &'static str {
            match self {
                Xgafv::_1 => "1",
                Xgafv::_2 => "2",
            }
        }
    }
    impl ::std::convert::AsRef<str> for Xgafv {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for Xgafv {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<Xgafv, ()> {
            Ok(match s {
                "1" => Xgafv::_1,
                "2" => Xgafv::_2,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for Xgafv {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Xgafv {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Xgafv {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "1" => Xgafv::_1,
                "2" => Xgafv::_2,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for Xgafv {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Xgafv {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
}
pub struct Client {
    reqwest: ::reqwest::Client,
    auth: Box<dyn ::google_api_auth::GetAccessToken>,
}
impl Client {
    pub fn new<A>(auth: A) -> Self
    where
        A: ::google_api_auth::GetAccessToken + 'static,
    {
        Client::with_reqwest_client(auth, ::reqwest::Client::builder().build().unwrap())
    }
    pub fn with_reqwest_client<A>(auth: A, reqwest: ::reqwest::Client) -> Self
    where
        A: ::google_api_auth::GetAccessToken + 'static,
    {
        Client {
            reqwest,
            auth: Box::new(auth),
        }
    }
    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
        self.auth.as_ref()
    }
    #[doc = "Actions that can be performed on the callback resource"]
    pub fn callback(&self) -> crate::resources::callback::CallbackActions {
        crate::resources::callback::CallbackActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the connector_platform_regions resource"]
    pub fn connector_platform_regions(
        &self,
    ) -> crate::resources::connector_platform_regions::ConnectorPlatformRegionsActions {
        crate::resources::connector_platform_regions::ConnectorPlatformRegionsActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
    #[doc = "Actions that can be performed on the projects resource"]
    pub fn projects(&self) -> crate::resources::projects::ProjectsActions {
        crate::resources::projects::ProjectsActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
}
pub mod resources {
    pub mod callback {
        pub mod params {
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum GenerateTokenProduct {
                Apigee,
                Ip,
                Security,
                UnspecifiedProduct,
            }
            impl GenerateTokenProduct {
                pub fn as_str(self) -> &'static str {
                    match self {
                        GenerateTokenProduct::Apigee => "APIGEE",
                        GenerateTokenProduct::Ip => "IP",
                        GenerateTokenProduct::Security => "SECURITY",
                        GenerateTokenProduct::UnspecifiedProduct => "UNSPECIFIED_PRODUCT",
                    }
                }
            }
            impl ::std::convert::AsRef<str> for GenerateTokenProduct {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
            impl ::std::str::FromStr for GenerateTokenProduct {
                type Err = ();
                fn from_str(s: &str) -> ::std::result::Result<GenerateTokenProduct, ()> {
                    Ok(match s {
                        "APIGEE" => GenerateTokenProduct::Apigee,
                        "IP" => GenerateTokenProduct::Ip,
                        "SECURITY" => GenerateTokenProduct::Security,
                        "UNSPECIFIED_PRODUCT" => GenerateTokenProduct::UnspecifiedProduct,
                        _ => return Err(()),
                    })
                }
            }
            impl ::std::fmt::Display for GenerateTokenProduct {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for GenerateTokenProduct {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for GenerateTokenProduct {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "APIGEE" => GenerateTokenProduct::Apigee,
                        "IP" => GenerateTokenProduct::Ip,
                        "SECURITY" => GenerateTokenProduct::Security,
                        "UNSPECIFIED_PRODUCT" => GenerateTokenProduct::UnspecifiedProduct,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::google_field_selector::FieldSelector for GenerateTokenProduct {
                fn fields() -> Vec<::google_field_selector::Field> {
                    Vec::new()
                }
            }
            impl ::google_field_selector::ToFieldType for GenerateTokenProduct {
                fn field_type() -> ::google_field_selector::FieldType {
                    ::google_field_selector::FieldType::Leaf
                }
            }
        }
        pub struct CallbackActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> CallbackActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Receives the auth code and auth config id to combine that with the client id and secret to retrieve access tokens from the token endpoint. Returns either a success or error message when itâ€™s done."]
            pub fn generate_token(&self) -> GenerateTokenRequestBuilder {
                GenerateTokenRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    code: None,
                    gcp_project_id: None,
                    product: None,
                    redirect_uri: None,
                    state: None,
                }
            }
        }
        #[doc = "Created via [CallbackActions::generate_token()](struct.CallbackActions.html#method.generate_token)"]
        #[derive(Debug, Clone)]
        pub struct GenerateTokenRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            code: ::std::option::Option<String>,
            gcp_project_id: ::std::option::Option<String>,
            product:
                ::std::option::Option<crate::resources::callback::params::GenerateTokenProduct>,
            redirect_uri: ::std::option::Option<String>,
            state: ::std::option::Option<String>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GenerateTokenRequestBuilder<'a> {
            #[doc = "The auth code for the given request"]
            pub fn code(mut self, value: impl Into<String>) -> Self {
                self.code = Some(value.into());
                self
            }
            #[doc = "The gcp project id of the request"]
            pub fn gcp_project_id(mut self, value: impl Into<String>) -> Self {
                self.gcp_project_id = Some(value.into());
                self
            }
            #[doc = "Which product sends the request"]
            pub fn product(
                mut self,
                value: crate::resources::callback::params::GenerateTokenProduct,
            ) -> Self {
                self.product = Some(value);
                self
            }
            #[doc = "Redirect uri of the auth code request"]
            pub fn redirect_uri(mut self, value: impl Into<String>) -> Self {
                self.redirect_uri = Some(value.into());
                self
            }
            #[doc = "The auth config id for the given request"]
            pub fn state(mut self, value: impl Into<String>) -> Self {
                self.state = Some(value.into());
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<
                crate::schemas::GoogleCloudIntegrationsV1AlphaGenerateTokenResponse,
                crate::Error,
            > {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<
                crate::schemas::GoogleCloudIntegrationsV1AlphaGenerateTokenResponse,
                crate::Error,
            > {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://integrations.googleapis.com/".to_owned();
                output.push_str("v1alpha/callback:generateToken");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("code", &self.code)]);
                req = req.query(&[("gcpProjectId", &self.gcp_project_id)]);
                req = req.query(&[("product", &self.product)]);
                req = req.query(&[("redirectUri", &self.redirect_uri)]);
                req = req.query(&[("state", &self.state)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
    }
    pub mod connector_platform_regions {
        pub mod params {}
        pub struct ConnectorPlatformRegionsActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> ConnectorPlatformRegionsActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Enumerates the regions for which Connector Platform is provisioned."]
            pub fn enumerate(&self) -> EnumerateRequestBuilder {
                EnumerateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                }
            }
        }
        #[doc = "Created via [ConnectorPlatformRegionsActions::enumerate()](struct.ConnectorPlatformRegionsActions.html#method.enumerate)"]
        #[derive(Debug, Clone)]
        pub struct EnumerateRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> EnumerateRequestBuilder<'a> {
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaEnumerateConnectorPlatformRegionsResponse , crate :: Error >{
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaEnumerateConnectorPlatformRegionsResponse , crate :: Error >{
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://integrations.googleapis.com/".to_owned();
                output.push_str("v1alpha/connectorPlatformRegions:enumerate");
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
    }
    pub mod projects {
        pub mod params {}
        pub struct ProjectsActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> ProjectsActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Actions that can be performed on the locations resource"]
            pub fn locations(&self) -> crate::resources::projects::locations::LocationsActions {
                crate::resources::projects::locations::LocationsActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        pub mod locations {
            pub mod params {}
            pub struct LocationsActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> LocationsActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Actions that can be performed on the apps_script_projects resource"]                pub fn apps_script_projects (& self) -> crate :: resources :: projects :: locations :: apps_script_projects :: AppsScriptProjectsActions{
                    crate :: resources :: projects :: locations :: apps_script_projects :: AppsScriptProjectsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                }
                #[doc = "Actions that can be performed on the auth_configs resource"]
                pub fn auth_configs(
                    &self,
                ) -> crate::resources::projects::locations::auth_configs::AuthConfigsActions
                {
                    crate::resources::projects::locations::auth_configs::AuthConfigsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the certificates resource"]
                pub fn certificates(
                    &self,
                ) -> crate::resources::projects::locations::certificates::CertificatesActions
                {
                    crate::resources::projects::locations::certificates::CertificatesActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the connections resource"]
                pub fn connections(
                    &self,
                ) -> crate::resources::projects::locations::connections::ConnectionsActions
                {
                    crate::resources::projects::locations::connections::ConnectionsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the integrations resource"]
                pub fn integrations(
                    &self,
                ) -> crate::resources::projects::locations::integrations::IntegrationsActions
                {
                    crate::resources::projects::locations::integrations::IntegrationsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the products resource"]
                pub fn products(
                    &self,
                ) -> crate::resources::projects::locations::products::ProductsActions
                {
                    crate::resources::projects::locations::products::ProductsActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
                #[doc = "Actions that can be performed on the sfdc_instances resource"]
                pub fn sfdc_instances(
                    &self,
                ) -> crate::resources::projects::locations::sfdc_instances::SfdcInstancesActions
                {
                    crate::resources::projects::locations::sfdc_instances::SfdcInstancesActions {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                    }
                }
            }
            pub mod apps_script_projects {
                pub mod params {}
                pub struct AppsScriptProjectsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> AppsScriptProjectsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Creates an Apps Script project."]
                    pub fn create(
                        &self,
                        request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectRequest,
                        parent: impl Into<String>,
                    ) -> CreateRequestBuilder {
                        CreateRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                        }
                    }
                    #[doc = "Links a existing Apps Script project."]
                    pub fn link(
                        &self,
                        request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectRequest,
                        parent: impl Into<String>,
                    ) -> LinkRequestBuilder {
                        LinkRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                        }
                    }
                }
                #[doc = "Created via [AppsScriptProjectsActions::create()](struct.AppsScriptProjectsActions.html#method.create)"]
                #[derive(Debug, Clone)]
                pub struct CreateRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectRequest , parent : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                impl<'a> CreateRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]                    pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectResponse , crate :: Error >{
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]                    pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaCreateAppsScriptProjectResponse , crate :: Error >{
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/appsScriptProjects");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [AppsScriptProjectsActions::link()](struct.AppsScriptProjectsActions.html#method.link)"]
                #[derive(Debug, Clone)]
                pub struct LinkRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request:
                        crate::schemas::GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectRequest,
                    parent: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> LinkRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaLinkAppsScriptProjectResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/appsScriptProjects:link");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
            }
            pub mod auth_configs {
                pub mod params {}
                pub struct AuthConfigsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> AuthConfigsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Creates an auth config record. Fetch corresponding credentials for specific auth types, e.g. access token for OAuth 2.0, JWT token for JWT. Encrypt the auth config with Cloud KMS and store the encrypted credentials in Spanner. Returns the encrypted auth config."]
                    pub fn create(
                        &self,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        parent: impl Into<String>,
                    ) -> CreateRequestBuilder {
                        CreateRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            client_certificate_encrypted_private_key: None,
                            client_certificate_passphrase: None,
                            client_certificate_ssl_certificate: None,
                        }
                    }
                    #[doc = "Deletes an auth config."]
                    pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                        DeleteRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Gets a complete auth config. If the auth config doesnâ€™t exist, Code.NOT_FOUND exception will be thrown. Returns the decrypted auth config."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Lists all auth configs that match the filter. Restrict to auth configs belong to the current client only."]
                    pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                        ListRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            filter: None,
                            page_size: None,
                            page_token: None,
                            read_mask: None,
                        }
                    }
                    #[doc = "Updates an auth config. If credential is updated, fetch the encrypted auth config from Spanner, decrypt with Cloud KMS key, update the credential fields, re-encrypt with Cloud KMS key and update the Spanner record. For other fields, directly update the Spanner record. Returns the encrypted auth config."]
                    pub fn patch(
                        &self,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        name: impl Into<String>,
                    ) -> PatchRequestBuilder {
                        PatchRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            client_certificate_encrypted_private_key: None,
                            client_certificate_passphrase: None,
                            client_certificate_ssl_certificate: None,
                            update_mask: None,
                        }
                    }
                }
                #[doc = "Created via [AuthConfigsActions::create()](struct.AuthConfigsActions.html#method.create)"]
                #[derive(Debug, Clone)]
                pub struct CreateRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                    parent: String,
                    client_certificate_encrypted_private_key: ::std::option::Option<String>,
                    client_certificate_passphrase: ::std::option::Option<String>,
                    client_certificate_ssl_certificate: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> CreateRequestBuilder<'a> {
                    #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
                    pub fn client_certificate_encrypted_private_key(
                        mut self,
                        value: impl Into<String>,
                    ) -> Self {
                        self.client_certificate_encrypted_private_key = Some(value.into());
                        self
                    }
                    #[doc = "â€˜passphraseâ€™ should be left unset if private key is not encrypted. Note that â€˜passphraseâ€™ is not the password for web server, but an extra layer of security to protected private key."]
                    pub fn client_certificate_passphrase(
                        mut self,
                        value: impl Into<String>,
                    ) -> Self {
                        self.client_certificate_passphrase = Some(value.into());
                        self
                    }
                    #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
                    pub fn client_certificate_ssl_certificate(
                        mut self,
                        value: impl Into<String>,
                    ) -> Self {
                        self.client_certificate_ssl_certificate = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/authConfigs");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[(
                            "clientCertificate.encryptedPrivateKey",
                            &self.client_certificate_encrypted_private_key,
                        )]);
                        req = req.query(&[(
                            "clientCertificate.passphrase",
                            &self.client_certificate_passphrase,
                        )]);
                        req = req.query(&[(
                            "clientCertificate.sslCertificate",
                            &self.client_certificate_ssl_certificate,
                        )]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [AuthConfigsActions::delete()](struct.AuthConfigsActions.html#method.delete)"]
                #[derive(Debug, Clone)]
                pub struct DeleteRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> DeleteRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [AuthConfigsActions::get()](struct.AuthConfigsActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [AuthConfigsActions::list()](struct.AuthConfigsActions.html#method.list)"]
                #[derive(Debug, Clone)]
                pub struct ListRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    parent: String,
                    filter: ::std::option::Option<String>,
                    page_size: ::std::option::Option<i32>,
                    page_token: ::std::option::Option<String>,
                    read_mask: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> ListRequestBuilder<'a> {
                    #[doc = "Filtering as supported in https://developers.google.com/authorized-buyers/apis/guides/v2/list-filters."]
                    pub fn filter(mut self, value: impl Into<String>) -> Self {
                        self.filter = Some(value.into());
                        self
                    }
                    #[doc = "The size of entries in the response. If unspecified, defaults to 100."]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "The token returned in the previous response."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = "The mask which specifies fields that need to be returned in the AuthConfigâ€™s response."]
                    pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                        self.read_mask = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = "\nExecute the request and yield each item in the `authConfigs` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                    pub fn stream_auth_configs<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_auth_configs_with_fields(fields)
                    }
                    #[doc = "\nExecute the request and yield each item in the `authConfigs` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                    pub fn stream_auth_configs_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_auth_configs_with_fields(None::<String>)
                    }
                    #[doc = "\nExecute the request and yield each item in the `authConfigs` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                    pub fn stream_auth_configs_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_auth_configs_with_fields(Some("*"))
                    }
                    #[doc = "\nExecute the request and yield each item in the `authConfigs` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                    pub fn stream_auth_configs_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                        struct Page<T> {
                            #[serde(rename = "nextPageToken")]
                            pub next_page_token: ::std::option::Option<String>,
                            #[serde(rename = "authConfigs")]
                            pub items: Vec<T>,
                        }
                        impl<T> crate::GetNextPageToken<String> for Page<T> {
                            fn next_page_token(&self) -> ::std::option::Option<String> {
                                self.next_page_token.to_owned()
                            }
                        }
                        impl<T> crate::stream::IntoPageItems for Page<T> {
                            type Items = Vec<T>;
                            fn into_page_items(self) -> Self::Items {
                                self.items
                            }
                        }
                        self.fields = Some({
                            let mut selector = concat!("nextPageToken,", "authConfigs").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::stream::page_item_stream::<_, Page<T>>(self)
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                    pub fn stream<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String>
                            + ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_with_fields(fields)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the default set of fields from the server."]
                    pub fn stream_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests all fields from the server."]
                    pub fn stream_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                    #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    pub fn stream_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::stream::page_stream(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/authConfigs");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("filter", &self.filter)]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("readMask", &self.read_mask)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[async_trait::async_trait]
                impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                    type PageToken = String;
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    async fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                    {
                        self._execute().await
                    }
                }
                #[doc = "Created via [AuthConfigsActions::patch()](struct.AuthConfigsActions.html#method.patch)"]
                #[derive(Debug, Clone)]
                pub struct PatchRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                    name: String,
                    client_certificate_encrypted_private_key: ::std::option::Option<String>,
                    client_certificate_passphrase: ::std::option::Option<String>,
                    client_certificate_ssl_certificate: ::std::option::Option<String>,
                    update_mask: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> PatchRequestBuilder<'a> {
                    #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
                    pub fn client_certificate_encrypted_private_key(
                        mut self,
                        value: impl Into<String>,
                    ) -> Self {
                        self.client_certificate_encrypted_private_key = Some(value.into());
                        self
                    }
                    #[doc = "â€˜passphraseâ€™ should be left unset if private key is not encrypted. Note that â€˜passphraseâ€™ is not the password for web server, but an extra layer of security to protected private key."]
                    pub fn client_certificate_passphrase(
                        mut self,
                        value: impl Into<String>,
                    ) -> Self {
                        self.client_certificate_passphrase = Some(value.into());
                        self
                    }
                    #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
                    pub fn client_certificate_ssl_certificate(
                        mut self,
                        value: impl Into<String>,
                    ) -> Self {
                        self.client_certificate_ssl_certificate = Some(value.into());
                        self
                    }
                    #[doc = "Field mask specifying the fields in the above AuthConfig that have been modified and need to be updated."]
                    pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                        self.update_mask = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                        req = req.query(&[(
                            "clientCertificate.encryptedPrivateKey",
                            &self.client_certificate_encrypted_private_key,
                        )]);
                        req = req.query(&[(
                            "clientCertificate.passphrase",
                            &self.client_certificate_passphrase,
                        )]);
                        req = req.query(&[(
                            "clientCertificate.sslCertificate",
                            &self.client_certificate_ssl_certificate,
                        )]);
                        req = req.query(&[("updateMask", &self.update_mask)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
            }
            pub mod certificates {
                pub mod params {}
                pub struct CertificatesActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> CertificatesActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Get a certificates in the specified project."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                }
                #[doc = "Created via [CertificatesActions::get()](struct.CertificatesActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
            }
            pub mod connections {
                pub mod params {}
                pub struct ConnectionsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> ConnectionsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Lists the available entities and actions associated with a Connection."]
                    pub fn get_connection_schema_metadata(
                        &self,
                        name: impl Into<String>,
                    ) -> GetConnectionSchemaMetadataRequestBuilder {
                        GetConnectionSchemaMetadataRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Lists Connections in a given project and location."]
                    pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                        ListRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            filter: None,
                            order_by: None,
                            page_size: None,
                            page_token: None,
                        }
                    }
                    #[doc = "Actions that can be performed on the runtime_action_schemas resource"]                    pub fn runtime_action_schemas (& self) -> crate :: resources :: projects :: locations :: connections :: runtime_action_schemas :: RuntimeActionSchemasActions{
                        crate :: resources :: projects :: locations :: connections :: runtime_action_schemas :: RuntimeActionSchemasActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                    #[doc = "Actions that can be performed on the runtime_entity_schemas resource"]                    pub fn runtime_entity_schemas (& self) -> crate :: resources :: projects :: locations :: connections :: runtime_entity_schemas :: RuntimeEntitySchemasActions{
                        crate :: resources :: projects :: locations :: connections :: runtime_entity_schemas :: RuntimeEntitySchemasActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                }
                #[doc = "Created via [ConnectionsActions::get_connection_schema_metadata()](struct.ConnectionsActions.html#method.get_connection_schema_metadata)"]
                #[derive(Debug, Clone)]
                pub struct GetConnectionSchemaMetadataRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetConnectionSchemaMetadataRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaConnectionSchemaMetadata,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaConnectionSchemaMetadata,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [ConnectionsActions::list()](struct.ConnectionsActions.html#method.list)"]
                #[derive(Debug, Clone)]
                pub struct ListRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    parent: String,
                    filter: ::std::option::Option<String>,
                    order_by: ::std::option::Option<String>,
                    page_size: ::std::option::Option<i32>,
                    page_token: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> ListRequestBuilder<'a> {
                    #[doc = "Filter."]
                    pub fn filter(mut self, value: impl Into<String>) -> Self {
                        self.filter = Some(value.into());
                        self
                    }
                    #[doc = "Order by parameters."]
                    pub fn order_by(mut self, value: impl Into<String>) -> Self {
                        self.order_by = Some(value.into());
                        self
                    }
                    #[doc = "Page size."]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "Page token."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = "\nExecute the request and yield each item in the `connections` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                    pub fn stream_connections<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_connections_with_fields(fields)
                    }
                    #[doc = "\nExecute the request and yield each item in the `connections` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                    pub fn stream_connections_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudConnectorsV1Connection,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_connections_with_fields(None::<String>)
                    }
                    #[doc = "\nExecute the request and yield each item in the `connections` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                    pub fn stream_connections_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudConnectorsV1Connection,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_connections_with_fields(Some("*"))
                    }
                    #[doc = "\nExecute the request and yield each item in the `connections` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                    pub fn stream_connections_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                        struct Page<T> {
                            #[serde(rename = "nextPageToken")]
                            pub next_page_token: ::std::option::Option<String>,
                            #[serde(rename = "connections")]
                            pub items: Vec<T>,
                        }
                        impl<T> crate::GetNextPageToken<String> for Page<T> {
                            fn next_page_token(&self) -> ::std::option::Option<String> {
                                self.next_page_token.to_owned()
                            }
                        }
                        impl<T> crate::stream::IntoPageItems for Page<T> {
                            type Items = Vec<T>;
                            fn into_page_items(self) -> Self::Items {
                                self.items
                            }
                        }
                        self.fields = Some({
                            let mut selector = concat!("nextPageToken,", "connections").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::stream::page_item_stream::<_, Page<T>>(self)
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                    pub fn stream<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String>
                            + ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_with_fields(fields)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the default set of fields from the server."]
                    pub fn stream_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListConnectionsResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests all fields from the server."]
                    pub fn stream_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListConnectionsResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                    #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    pub fn stream_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::stream::page_stream(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaListConnectionsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaListConnectionsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/connections");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("filter", &self.filter)]);
                        req = req.query(&[("orderBy", &self.order_by)]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[async_trait::async_trait]
                impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                    type PageToken = String;
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    async fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                    {
                        self._execute().await
                    }
                }
                pub mod runtime_action_schemas {
                    pub mod params {}
                    pub struct RuntimeActionSchemasActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> RuntimeActionSchemasActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Lists the JSON schemas for the inputs and outputs of actions, filtered by action name."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                page_size: None,
                                page_token: None,
                            }
                        }
                    }
                    #[doc = "Created via [RuntimeActionSchemasActions::list()](struct.RuntimeActionSchemasActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Filter. Only the action field with literal equality operator is supported."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "Page size."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "Page token."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `runtimeActionSchemas` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_runtime_action_schemas<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_runtime_action_schemas_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `runtimeActionSchemas` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_runtime_action_schemas_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaRuntimeActionSchema,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_runtime_action_schemas_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `runtimeActionSchemas` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_runtime_action_schemas_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaRuntimeActionSchema,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_runtime_action_schemas_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `runtimeActionSchemas` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_runtime_action_schemas_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "runtimeActionSchemas")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "runtimeActionSchemas").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListRuntimeActionSchemasResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListRuntimeActionSchemasResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListRuntimeActionSchemasResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListRuntimeActionSchemasResponse , crate :: Error >{
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/runtimeActionSchemas");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                }
                pub mod runtime_entity_schemas {
                    pub mod params {}
                    pub struct RuntimeEntitySchemasActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> RuntimeEntitySchemasActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Lists the JSON schemas for the properties of runtime entities, filtered by entity name."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                page_size: None,
                                page_token: None,
                            }
                        }
                    }
                    #[doc = "Created via [RuntimeEntitySchemasActions::list()](struct.RuntimeEntitySchemasActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Filter. Only the entity field with literal equality operator is supported."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "Page size."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "Page token."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `runtimeEntitySchemas` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_runtime_entity_schemas<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_runtime_entity_schemas_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `runtimeEntitySchemas` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_runtime_entity_schemas_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaRuntimeEntitySchema,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_runtime_entity_schemas_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `runtimeEntitySchemas` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_runtime_entity_schemas_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaRuntimeEntitySchema,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_runtime_entity_schemas_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `runtimeEntitySchemas` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_runtime_entity_schemas_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "runtimeEntitySchemas")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "runtimeEntitySchemas").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListRuntimeEntitySchemasResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListRuntimeEntitySchemasResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListRuntimeEntitySchemasResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListRuntimeEntitySchemasResponse , crate :: Error >{
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/runtimeEntitySchemas");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                }
            }
            pub mod integrations {
                pub mod params {}
                pub struct IntegrationsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> IntegrationsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Delete the selected integration and all versions inside"]
                    pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                        DeleteRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Executes integrations synchronously by passing the trigger id in the request body. The request is not returned until the requested executions are either fulfilled or experienced an error. If the integration name is not specified (passing `-`), all of the associated integration under the given trigger_id will be executed. Otherwise only the specified integration for the given `trigger_id` is executed. This is helpful for execution the integration from UI."]
                    pub fn execute(
                        &self,
                        request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaExecuteIntegrationsRequest,
                        name: impl Into<String>,
                    ) -> ExecuteRequestBuilder {
                        ExecuteRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Returns the list of all integrations in the specified project."]
                    pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                        ListRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            filter: None,
                            order_by: None,
                            page_size: None,
                            page_token: None,
                        }
                    }
                    #[doc = "Schedules an integration for execution by passing the trigger id and the scheduled time in the request body."]
                    pub fn schedule(
                        &self,
                        request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaScheduleIntegrationsRequest,
                        name: impl Into<String>,
                    ) -> ScheduleRequestBuilder {
                        ScheduleRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Actions that can be performed on the executions resource"]                    pub fn executions (& self) -> crate :: resources :: projects :: locations :: integrations :: executions :: ExecutionsActions{
                        crate :: resources :: projects :: locations :: integrations :: executions :: ExecutionsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                    #[doc = "Actions that can be performed on the versions resource"]                    pub fn versions (& self) -> crate :: resources :: projects :: locations :: integrations :: versions :: VersionsActions{
                        crate :: resources :: projects :: locations :: integrations :: versions :: VersionsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                }
                #[doc = "Created via [IntegrationsActions::delete()](struct.IntegrationsActions.html#method.delete)"]
                #[derive(Debug, Clone)]
                pub struct DeleteRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> DeleteRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [IntegrationsActions::execute()](struct.IntegrationsActions.html#method.execute)"]
                #[derive(Debug, Clone)]
                pub struct ExecuteRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request:
                        crate::schemas::GoogleCloudIntegrationsV1AlphaExecuteIntegrationsRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> ExecuteRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaExecuteIntegrationsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaExecuteIntegrationsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str(":execute");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [IntegrationsActions::list()](struct.IntegrationsActions.html#method.list)"]
                #[derive(Debug, Clone)]
                pub struct ListRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    parent: String,
                    filter: ::std::option::Option<String>,
                    order_by: ::std::option::Option<String>,
                    page_size: ::std::option::Option<i32>,
                    page_token: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> ListRequestBuilder<'a> {
                    #[doc = "Filter on fields of IntegrationVersion. Fields can be compared with literal values by use of â€œ:â€ (containment), â€œ=â€ (equality), â€œ\\>â€ (greater), â€œ\\<â€ (less than), >=â€œ (greater than or equal to), â€œ\\<=â€ (less than or equal to), and â€œ!=â€ (inequality) operators. Negation, conjunction, and disjunction are written using NOT, AND, and OR keywords. For example, organization_id=\"1\" AND state=ACTIVE AND description:â€œtestâ€. Filtering cannot be performed on repeated fields like `task_config`."]
                    pub fn filter(mut self, value: impl Into<String>) -> Self {
                        self.filter = Some(value.into());
                        self
                    }
                    #[doc = "The results would be returned in order you specified here. Supported sort keys are: Descending sort order by â€œlast_modified_timeâ€, â€œcreated_timeâ€, â€œsnapshot_numberâ€. Ascending sort order by the integration name."]
                    pub fn order_by(mut self, value: impl Into<String>) -> Self {
                        self.order_by = Some(value.into());
                        self
                    }
                    #[doc = "The page size for the resquest."]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "The page token for the resquest."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = "\nExecute the request and yield each item in the `integrations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                    pub fn stream_integrations<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_integrations_with_fields(fields)
                    }
                    #[doc = "\nExecute the request and yield each item in the `integrations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                    pub fn stream_integrations_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegration,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_integrations_with_fields(None::<String>)
                    }
                    #[doc = "\nExecute the request and yield each item in the `integrations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                    pub fn stream_integrations_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegration,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_integrations_with_fields(Some("*"))
                    }
                    #[doc = "\nExecute the request and yield each item in the `integrations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                    pub fn stream_integrations_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                        struct Page<T> {
                            #[serde(rename = "nextPageToken")]
                            pub next_page_token: ::std::option::Option<String>,
                            #[serde(rename = "integrations")]
                            pub items: Vec<T>,
                        }
                        impl<T> crate::GetNextPageToken<String> for Page<T> {
                            fn next_page_token(&self) -> ::std::option::Option<String> {
                                self.next_page_token.to_owned()
                            }
                        }
                        impl<T> crate::stream::IntoPageItems for Page<T> {
                            type Items = Vec<T>;
                            fn into_page_items(self) -> Self::Items {
                                self.items
                            }
                        }
                        self.fields = Some({
                            let mut selector = concat!("nextPageToken,", "integrations").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::stream::page_item_stream::<_, Page<T>>(self)
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                    pub fn stream<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String>
                            + ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_with_fields(fields)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the default set of fields from the server."]
                    pub fn stream_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListIntegrationsResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests all fields from the server."]
                    pub fn stream_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListIntegrationsResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                    #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    pub fn stream_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::stream::page_stream(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaListIntegrationsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaListIntegrationsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/integrations");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("filter", &self.filter)]);
                        req = req.query(&[("orderBy", &self.order_by)]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[async_trait::async_trait]
                impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                    type PageToken = String;
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    async fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                    {
                        self._execute().await
                    }
                }
                #[doc = "Created via [IntegrationsActions::schedule()](struct.IntegrationsActions.html#method.schedule)"]
                #[derive(Debug, Clone)]
                pub struct ScheduleRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request:
                        crate::schemas::GoogleCloudIntegrationsV1AlphaScheduleIntegrationsRequest,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> ScheduleRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaScheduleIntegrationsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaScheduleIntegrationsResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str(":schedule");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                pub mod executions {
                    pub mod params {}
                    pub struct ExecutionsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> ExecutionsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Lists the results of all the integration executions. The response includes the same information as the [execution log](https://cloud.google.com/application-integration/docs/viewing-logs) in the Integration UI."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                filter_params_custom_filter: None,
                                filter_params_end_time: None,
                                filter_params_event_statuses: None,
                                filter_params_execution_id: None,
                                filter_params_parameter_key: None,
                                filter_params_parameter_pair_key: None,
                                filter_params_parameter_pair_value: None,
                                filter_params_parameter_type: None,
                                filter_params_parameter_value: None,
                                filter_params_start_time: None,
                                filter_params_task_statuses: None,
                                filter_params_workflow_name: None,
                                order_by: None,
                                page_size: None,
                                page_token: None,
                                read_mask: None,
                                refresh_acl: None,
                                truncate_params: None,
                            }
                        }
                        #[doc = "Actions that can be performed on the suspensions resource"]                        pub fn suspensions (& self) -> crate :: resources :: projects :: locations :: integrations :: executions :: suspensions :: SuspensionsActions{
                            crate :: resources :: projects :: locations :: integrations :: executions :: suspensions :: SuspensionsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                        }
                    }
                    #[doc = "Created via [ExecutionsActions::list()](struct.ExecutionsActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: ::std::option::Option<String>,
                        filter_params_custom_filter: ::std::option::Option<String>,
                        filter_params_end_time: ::std::option::Option<i64>,
                        filter_params_event_statuses: ::std::option::Option<Vec<String>>,
                        filter_params_execution_id: ::std::option::Option<String>,
                        filter_params_parameter_key: ::std::option::Option<String>,
                        filter_params_parameter_pair_key: ::std::option::Option<String>,
                        filter_params_parameter_pair_value: ::std::option::Option<String>,
                        filter_params_parameter_type: ::std::option::Option<String>,
                        filter_params_parameter_value: ::std::option::Option<String>,
                        filter_params_start_time: ::std::option::Option<i64>,
                        filter_params_task_statuses: ::std::option::Option<Vec<String>>,
                        filter_params_workflow_name: ::std::option::Option<String>,
                        order_by: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        read_mask: ::std::option::Option<String>,
                        refresh_acl: ::std::option::Option<bool>,
                        truncate_params: ::std::option::Option<bool>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Optional. Standard filter field, we support filtering on all fields in EventExecutionParamIndexes table. All fields support for EQUALS, in additional: CreateTimestamp support for LESS_THAN, GREATER_THAN ParameterKey, ParameterValue, ParameterType support for HAS For example: â€œparameter_valueâ€ HAS \"parameter1\" Also supports operators like AND, OR, NOT For example, trigger_id=\"id1\" AND event_execution_state=\"FAILED\""]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "Optional user-provided custom filter."]
                        pub fn filter_params_custom_filter(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.filter_params_custom_filter = Some(value.into());
                            self
                        }
                        #[doc = "End timestamp."]
                        pub fn filter_params_end_time(mut self, value: i64) -> Self {
                            self.filter_params_end_time = Some(value);
                            self
                        }
                        #[doc = "List of possible event statuses."]
                        pub fn filter_params_event_statuses(
                            mut self,
                            value: impl Into<Vec<String>>,
                        ) -> Self {
                            self.filter_params_event_statuses = Some(value.into());
                            self
                        }
                        #[doc = "Execution id."]
                        pub fn filter_params_execution_id(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.filter_params_execution_id = Some(value.into());
                            self
                        }
                        #[doc = "Param key. DEPRECATED. User parameter_pair_key instead."]
                        pub fn filter_params_parameter_key(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.filter_params_parameter_key = Some(value.into());
                            self
                        }
                        #[doc = "Param key in the key value pair filter."]
                        pub fn filter_params_parameter_pair_key(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.filter_params_parameter_pair_key = Some(value.into());
                            self
                        }
                        #[doc = "Param value in the key value pair filter."]
                        pub fn filter_params_parameter_pair_value(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.filter_params_parameter_pair_value = Some(value.into());
                            self
                        }
                        #[doc = "Param type."]
                        pub fn filter_params_parameter_type(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.filter_params_parameter_type = Some(value.into());
                            self
                        }
                        #[doc = "Param value. DEPRECATED. User parameter_pair_value instead."]
                        pub fn filter_params_parameter_value(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.filter_params_parameter_value = Some(value.into());
                            self
                        }
                        #[doc = "Start timestamp."]
                        pub fn filter_params_start_time(mut self, value: i64) -> Self {
                            self.filter_params_start_time = Some(value);
                            self
                        }
                        #[doc = "List of possible task statuses."]
                        pub fn filter_params_task_statuses(
                            mut self,
                            value: impl Into<Vec<String>>,
                        ) -> Self {
                            self.filter_params_task_statuses = Some(value.into());
                            self
                        }
                        #[doc = "Workflow name."]
                        pub fn filter_params_workflow_name(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.filter_params_workflow_name = Some(value.into());
                            self
                        }
                        #[doc = "Optional. The results would be returned in order you specified here. Currently supporting â€œlast_modified_timeâ€ and â€œcreate_timeâ€."]
                        pub fn order_by(mut self, value: impl Into<String>) -> Self {
                            self.order_by = Some(value.into());
                            self
                        }
                        #[doc = "Optional. The size of entries in the response."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "Optional. The token returned in the previous response."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "Optional. View mask for the response data. If set, only the field specified will be returned as part of the result. If not set, all fields in event execution info will be filled and returned."]
                        pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                            self.read_mask = Some(value.into());
                            self
                        }
                        #[doc = "Optional. If true, the service will use the most recent acl information to list event execution infos and renew the acl cache. Note that fetching the most recent acl is synchronous, so it will increase RPC call latency."]
                        pub fn refresh_acl(mut self, value: bool) -> Self {
                            self.refresh_acl = Some(value);
                            self
                        }
                        #[doc = "Optional. If true, the service will truncate the params to only keep the first 1000 characters of string params and empty the executions in order to make response smaller. Only works for UI and when the params fields are not filtered out."]
                        pub fn truncate_params(mut self, value: bool) -> Self {
                            self.truncate_params = Some(value);
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `executionInfos` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_execution_infos<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_execution_infos_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `executionInfos` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]                        pub fn stream_execution_infos_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoEventExecutionInfo , crate :: Error >> + 'a{
                            self.stream_execution_infos_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `executionInfos` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]                        pub fn stream_execution_infos_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoEventExecutionInfo , crate :: Error >> + 'a{
                            self.stream_execution_infos_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `executionInfos` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_execution_infos_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "executionInfos")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "executionInfos").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = "\nExecute the request and yield each item in the `executions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_executions<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_executions_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `executions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_executions_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaExecution,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_executions_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `executions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_executions_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaExecution,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_executions_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `executions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_executions_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "executions")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "executions").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListExecutionsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListExecutionsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListExecutionsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListExecutionsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/executions");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[(
                                "filterParams.customFilter",
                                &self.filter_params_custom_filter,
                            )]);
                            req = req
                                .query(&[("filterParams.endTime", &self.filter_params_end_time)]);
                            for value in self.filter_params_event_statuses.iter().flatten() {
                                req = req.query(&[("filterParams.eventStatuses", value)]);
                            }
                            req = req.query(&[(
                                "filterParams.executionId",
                                &self.filter_params_execution_id,
                            )]);
                            req = req.query(&[(
                                "filterParams.parameterKey",
                                &self.filter_params_parameter_key,
                            )]);
                            req = req.query(&[(
                                "filterParams.parameterPairKey",
                                &self.filter_params_parameter_pair_key,
                            )]);
                            req = req.query(&[(
                                "filterParams.parameterPairValue",
                                &self.filter_params_parameter_pair_value,
                            )]);
                            req = req.query(&[(
                                "filterParams.parameterType",
                                &self.filter_params_parameter_type,
                            )]);
                            req = req.query(&[(
                                "filterParams.parameterValue",
                                &self.filter_params_parameter_value,
                            )]);
                            req = req.query(&[(
                                "filterParams.startTime",
                                &self.filter_params_start_time,
                            )]);
                            for value in self.filter_params_task_statuses.iter().flatten() {
                                req = req.query(&[("filterParams.taskStatuses", value)]);
                            }
                            req = req.query(&[(
                                "filterParams.workflowName",
                                &self.filter_params_workflow_name,
                            )]);
                            req = req.query(&[("orderBy", &self.order_by)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("readMask", &self.read_mask)]);
                            req = req.query(&[("refreshAcl", &self.refresh_acl)]);
                            req = req.query(&[("truncateParams", &self.truncate_params)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                    pub mod suspensions {
                        pub mod params {}
                        pub struct SuspensionsActions<'a> {
                            pub(crate) reqwest: &'a reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        }
                        impl<'a> SuspensionsActions<'a> {
                            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                                self.auth
                            }
                            #[doc = "* Lifts suspension for advanced suspension task. Fetch corresponding suspension with provided suspension Id, resolve suspension, and set up suspension result for the Suspension Task."]
                            pub fn lift(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaLiftSuspensionRequest,
                                name: impl Into<String>,
                            ) -> LiftRequestBuilder {
                                LiftRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "* Lists suspensions associated with a specific execution. Only those with permissions to resolve the relevant suspensions will be able to view them."]
                            pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                                ListRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                    filter: None,
                                    order_by: None,
                                    page_size: None,
                                    page_token: None,
                                }
                            }
                            #[doc = "* Resolves (lifts/rejects) any number of suspensions. If the integration is already running, only the status of the suspension is updated. Otherwise, the suspended integration will begin execution again."]
                            pub fn resolve(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaResolveSuspensionRequest,
                                name: impl Into<String>,
                            ) -> ResolveRequestBuilder {
                                ResolveRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                        }
                        #[doc = "Created via [SuspensionsActions::lift()](struct.SuspensionsActions.html#method.lift)"]
                        #[derive(Debug, Clone)]
                        pub struct LiftRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            request:
                                crate::schemas::GoogleCloudIntegrationsV1AlphaLiftSuspensionRequest,
                            name: String,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> LiftRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaLiftSuspensionResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaLiftSuspensionResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str(":lift");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [SuspensionsActions::list()](struct.SuspensionsActions.html#method.list)"]
                        #[derive(Debug, Clone)]
                        pub struct ListRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            parent: String,
                            filter: ::std::option::Option<String>,
                            order_by: ::std::option::Option<String>,
                            page_size: ::std::option::Option<i32>,
                            page_token: ::std::option::Option<String>,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> ListRequestBuilder<'a> {
                            #[doc = "Standard filter field."]
                            pub fn filter(mut self, value: impl Into<String>) -> Self {
                                self.filter = Some(value.into());
                                self
                            }
                            #[doc = "Field name to order by."]
                            pub fn order_by(mut self, value: impl Into<String>) -> Self {
                                self.order_by = Some(value.into());
                                self
                            }
                            #[doc = "Maximum number of entries in the response."]
                            pub fn page_size(mut self, value: i32) -> Self {
                                self.page_size = Some(value);
                                self
                            }
                            #[doc = "Token to retrieve a specific page."]
                            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                                self.page_token = Some(value.into());
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = "\nExecute the request and yield each item in the `suspensions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                            pub fn stream_suspensions<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_suspensions_with_fields(fields)
                            }
                            #[doc = "\nExecute the request and yield each item in the `suspensions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                            pub fn stream_suspensions_with_default_fields(
                                self,
                            ) -> impl ::futures::Stream<
                                Item = Result<
                                    crate::schemas::GoogleCloudIntegrationsV1AlphaSuspension,
                                    crate::Error,
                                >,
                            > + 'a {
                                self.stream_suspensions_with_fields(None::<String>)
                            }
                            #[doc = "\nExecute the request and yield each item in the `suspensions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                            pub fn stream_suspensions_with_all_fields(
                                self,
                            ) -> impl ::futures::Stream<
                                Item = Result<
                                    crate::schemas::GoogleCloudIntegrationsV1AlphaSuspension,
                                    crate::Error,
                                >,
                            > + 'a {
                                self.stream_suspensions_with_fields(Some("*"))
                            }
                            #[doc = "\nExecute the request and yield each item in the `suspensions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                            pub fn stream_suspensions_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned + 'a,
                                F: AsRef<str>,
                            {
                                #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                                struct Page<T> {
                                    #[serde(rename = "nextPageToken")]
                                    pub next_page_token: ::std::option::Option<String>,
                                    #[serde(rename = "suspensions")]
                                    pub items: Vec<T>,
                                }
                                impl<T> crate::GetNextPageToken<String> for Page<T> {
                                    fn next_page_token(&self) -> ::std::option::Option<String> {
                                        self.next_page_token.to_owned()
                                    }
                                }
                                impl<T> crate::stream::IntoPageItems for Page<T> {
                                    type Items = Vec<T>;
                                    fn into_page_items(self) -> Self::Items {
                                        self.items
                                    }
                                }
                                self.fields = Some({
                                    let mut selector =
                                        concat!("nextPageToken,", "suspensions").to_owned();
                                    let items_fields =
                                        fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                    if !items_fields.is_empty() {
                                        selector.push_str("(");
                                        selector.push_str(items_fields);
                                        selector.push_str(")");
                                    }
                                    selector
                                });
                                crate::stream::page_item_stream::<_, Page<T>>(self)
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                            pub fn stream<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_with_fields(fields)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the default set of fields from the server."]                            pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSuspensionsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests all fields from the server."]                            pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSuspensionsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                            #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            pub fn stream_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + 'a,
                                F: AsRef<str>,
                            {
                                let mut fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                                if !fields.is_empty() {
                                    match fields.chars().rev().nth(0) {
                                        Some(',') | None => {}
                                        _ => fields.push_str(","),
                                    }
                                    fields.push_str("nextPageToken");
                                    self.fields = Some(fields);
                                }
                                crate::stream::page_stream(self)
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSuspensionsResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSuspensionsResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/suspensions");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("filter", &self.filter)]);
                                req = req.query(&[("orderBy", &self.order_by)]);
                                req = req.query(&[("pageSize", &self.page_size)]);
                                req = req.query(&[("pageToken", &self.page_token)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[async_trait::async_trait]
                        impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                            type PageToken = String;
                            fn set_page_token(&mut self, value: String) {
                                self.page_token = value.into();
                            }
                            async fn execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                            {
                                self._execute().await
                            }
                        }
                        #[doc = "Created via [SuspensionsActions::resolve()](struct.SuspensionsActions.html#method.resolve)"]
                        #[derive(Debug, Clone)]
                        pub struct ResolveRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaResolveSuspensionRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                        impl<'a> ResolveRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaResolveSuspensionResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaResolveSuspensionResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str(":resolve");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                    }
                }
                pub mod versions {
                    pub mod params {
                        #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
                        pub enum DownloadFileFormat {
                            #[doc = "Unspecified file format"]
                            FileFormatUnspecified,
                            #[doc = "JSON File Format"]
                            Json,
                            #[doc = "YAML File Format"]
                            Yaml,
                        }
                        impl DownloadFileFormat {
                            pub fn as_str(self) -> &'static str {
                                match self {
                                    DownloadFileFormat::FileFormatUnspecified => {
                                        "FILE_FORMAT_UNSPECIFIED"
                                    }
                                    DownloadFileFormat::Json => "JSON",
                                    DownloadFileFormat::Yaml => "YAML",
                                }
                            }
                        }
                        impl ::std::convert::AsRef<str> for DownloadFileFormat {
                            fn as_ref(&self) -> &str {
                                self.as_str()
                            }
                        }
                        impl ::std::str::FromStr for DownloadFileFormat {
                            type Err = ();
                            fn from_str(s: &str) -> ::std::result::Result<DownloadFileFormat, ()> {
                                Ok(match s {
                                    "FILE_FORMAT_UNSPECIFIED" => {
                                        DownloadFileFormat::FileFormatUnspecified
                                    }
                                    "JSON" => DownloadFileFormat::Json,
                                    "YAML" => DownloadFileFormat::Yaml,
                                    _ => return Err(()),
                                })
                            }
                        }
                        impl ::std::fmt::Display for DownloadFileFormat {
                            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                                f.write_str(self.as_str())
                            }
                        }
                        impl ::serde::Serialize for DownloadFileFormat {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> ::std::result::Result<S::Ok, S::Error>
                            where
                                S: ::serde::ser::Serializer,
                            {
                                serializer.serialize_str(self.as_str())
                            }
                        }
                        impl<'de> ::serde::Deserialize<'de> for DownloadFileFormat {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> ::std::result::Result<Self, D::Error>
                            where
                                D: ::serde::de::Deserializer<'de>,
                            {
                                let value: &'de str = <&str>::deserialize(deserializer)?;
                                Ok(match value {
                                    "FILE_FORMAT_UNSPECIFIED" => {
                                        DownloadFileFormat::FileFormatUnspecified
                                    }
                                    "JSON" => DownloadFileFormat::Json,
                                    "YAML" => DownloadFileFormat::Yaml,
                                    _ => {
                                        return Err(::serde::de::Error::custom(format!(
                                            "invalid enum for #name: {}",
                                            value
                                        )))
                                    }
                                })
                            }
                        }
                        impl ::google_field_selector::FieldSelector for DownloadFileFormat {
                            fn fields() -> Vec<::google_field_selector::Field> {
                                Vec::new()
                            }
                        }
                        impl ::google_field_selector::ToFieldType for DownloadFileFormat {
                            fn field_type() -> ::google_field_selector::FieldType {
                                ::google_field_selector::FieldType::Leaf
                            }
                        }
                    }
                    pub struct VersionsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> VersionsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Create a integration with a draft version in the specified project."]
                        pub fn create(
                            &self,
                            request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            parent: impl Into<String>,
                        ) -> CreateRequestBuilder {
                            CreateRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                new_integration: None,
                            }
                        }
                        #[doc = "Soft-deletes the integration. Changes the status of the integration to ARCHIVED. If the integration being ARCHIVED is tagged as â€œHEADâ€, the tag is removed from this snapshot and set to the previous non-ARCHIVED snapshot. The PUBLISH_REQUESTED, DUE_FOR_DELETION tags are removed too. This RPC throws an exception if the version being deleted is DRAFT, and if the `locked_by` user is not the same as the user performing the Delete. Audit fields updated include last_modified_timestamp, last_modified_by. Any existing lock is released when Deleting a integration. Currently, there is no undelete mechanism."]
                        pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                            DeleteRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Downloads an integration. Retrieves the `IntegrationVersion` for a given `integration_id` and returns the response as a string."]
                        pub fn download(&self, name: impl Into<String>) -> DownloadRequestBuilder {
                            DownloadRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                                file_format: None,
                            }
                        }
                        #[doc = "Get a integration in the specified project."]
                        pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                            GetRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Returns the list of all integration versions in the specified project."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                field_mask: None,
                                filter: None,
                                order_by: None,
                                page_size: None,
                                page_token: None,
                            }
                        }
                        #[doc = "Update a integration with a draft version in the specified project."]
                        pub fn patch(
                            &self,
                            request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            name: impl Into<String>,
                        ) -> PatchRequestBuilder {
                            PatchRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                                update_mask: None,
                            }
                        }
                        #[doc = "This RPC throws an exception if the integration is in ARCHIVED or ACTIVE state. This RPC throws an exception if the version being published is DRAFT, and if the `locked_by` user is not the same as the user performing the Publish. Audit fields updated include last_published_timestamp, last_published_by, last_modified_timestamp, last_modified_by. Any existing lock is on this integration is released."]
                        pub fn publish(
                            &self,
                            request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionRequest,
                            name: impl Into<String>,
                        ) -> PublishRequestBuilder {
                            PublishRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Clears the `locked_by` and `locked_at_timestamp`in the DRAFT version of this integration. It then performs the same action as the CreateDraftIntegrationVersion (i.e., copies the DRAFT version of the integration as a SNAPSHOT and then creates a new DRAFT version with the `locked_by` set to the `user_taking_over` and the `locked_at_timestamp` set to the current timestamp). Both the `locked_by` and `user_taking_over` are notified via email about the takeover. This RPC throws an exception if the integration is not in DRAFT status or if the `locked_by` and `locked_at_timestamp` fields are not set.The TakeoverEdit lock is treated the same as an edit of the integration, and hence shares ACLs with edit. Audit fields updated include last_modified_timestamp, last_modified_by."]
                        pub fn takeover_edit_lock(
                            &self,
                            request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaTakeoverEditLockRequest,
                            integration_version: impl Into<String>,
                        ) -> TakeoverEditLockRequestBuilder {
                            TakeoverEditLockRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                integration_version: integration_version.into(),
                            }
                        }
                        #[doc = "Sets the status of the ACTIVE integration to SNAPSHOT with a new tag â€œPREVIOUSLY_PUBLISHEDâ€ after validating it. The â€œHEADâ€ and â€œPUBLISH_REQUESTEDâ€ tags do not change. This RPC throws an exception if the version being snapshot is not ACTIVE. Audit fields added include action, action_by, action_timestamp."]
                        pub fn unpublish(
                            &self,
                            request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaUnpublishIntegrationVersionRequest,
                            name: impl Into<String>,
                        ) -> UnpublishRequestBuilder {
                            UnpublishRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Uploads an integration. The content can be a previously downloaded integration. Performs the same function as CreateDraftIntegrationVersion, but accepts input in a string format, which holds the complete representation of the IntegrationVersion content."]
                        pub fn upload(
                            &self,
                            request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequest,
                            parent: impl Into<String>,
                        ) -> UploadRequestBuilder {
                            UploadRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                            }
                        }
                    }
                    #[doc = "Created via [VersionsActions::create()](struct.VersionsActions.html#method.create)"]
                    #[derive(Debug, Clone)]
                    pub struct CreateRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                        parent: String,
                        new_integration: ::std::option::Option<bool>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> CreateRequestBuilder<'a> {
                        #[doc = "Set this flag to true, if draft version is to be created for a brand new integration. False, if the request is for an existing integration. For backward compatibility reasons, even if this flag is set to `false` and no existing integration is found, a new draft integration will still be created."]
                        pub fn new_integration(mut self, value: bool) -> Self {
                            self.new_integration = Some(value);
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/versions");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("newIntegration", &self.new_integration)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [VersionsActions::delete()](struct.VersionsActions.html#method.delete)"]
                    #[derive(Debug, Clone)]
                    pub struct DeleteRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> DeleteRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [VersionsActions::download()](struct.VersionsActions.html#method.download)"]
                    #[derive(Debug, Clone)]
                    pub struct DownloadRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , name : String , file_format : :: std :: option :: Option < crate :: resources :: projects :: locations :: integrations :: versions :: params :: DownloadFileFormat > , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                    impl<'a> DownloadRequestBuilder<'a> {
                        #[doc = "File format for download request."]
                        pub fn file_format(
                            mut self,
                            value : crate :: resources :: projects :: locations :: integrations :: versions :: params :: DownloadFileFormat,
                        ) -> Self {
                            self.file_format = Some(value);
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaDownloadIntegrationVersionResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaDownloadIntegrationVersionResponse , crate :: Error >{
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str(":download");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("fileFormat", &self.file_format)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [VersionsActions::get()](struct.VersionsActions.html#method.get)"]
                    #[derive(Debug, Clone)]
                    pub struct GetRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> GetRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [VersionsActions::list()](struct.VersionsActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        field_mask: ::std::option::Option<String>,
                        filter: ::std::option::Option<String>,
                        order_by: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "The field mask which specifies the particular data to be returned."]
                        pub fn field_mask(mut self, value: impl Into<String>) -> Self {
                            self.field_mask = Some(value.into());
                            self
                        }
                        #[doc = "Filter on fields of IntegrationVersion. Fields can be compared with literal values by use of â€œ:â€ (containment), â€œ=â€ (equality), â€œ\\>â€ (greater), â€œ\\<â€ (less than), >=â€œ (greater than or equal to), â€œ\\<=â€ (less than or equal to), and â€œ!=â€ (inequality) operators. Negation, conjunction, and disjunction are written using NOT, AND, and OR keywords. For example, organization_id=\"1\" AND state=ACTIVE AND description:â€œtestâ€. Filtering cannot be performed on repeated fields like `task_config`."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "The results would be returned in order you specified here. Currently supported sort keys are: Descending sort order for â€œlast_modified_timeâ€, â€œcreated_timeâ€, â€œsnapshot_numberâ€ Ascending sort order for â€œnameâ€."]
                        pub fn order_by(mut self, value: impl Into<String>) -> Self {
                            self.order_by = Some(value.into());
                            self
                        }
                        #[doc = "The maximum number of versions to return. The service may return fewer than this value. If unspecified, at most 50 versions will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "A page token, received from a previous `ListIntegrationVersions` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListIntegrationVersions` must match the call that provided the page token."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `integrationVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_integration_versions<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_integration_versions_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `integrationVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_integration_versions_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_integration_versions_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `integrationVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_integration_versions_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_integration_versions_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `integrationVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_integration_versions_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "integrationVersions")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "integrationVersions").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse , crate :: Error >{
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/versions");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("fieldMask", &self.field_mask)]);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("orderBy", &self.order_by)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                    #[doc = "Created via [VersionsActions::patch()](struct.VersionsActions.html#method.patch)"]
                    #[derive(Debug, Clone)]
                    pub struct PatchRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                        name: String,
                        update_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> PatchRequestBuilder<'a> {
                        #[doc = "Field mask specifying the fields in the above integration that have been modified and need to be updated."]
                        pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                            self.update_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                            req = req.query(&[("updateMask", &self.update_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [VersionsActions::publish()](struct.VersionsActions.html#method.publish)"]
                    #[derive(Debug, Clone)]
                    pub struct PublishRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                    impl<'a> PublishRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionResponse , crate :: Error >{
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str(":publish");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [VersionsActions::takeover_edit_lock()](struct.VersionsActions.html#method.takeover_edit_lock)"]
                    #[derive(Debug, Clone)]
                    pub struct TakeoverEditLockRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request:
                            crate::schemas::GoogleCloudIntegrationsV1AlphaTakeoverEditLockRequest,
                        integration_version: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> TakeoverEditLockRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaTakeoverEditLockResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaTakeoverEditLockResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.integration_version;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str(":takeoverEditLock");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [VersionsActions::unpublish()](struct.VersionsActions.html#method.unpublish)"]
                    #[derive(Debug, Clone)]
                    pub struct UnpublishRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaUnpublishIntegrationVersionRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                    impl<'a> UnpublishRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str(":unpublish");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [VersionsActions::upload()](struct.VersionsActions.html#method.upload)"]
                    #[derive(Debug, Clone)]
                    pub struct UploadRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequest , parent : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                    impl<'a> UploadRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionResponse , crate :: Error >{
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/versions:upload");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                }
            }
            pub mod products {
                pub mod params {}
                pub struct ProductsActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> ProductsActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Actions that can be performed on the auth_configs resource"]                    pub fn auth_configs (& self) -> crate :: resources :: projects :: locations :: products :: auth_configs :: AuthConfigsActions{
                        crate :: resources :: projects :: locations :: products :: auth_configs :: AuthConfigsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                    #[doc = "Actions that can be performed on the certificates resource"]                    pub fn certificates (& self) -> crate :: resources :: projects :: locations :: products :: certificates :: CertificatesActions{
                        crate :: resources :: projects :: locations :: products :: certificates :: CertificatesActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                    #[doc = "Actions that can be performed on the integrations resource"]                    pub fn integrations (& self) -> crate :: resources :: projects :: locations :: products :: integrations :: IntegrationsActions{
                        crate :: resources :: projects :: locations :: products :: integrations :: IntegrationsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                    #[doc = "Actions that can be performed on the integrationtemplates resource"]                    pub fn integrationtemplates (& self) -> crate :: resources :: projects :: locations :: products :: integrationtemplates :: IntegrationtemplatesActions{
                        crate :: resources :: projects :: locations :: products :: integrationtemplates :: IntegrationtemplatesActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                    #[doc = "Actions that can be performed on the sfdc_instances resource"]                    pub fn sfdc_instances (& self) -> crate :: resources :: projects :: locations :: products :: sfdc_instances :: SfdcInstancesActions{
                        crate :: resources :: projects :: locations :: products :: sfdc_instances :: SfdcInstancesActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                }
                pub mod auth_configs {
                    pub mod params {}
                    pub struct AuthConfigsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> AuthConfigsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Creates an auth config record. Fetch corresponding credentials for specific auth types, e.g. access token for OAuth 2.0, JWT token for JWT. Encrypt the auth config with Cloud KMS and store the encrypted credentials in Spanner. Returns the encrypted auth config."]
                        pub fn create(
                            &self,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            parent: impl Into<String>,
                        ) -> CreateRequestBuilder {
                            CreateRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                client_certificate_encrypted_private_key: None,
                                client_certificate_passphrase: None,
                                client_certificate_ssl_certificate: None,
                            }
                        }
                        #[doc = "Deletes an auth config."]
                        pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                            DeleteRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Gets a complete auth config. If the auth config doesnâ€™t exist, Code.NOT_FOUND exception will be thrown. Returns the decrypted auth config."]
                        pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                            GetRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Lists all auth configs that match the filter. Restrict to auth configs belong to the current client only."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                page_size: None,
                                page_token: None,
                                read_mask: None,
                            }
                        }
                        #[doc = "Updates an auth config. If credential is updated, fetch the encrypted auth config from Spanner, decrypt with Cloud KMS key, update the credential fields, re-encrypt with Cloud KMS key and update the Spanner record. For other fields, directly update the Spanner record. Returns the encrypted auth config."]
                        pub fn patch(
                            &self,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            name: impl Into<String>,
                        ) -> PatchRequestBuilder {
                            PatchRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                                client_certificate_encrypted_private_key: None,
                                client_certificate_passphrase: None,
                                client_certificate_ssl_certificate: None,
                                update_mask: None,
                            }
                        }
                    }
                    #[doc = "Created via [AuthConfigsActions::create()](struct.AuthConfigsActions.html#method.create)"]
                    #[derive(Debug, Clone)]
                    pub struct CreateRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        parent: String,
                        client_certificate_encrypted_private_key: ::std::option::Option<String>,
                        client_certificate_passphrase: ::std::option::Option<String>,
                        client_certificate_ssl_certificate: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> CreateRequestBuilder<'a> {
                        #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
                        pub fn client_certificate_encrypted_private_key(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.client_certificate_encrypted_private_key = Some(value.into());
                            self
                        }
                        #[doc = "â€˜passphraseâ€™ should be left unset if private key is not encrypted. Note that â€˜passphraseâ€™ is not the password for web server, but an extra layer of security to protected private key."]
                        pub fn client_certificate_passphrase(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.client_certificate_passphrase = Some(value.into());
                            self
                        }
                        #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
                        pub fn client_certificate_ssl_certificate(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.client_certificate_ssl_certificate = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/authConfigs");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[(
                                "clientCertificate.encryptedPrivateKey",
                                &self.client_certificate_encrypted_private_key,
                            )]);
                            req = req.query(&[(
                                "clientCertificate.passphrase",
                                &self.client_certificate_passphrase,
                            )]);
                            req = req.query(&[(
                                "clientCertificate.sslCertificate",
                                &self.client_certificate_ssl_certificate,
                            )]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [AuthConfigsActions::delete()](struct.AuthConfigsActions.html#method.delete)"]
                    #[derive(Debug, Clone)]
                    pub struct DeleteRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> DeleteRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [AuthConfigsActions::get()](struct.AuthConfigsActions.html#method.get)"]
                    #[derive(Debug, Clone)]
                    pub struct GetRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> GetRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [AuthConfigsActions::list()](struct.AuthConfigsActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        read_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Filtering as supported in https://developers.google.com/authorized-buyers/apis/guides/v2/list-filters."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "The size of entries in the response. If unspecified, defaults to 100."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "The token returned in the previous response."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "The mask which specifies fields that need to be returned in the AuthConfigâ€™s response."]
                        pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                            self.read_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `authConfigs` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_auth_configs<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_auth_configs_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `authConfigs` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_auth_configs_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_auth_configs_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `authConfigs` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_auth_configs_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_auth_configs_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `authConfigs` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_auth_configs_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "authConfigs")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "authConfigs").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListAuthConfigsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/authConfigs");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("readMask", &self.read_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                    #[doc = "Created via [AuthConfigsActions::patch()](struct.AuthConfigsActions.html#method.patch)"]
                    #[derive(Debug, Clone)]
                    pub struct PatchRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                        name: String,
                        client_certificate_encrypted_private_key: ::std::option::Option<String>,
                        client_certificate_passphrase: ::std::option::Option<String>,
                        client_certificate_ssl_certificate: ::std::option::Option<String>,
                        update_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> PatchRequestBuilder<'a> {
                        #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
                        pub fn client_certificate_encrypted_private_key(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.client_certificate_encrypted_private_key = Some(value.into());
                            self
                        }
                        #[doc = "â€˜passphraseâ€™ should be left unset if private key is not encrypted. Note that â€˜passphraseâ€™ is not the password for web server, but an extra layer of security to protected private key."]
                        pub fn client_certificate_passphrase(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.client_certificate_passphrase = Some(value.into());
                            self
                        }
                        #[doc = "The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines. For example, â€”â€“BEGIN CERTIFICATEâ€”â€“ MIICTTCCAbagAwIBAgIJAPT0tSKNxan/MA0GCSqGSIb3DQEBCwUAMCoxFzAVBgNV BAoTDkdvb2dsZSBURVNUSU5HMQ8wDQYDVQQDEwZ0ZXN0Q0EwHhcNMTUwMTAxMDAw MDAwWhcNMjUwMTAxMDAwMDAwWjAuMRcwFQYDVQQKEw5Hb29nbGUgVEVTVElORzET MBEGA1UEAwwKam9lQGJhbmFuYTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA vDYFgMgxi5W488d9J7UpCInl0NXmZQpJDEHE4hvkaRlH7pnC71H0DLt0/3zATRP1 JzY2+eqBmbGl4/sgZKYv8UrLnNyQNUTsNx1iZAfPUflf5FwgVsai8BM0pUciq1NB xD429VFcrGZNucvFLh72RuRFIKH8WUpiK/iZNFkWhZ0CAwEAAaN3MHUwDgYDVR0P AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB Af8EAjAAMBkGA1UdDgQSBBCVgnFBCWgL/iwCqnGrhTPQMBsGA1UdIwQUMBKAEKey Um2o4k2WiEVA0ldQvNYwDQYJKoZIhvcNAQELBQADgYEAYK986R4E3L1v+Q6esBtW JrUwA9UmJRSQr0N5w3o9XzarU37/bkjOP0Fw0k/A6Vv1n3vlciYfBFaBIam1qRHr 5dMsYf4CZS6w50r7hyzqyrwDoyNxkLnd2PdcHT/sym1QmflsjEs7pejtnohO6N2H wQW6M0H7Zt8claGRla4fKkg= â€”â€“END CERTIFICATEâ€”â€“"]
                        pub fn client_certificate_ssl_certificate(
                            mut self,
                            value: impl Into<String>,
                        ) -> Self {
                            self.client_certificate_ssl_certificate = Some(value.into());
                            self
                        }
                        #[doc = "Field mask specifying the fields in the above AuthConfig that have been modified and need to be updated."]
                        pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                            self.update_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaAuthConfig,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                            req = req.query(&[(
                                "clientCertificate.encryptedPrivateKey",
                                &self.client_certificate_encrypted_private_key,
                            )]);
                            req = req.query(&[(
                                "clientCertificate.passphrase",
                                &self.client_certificate_passphrase,
                            )]);
                            req = req.query(&[(
                                "clientCertificate.sslCertificate",
                                &self.client_certificate_ssl_certificate,
                            )]);
                            req = req.query(&[("updateMask", &self.update_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                }
                pub mod certificates {
                    pub mod params {}
                    pub struct CertificatesActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> CertificatesActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Creates a new certificate. The certificate will be registered to the trawler service and will be encrypted using cloud KMS and stored in Spanner Returns the certificate."]
                        pub fn create(
                            &self,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                            parent: impl Into<String>,
                        ) -> CreateRequestBuilder {
                            CreateRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                            }
                        }
                        #[doc = "Delete a certificate"]
                        pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                            DeleteRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Get a certificates in the specified project."]
                        pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                            GetRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "List all the certificates that match the filter. Restrict to certificate of current client only."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                page_size: None,
                                page_token: None,
                                read_mask: None,
                            }
                        }
                        #[doc = "Updates the certificate by id. If new certificate file is updated, it will register with the trawler service, re-encrypt with cloud KMS and update the Spanner record. Other fields will directly update the Spanner record. Returns the Certificate."]
                        pub fn patch(
                            &self,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                            name: impl Into<String>,
                        ) -> PatchRequestBuilder {
                            PatchRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                                update_mask: None,
                            }
                        }
                    }
                    #[doc = "Created via [CertificatesActions::create()](struct.CertificatesActions.html#method.create)"]
                    #[derive(Debug, Clone)]
                    pub struct CreateRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                        parent: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> CreateRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/certificates");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [CertificatesActions::delete()](struct.CertificatesActions.html#method.delete)"]
                    #[derive(Debug, Clone)]
                    pub struct DeleteRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> DeleteRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [CertificatesActions::get()](struct.CertificatesActions.html#method.get)"]
                    #[derive(Debug, Clone)]
                    pub struct GetRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> GetRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [CertificatesActions::list()](struct.CertificatesActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        read_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Filtering as supported in https://developers.google.com/authorized-buyers/apis/guides/v2/list-filters."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "The size of entries in the response. If unspecified, defaults to 100."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "The token returned in the previous response."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "The mask which specifies fields that need to be returned in the Certificateâ€™s response."]
                        pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                            self.read_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `certificates` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_certificates<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_certificates_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `certificates` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_certificates_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_certificates_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `certificates` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_certificates_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_certificates_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `certificates` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_certificates_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "certificates")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "certificates").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListCertificatesResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListCertificatesResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListCertificatesResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListCertificatesResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/certificates");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("readMask", &self.read_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                    #[doc = "Created via [CertificatesActions::patch()](struct.CertificatesActions.html#method.patch)"]
                    #[derive(Debug, Clone)]
                    pub struct PatchRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                        name: String,
                        update_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> PatchRequestBuilder<'a> {
                        #[doc = "Field mask specifying the fields in the above Certificate that have been modified and need to be updated."]
                        pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                            self.update_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaCertificate,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                            req = req.query(&[("updateMask", &self.update_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                }
                pub mod integrations {
                    pub mod params {}
                    pub struct IntegrationsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> IntegrationsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Executes integrations synchronously by passing the trigger id in the request body. The request is not returned until the requested executions are either fulfilled or experienced an error. If the integration name is not specified (passing `-`), all of the associated integration under the given trigger_id will be executed. Otherwise only the specified integration for the given `trigger_id` is executed. This is helpful for execution the integration from UI."]
                        pub fn execute(
                            &self,
                            request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaExecuteIntegrationsRequest,
                            name: impl Into<String>,
                        ) -> ExecuteRequestBuilder {
                            ExecuteRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Returns the list of all integrations in the specified project."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                order_by: None,
                                page_size: None,
                                page_token: None,
                            }
                        }
                        #[doc = "Schedules an integration for execution by passing the trigger id and the scheduled time in the request body."]
                        pub fn schedule(
                            &self,
                            request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaScheduleIntegrationsRequest,
                            name: impl Into<String>,
                        ) -> ScheduleRequestBuilder {
                            ScheduleRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Actions that can be performed on the executions resource"]                        pub fn executions (& self) -> crate :: resources :: projects :: locations :: products :: integrations :: executions :: ExecutionsActions{
                            crate :: resources :: projects :: locations :: products :: integrations :: executions :: ExecutionsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                        }
                        #[doc = "Actions that can be performed on the versions resource"]                        pub fn versions (& self) -> crate :: resources :: projects :: locations :: products :: integrations :: versions :: VersionsActions{
                            crate :: resources :: projects :: locations :: products :: integrations :: versions :: VersionsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                        }
                    }
                    #[doc = "Created via [IntegrationsActions::execute()](struct.IntegrationsActions.html#method.execute)"]
                    #[derive(Debug, Clone)]
                    pub struct ExecuteRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaExecuteIntegrationsRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                    impl<'a> ExecuteRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaExecuteIntegrationsResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaExecuteIntegrationsResponse , crate :: Error >{
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str(":execute");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [IntegrationsActions::list()](struct.IntegrationsActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: ::std::option::Option<String>,
                        order_by: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Filter on fields of IntegrationVersion. Fields can be compared with literal values by use of â€œ:â€ (containment), â€œ=â€ (equality), â€œ\\>â€ (greater), â€œ\\<â€ (less than), >=â€œ (greater than or equal to), â€œ\\<=â€ (less than or equal to), and â€œ!=â€ (inequality) operators. Negation, conjunction, and disjunction are written using NOT, AND, and OR keywords. For example, organization_id=\"1\" AND state=ACTIVE AND description:â€œtestâ€. Filtering cannot be performed on repeated fields like `task_config`."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "The results would be returned in order you specified here. Supported sort keys are: Descending sort order by â€œlast_modified_timeâ€, â€œcreated_timeâ€, â€œsnapshot_numberâ€. Ascending sort order by the integration name."]
                        pub fn order_by(mut self, value: impl Into<String>) -> Self {
                            self.order_by = Some(value.into());
                            self
                        }
                        #[doc = "The page size for the resquest."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "The page token for the resquest."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `integrations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_integrations<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_integrations_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `integrations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_integrations_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegration,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_integrations_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `integrations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_integrations_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegration,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_integrations_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `integrations` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_integrations_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "integrations")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "integrations").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListIntegrationsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListIntegrationsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/integrations");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("orderBy", &self.order_by)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                    #[doc = "Created via [IntegrationsActions::schedule()](struct.IntegrationsActions.html#method.schedule)"]
                    #[derive(Debug, Clone)]
                    pub struct ScheduleRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaScheduleIntegrationsRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                    impl<'a> ScheduleRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]                        pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaScheduleIntegrationsResponse , crate :: Error >{
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]                        pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaScheduleIntegrationsResponse , crate :: Error >{
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str(":schedule");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    pub mod executions {
                        pub mod params {}
                        pub struct ExecutionsActions<'a> {
                            pub(crate) reqwest: &'a reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        }
                        impl<'a> ExecutionsActions<'a> {
                            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                                self.auth
                            }
                            #[doc = "Cancellation of an execution"]
                            pub fn cancel(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaCancelExecutionRequest,
                                name: impl Into<String>,
                            ) -> CancelRequestBuilder {
                                CancelRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Get an execution in the specified project."]
                            pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                                GetRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Lists the results of all the integration executions. The response includes the same information as the [execution log](https://cloud.google.com/application-integration/docs/viewing-logs) in the Integration UI."]
                            pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                                ListRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                    filter: None,
                                    filter_params_custom_filter: None,
                                    filter_params_end_time: None,
                                    filter_params_event_statuses: None,
                                    filter_params_execution_id: None,
                                    filter_params_parameter_key: None,
                                    filter_params_parameter_pair_key: None,
                                    filter_params_parameter_pair_value: None,
                                    filter_params_parameter_type: None,
                                    filter_params_parameter_value: None,
                                    filter_params_start_time: None,
                                    filter_params_task_statuses: None,
                                    filter_params_workflow_name: None,
                                    order_by: None,
                                    page_size: None,
                                    page_token: None,
                                    read_mask: None,
                                    refresh_acl: None,
                                    truncate_params: None,
                                }
                            }
                            #[doc = "Actions that can be performed on the suspensions resource"]                            pub fn suspensions (& self) -> crate :: resources :: projects :: locations :: products :: integrations :: executions :: suspensions :: SuspensionsActions{
                                crate :: resources :: projects :: locations :: products :: integrations :: executions :: suspensions :: SuspensionsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                            }
                        }
                        #[doc = "Created via [ExecutionsActions::cancel()](struct.ExecutionsActions.html#method.cancel)"]
                        #[derive(Debug, Clone)]
                        pub struct CancelRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaCancelExecutionRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                        impl<'a> CancelRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaCancelExecutionResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaCancelExecutionResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str(":cancel");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [ExecutionsActions::get()](struct.ExecutionsActions.html#method.get)"]
                        #[derive(Debug, Clone)]
                        pub struct GetRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            name: String,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> GetRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaExecution,
                                crate::Error,
                            > {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaExecution,
                                crate::Error,
                            > {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [ExecutionsActions::list()](struct.ExecutionsActions.html#method.list)"]
                        #[derive(Debug, Clone)]
                        pub struct ListRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            parent: String,
                            filter: ::std::option::Option<String>,
                            filter_params_custom_filter: ::std::option::Option<String>,
                            filter_params_end_time: ::std::option::Option<i64>,
                            filter_params_event_statuses: ::std::option::Option<Vec<String>>,
                            filter_params_execution_id: ::std::option::Option<String>,
                            filter_params_parameter_key: ::std::option::Option<String>,
                            filter_params_parameter_pair_key: ::std::option::Option<String>,
                            filter_params_parameter_pair_value: ::std::option::Option<String>,
                            filter_params_parameter_type: ::std::option::Option<String>,
                            filter_params_parameter_value: ::std::option::Option<String>,
                            filter_params_start_time: ::std::option::Option<i64>,
                            filter_params_task_statuses: ::std::option::Option<Vec<String>>,
                            filter_params_workflow_name: ::std::option::Option<String>,
                            order_by: ::std::option::Option<String>,
                            page_size: ::std::option::Option<i32>,
                            page_token: ::std::option::Option<String>,
                            read_mask: ::std::option::Option<String>,
                            refresh_acl: ::std::option::Option<bool>,
                            truncate_params: ::std::option::Option<bool>,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> ListRequestBuilder<'a> {
                            #[doc = "Optional. Standard filter field, we support filtering on all fields in EventExecutionParamIndexes table. All fields support for EQUALS, in additional: CreateTimestamp support for LESS_THAN, GREATER_THAN ParameterKey, ParameterValue, ParameterType support for HAS For example: â€œparameter_valueâ€ HAS \"parameter1\" Also supports operators like AND, OR, NOT For example, trigger_id=\"id1\" AND event_execution_state=\"FAILED\""]
                            pub fn filter(mut self, value: impl Into<String>) -> Self {
                                self.filter = Some(value.into());
                                self
                            }
                            #[doc = "Optional user-provided custom filter."]
                            pub fn filter_params_custom_filter(
                                mut self,
                                value: impl Into<String>,
                            ) -> Self {
                                self.filter_params_custom_filter = Some(value.into());
                                self
                            }
                            #[doc = "End timestamp."]
                            pub fn filter_params_end_time(mut self, value: i64) -> Self {
                                self.filter_params_end_time = Some(value);
                                self
                            }
                            #[doc = "List of possible event statuses."]
                            pub fn filter_params_event_statuses(
                                mut self,
                                value: impl Into<Vec<String>>,
                            ) -> Self {
                                self.filter_params_event_statuses = Some(value.into());
                                self
                            }
                            #[doc = "Execution id."]
                            pub fn filter_params_execution_id(
                                mut self,
                                value: impl Into<String>,
                            ) -> Self {
                                self.filter_params_execution_id = Some(value.into());
                                self
                            }
                            #[doc = "Param key. DEPRECATED. User parameter_pair_key instead."]
                            pub fn filter_params_parameter_key(
                                mut self,
                                value: impl Into<String>,
                            ) -> Self {
                                self.filter_params_parameter_key = Some(value.into());
                                self
                            }
                            #[doc = "Param key in the key value pair filter."]
                            pub fn filter_params_parameter_pair_key(
                                mut self,
                                value: impl Into<String>,
                            ) -> Self {
                                self.filter_params_parameter_pair_key = Some(value.into());
                                self
                            }
                            #[doc = "Param value in the key value pair filter."]
                            pub fn filter_params_parameter_pair_value(
                                mut self,
                                value: impl Into<String>,
                            ) -> Self {
                                self.filter_params_parameter_pair_value = Some(value.into());
                                self
                            }
                            #[doc = "Param type."]
                            pub fn filter_params_parameter_type(
                                mut self,
                                value: impl Into<String>,
                            ) -> Self {
                                self.filter_params_parameter_type = Some(value.into());
                                self
                            }
                            #[doc = "Param value. DEPRECATED. User parameter_pair_value instead."]
                            pub fn filter_params_parameter_value(
                                mut self,
                                value: impl Into<String>,
                            ) -> Self {
                                self.filter_params_parameter_value = Some(value.into());
                                self
                            }
                            #[doc = "Start timestamp."]
                            pub fn filter_params_start_time(mut self, value: i64) -> Self {
                                self.filter_params_start_time = Some(value);
                                self
                            }
                            #[doc = "List of possible task statuses."]
                            pub fn filter_params_task_statuses(
                                mut self,
                                value: impl Into<Vec<String>>,
                            ) -> Self {
                                self.filter_params_task_statuses = Some(value.into());
                                self
                            }
                            #[doc = "Workflow name."]
                            pub fn filter_params_workflow_name(
                                mut self,
                                value: impl Into<String>,
                            ) -> Self {
                                self.filter_params_workflow_name = Some(value.into());
                                self
                            }
                            #[doc = "Optional. The results would be returned in order you specified here. Currently supporting â€œlast_modified_timeâ€ and â€œcreate_timeâ€."]
                            pub fn order_by(mut self, value: impl Into<String>) -> Self {
                                self.order_by = Some(value.into());
                                self
                            }
                            #[doc = "Optional. The size of entries in the response."]
                            pub fn page_size(mut self, value: i32) -> Self {
                                self.page_size = Some(value);
                                self
                            }
                            #[doc = "Optional. The token returned in the previous response."]
                            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                                self.page_token = Some(value.into());
                                self
                            }
                            #[doc = "Optional. View mask for the response data. If set, only the field specified will be returned as part of the result. If not set, all fields in event execution info will be filled and returned."]
                            pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                                self.read_mask = Some(value.into());
                                self
                            }
                            #[doc = "Optional. If true, the service will use the most recent acl information to list event execution infos and renew the acl cache. Note that fetching the most recent acl is synchronous, so it will increase RPC call latency."]
                            pub fn refresh_acl(mut self, value: bool) -> Self {
                                self.refresh_acl = Some(value);
                                self
                            }
                            #[doc = "Optional. If true, the service will truncate the params to only keep the first 1000 characters of string params and empty the executions in order to make response smaller. Only works for UI and when the params fields are not filtered out."]
                            pub fn truncate_params(mut self, value: bool) -> Self {
                                self.truncate_params = Some(value);
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = "\nExecute the request and yield each item in the `executionInfos` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                            pub fn stream_execution_infos<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_execution_infos_with_fields(fields)
                            }
                            #[doc = "\nExecute the request and yield each item in the `executionInfos` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]                            pub fn stream_execution_infos_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoEventExecutionInfo , crate :: Error >> + 'a{
                                self.stream_execution_infos_with_fields(None::<String>)
                            }
                            #[doc = "\nExecute the request and yield each item in the `executionInfos` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]                            pub fn stream_execution_infos_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: EnterpriseCrmFrontendsEventbusProtoEventExecutionInfo , crate :: Error >> + 'a{
                                self.stream_execution_infos_with_fields(Some("*"))
                            }
                            #[doc = "\nExecute the request and yield each item in the `executionInfos` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                            pub fn stream_execution_infos_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned + 'a,
                                F: AsRef<str>,
                            {
                                #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                                struct Page<T> {
                                    #[serde(rename = "nextPageToken")]
                                    pub next_page_token: ::std::option::Option<String>,
                                    #[serde(rename = "executionInfos")]
                                    pub items: Vec<T>,
                                }
                                impl<T> crate::GetNextPageToken<String> for Page<T> {
                                    fn next_page_token(&self) -> ::std::option::Option<String> {
                                        self.next_page_token.to_owned()
                                    }
                                }
                                impl<T> crate::stream::IntoPageItems for Page<T> {
                                    type Items = Vec<T>;
                                    fn into_page_items(self) -> Self::Items {
                                        self.items
                                    }
                                }
                                self.fields = Some({
                                    let mut selector =
                                        concat!("nextPageToken,", "executionInfos").to_owned();
                                    let items_fields =
                                        fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                    if !items_fields.is_empty() {
                                        selector.push_str("(");
                                        selector.push_str(items_fields);
                                        selector.push_str(")");
                                    }
                                    selector
                                });
                                crate::stream::page_item_stream::<_, Page<T>>(self)
                            }
                            #[doc = "\nExecute the request and yield each item in the `executions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                            pub fn stream_executions<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_executions_with_fields(fields)
                            }
                            #[doc = "\nExecute the request and yield each item in the `executions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                            pub fn stream_executions_with_default_fields(
                                self,
                            ) -> impl ::futures::Stream<
                                Item = Result<
                                    crate::schemas::GoogleCloudIntegrationsV1AlphaExecution,
                                    crate::Error,
                                >,
                            > + 'a {
                                self.stream_executions_with_fields(None::<String>)
                            }
                            #[doc = "\nExecute the request and yield each item in the `executions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                            pub fn stream_executions_with_all_fields(
                                self,
                            ) -> impl ::futures::Stream<
                                Item = Result<
                                    crate::schemas::GoogleCloudIntegrationsV1AlphaExecution,
                                    crate::Error,
                                >,
                            > + 'a {
                                self.stream_executions_with_fields(Some("*"))
                            }
                            #[doc = "\nExecute the request and yield each item in the `executions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                            pub fn stream_executions_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned + 'a,
                                F: AsRef<str>,
                            {
                                #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                                struct Page<T> {
                                    #[serde(rename = "nextPageToken")]
                                    pub next_page_token: ::std::option::Option<String>,
                                    #[serde(rename = "executions")]
                                    pub items: Vec<T>,
                                }
                                impl<T> crate::GetNextPageToken<String> for Page<T> {
                                    fn next_page_token(&self) -> ::std::option::Option<String> {
                                        self.next_page_token.to_owned()
                                    }
                                }
                                impl<T> crate::stream::IntoPageItems for Page<T> {
                                    type Items = Vec<T>;
                                    fn into_page_items(self) -> Self::Items {
                                        self.items
                                    }
                                }
                                self.fields = Some({
                                    let mut selector =
                                        concat!("nextPageToken,", "executions").to_owned();
                                    let items_fields =
                                        fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                    if !items_fields.is_empty() {
                                        selector.push_str("(");
                                        selector.push_str(items_fields);
                                        selector.push_str(")");
                                    }
                                    selector
                                });
                                crate::stream::page_item_stream::<_, Page<T>>(self)
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                            pub fn stream<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_with_fields(fields)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the default set of fields from the server."]                            pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListExecutionsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests all fields from the server."]                            pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListExecutionsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                            #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            pub fn stream_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + 'a,
                                F: AsRef<str>,
                            {
                                let mut fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                                if !fields.is_empty() {
                                    match fields.chars().rev().nth(0) {
                                        Some(',') | None => {}
                                        _ => fields.push_str(","),
                                    }
                                    fields.push_str("nextPageToken");
                                    self.fields = Some(fields);
                                }
                                crate::stream::page_stream(self)
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListExecutionsResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListExecutionsResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/executions");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("filter", &self.filter)]);
                                req = req.query(&[(
                                    "filterParams.customFilter",
                                    &self.filter_params_custom_filter,
                                )]);
                                req = req.query(&[(
                                    "filterParams.endTime",
                                    &self.filter_params_end_time,
                                )]);
                                for value in self.filter_params_event_statuses.iter().flatten() {
                                    req = req.query(&[("filterParams.eventStatuses", value)]);
                                }
                                req = req.query(&[(
                                    "filterParams.executionId",
                                    &self.filter_params_execution_id,
                                )]);
                                req = req.query(&[(
                                    "filterParams.parameterKey",
                                    &self.filter_params_parameter_key,
                                )]);
                                req = req.query(&[(
                                    "filterParams.parameterPairKey",
                                    &self.filter_params_parameter_pair_key,
                                )]);
                                req = req.query(&[(
                                    "filterParams.parameterPairValue",
                                    &self.filter_params_parameter_pair_value,
                                )]);
                                req = req.query(&[(
                                    "filterParams.parameterType",
                                    &self.filter_params_parameter_type,
                                )]);
                                req = req.query(&[(
                                    "filterParams.parameterValue",
                                    &self.filter_params_parameter_value,
                                )]);
                                req = req.query(&[(
                                    "filterParams.startTime",
                                    &self.filter_params_start_time,
                                )]);
                                for value in self.filter_params_task_statuses.iter().flatten() {
                                    req = req.query(&[("filterParams.taskStatuses", value)]);
                                }
                                req = req.query(&[(
                                    "filterParams.workflowName",
                                    &self.filter_params_workflow_name,
                                )]);
                                req = req.query(&[("orderBy", &self.order_by)]);
                                req = req.query(&[("pageSize", &self.page_size)]);
                                req = req.query(&[("pageToken", &self.page_token)]);
                                req = req.query(&[("readMask", &self.read_mask)]);
                                req = req.query(&[("refreshAcl", &self.refresh_acl)]);
                                req = req.query(&[("truncateParams", &self.truncate_params)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[async_trait::async_trait]
                        impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                            type PageToken = String;
                            fn set_page_token(&mut self, value: String) {
                                self.page_token = value.into();
                            }
                            async fn execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                            {
                                self._execute().await
                            }
                        }
                        pub mod suspensions {
                            pub mod params {}
                            pub struct SuspensionsActions<'a> {
                                pub(crate) reqwest: &'a reqwest::Client,
                                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            }
                            impl<'a> SuspensionsActions<'a> {
                                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                                    self.auth
                                }
                                #[doc = "* Lifts suspension for advanced suspension task. Fetch corresponding suspension with provided suspension Id, resolve suspension, and set up suspension result for the Suspension Task."]
                                pub fn lift(
                                    &self,
                                    request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaLiftSuspensionRequest,
                                    name: impl Into<String>,
                                ) -> LiftRequestBuilder {
                                    LiftRequestBuilder {
                                        reqwest: &self.reqwest,
                                        auth: self.auth_ref(),
                                        request,
                                        access_token: None,
                                        alt: None,
                                        callback: None,
                                        fields: None,
                                        key: None,
                                        oauth_token: None,
                                        pretty_print: None,
                                        quota_user: None,
                                        upload_protocol: None,
                                        upload_type: None,
                                        xgafv: None,
                                        name: name.into(),
                                    }
                                }
                                #[doc = "* Lists suspensions associated with a specific execution. Only those with permissions to resolve the relevant suspensions will be able to view them."]
                                pub fn list(
                                    &self,
                                    parent: impl Into<String>,
                                ) -> ListRequestBuilder {
                                    ListRequestBuilder {
                                        reqwest: &self.reqwest,
                                        auth: self.auth_ref(),
                                        access_token: None,
                                        alt: None,
                                        callback: None,
                                        fields: None,
                                        key: None,
                                        oauth_token: None,
                                        pretty_print: None,
                                        quota_user: None,
                                        upload_protocol: None,
                                        upload_type: None,
                                        xgafv: None,
                                        parent: parent.into(),
                                        filter: None,
                                        order_by: None,
                                        page_size: None,
                                        page_token: None,
                                    }
                                }
                                #[doc = "* Resolves (lifts/rejects) any number of suspensions. If the integration is already running, only the status of the suspension is updated. Otherwise, the suspended integration will begin execution again."]
                                pub fn resolve(
                                    &self,
                                    request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaResolveSuspensionRequest,
                                    name: impl Into<String>,
                                ) -> ResolveRequestBuilder {
                                    ResolveRequestBuilder {
                                        reqwest: &self.reqwest,
                                        auth: self.auth_ref(),
                                        request,
                                        access_token: None,
                                        alt: None,
                                        callback: None,
                                        fields: None,
                                        key: None,
                                        oauth_token: None,
                                        pretty_print: None,
                                        quota_user: None,
                                        upload_protocol: None,
                                        upload_type: None,
                                        xgafv: None,
                                        name: name.into(),
                                    }
                                }
                            }
                            #[doc = "Created via [SuspensionsActions::lift()](struct.SuspensionsActions.html#method.lift)"]
                            #[derive(Debug, Clone)]
                            pub struct LiftRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaLiftSuspensionRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                            impl<'a> LiftRequestBuilder<'a> {
                                #[doc = "OAuth access token."]
                                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                    self.access_token = Some(value.into());
                                    self
                                }
                                #[doc = "JSONP"]
                                pub fn callback(mut self, value: impl Into<String>) -> Self {
                                    self.callback = Some(value.into());
                                    self
                                }
                                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                                pub fn key(mut self, value: impl Into<String>) -> Self {
                                    self.key = Some(value.into());
                                    self
                                }
                                #[doc = "OAuth 2.0 token for the current user."]
                                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                    self.oauth_token = Some(value.into());
                                    self
                                }
                                #[doc = "Returns response with indentations and line breaks."]
                                pub fn pretty_print(mut self, value: bool) -> Self {
                                    self.pretty_print = Some(value);
                                    self
                                }
                                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                    self.quota_user = Some(value.into());
                                    self
                                }
                                #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                    self.upload_protocol = Some(value.into());
                                    self
                                }
                                #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                    self.upload_type = Some(value.into());
                                    self
                                }
                                #[doc = "V1 error format."]
                                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                    self.xgafv = Some(value);
                                    self
                                }
                                #[doc = r" Execute the given operation. The fields requested are"]
                                #[doc = r" determined by the FieldSelector attribute of the return type."]
                                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                                #[doc = r" are not generic over the return type and deserialize the"]
                                #[doc = r" response into an auto-generated struct will all possible"]
                                #[doc = r" fields."]
                                pub async fn execute<T>(self) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned
                                        + ::google_field_selector::FieldSelector,
                                {
                                    let fields = ::google_field_selector::to_string::<T>();
                                    let fields: ::std::option::Option<String> = if fields.is_empty()
                                    {
                                        None
                                    } else {
                                        Some(fields)
                                    };
                                    self.execute_with_fields(fields).await
                                }
                                #[doc = r" Execute the given operation. This will not provide any"]
                                #[doc = r" `fields` selector indicating that the server will determine"]
                                #[doc = r" the fields returned. This typically includes the most common"]
                                #[doc = r" fields, but it will not include every possible attribute of"]
                                #[doc = r" the response resource."]                                pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaLiftSuspensionResponse , crate :: Error >{
                                    self.execute_with_fields(None::<&str>).await
                                }
                                #[doc = r" Execute the given operation. This will provide a `fields`"]
                                #[doc = r" selector of `*`. This will include every attribute of the"]
                                #[doc = r" response resource and should be limited to use during"]
                                #[doc = r" development or debugging."]                                pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaLiftSuspensionResponse , crate :: Error >{
                                    self.execute_with_fields(Some("*")).await
                                }
                                #[doc = r" Execute the given operation. This will use the `fields`"]
                                #[doc = r" selector provided and will deserialize the response into"]
                                #[doc = r" whatever return value is provided."]
                                pub async fn execute_with_fields<T, F>(
                                    mut self,
                                    fields: ::std::option::Option<F>,
                                ) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned,
                                    F: Into<String>,
                                {
                                    self.fields = fields.map(Into::into);
                                    self._execute().await
                                }
                                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned,
                                {
                                    let req = self._request(&self._path()).await?;
                                    let req = req.json(&self.request);
                                    Ok(req.send().await?.error_for_status()?.json().await?)
                                }
                                fn _path(&self) -> String {
                                    let mut output =
                                        "https://integrations.googleapis.com/".to_owned();
                                    output.push_str("v1alpha/");
                                    {
                                        let var_as_str = &self.name;
                                        output.extend(::percent_encoding::utf8_percent_encode(
                                            &var_as_str,
                                            crate::RESERVED,
                                        ));
                                    }
                                    output.push_str(":lift");
                                    output
                                }
                                async fn _request(
                                    &self,
                                    path: &str,
                                ) -> Result<::reqwest::RequestBuilder, crate::Error>
                                {
                                    let mut req =
                                        self.reqwest.request(::reqwest::Method::POST, path);
                                    req = req.query(&[("access_token", &self.access_token)]);
                                    req = req.query(&[("alt", &self.alt)]);
                                    req = req.query(&[("callback", &self.callback)]);
                                    req = req.query(&[("fields", &self.fields)]);
                                    req = req.query(&[("key", &self.key)]);
                                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                    req = req.query(&[("quotaUser", &self.quota_user)]);
                                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                    req = req.query(&[("uploadType", &self.upload_type)]);
                                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                                    let access_token = self
                                        .auth
                                        .access_token()
                                        .await
                                        .map_err(|err| crate::Error::OAuth2(err))?;
                                    req = req.bearer_auth(access_token);
                                    Ok(req)
                                }
                            }
                            #[doc = "Created via [SuspensionsActions::list()](struct.SuspensionsActions.html#method.list)"]
                            #[derive(Debug, Clone)]
                            pub struct ListRequestBuilder<'a> {
                                pub(crate) reqwest: &'a ::reqwest::Client,
                                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                                parent: String,
                                filter: ::std::option::Option<String>,
                                order_by: ::std::option::Option<String>,
                                page_size: ::std::option::Option<i32>,
                                page_token: ::std::option::Option<String>,
                                access_token: ::std::option::Option<String>,
                                alt: ::std::option::Option<crate::params::Alt>,
                                callback: ::std::option::Option<String>,
                                fields: ::std::option::Option<String>,
                                key: ::std::option::Option<String>,
                                oauth_token: ::std::option::Option<String>,
                                pretty_print: ::std::option::Option<bool>,
                                quota_user: ::std::option::Option<String>,
                                upload_protocol: ::std::option::Option<String>,
                                upload_type: ::std::option::Option<String>,
                                xgafv: ::std::option::Option<crate::params::Xgafv>,
                            }
                            impl<'a> ListRequestBuilder<'a> {
                                #[doc = "Standard filter field."]
                                pub fn filter(mut self, value: impl Into<String>) -> Self {
                                    self.filter = Some(value.into());
                                    self
                                }
                                #[doc = "Field name to order by."]
                                pub fn order_by(mut self, value: impl Into<String>) -> Self {
                                    self.order_by = Some(value.into());
                                    self
                                }
                                #[doc = "Maximum number of entries in the response."]
                                pub fn page_size(mut self, value: i32) -> Self {
                                    self.page_size = Some(value);
                                    self
                                }
                                #[doc = "Token to retrieve a specific page."]
                                pub fn page_token(mut self, value: impl Into<String>) -> Self {
                                    self.page_token = Some(value.into());
                                    self
                                }
                                #[doc = "OAuth access token."]
                                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                    self.access_token = Some(value.into());
                                    self
                                }
                                #[doc = "JSONP"]
                                pub fn callback(mut self, value: impl Into<String>) -> Self {
                                    self.callback = Some(value.into());
                                    self
                                }
                                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                                pub fn key(mut self, value: impl Into<String>) -> Self {
                                    self.key = Some(value.into());
                                    self
                                }
                                #[doc = "OAuth 2.0 token for the current user."]
                                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                    self.oauth_token = Some(value.into());
                                    self
                                }
                                #[doc = "Returns response with indentations and line breaks."]
                                pub fn pretty_print(mut self, value: bool) -> Self {
                                    self.pretty_print = Some(value);
                                    self
                                }
                                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                    self.quota_user = Some(value.into());
                                    self
                                }
                                #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                    self.upload_protocol = Some(value.into());
                                    self
                                }
                                #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                    self.upload_type = Some(value.into());
                                    self
                                }
                                #[doc = "V1 error format."]
                                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                    self.xgafv = Some(value);
                                    self
                                }
                                #[doc = "\nExecute the request and yield each item in the `suspensions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                                pub fn stream_suspensions<T>(
                                    self,
                                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                                where
                                    T: ::serde::de::DeserializeOwned
                                        + ::google_field_selector::FieldSelector
                                        + 'a,
                                {
                                    let fields = ::google_field_selector::to_string::<T>();
                                    let fields: ::std::option::Option<String> = if fields.is_empty()
                                    {
                                        None
                                    } else {
                                        Some(fields)
                                    };
                                    self.stream_suspensions_with_fields(fields)
                                }
                                #[doc = "\nExecute the request and yield each item in the `suspensions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                                pub fn stream_suspensions_with_default_fields(
                                    self,
                                ) -> impl ::futures::Stream<
                                    Item = Result<
                                        crate::schemas::GoogleCloudIntegrationsV1AlphaSuspension,
                                        crate::Error,
                                    >,
                                > + 'a {
                                    self.stream_suspensions_with_fields(None::<String>)
                                }
                                #[doc = "\nExecute the request and yield each item in the `suspensions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                                pub fn stream_suspensions_with_all_fields(
                                    self,
                                ) -> impl ::futures::Stream<
                                    Item = Result<
                                        crate::schemas::GoogleCloudIntegrationsV1AlphaSuspension,
                                        crate::Error,
                                    >,
                                > + 'a {
                                    self.stream_suspensions_with_fields(Some("*"))
                                }
                                #[doc = "\nExecute the request and yield each item in the `suspensions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                                pub fn stream_suspensions_with_fields<T, F>(
                                    mut self,
                                    fields: ::std::option::Option<F>,
                                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                                where
                                    T: ::serde::de::DeserializeOwned + 'a,
                                    F: AsRef<str>,
                                {
                                    #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                                    struct Page<T> {
                                        #[serde(rename = "nextPageToken")]
                                        pub next_page_token: ::std::option::Option<String>,
                                        #[serde(rename = "suspensions")]
                                        pub items: Vec<T>,
                                    }
                                    impl<T> crate::GetNextPageToken<String> for Page<T> {
                                        fn next_page_token(&self) -> ::std::option::Option<String> {
                                            self.next_page_token.to_owned()
                                        }
                                    }
                                    impl<T> crate::stream::IntoPageItems for Page<T> {
                                        type Items = Vec<T>;
                                        fn into_page_items(self) -> Self::Items {
                                            self.items
                                        }
                                    }
                                    self.fields = Some({
                                        let mut selector =
                                            concat!("nextPageToken,", "suspensions").to_owned();
                                        let items_fields =
                                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                        if !items_fields.is_empty() {
                                            selector.push_str("(");
                                            selector.push_str(items_fields);
                                            selector.push_str(")");
                                        }
                                        selector
                                    });
                                    crate::stream::page_item_stream::<_, Page<T>>(self)
                                }
                                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                                #[doc = r" token is returned."]
                                #[doc = r""]
                                #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                                #[doc = r""]
                                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                                #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                                pub fn stream<T>(
                                    self,
                                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                                where
                                    T: crate::GetNextPageToken<String>
                                        + ::serde::de::DeserializeOwned
                                        + ::google_field_selector::FieldSelector
                                        + 'a,
                                {
                                    let fields = ::google_field_selector::to_string::<T>();
                                    let fields: ::std::option::Option<String> = if fields.is_empty()
                                    {
                                        None
                                    } else {
                                        Some(fields)
                                    };
                                    self.stream_with_fields(fields)
                                }
                                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                                #[doc = r" repeated until no page token is returned."]
                                #[doc = r""]
                                #[doc = r" Requests the default set of fields from the server."]                                pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSuspensionsResponse , crate :: Error >> + 'a{
                                    self.stream_with_fields(None::<&str>)
                                }
                                #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                                #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                                #[doc = r" repeated until no page token is returned."]
                                #[doc = r""]
                                #[doc = r" Requests all fields from the server."]                                pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSuspensionsResponse , crate :: Error >> + 'a{
                                    self.stream_with_fields(Some("*"))
                                }
                                #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                                #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                                #[doc = r" token is returned."]
                                #[doc = r""]
                                #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                                #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                                #[doc = r""]
                                #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                                pub fn stream_with_fields<T, F>(
                                    mut self,
                                    fields: ::std::option::Option<F>,
                                ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                                where
                                    T: crate::GetNextPageToken<String>
                                        + ::serde::de::DeserializeOwned
                                        + 'a,
                                    F: AsRef<str>,
                                {
                                    let mut fields = fields
                                        .as_ref()
                                        .map(|x| x.as_ref())
                                        .unwrap_or("")
                                        .to_owned();
                                    if !fields.is_empty() {
                                        match fields.chars().rev().nth(0) {
                                            Some(',') | None => {}
                                            _ => fields.push_str(","),
                                        }
                                        fields.push_str("nextPageToken");
                                        self.fields = Some(fields);
                                    }
                                    crate::stream::page_stream(self)
                                }
                                #[doc = r" Execute the given operation. The fields requested are"]
                                #[doc = r" determined by the FieldSelector attribute of the return type."]
                                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                                #[doc = r" are not generic over the return type and deserialize the"]
                                #[doc = r" response into an auto-generated struct will all possible"]
                                #[doc = r" fields."]
                                pub async fn execute<T>(self) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned
                                        + ::google_field_selector::FieldSelector,
                                {
                                    let fields = ::google_field_selector::to_string::<T>();
                                    let fields: ::std::option::Option<String> = if fields.is_empty()
                                    {
                                        None
                                    } else {
                                        Some(fields)
                                    };
                                    self.execute_with_fields(fields).await
                                }
                                #[doc = r" Execute the given operation. This will not provide any"]
                                #[doc = r" `fields` selector indicating that the server will determine"]
                                #[doc = r" the fields returned. This typically includes the most common"]
                                #[doc = r" fields, but it will not include every possible attribute of"]
                                #[doc = r" the response resource."]                                pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSuspensionsResponse , crate :: Error >{
                                    self.execute_with_fields(None::<&str>).await
                                }
                                #[doc = r" Execute the given operation. This will provide a `fields`"]
                                #[doc = r" selector of `*`. This will include every attribute of the"]
                                #[doc = r" response resource and should be limited to use during"]
                                #[doc = r" development or debugging."]                                pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSuspensionsResponse , crate :: Error >{
                                    self.execute_with_fields(Some("*")).await
                                }
                                #[doc = r" Execute the given operation. This will use the `fields`"]
                                #[doc = r" selector provided and will deserialize the response into"]
                                #[doc = r" whatever return value is provided."]
                                pub async fn execute_with_fields<T, F>(
                                    mut self,
                                    fields: ::std::option::Option<F>,
                                ) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned,
                                    F: Into<String>,
                                {
                                    self.fields = fields.map(Into::into);
                                    self._execute().await
                                }
                                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned,
                                {
                                    let req = self._request(&self._path()).await?;
                                    Ok(req.send().await?.error_for_status()?.json().await?)
                                }
                                fn _path(&self) -> String {
                                    let mut output =
                                        "https://integrations.googleapis.com/".to_owned();
                                    output.push_str("v1alpha/");
                                    {
                                        let var_as_str = &self.parent;
                                        output.extend(::percent_encoding::utf8_percent_encode(
                                            &var_as_str,
                                            crate::RESERVED,
                                        ));
                                    }
                                    output.push_str("/suspensions");
                                    output
                                }
                                async fn _request(
                                    &self,
                                    path: &str,
                                ) -> Result<::reqwest::RequestBuilder, crate::Error>
                                {
                                    let mut req =
                                        self.reqwest.request(::reqwest::Method::GET, path);
                                    req = req.query(&[("filter", &self.filter)]);
                                    req = req.query(&[("orderBy", &self.order_by)]);
                                    req = req.query(&[("pageSize", &self.page_size)]);
                                    req = req.query(&[("pageToken", &self.page_token)]);
                                    req = req.query(&[("access_token", &self.access_token)]);
                                    req = req.query(&[("alt", &self.alt)]);
                                    req = req.query(&[("callback", &self.callback)]);
                                    req = req.query(&[("fields", &self.fields)]);
                                    req = req.query(&[("key", &self.key)]);
                                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                    req = req.query(&[("quotaUser", &self.quota_user)]);
                                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                    req = req.query(&[("uploadType", &self.upload_type)]);
                                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                                    let access_token = self
                                        .auth
                                        .access_token()
                                        .await
                                        .map_err(|err| crate::Error::OAuth2(err))?;
                                    req = req.bearer_auth(access_token);
                                    Ok(req)
                                }
                            }
                            #[async_trait::async_trait]
                            impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                                type PageToken = String;
                                fn set_page_token(&mut self, value: String) {
                                    self.page_token = value.into();
                                }
                                async fn execute<T>(&mut self) -> Result<T, crate::Error>
                                where
                                    T: crate::GetNextPageToken<String>
                                        + ::serde::de::DeserializeOwned,
                                {
                                    self._execute().await
                                }
                            }
                            #[doc = "Created via [SuspensionsActions::resolve()](struct.SuspensionsActions.html#method.resolve)"]
                            #[derive(Debug, Clone)]
                            pub struct ResolveRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaResolveSuspensionRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                            impl<'a> ResolveRequestBuilder<'a> {
                                #[doc = "OAuth access token."]
                                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                    self.access_token = Some(value.into());
                                    self
                                }
                                #[doc = "JSONP"]
                                pub fn callback(mut self, value: impl Into<String>) -> Self {
                                    self.callback = Some(value.into());
                                    self
                                }
                                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                                pub fn key(mut self, value: impl Into<String>) -> Self {
                                    self.key = Some(value.into());
                                    self
                                }
                                #[doc = "OAuth 2.0 token for the current user."]
                                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                    self.oauth_token = Some(value.into());
                                    self
                                }
                                #[doc = "Returns response with indentations and line breaks."]
                                pub fn pretty_print(mut self, value: bool) -> Self {
                                    self.pretty_print = Some(value);
                                    self
                                }
                                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                    self.quota_user = Some(value.into());
                                    self
                                }
                                #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                    self.upload_protocol = Some(value.into());
                                    self
                                }
                                #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                    self.upload_type = Some(value.into());
                                    self
                                }
                                #[doc = "V1 error format."]
                                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                    self.xgafv = Some(value);
                                    self
                                }
                                #[doc = r" Execute the given operation. The fields requested are"]
                                #[doc = r" determined by the FieldSelector attribute of the return type."]
                                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                                #[doc = r" are not generic over the return type and deserialize the"]
                                #[doc = r" response into an auto-generated struct will all possible"]
                                #[doc = r" fields."]
                                pub async fn execute<T>(self) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned
                                        + ::google_field_selector::FieldSelector,
                                {
                                    let fields = ::google_field_selector::to_string::<T>();
                                    let fields: ::std::option::Option<String> = if fields.is_empty()
                                    {
                                        None
                                    } else {
                                        Some(fields)
                                    };
                                    self.execute_with_fields(fields).await
                                }
                                #[doc = r" Execute the given operation. This will not provide any"]
                                #[doc = r" `fields` selector indicating that the server will determine"]
                                #[doc = r" the fields returned. This typically includes the most common"]
                                #[doc = r" fields, but it will not include every possible attribute of"]
                                #[doc = r" the response resource."]                                pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaResolveSuspensionResponse , crate :: Error >{
                                    self.execute_with_fields(None::<&str>).await
                                }
                                #[doc = r" Execute the given operation. This will provide a `fields`"]
                                #[doc = r" selector of `*`. This will include every attribute of the"]
                                #[doc = r" response resource and should be limited to use during"]
                                #[doc = r" development or debugging."]                                pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaResolveSuspensionResponse , crate :: Error >{
                                    self.execute_with_fields(Some("*")).await
                                }
                                #[doc = r" Execute the given operation. This will use the `fields`"]
                                #[doc = r" selector provided and will deserialize the response into"]
                                #[doc = r" whatever return value is provided."]
                                pub async fn execute_with_fields<T, F>(
                                    mut self,
                                    fields: ::std::option::Option<F>,
                                ) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned,
                                    F: Into<String>,
                                {
                                    self.fields = fields.map(Into::into);
                                    self._execute().await
                                }
                                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                                where
                                    T: ::serde::de::DeserializeOwned,
                                {
                                    let req = self._request(&self._path()).await?;
                                    let req = req.json(&self.request);
                                    Ok(req.send().await?.error_for_status()?.json().await?)
                                }
                                fn _path(&self) -> String {
                                    let mut output =
                                        "https://integrations.googleapis.com/".to_owned();
                                    output.push_str("v1alpha/");
                                    {
                                        let var_as_str = &self.name;
                                        output.extend(::percent_encoding::utf8_percent_encode(
                                            &var_as_str,
                                            crate::RESERVED,
                                        ));
                                    }
                                    output.push_str(":resolve");
                                    output
                                }
                                async fn _request(
                                    &self,
                                    path: &str,
                                ) -> Result<::reqwest::RequestBuilder, crate::Error>
                                {
                                    let mut req =
                                        self.reqwest.request(::reqwest::Method::POST, path);
                                    req = req.query(&[("access_token", &self.access_token)]);
                                    req = req.query(&[("alt", &self.alt)]);
                                    req = req.query(&[("callback", &self.callback)]);
                                    req = req.query(&[("fields", &self.fields)]);
                                    req = req.query(&[("key", &self.key)]);
                                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                    req = req.query(&[("quotaUser", &self.quota_user)]);
                                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                    req = req.query(&[("uploadType", &self.upload_type)]);
                                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                                    let access_token = self
                                        .auth
                                        .access_token()
                                        .await
                                        .map_err(|err| crate::Error::OAuth2(err))?;
                                    req = req.bearer_auth(access_token);
                                    Ok(req)
                                }
                            }
                        }
                    }
                    pub mod versions {
                        pub mod params {
                            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
                            pub enum DownloadFileFormat {
                                #[doc = "Unspecified file format"]
                                FileFormatUnspecified,
                                #[doc = "JSON File Format"]
                                Json,
                                #[doc = "YAML File Format"]
                                Yaml,
                            }
                            impl DownloadFileFormat {
                                pub fn as_str(self) -> &'static str {
                                    match self {
                                        DownloadFileFormat::FileFormatUnspecified => {
                                            "FILE_FORMAT_UNSPECIFIED"
                                        }
                                        DownloadFileFormat::Json => "JSON",
                                        DownloadFileFormat::Yaml => "YAML",
                                    }
                                }
                            }
                            impl ::std::convert::AsRef<str> for DownloadFileFormat {
                                fn as_ref(&self) -> &str {
                                    self.as_str()
                                }
                            }
                            impl ::std::str::FromStr for DownloadFileFormat {
                                type Err = ();
                                fn from_str(
                                    s: &str,
                                ) -> ::std::result::Result<DownloadFileFormat, ()>
                                {
                                    Ok(match s {
                                        "FILE_FORMAT_UNSPECIFIED" => {
                                            DownloadFileFormat::FileFormatUnspecified
                                        }
                                        "JSON" => DownloadFileFormat::Json,
                                        "YAML" => DownloadFileFormat::Yaml,
                                        _ => return Err(()),
                                    })
                                }
                            }
                            impl ::std::fmt::Display for DownloadFileFormat {
                                fn fmt(
                                    &self,
                                    f: &mut std::fmt::Formatter<'_>,
                                ) -> ::std::fmt::Result {
                                    f.write_str(self.as_str())
                                }
                            }
                            impl ::serde::Serialize for DownloadFileFormat {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> ::std::result::Result<S::Ok, S::Error>
                                where
                                    S: ::serde::ser::Serializer,
                                {
                                    serializer.serialize_str(self.as_str())
                                }
                            }
                            impl<'de> ::serde::Deserialize<'de> for DownloadFileFormat {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> ::std::result::Result<Self, D::Error>
                                where
                                    D: ::serde::de::Deserializer<'de>,
                                {
                                    let value: &'de str = <&str>::deserialize(deserializer)?;
                                    Ok(match value {
                                        "FILE_FORMAT_UNSPECIFIED" => {
                                            DownloadFileFormat::FileFormatUnspecified
                                        }
                                        "JSON" => DownloadFileFormat::Json,
                                        "YAML" => DownloadFileFormat::Yaml,
                                        _ => {
                                            return Err(::serde::de::Error::custom(format!(
                                                "invalid enum for #name: {}",
                                                value
                                            )))
                                        }
                                    })
                                }
                            }
                            impl ::google_field_selector::FieldSelector for DownloadFileFormat {
                                fn fields() -> Vec<::google_field_selector::Field> {
                                    Vec::new()
                                }
                            }
                            impl ::google_field_selector::ToFieldType for DownloadFileFormat {
                                fn field_type() -> ::google_field_selector::FieldType {
                                    ::google_field_selector::FieldType::Leaf
                                }
                            }
                        }
                        pub struct VersionsActions<'a> {
                            pub(crate) reqwest: &'a reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        }
                        impl<'a> VersionsActions<'a> {
                            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                                self.auth
                            }
                            #[doc = "Create a integration with a draft version in the specified project."]
                            pub fn create(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                parent: impl Into<String>,
                            ) -> CreateRequestBuilder {
                                CreateRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                    new_integration: None,
                                }
                            }
                            #[doc = "Soft-deletes the integration. Changes the status of the integration to ARCHIVED. If the integration being ARCHIVED is tagged as â€œHEADâ€, the tag is removed from this snapshot and set to the previous non-ARCHIVED snapshot. The PUBLISH_REQUESTED, DUE_FOR_DELETION tags are removed too. This RPC throws an exception if the version being deleted is DRAFT, and if the `locked_by` user is not the same as the user performing the Delete. Audit fields updated include last_modified_timestamp, last_modified_by. Any existing lock is released when Deleting a integration. Currently, there is no undelete mechanism."]
                            pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                                DeleteRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Downloads an integration. Retrieves the `IntegrationVersion` for a given `integration_id` and returns the response as a string."]
                            pub fn download(
                                &self,
                                name: impl Into<String>,
                            ) -> DownloadRequestBuilder {
                                DownloadRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                    file_format: None,
                                }
                            }
                            #[doc = "Get a integration in the specified project."]
                            pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                                GetRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Returns the list of all integration versions in the specified project."]
                            pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                                ListRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                    field_mask: None,
                                    filter: None,
                                    order_by: None,
                                    page_size: None,
                                    page_token: None,
                                }
                            }
                            #[doc = "Update a integration with a draft version in the specified project."]
                            pub fn patch(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                name: impl Into<String>,
                            ) -> PatchRequestBuilder {
                                PatchRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                    update_mask: None,
                                }
                            }
                            #[doc = "This RPC throws an exception if the integration is in ARCHIVED or ACTIVE state. This RPC throws an exception if the version being published is DRAFT, and if the `locked_by` user is not the same as the user performing the Publish. Audit fields updated include last_published_timestamp, last_published_by, last_modified_timestamp, last_modified_by. Any existing lock is on this integration is released."]
                            pub fn publish(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionRequest,
                                name: impl Into<String>,
                            ) -> PublishRequestBuilder {
                                PublishRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Clears the `locked_by` and `locked_at_timestamp`in the DRAFT version of this integration. It then performs the same action as the CreateDraftIntegrationVersion (i.e., copies the DRAFT version of the integration as a SNAPSHOT and then creates a new DRAFT version with the `locked_by` set to the `user_taking_over` and the `locked_at_timestamp` set to the current timestamp). Both the `locked_by` and `user_taking_over` are notified via email about the takeover. This RPC throws an exception if the integration is not in DRAFT status or if the `locked_by` and `locked_at_timestamp` fields are not set.The TakeoverEdit lock is treated the same as an edit of the integration, and hence shares ACLs with edit. Audit fields updated include last_modified_timestamp, last_modified_by."]
                            pub fn takeover_edit_lock(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaTakeoverEditLockRequest,
                                integration_version: impl Into<String>,
                            ) -> TakeoverEditLockRequestBuilder {
                                TakeoverEditLockRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    integration_version: integration_version.into(),
                                }
                            }
                            #[doc = "Sets the status of the ACTIVE integration to SNAPSHOT with a new tag â€œPREVIOUSLY_PUBLISHEDâ€ after validating it. The â€œHEADâ€ and â€œPUBLISH_REQUESTEDâ€ tags do not change. This RPC throws an exception if the version being snapshot is not ACTIVE. Audit fields added include action, action_by, action_timestamp."]
                            pub fn unpublish(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaUnpublishIntegrationVersionRequest,
                                name: impl Into<String>,
                            ) -> UnpublishRequestBuilder {
                                UnpublishRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Uploads an integration. The content can be a previously downloaded integration. Performs the same function as CreateDraftIntegrationVersion, but accepts input in a string format, which holds the complete representation of the IntegrationVersion content."]
                            pub fn upload(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequest,
                                parent: impl Into<String>,
                            ) -> UploadRequestBuilder {
                                UploadRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                }
                            }
                        }
                        #[doc = "Created via [VersionsActions::create()](struct.VersionsActions.html#method.create)"]
                        #[derive(Debug, Clone)]
                        pub struct CreateRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            request:
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            parent: String,
                            new_integration: ::std::option::Option<bool>,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> CreateRequestBuilder<'a> {
                            #[doc = "Set this flag to true, if draft version is to be created for a brand new integration. False, if the request is for an existing integration. For backward compatibility reasons, even if this flag is set to `false` and no existing integration is found, a new draft integration will still be created."]
                            pub fn new_integration(mut self, value: bool) -> Self {
                                self.new_integration = Some(value);
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                crate::Error,
                            > {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                crate::Error,
                            > {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/versions");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("newIntegration", &self.new_integration)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::delete()](struct.VersionsActions.html#method.delete)"]
                        #[derive(Debug, Clone)]
                        pub struct DeleteRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            name: String,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> DeleteRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                            {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                            {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::download()](struct.VersionsActions.html#method.download)"]
                        #[derive(Debug, Clone)]
                        pub struct DownloadRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , name : String , file_format : :: std :: option :: Option < crate :: resources :: projects :: locations :: products :: integrations :: versions :: params :: DownloadFileFormat > , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                        impl<'a> DownloadRequestBuilder<'a> {
                            #[doc = "File format for download request."]
                            pub fn file_format(
                                mut self,
                                value : crate :: resources :: projects :: locations :: products :: integrations :: versions :: params :: DownloadFileFormat,
                            ) -> Self {
                                self.file_format = Some(value);
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaDownloadIntegrationVersionResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaDownloadIntegrationVersionResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str(":download");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("fileFormat", &self.file_format)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::get()](struct.VersionsActions.html#method.get)"]
                        #[derive(Debug, Clone)]
                        pub struct GetRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            name: String,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> GetRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                crate::Error,
                            > {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                crate::Error,
                            > {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::list()](struct.VersionsActions.html#method.list)"]
                        #[derive(Debug, Clone)]
                        pub struct ListRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            parent: String,
                            field_mask: ::std::option::Option<String>,
                            filter: ::std::option::Option<String>,
                            order_by: ::std::option::Option<String>,
                            page_size: ::std::option::Option<i32>,
                            page_token: ::std::option::Option<String>,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> ListRequestBuilder<'a> {
                            #[doc = "The field mask which specifies the particular data to be returned."]
                            pub fn field_mask(mut self, value: impl Into<String>) -> Self {
                                self.field_mask = Some(value.into());
                                self
                            }
                            #[doc = "Filter on fields of IntegrationVersion. Fields can be compared with literal values by use of â€œ:â€ (containment), â€œ=â€ (equality), â€œ\\>â€ (greater), â€œ\\<â€ (less than), >=â€œ (greater than or equal to), â€œ\\<=â€ (less than or equal to), and â€œ!=â€ (inequality) operators. Negation, conjunction, and disjunction are written using NOT, AND, and OR keywords. For example, organization_id=\"1\" AND state=ACTIVE AND description:â€œtestâ€. Filtering cannot be performed on repeated fields like `task_config`."]
                            pub fn filter(mut self, value: impl Into<String>) -> Self {
                                self.filter = Some(value.into());
                                self
                            }
                            #[doc = "The results would be returned in order you specified here. Currently supported sort keys are: Descending sort order for â€œlast_modified_timeâ€, â€œcreated_timeâ€, â€œsnapshot_numberâ€ Ascending sort order for â€œnameâ€."]
                            pub fn order_by(mut self, value: impl Into<String>) -> Self {
                                self.order_by = Some(value.into());
                                self
                            }
                            #[doc = "The maximum number of versions to return. The service may return fewer than this value. If unspecified, at most 50 versions will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000."]
                            pub fn page_size(mut self, value: i32) -> Self {
                                self.page_size = Some(value);
                                self
                            }
                            #[doc = "A page token, received from a previous `ListIntegrationVersions` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListIntegrationVersions` must match the call that provided the page token."]
                            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                                self.page_token = Some(value.into());
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = "\nExecute the request and yield each item in the `integrationVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                            pub fn stream_integration_versions<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_integration_versions_with_fields(fields)
                            }
                            #[doc = "\nExecute the request and yield each item in the `integrationVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]                            pub fn stream_integration_versions_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersion , crate :: Error >> + 'a{
                                self.stream_integration_versions_with_fields(None::<String>)
                            }
                            #[doc = "\nExecute the request and yield each item in the `integrationVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]                            pub fn stream_integration_versions_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationVersion , crate :: Error >> + 'a{
                                self.stream_integration_versions_with_fields(Some("*"))
                            }
                            #[doc = "\nExecute the request and yield each item in the `integrationVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                            pub fn stream_integration_versions_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned + 'a,
                                F: AsRef<str>,
                            {
                                #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                                struct Page<T> {
                                    #[serde(rename = "nextPageToken")]
                                    pub next_page_token: ::std::option::Option<String>,
                                    #[serde(rename = "integrationVersions")]
                                    pub items: Vec<T>,
                                }
                                impl<T> crate::GetNextPageToken<String> for Page<T> {
                                    fn next_page_token(&self) -> ::std::option::Option<String> {
                                        self.next_page_token.to_owned()
                                    }
                                }
                                impl<T> crate::stream::IntoPageItems for Page<T> {
                                    type Items = Vec<T>;
                                    fn into_page_items(self) -> Self::Items {
                                        self.items
                                    }
                                }
                                self.fields = Some({
                                    let mut selector =
                                        concat!("nextPageToken,", "integrationVersions").to_owned();
                                    let items_fields =
                                        fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                    if !items_fields.is_empty() {
                                        selector.push_str("(");
                                        selector.push_str(items_fields);
                                        selector.push_str(")");
                                    }
                                    selector
                                });
                                crate::stream::page_item_stream::<_, Page<T>>(self)
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                            pub fn stream<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_with_fields(fields)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the default set of fields from the server."]                            pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests all fields from the server."]                            pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                            #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            pub fn stream_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + 'a,
                                F: AsRef<str>,
                            {
                                let mut fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                                if !fields.is_empty() {
                                    match fields.chars().rev().nth(0) {
                                        Some(',') | None => {}
                                        _ => fields.push_str(","),
                                    }
                                    fields.push_str("nextPageToken");
                                    self.fields = Some(fields);
                                }
                                crate::stream::page_stream(self)
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationVersionsResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/versions");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("fieldMask", &self.field_mask)]);
                                req = req.query(&[("filter", &self.filter)]);
                                req = req.query(&[("orderBy", &self.order_by)]);
                                req = req.query(&[("pageSize", &self.page_size)]);
                                req = req.query(&[("pageToken", &self.page_token)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[async_trait::async_trait]
                        impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                            type PageToken = String;
                            fn set_page_token(&mut self, value: String) {
                                self.page_token = value.into();
                            }
                            async fn execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                            {
                                self._execute().await
                            }
                        }
                        #[doc = "Created via [VersionsActions::patch()](struct.VersionsActions.html#method.patch)"]
                        #[derive(Debug, Clone)]
                        pub struct PatchRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            request:
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                            name: String,
                            update_mask: ::std::option::Option<String>,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> PatchRequestBuilder<'a> {
                            #[doc = "Field mask specifying the fields in the above integration that have been modified and need to be updated."]
                            pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                                self.update_mask = Some(value.into());
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                crate::Error,
                            > {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaIntegrationVersion,
                                crate::Error,
                            > {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                                req = req.query(&[("updateMask", &self.update_mask)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::publish()](struct.VersionsActions.html#method.publish)"]
                        #[derive(Debug, Clone)]
                        pub struct PublishRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                        impl<'a> PublishRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaPublishIntegrationVersionResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str(":publish");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::takeover_edit_lock()](struct.VersionsActions.html#method.takeover_edit_lock)"]
                        #[derive(Debug, Clone)]
                        pub struct TakeoverEditLockRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaTakeoverEditLockRequest , integration_version : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                        impl<'a> TakeoverEditLockRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaTakeoverEditLockResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaTakeoverEditLockResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.integration_version;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str(":takeoverEditLock");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::unpublish()](struct.VersionsActions.html#method.unpublish)"]
                        #[derive(Debug, Clone)]
                        pub struct UnpublishRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaUnpublishIntegrationVersionRequest , name : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                        impl<'a> UnpublishRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                            {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                            {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str(":unpublish");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::upload()](struct.VersionsActions.html#method.upload)"]
                        #[derive(Debug, Clone)]
                        pub struct UploadRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionRequest , parent : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                        impl<'a> UploadRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaUploadIntegrationVersionResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/versions:upload");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                    }
                }
                pub mod integrationtemplates {
                    pub mod params {}
                    pub struct IntegrationtemplatesActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> IntegrationtemplatesActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Actions that can be performed on the versions resource"]                        pub fn versions (& self) -> crate :: resources :: projects :: locations :: products :: integrationtemplates :: versions :: VersionsActions{
                            crate :: resources :: projects :: locations :: products :: integrationtemplates :: versions :: VersionsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                        }
                    }
                    pub mod versions {
                        pub mod params {}
                        pub struct VersionsActions<'a> {
                            pub(crate) reqwest: &'a reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        }
                        impl<'a> VersionsActions<'a> {
                            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                                self.auth
                            }
                            #[doc = "Creates an IntegrationTemplateVersion."]
                            pub fn create(
                                &self,
                                request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion,
                                parent: impl Into<String>,
                            ) -> CreateRequestBuilder {
                                CreateRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                }
                            }
                            #[doc = "Returns an IntegrationTemplateVersion in the specified project."]
                            pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                                GetRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Returns the list of all IntegrationTemplateVersions in the specified project."]
                            pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                                ListRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                    filter: None,
                                    page_size: None,
                                    page_token: None,
                                }
                            }
                        }
                        #[doc = "Created via [VersionsActions::create()](struct.VersionsActions.html#method.create)"]
                        #[derive(Debug, Clone)]
                        pub struct CreateRequestBuilder < 'a > { pub (crate) reqwest : & 'a :: reqwest :: Client , pub (crate) auth : & 'a dyn :: google_api_auth :: GetAccessToken , request : crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion , parent : String , access_token : :: std :: option :: Option < String > , alt : :: std :: option :: Option < crate :: params :: Alt > , callback : :: std :: option :: Option < String > , fields : :: std :: option :: Option < String > , key : :: std :: option :: Option < String > , oauth_token : :: std :: option :: Option < String > , pretty_print : :: std :: option :: Option < bool > , quota_user : :: std :: option :: Option < String > , upload_protocol : :: std :: option :: Option < String > , upload_type : :: std :: option :: Option < String > , xgafv : :: std :: option :: Option < crate :: params :: Xgafv > , }
                        impl<'a> CreateRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/versions");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::get()](struct.VersionsActions.html#method.get)"]
                        #[derive(Debug, Clone)]
                        pub struct GetRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            name: String,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> GetRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [VersionsActions::list()](struct.VersionsActions.html#method.list)"]
                        #[derive(Debug, Clone)]
                        pub struct ListRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            parent: String,
                            filter: ::std::option::Option<String>,
                            page_size: ::std::option::Option<i32>,
                            page_token: ::std::option::Option<String>,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> ListRequestBuilder<'a> {
                            #[doc = "Filter syntax: defined in the EBNF grammar."]
                            pub fn filter(mut self, value: impl Into<String>) -> Self {
                                self.filter = Some(value.into());
                                self
                            }
                            #[doc = "The maximum number of IntegrationTemplateVersions to return. The service may return fewer than this value. If unspecified, at most 50 versions will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000."]
                            pub fn page_size(mut self, value: i32) -> Self {
                                self.page_size = Some(value);
                                self
                            }
                            #[doc = "A page token, received from a previous `ListIntegrationTemplateVersions` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListIntegrationTemplateVersions` must match the call that provided the page token."]
                            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                                self.page_token = Some(value.into());
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = "\nExecute the request and yield each item in the `integrationTemplateVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                            pub fn stream_integration_template_versions<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_integration_template_versions_with_fields(fields)
                            }
                            #[doc = "\nExecute the request and yield each item in the `integrationTemplateVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]                            pub fn stream_integration_template_versions_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion , crate :: Error >> + 'a{
                                self.stream_integration_template_versions_with_fields(
                                    None::<String>,
                                )
                            }
                            #[doc = "\nExecute the request and yield each item in the `integrationTemplateVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]                            pub fn stream_integration_template_versions_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaIntegrationTemplateVersion , crate :: Error >> + 'a{
                                self.stream_integration_template_versions_with_fields(Some("*"))
                            }
                            #[doc = "\nExecute the request and yield each item in the `integrationTemplateVersions` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                            pub fn stream_integration_template_versions_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned + 'a,
                                F: AsRef<str>,
                            {
                                #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                                struct Page<T> {
                                    #[serde(rename = "nextPageToken")]
                                    pub next_page_token: ::std::option::Option<String>,
                                    #[serde(rename = "integrationTemplateVersions")]
                                    pub items: Vec<T>,
                                }
                                impl<T> crate::GetNextPageToken<String> for Page<T> {
                                    fn next_page_token(&self) -> ::std::option::Option<String> {
                                        self.next_page_token.to_owned()
                                    }
                                }
                                impl<T> crate::stream::IntoPageItems for Page<T> {
                                    type Items = Vec<T>;
                                    fn into_page_items(self) -> Self::Items {
                                        self.items
                                    }
                                }
                                self.fields = Some({
                                    let mut selector =
                                        concat!("nextPageToken,", "integrationTemplateVersions")
                                            .to_owned();
                                    let items_fields =
                                        fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                    if !items_fields.is_empty() {
                                        selector.push_str("(");
                                        selector.push_str(items_fields);
                                        selector.push_str(")");
                                    }
                                    selector
                                });
                                crate::stream::page_item_stream::<_, Page<T>>(self)
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                            pub fn stream<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_with_fields(fields)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the default set of fields from the server."]                            pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationTemplateVersionsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests all fields from the server."]                            pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationTemplateVersionsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                            #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            pub fn stream_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + 'a,
                                F: AsRef<str>,
                            {
                                let mut fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                                if !fields.is_empty() {
                                    match fields.chars().rev().nth(0) {
                                        Some(',') | None => {}
                                        _ => fields.push_str(","),
                                    }
                                    fields.push_str("nextPageToken");
                                    self.fields = Some(fields);
                                }
                                crate::stream::page_stream(self)
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationTemplateVersionsResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListIntegrationTemplateVersionsResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/versions");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("filter", &self.filter)]);
                                req = req.query(&[("pageSize", &self.page_size)]);
                                req = req.query(&[("pageToken", &self.page_token)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[async_trait::async_trait]
                        impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                            type PageToken = String;
                            fn set_page_token(&mut self, value: String) {
                                self.page_token = value.into();
                            }
                            async fn execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                            {
                                self._execute().await
                            }
                        }
                    }
                }
                pub mod sfdc_instances {
                    pub mod params {}
                    pub struct SfdcInstancesActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> SfdcInstancesActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Creates an sfdc instance record. Store the sfdc instance in Spanner. Returns the sfdc instance."]
                        pub fn create(
                            &self,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            parent: impl Into<String>,
                        ) -> CreateRequestBuilder {
                            CreateRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                            }
                        }
                        #[doc = "Deletes an sfdc instance."]
                        pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                            DeleteRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Gets an sfdc instance. If the instance doesnâ€™t exist, Code.NOT_FOUND exception will be thrown."]
                        pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                            GetRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Lists all sfdc instances that match the filter. Restrict to sfdc instances belonging to the current client only."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                page_size: None,
                                page_token: None,
                                read_mask: None,
                            }
                        }
                        #[doc = "Updates an sfdc instance. Updates the sfdc instance in spanner. Returns the sfdc instance."]
                        pub fn patch(
                            &self,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            name: impl Into<String>,
                        ) -> PatchRequestBuilder {
                            PatchRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                                update_mask: None,
                            }
                        }
                        #[doc = "Actions that can be performed on the sfdc_channels resource"]                        pub fn sfdc_channels (& self) -> crate :: resources :: projects :: locations :: products :: sfdc_instances :: sfdc_channels :: SfdcChannelsActions{
                            crate :: resources :: projects :: locations :: products :: sfdc_instances :: sfdc_channels :: SfdcChannelsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                        }
                    }
                    #[doc = "Created via [SfdcInstancesActions::create()](struct.SfdcInstancesActions.html#method.create)"]
                    #[derive(Debug, Clone)]
                    pub struct CreateRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        parent: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> CreateRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/sfdcInstances");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [SfdcInstancesActions::delete()](struct.SfdcInstancesActions.html#method.delete)"]
                    #[derive(Debug, Clone)]
                    pub struct DeleteRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> DeleteRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [SfdcInstancesActions::get()](struct.SfdcInstancesActions.html#method.get)"]
                    #[derive(Debug, Clone)]
                    pub struct GetRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> GetRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [SfdcInstancesActions::list()](struct.SfdcInstancesActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        read_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Filtering as supported in https://developers.google.com/authorized-buyers/apis/guides/v2/list-filters."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "The size of entries in the response. If unspecified, defaults to 100."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "The token returned in the previous response."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "The mask which specifies fields that need to be returned in the SfdcInstanceâ€™s response."]
                        pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                            self.read_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `sfdcInstances` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_sfdc_instances<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_sfdc_instances_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `sfdcInstances` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_sfdc_instances_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_sfdc_instances_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `sfdcInstances` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_sfdc_instances_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_sfdc_instances_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `sfdcInstances` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_sfdc_instances_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "sfdcInstances")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "sfdcInstances").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/sfdcInstances");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("readMask", &self.read_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                    #[doc = "Created via [SfdcInstancesActions::patch()](struct.SfdcInstancesActions.html#method.patch)"]
                    #[derive(Debug, Clone)]
                    pub struct PatchRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        name: String,
                        update_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> PatchRequestBuilder<'a> {
                        #[doc = "Field mask specifying the fields in the above SfdcInstance that have been modified and need to be updated."]
                        pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                            self.update_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                            req = req.query(&[("updateMask", &self.update_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    pub mod sfdc_channels {
                        pub mod params {}
                        pub struct SfdcChannelsActions<'a> {
                            pub(crate) reqwest: &'a reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        }
                        impl<'a> SfdcChannelsActions<'a> {
                            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                                self.auth
                            }
                            #[doc = "Creates an sfdc channel record. Store the sfdc channel in Spanner. Returns the sfdc channel."]
                            pub fn create(
                                &self,
                                request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                parent: impl Into<String>,
                            ) -> CreateRequestBuilder {
                                CreateRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                }
                            }
                            #[doc = "Deletes an sfdc channel."]
                            pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                                DeleteRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Gets an sfdc channel. If the channel doesnâ€™t exist, Code.NOT_FOUND exception will be thrown."]
                            pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                                GetRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                }
                            }
                            #[doc = "Lists all sfdc channels that match the filter. Restrict to sfdc channels belonging to the current client only."]
                            pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                                ListRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    parent: parent.into(),
                                    filter: None,
                                    page_size: None,
                                    page_token: None,
                                    read_mask: None,
                                }
                            }
                            #[doc = "Updates an sfdc channel. Updates the sfdc channel in spanner. Returns the sfdc channel."]
                            pub fn patch(
                                &self,
                                request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                name: impl Into<String>,
                            ) -> PatchRequestBuilder {
                                PatchRequestBuilder {
                                    reqwest: &self.reqwest,
                                    auth: self.auth_ref(),
                                    request,
                                    access_token: None,
                                    alt: None,
                                    callback: None,
                                    fields: None,
                                    key: None,
                                    oauth_token: None,
                                    pretty_print: None,
                                    quota_user: None,
                                    upload_protocol: None,
                                    upload_type: None,
                                    xgafv: None,
                                    name: name.into(),
                                    update_mask: None,
                                }
                            }
                        }
                        #[doc = "Created via [SfdcChannelsActions::create()](struct.SfdcChannelsActions.html#method.create)"]
                        #[derive(Debug, Clone)]
                        pub struct CreateRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            parent: String,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> CreateRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                crate::Error,
                            > {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                crate::Error,
                            > {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/sfdcChannels");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [SfdcChannelsActions::delete()](struct.SfdcChannelsActions.html#method.delete)"]
                        #[derive(Debug, Clone)]
                        pub struct DeleteRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            name: String,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> DeleteRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                            {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                            {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [SfdcChannelsActions::get()](struct.SfdcChannelsActions.html#method.get)"]
                        #[derive(Debug, Clone)]
                        pub struct GetRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            name: String,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> GetRequestBuilder<'a> {
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                crate::Error,
                            > {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                crate::Error,
                            > {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[doc = "Created via [SfdcChannelsActions::list()](struct.SfdcChannelsActions.html#method.list)"]
                        #[derive(Debug, Clone)]
                        pub struct ListRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            parent: String,
                            filter: ::std::option::Option<String>,
                            page_size: ::std::option::Option<i32>,
                            page_token: ::std::option::Option<String>,
                            read_mask: ::std::option::Option<String>,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> ListRequestBuilder<'a> {
                            #[doc = "Filtering as supported in https://developers.google.com/authorized-buyers/apis/guides/v2/list-filters."]
                            pub fn filter(mut self, value: impl Into<String>) -> Self {
                                self.filter = Some(value.into());
                                self
                            }
                            #[doc = "The size of entries in the response. If unspecified, defaults to 100."]
                            pub fn page_size(mut self, value: i32) -> Self {
                                self.page_size = Some(value);
                                self
                            }
                            #[doc = "The token returned in the previous response."]
                            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                                self.page_token = Some(value.into());
                                self
                            }
                            #[doc = "The mask which specifies fields that need to be returned in the SfdcChannelâ€™s response."]
                            pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                                self.read_mask = Some(value.into());
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = "\nExecute the request and yield each item in the `sfdcChannels` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                            pub fn stream_sfdc_channels<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_sfdc_channels_with_fields(fields)
                            }
                            #[doc = "\nExecute the request and yield each item in the `sfdcChannels` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                            pub fn stream_sfdc_channels_with_default_fields(
                                self,
                            ) -> impl ::futures::Stream<
                                Item = Result<
                                    crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                    crate::Error,
                                >,
                            > + 'a {
                                self.stream_sfdc_channels_with_fields(None::<String>)
                            }
                            #[doc = "\nExecute the request and yield each item in the `sfdcChannels` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                            pub fn stream_sfdc_channels_with_all_fields(
                                self,
                            ) -> impl ::futures::Stream<
                                Item = Result<
                                    crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                    crate::Error,
                                >,
                            > + 'a {
                                self.stream_sfdc_channels_with_fields(Some("*"))
                            }
                            #[doc = "\nExecute the request and yield each item in the `sfdcChannels` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                            pub fn stream_sfdc_channels_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: ::serde::de::DeserializeOwned + 'a,
                                F: AsRef<str>,
                            {
                                #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                                struct Page<T> {
                                    #[serde(rename = "nextPageToken")]
                                    pub next_page_token: ::std::option::Option<String>,
                                    #[serde(rename = "sfdcChannels")]
                                    pub items: Vec<T>,
                                }
                                impl<T> crate::GetNextPageToken<String> for Page<T> {
                                    fn next_page_token(&self) -> ::std::option::Option<String> {
                                        self.next_page_token.to_owned()
                                    }
                                }
                                impl<T> crate::stream::IntoPageItems for Page<T> {
                                    type Items = Vec<T>;
                                    fn into_page_items(self) -> Self::Items {
                                        self.items
                                    }
                                }
                                self.fields = Some({
                                    let mut selector =
                                        concat!("nextPageToken,", "sfdcChannels").to_owned();
                                    let items_fields =
                                        fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                    if !items_fields.is_empty() {
                                        selector.push_str("(");
                                        selector.push_str(items_fields);
                                        selector.push_str(")");
                                    }
                                    selector
                                });
                                crate::stream::page_item_stream::<_, Page<T>>(self)
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                            pub fn stream<T>(
                                self,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector
                                    + 'a,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.stream_with_fields(fields)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests the default set of fields from the server."]                            pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(None::<&str>)
                            }
                            #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                            #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                            #[doc = r" repeated until no page token is returned."]
                            #[doc = r""]
                            #[doc = r" Requests all fields from the server."]                            pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse , crate :: Error >> + 'a{
                                self.stream_with_fields(Some("*"))
                            }
                            #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                            #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                            #[doc = r" token is returned."]
                            #[doc = r""]
                            #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                            #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                            #[doc = r""]
                            #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                            pub fn stream_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                            where
                                T: crate::GetNextPageToken<String>
                                    + ::serde::de::DeserializeOwned
                                    + 'a,
                                F: AsRef<str>,
                            {
                                let mut fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                                if !fields.is_empty() {
                                    match fields.chars().rev().nth(0) {
                                        Some(',') | None => {}
                                        _ => fields.push_str(","),
                                    }
                                    fields.push_str("nextPageToken");
                                    self.fields = Some(fields);
                                }
                                crate::stream::page_stream(self)
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]                            pub async fn execute_with_default_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse , crate :: Error >{
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]                            pub async fn execute_with_all_fields (self) -> Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse , crate :: Error >{
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.parent;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output.push_str("/sfdcChannels");
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                                req = req.query(&[("filter", &self.filter)]);
                                req = req.query(&[("pageSize", &self.page_size)]);
                                req = req.query(&[("pageToken", &self.page_token)]);
                                req = req.query(&[("readMask", &self.read_mask)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                        #[async_trait::async_trait]
                        impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                            type PageToken = String;
                            fn set_page_token(&mut self, value: String) {
                                self.page_token = value.into();
                            }
                            async fn execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                            {
                                self._execute().await
                            }
                        }
                        #[doc = "Created via [SfdcChannelsActions::patch()](struct.SfdcChannelsActions.html#method.patch)"]
                        #[derive(Debug, Clone)]
                        pub struct PatchRequestBuilder<'a> {
                            pub(crate) reqwest: &'a ::reqwest::Client,
                            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            name: String,
                            update_mask: ::std::option::Option<String>,
                            access_token: ::std::option::Option<String>,
                            alt: ::std::option::Option<crate::params::Alt>,
                            callback: ::std::option::Option<String>,
                            fields: ::std::option::Option<String>,
                            key: ::std::option::Option<String>,
                            oauth_token: ::std::option::Option<String>,
                            pretty_print: ::std::option::Option<bool>,
                            quota_user: ::std::option::Option<String>,
                            upload_protocol: ::std::option::Option<String>,
                            upload_type: ::std::option::Option<String>,
                            xgafv: ::std::option::Option<crate::params::Xgafv>,
                        }
                        impl<'a> PatchRequestBuilder<'a> {
                            #[doc = "Field mask specifying the fields in the above SfdcChannel that have been modified and need to be updated."]
                            pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                                self.update_mask = Some(value.into());
                                self
                            }
                            #[doc = "OAuth access token."]
                            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                                self.access_token = Some(value.into());
                                self
                            }
                            #[doc = "JSONP"]
                            pub fn callback(mut self, value: impl Into<String>) -> Self {
                                self.callback = Some(value.into());
                                self
                            }
                            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                            pub fn key(mut self, value: impl Into<String>) -> Self {
                                self.key = Some(value.into());
                                self
                            }
                            #[doc = "OAuth 2.0 token for the current user."]
                            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                                self.oauth_token = Some(value.into());
                                self
                            }
                            #[doc = "Returns response with indentations and line breaks."]
                            pub fn pretty_print(mut self, value: bool) -> Self {
                                self.pretty_print = Some(value);
                                self
                            }
                            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                                self.quota_user = Some(value.into());
                                self
                            }
                            #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                                self.upload_protocol = Some(value.into());
                                self
                            }
                            #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                                self.upload_type = Some(value.into());
                                self
                            }
                            #[doc = "V1 error format."]
                            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                                self.xgafv = Some(value);
                                self
                            }
                            #[doc = r" Execute the given operation. The fields requested are"]
                            #[doc = r" determined by the FieldSelector attribute of the return type."]
                            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                            #[doc = r" are not generic over the return type and deserialize the"]
                            #[doc = r" response into an auto-generated struct will all possible"]
                            #[doc = r" fields."]
                            pub async fn execute<T>(self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned
                                    + ::google_field_selector::FieldSelector,
                            {
                                let fields = ::google_field_selector::to_string::<T>();
                                let fields: ::std::option::Option<String> = if fields.is_empty() {
                                    None
                                } else {
                                    Some(fields)
                                };
                                self.execute_with_fields(fields).await
                            }
                            #[doc = r" Execute the given operation. This will not provide any"]
                            #[doc = r" `fields` selector indicating that the server will determine"]
                            #[doc = r" the fields returned. This typically includes the most common"]
                            #[doc = r" fields, but it will not include every possible attribute of"]
                            #[doc = r" the response resource."]
                            pub async fn execute_with_default_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                crate::Error,
                            > {
                                self.execute_with_fields(None::<&str>).await
                            }
                            #[doc = r" Execute the given operation. This will provide a `fields`"]
                            #[doc = r" selector of `*`. This will include every attribute of the"]
                            #[doc = r" response resource and should be limited to use during"]
                            #[doc = r" development or debugging."]
                            pub async fn execute_with_all_fields(
                                self,
                            ) -> Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                crate::Error,
                            > {
                                self.execute_with_fields(Some("*")).await
                            }
                            #[doc = r" Execute the given operation. This will use the `fields`"]
                            #[doc = r" selector provided and will deserialize the response into"]
                            #[doc = r" whatever return value is provided."]
                            pub async fn execute_with_fields<T, F>(
                                mut self,
                                fields: ::std::option::Option<F>,
                            ) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                                F: Into<String>,
                            {
                                self.fields = fields.map(Into::into);
                                self._execute().await
                            }
                            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                            where
                                T: ::serde::de::DeserializeOwned,
                            {
                                let req = self._request(&self._path()).await?;
                                let req = req.json(&self.request);
                                Ok(req.send().await?.error_for_status()?.json().await?)
                            }
                            fn _path(&self) -> String {
                                let mut output = "https://integrations.googleapis.com/".to_owned();
                                output.push_str("v1alpha/");
                                {
                                    let var_as_str = &self.name;
                                    output.extend(::percent_encoding::utf8_percent_encode(
                                        &var_as_str,
                                        crate::RESERVED,
                                    ));
                                }
                                output
                            }
                            async fn _request(
                                &self,
                                path: &str,
                            ) -> Result<::reqwest::RequestBuilder, crate::Error>
                            {
                                let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                                req = req.query(&[("updateMask", &self.update_mask)]);
                                req = req.query(&[("access_token", &self.access_token)]);
                                req = req.query(&[("alt", &self.alt)]);
                                req = req.query(&[("callback", &self.callback)]);
                                req = req.query(&[("fields", &self.fields)]);
                                req = req.query(&[("key", &self.key)]);
                                req = req.query(&[("oauth_token", &self.oauth_token)]);
                                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                                req = req.query(&[("quotaUser", &self.quota_user)]);
                                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                                req = req.query(&[("uploadType", &self.upload_type)]);
                                req = req.query(&[("$.xgafv", &self.xgafv)]);
                                let access_token = self
                                    .auth
                                    .access_token()
                                    .await
                                    .map_err(|err| crate::Error::OAuth2(err))?;
                                req = req.bearer_auth(access_token);
                                Ok(req)
                            }
                        }
                    }
                }
            }
            pub mod sfdc_instances {
                pub mod params {}
                pub struct SfdcInstancesActions<'a> {
                    pub(crate) reqwest: &'a reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                }
                impl<'a> SfdcInstancesActions<'a> {
                    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                        self.auth
                    }
                    #[doc = "Creates an sfdc instance record. Store the sfdc instance in Spanner. Returns the sfdc instance."]
                    pub fn create(
                        &self,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        parent: impl Into<String>,
                    ) -> CreateRequestBuilder {
                        CreateRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                        }
                    }
                    #[doc = "Deletes an sfdc instance."]
                    pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                        DeleteRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Gets an sfdc instance. If the instance doesnâ€™t exist, Code.NOT_FOUND exception will be thrown."]
                    pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                        GetRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                        }
                    }
                    #[doc = "Lists all sfdc instances that match the filter. Restrict to sfdc instances belonging to the current client only."]
                    pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                        ListRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            parent: parent.into(),
                            filter: None,
                            page_size: None,
                            page_token: None,
                            read_mask: None,
                        }
                    }
                    #[doc = "Updates an sfdc instance. Updates the sfdc instance in spanner. Returns the sfdc instance."]
                    pub fn patch(
                        &self,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        name: impl Into<String>,
                    ) -> PatchRequestBuilder {
                        PatchRequestBuilder {
                            reqwest: &self.reqwest,
                            auth: self.auth_ref(),
                            request,
                            access_token: None,
                            alt: None,
                            callback: None,
                            fields: None,
                            key: None,
                            oauth_token: None,
                            pretty_print: None,
                            quota_user: None,
                            upload_protocol: None,
                            upload_type: None,
                            xgafv: None,
                            name: name.into(),
                            update_mask: None,
                        }
                    }
                    #[doc = "Actions that can be performed on the sfdc_channels resource"]                    pub fn sfdc_channels (& self) -> crate :: resources :: projects :: locations :: sfdc_instances :: sfdc_channels :: SfdcChannelsActions{
                        crate :: resources :: projects :: locations :: sfdc_instances :: sfdc_channels :: SfdcChannelsActions { reqwest : & self . reqwest , auth : self . auth_ref () , }
                    }
                }
                #[doc = "Created via [SfdcInstancesActions::create()](struct.SfdcInstancesActions.html#method.create)"]
                #[derive(Debug, Clone)]
                pub struct CreateRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                    parent: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> CreateRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/sfdcInstances");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [SfdcInstancesActions::delete()](struct.SfdcInstancesActions.html#method.delete)"]
                #[derive(Debug, Clone)]
                pub struct DeleteRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> DeleteRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                    {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                    {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [SfdcInstancesActions::get()](struct.SfdcInstancesActions.html#method.get)"]
                #[derive(Debug, Clone)]
                pub struct GetRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    name: String,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> GetRequestBuilder<'a> {
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[doc = "Created via [SfdcInstancesActions::list()](struct.SfdcInstancesActions.html#method.list)"]
                #[derive(Debug, Clone)]
                pub struct ListRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    parent: String,
                    filter: ::std::option::Option<String>,
                    page_size: ::std::option::Option<i32>,
                    page_token: ::std::option::Option<String>,
                    read_mask: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> ListRequestBuilder<'a> {
                    #[doc = "Filtering as supported in https://developers.google.com/authorized-buyers/apis/guides/v2/list-filters."]
                    pub fn filter(mut self, value: impl Into<String>) -> Self {
                        self.filter = Some(value.into());
                        self
                    }
                    #[doc = "The size of entries in the response. If unspecified, defaults to 100."]
                    pub fn page_size(mut self, value: i32) -> Self {
                        self.page_size = Some(value);
                        self
                    }
                    #[doc = "The token returned in the previous response."]
                    pub fn page_token(mut self, value: impl Into<String>) -> Self {
                        self.page_token = Some(value.into());
                        self
                    }
                    #[doc = "The mask which specifies fields that need to be returned in the SfdcInstanceâ€™s response."]
                    pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                        self.read_mask = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = "\nExecute the request and yield each item in the `sfdcInstances` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                    pub fn stream_sfdc_instances<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_sfdc_instances_with_fields(fields)
                    }
                    #[doc = "\nExecute the request and yield each item in the `sfdcInstances` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                    pub fn stream_sfdc_instances_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_sfdc_instances_with_fields(None::<String>)
                    }
                    #[doc = "\nExecute the request and yield each item in the `sfdcInstances` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                    pub fn stream_sfdc_instances_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_sfdc_instances_with_fields(Some("*"))
                    }
                    #[doc = "\nExecute the request and yield each item in the `sfdcInstances` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                    pub fn stream_sfdc_instances_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                        struct Page<T> {
                            #[serde(rename = "nextPageToken")]
                            pub next_page_token: ::std::option::Option<String>,
                            #[serde(rename = "sfdcInstances")]
                            pub items: Vec<T>,
                        }
                        impl<T> crate::GetNextPageToken<String> for Page<T> {
                            fn next_page_token(&self) -> ::std::option::Option<String> {
                                self.next_page_token.to_owned()
                            }
                        }
                        impl<T> crate::stream::IntoPageItems for Page<T> {
                            type Items = Vec<T>;
                            fn into_page_items(self) -> Self::Items {
                                self.items
                            }
                        }
                        self.fields = Some({
                            let mut selector =
                                concat!("nextPageToken,", "sfdcInstances").to_owned();
                            let items_fields = fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                            if !items_fields.is_empty() {
                                selector.push_str("(");
                                selector.push_str(items_fields);
                                selector.push_str(")");
                            }
                            selector
                        });
                        crate::stream::page_item_stream::<_, Page<T>>(self)
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                    pub fn stream<T>(
                        self,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String>
                            + ::serde::de::DeserializeOwned
                            + ::google_field_selector::FieldSelector
                            + 'a,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.stream_with_fields(fields)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests the default set of fields from the server."]
                    pub fn stream_with_default_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(None::<&str>)
                    }
                    #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                    #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                    #[doc = r" repeated until no page token is returned."]
                    #[doc = r""]
                    #[doc = r" Requests all fields from the server."]
                    pub fn stream_with_all_fields(
                        self,
                    ) -> impl ::futures::Stream<
                        Item = Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse,
                            crate::Error,
                        >,
                    > + 'a {
                        self.stream_with_fields(Some("*"))
                    }
                    #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                    #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                    #[doc = r" token is returned."]
                    #[doc = r""]
                    #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                    #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                    #[doc = r""]
                    #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                    pub fn stream_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                        F: AsRef<str>,
                    {
                        let mut fields =
                            fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                        if !fields.is_empty() {
                            match fields.chars().rev().nth(0) {
                                Some(',') | None => {}
                                _ => fields.push_str(","),
                            }
                            fields.push_str("nextPageToken");
                            self.fields = Some(fields);
                        }
                        crate::stream::page_stream(self)
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaListSfdcInstancesResponse,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.parent;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output.push_str("/sfdcInstances");
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                        req = req.query(&[("filter", &self.filter)]);
                        req = req.query(&[("pageSize", &self.page_size)]);
                        req = req.query(&[("pageToken", &self.page_token)]);
                        req = req.query(&[("readMask", &self.read_mask)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                #[async_trait::async_trait]
                impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                    type PageToken = String;
                    fn set_page_token(&mut self, value: String) {
                        self.page_token = value.into();
                    }
                    async fn execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                    {
                        self._execute().await
                    }
                }
                #[doc = "Created via [SfdcInstancesActions::patch()](struct.SfdcInstancesActions.html#method.patch)"]
                #[derive(Debug, Clone)]
                pub struct PatchRequestBuilder<'a> {
                    pub(crate) reqwest: &'a ::reqwest::Client,
                    pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                    name: String,
                    update_mask: ::std::option::Option<String>,
                    access_token: ::std::option::Option<String>,
                    alt: ::std::option::Option<crate::params::Alt>,
                    callback: ::std::option::Option<String>,
                    fields: ::std::option::Option<String>,
                    key: ::std::option::Option<String>,
                    oauth_token: ::std::option::Option<String>,
                    pretty_print: ::std::option::Option<bool>,
                    quota_user: ::std::option::Option<String>,
                    upload_protocol: ::std::option::Option<String>,
                    upload_type: ::std::option::Option<String>,
                    xgafv: ::std::option::Option<crate::params::Xgafv>,
                }
                impl<'a> PatchRequestBuilder<'a> {
                    #[doc = "Field mask specifying the fields in the above SfdcInstance that have been modified and need to be updated."]
                    pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                        self.update_mask = Some(value.into());
                        self
                    }
                    #[doc = "OAuth access token."]
                    pub fn access_token(mut self, value: impl Into<String>) -> Self {
                        self.access_token = Some(value.into());
                        self
                    }
                    #[doc = "JSONP"]
                    pub fn callback(mut self, value: impl Into<String>) -> Self {
                        self.callback = Some(value.into());
                        self
                    }
                    #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                    pub fn key(mut self, value: impl Into<String>) -> Self {
                        self.key = Some(value.into());
                        self
                    }
                    #[doc = "OAuth 2.0 token for the current user."]
                    pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                        self.oauth_token = Some(value.into());
                        self
                    }
                    #[doc = "Returns response with indentations and line breaks."]
                    pub fn pretty_print(mut self, value: bool) -> Self {
                        self.pretty_print = Some(value);
                        self
                    }
                    #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                    pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                        self.quota_user = Some(value.into());
                        self
                    }
                    #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                    pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                        self.upload_protocol = Some(value.into());
                        self
                    }
                    #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                    pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                        self.upload_type = Some(value.into());
                        self
                    }
                    #[doc = "V1 error format."]
                    pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                        self.xgafv = Some(value);
                        self
                    }
                    #[doc = r" Execute the given operation. The fields requested are"]
                    #[doc = r" determined by the FieldSelector attribute of the return type."]
                    #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                    #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                    #[doc = r" are not generic over the return type and deserialize the"]
                    #[doc = r" response into an auto-generated struct will all possible"]
                    #[doc = r" fields."]
                    pub async fn execute<T>(self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                    {
                        let fields = ::google_field_selector::to_string::<T>();
                        let fields: ::std::option::Option<String> = if fields.is_empty() {
                            None
                        } else {
                            Some(fields)
                        };
                        self.execute_with_fields(fields).await
                    }
                    #[doc = r" Execute the given operation. This will not provide any"]
                    #[doc = r" `fields` selector indicating that the server will determine"]
                    #[doc = r" the fields returned. This typically includes the most common"]
                    #[doc = r" fields, but it will not include every possible attribute of"]
                    #[doc = r" the response resource."]
                    pub async fn execute_with_default_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        crate::Error,
                    > {
                        self.execute_with_fields(None::<&str>).await
                    }
                    #[doc = r" Execute the given operation. This will provide a `fields`"]
                    #[doc = r" selector of `*`. This will include every attribute of the"]
                    #[doc = r" response resource and should be limited to use during"]
                    #[doc = r" development or debugging."]
                    pub async fn execute_with_all_fields(
                        self,
                    ) -> Result<
                        crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcInstance,
                        crate::Error,
                    > {
                        self.execute_with_fields(Some("*")).await
                    }
                    #[doc = r" Execute the given operation. This will use the `fields`"]
                    #[doc = r" selector provided and will deserialize the response into"]
                    #[doc = r" whatever return value is provided."]
                    pub async fn execute_with_fields<T, F>(
                        mut self,
                        fields: ::std::option::Option<F>,
                    ) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                        F: Into<String>,
                    {
                        self.fields = fields.map(Into::into);
                        self._execute().await
                    }
                    async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                    where
                        T: ::serde::de::DeserializeOwned,
                    {
                        let req = self._request(&self._path()).await?;
                        let req = req.json(&self.request);
                        Ok(req.send().await?.error_for_status()?.json().await?)
                    }
                    fn _path(&self) -> String {
                        let mut output = "https://integrations.googleapis.com/".to_owned();
                        output.push_str("v1alpha/");
                        {
                            let var_as_str = &self.name;
                            output.extend(::percent_encoding::utf8_percent_encode(
                                &var_as_str,
                                crate::RESERVED,
                            ));
                        }
                        output
                    }
                    async fn _request(
                        &self,
                        path: &str,
                    ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                        let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                        req = req.query(&[("updateMask", &self.update_mask)]);
                        req = req.query(&[("access_token", &self.access_token)]);
                        req = req.query(&[("alt", &self.alt)]);
                        req = req.query(&[("callback", &self.callback)]);
                        req = req.query(&[("fields", &self.fields)]);
                        req = req.query(&[("key", &self.key)]);
                        req = req.query(&[("oauth_token", &self.oauth_token)]);
                        req = req.query(&[("prettyPrint", &self.pretty_print)]);
                        req = req.query(&[("quotaUser", &self.quota_user)]);
                        req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                        req = req.query(&[("uploadType", &self.upload_type)]);
                        req = req.query(&[("$.xgafv", &self.xgafv)]);
                        let access_token = self
                            .auth
                            .access_token()
                            .await
                            .map_err(|err| crate::Error::OAuth2(err))?;
                        req = req.bearer_auth(access_token);
                        Ok(req)
                    }
                }
                pub mod sfdc_channels {
                    pub mod params {}
                    pub struct SfdcChannelsActions<'a> {
                        pub(crate) reqwest: &'a reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                    }
                    impl<'a> SfdcChannelsActions<'a> {
                        fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                            self.auth
                        }
                        #[doc = "Creates an sfdc channel record. Store the sfdc channel in Spanner. Returns the sfdc channel."]
                        pub fn create(
                            &self,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            parent: impl Into<String>,
                        ) -> CreateRequestBuilder {
                            CreateRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                            }
                        }
                        #[doc = "Deletes an sfdc channel."]
                        pub fn delete(&self, name: impl Into<String>) -> DeleteRequestBuilder {
                            DeleteRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Gets an sfdc channel. If the channel doesnâ€™t exist, Code.NOT_FOUND exception will be thrown."]
                        pub fn get(&self, name: impl Into<String>) -> GetRequestBuilder {
                            GetRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                            }
                        }
                        #[doc = "Lists all sfdc channels that match the filter. Restrict to sfdc channels belonging to the current client only."]
                        pub fn list(&self, parent: impl Into<String>) -> ListRequestBuilder {
                            ListRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                parent: parent.into(),
                                filter: None,
                                page_size: None,
                                page_token: None,
                                read_mask: None,
                            }
                        }
                        #[doc = "Updates an sfdc channel. Updates the sfdc channel in spanner. Returns the sfdc channel."]
                        pub fn patch(
                            &self,
                            request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            name: impl Into<String>,
                        ) -> PatchRequestBuilder {
                            PatchRequestBuilder {
                                reqwest: &self.reqwest,
                                auth: self.auth_ref(),
                                request,
                                access_token: None,
                                alt: None,
                                callback: None,
                                fields: None,
                                key: None,
                                oauth_token: None,
                                pretty_print: None,
                                quota_user: None,
                                upload_protocol: None,
                                upload_type: None,
                                xgafv: None,
                                name: name.into(),
                                update_mask: None,
                            }
                        }
                    }
                    #[doc = "Created via [SfdcChannelsActions::create()](struct.SfdcChannelsActions.html#method.create)"]
                    #[derive(Debug, Clone)]
                    pub struct CreateRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                        parent: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> CreateRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/sfdcChannels");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::POST, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [SfdcChannelsActions::delete()](struct.SfdcChannelsActions.html#method.delete)"]
                    #[derive(Debug, Clone)]
                    pub struct DeleteRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> DeleteRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<crate::schemas::GoogleProtobufEmpty, crate::Error>
                        {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::DELETE, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [SfdcChannelsActions::get()](struct.SfdcChannelsActions.html#method.get)"]
                    #[derive(Debug, Clone)]
                    pub struct GetRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        name: String,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> GetRequestBuilder<'a> {
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[doc = "Created via [SfdcChannelsActions::list()](struct.SfdcChannelsActions.html#method.list)"]
                    #[derive(Debug, Clone)]
                    pub struct ListRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        parent: String,
                        filter: ::std::option::Option<String>,
                        page_size: ::std::option::Option<i32>,
                        page_token: ::std::option::Option<String>,
                        read_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> ListRequestBuilder<'a> {
                        #[doc = "Filtering as supported in https://developers.google.com/authorized-buyers/apis/guides/v2/list-filters."]
                        pub fn filter(mut self, value: impl Into<String>) -> Self {
                            self.filter = Some(value.into());
                            self
                        }
                        #[doc = "The size of entries in the response. If unspecified, defaults to 100."]
                        pub fn page_size(mut self, value: i32) -> Self {
                            self.page_size = Some(value);
                            self
                        }
                        #[doc = "The token returned in the previous response."]
                        pub fn page_token(mut self, value: impl Into<String>) -> Self {
                            self.page_token = Some(value.into());
                            self
                        }
                        #[doc = "The mask which specifies fields that need to be returned in the SfdcChannelâ€™s response."]
                        pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                            self.read_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = "\nExecute the request and yield each item in the `sfdcChannels` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the field given by the [`FieldSelector`] implementation from the server.\n\n[`FieldSelector`]: ::google_field_selector::FieldSelector\n"]
                        pub fn stream_sfdc_channels<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_sfdc_channels_with_fields(fields)
                        }
                        #[doc = "\nExecute the request and yield each item in the `sfdcChannels` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests the default set of fields from the server.\n"]
                        pub fn stream_sfdc_channels_with_default_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_sfdc_channels_with_fields(None::<String>)
                        }
                        #[doc = "\nExecute the request and yield each item in the `sfdcChannels` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nRequests all fields from the server.\n"]
                        pub fn stream_sfdc_channels_with_all_fields(
                            self,
                        ) -> impl ::futures::Stream<
                            Item = Result<
                                crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                                crate::Error,
                            >,
                        > + 'a {
                            self.stream_sfdc_channels_with_fields(Some("*"))
                        }
                        #[doc = "\nExecute the request and yield each item in the `sfdcChannels` list. If the response contains a\n`nextPageToken`, the request is executed again with the new token. This process is\nrepeated until no page token is returned.\n\nOnly the given `fields` are requested from the server.\n"]
                        pub fn stream_sfdc_channels_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            #[derive(:: serde :: Deserialize, :: serde :: Serialize)]
                            struct Page<T> {
                                #[serde(rename = "nextPageToken")]
                                pub next_page_token: ::std::option::Option<String>,
                                #[serde(rename = "sfdcChannels")]
                                pub items: Vec<T>,
                            }
                            impl<T> crate::GetNextPageToken<String> for Page<T> {
                                fn next_page_token(&self) -> ::std::option::Option<String> {
                                    self.next_page_token.to_owned()
                                }
                            }
                            impl<T> crate::stream::IntoPageItems for Page<T> {
                                type Items = Vec<T>;
                                fn into_page_items(self) -> Self::Items {
                                    self.items
                                }
                            }
                            self.fields = Some({
                                let mut selector =
                                    concat!("nextPageToken,", "sfdcChannels").to_owned();
                                let items_fields =
                                    fields.as_ref().map(|x| x.as_ref()).unwrap_or("");
                                if !items_fields.is_empty() {
                                    selector.push_str("(");
                                    selector.push_str(items_fields);
                                    selector.push_str(")");
                                }
                                selector
                            });
                            crate::stream::page_item_stream::<_, Page<T>>(self)
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the field given by the [`FieldSelector`] implementation from the server."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        #[doc = r" [`FieldSelector`]: ::google_field_selector::FieldSelector"]
                        pub fn stream<T>(
                            self,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String>
                                + ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector
                                + 'a,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.stream_with_fields(fields)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests the default set of fields from the server."]                        pub fn stream_with_default_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(None::<&str>)
                        }
                        #[doc = r" Execute the request and yield the returned value. If the response contains a"]
                        #[doc = r" `nextPageToken`, the request is executed again with the new token. This process is"]
                        #[doc = r" repeated until no page token is returned."]
                        #[doc = r""]
                        #[doc = r" Requests all fields from the server."]                        pub fn stream_with_all_fields (self) -> impl :: futures :: Stream < Item = Result < crate :: schemas :: GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse , crate :: Error >> + 'a{
                            self.stream_with_fields(Some("*"))
                        }
                        #[doc = r" Execute the request and yield the returned value. If [`next_page_token`] returns a value,"]
                        #[doc = r" the request is executed again with the new token. This process is repeated until no page"]
                        #[doc = r" token is returned."]
                        #[doc = r""]
                        #[doc = r" Only the given `fields` are requested from the server. If the list of fields is not"]
                        #[doc = r" empty, the `nextPageToken` field will be added to the list."]
                        #[doc = r""]
                        #[doc = r" [`next_page_token`]: crate::GetNextPageToken::next_page_token"]
                        pub fn stream_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> impl ::futures::Stream<Item = Result<T, crate::Error>> + 'a
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned + 'a,
                            F: AsRef<str>,
                        {
                            let mut fields =
                                fields.as_ref().map(|x| x.as_ref()).unwrap_or("").to_owned();
                            if !fields.is_empty() {
                                match fields.chars().rev().nth(0) {
                                    Some(',') | None => {}
                                    _ => fields.push_str(","),
                                }
                                fields.push_str("nextPageToken");
                                self.fields = Some(fields);
                            }
                            crate::stream::page_stream(self)
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaListSfdcChannelsResponse,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.parent;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output.push_str("/sfdcChannels");
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                            req = req.query(&[("filter", &self.filter)]);
                            req = req.query(&[("pageSize", &self.page_size)]);
                            req = req.query(&[("pageToken", &self.page_token)]);
                            req = req.query(&[("readMask", &self.read_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                    #[async_trait::async_trait]
                    impl<'a> crate::stream::StreamableMethod for ListRequestBuilder<'a> {
                        type PageToken = String;
                        fn set_page_token(&mut self, value: String) {
                            self.page_token = value.into();
                        }
                        async fn execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: crate::GetNextPageToken<String> + ::serde::de::DeserializeOwned,
                        {
                            self._execute().await
                        }
                    }
                    #[doc = "Created via [SfdcChannelsActions::patch()](struct.SfdcChannelsActions.html#method.patch)"]
                    #[derive(Debug, Clone)]
                    pub struct PatchRequestBuilder<'a> {
                        pub(crate) reqwest: &'a ::reqwest::Client,
                        pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                        request: crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                        name: String,
                        update_mask: ::std::option::Option<String>,
                        access_token: ::std::option::Option<String>,
                        alt: ::std::option::Option<crate::params::Alt>,
                        callback: ::std::option::Option<String>,
                        fields: ::std::option::Option<String>,
                        key: ::std::option::Option<String>,
                        oauth_token: ::std::option::Option<String>,
                        pretty_print: ::std::option::Option<bool>,
                        quota_user: ::std::option::Option<String>,
                        upload_protocol: ::std::option::Option<String>,
                        upload_type: ::std::option::Option<String>,
                        xgafv: ::std::option::Option<crate::params::Xgafv>,
                    }
                    impl<'a> PatchRequestBuilder<'a> {
                        #[doc = "Field mask specifying the fields in the above SfdcChannel that have been modified and need to be updated."]
                        pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                            self.update_mask = Some(value.into());
                            self
                        }
                        #[doc = "OAuth access token."]
                        pub fn access_token(mut self, value: impl Into<String>) -> Self {
                            self.access_token = Some(value.into());
                            self
                        }
                        #[doc = "JSONP"]
                        pub fn callback(mut self, value: impl Into<String>) -> Self {
                            self.callback = Some(value.into());
                            self
                        }
                        #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                        pub fn key(mut self, value: impl Into<String>) -> Self {
                            self.key = Some(value.into());
                            self
                        }
                        #[doc = "OAuth 2.0 token for the current user."]
                        pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                            self.oauth_token = Some(value.into());
                            self
                        }
                        #[doc = "Returns response with indentations and line breaks."]
                        pub fn pretty_print(mut self, value: bool) -> Self {
                            self.pretty_print = Some(value);
                            self
                        }
                        #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                        pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                            self.quota_user = Some(value.into());
                            self
                        }
                        #[doc = "Upload protocol for media (e.g. â€œrawâ€, â€œmultipartâ€)."]
                        pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                            self.upload_protocol = Some(value.into());
                            self
                        }
                        #[doc = "Legacy upload protocol for media (e.g. â€œmediaâ€, â€œmultipartâ€)."]
                        pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                            self.upload_type = Some(value.into());
                            self
                        }
                        #[doc = "V1 error format."]
                        pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                            self.xgafv = Some(value);
                            self
                        }
                        #[doc = r" Execute the given operation. The fields requested are"]
                        #[doc = r" determined by the FieldSelector attribute of the return type."]
                        #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                        #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                        #[doc = r" are not generic over the return type and deserialize the"]
                        #[doc = r" response into an auto-generated struct will all possible"]
                        #[doc = r" fields."]
                        pub async fn execute<T>(self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned
                                + ::google_field_selector::FieldSelector,
                        {
                            let fields = ::google_field_selector::to_string::<T>();
                            let fields: ::std::option::Option<String> = if fields.is_empty() {
                                None
                            } else {
                                Some(fields)
                            };
                            self.execute_with_fields(fields).await
                        }
                        #[doc = r" Execute the given operation. This will not provide any"]
                        #[doc = r" `fields` selector indicating that the server will determine"]
                        #[doc = r" the fields returned. This typically includes the most common"]
                        #[doc = r" fields, but it will not include every possible attribute of"]
                        #[doc = r" the response resource."]
                        pub async fn execute_with_default_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            crate::Error,
                        > {
                            self.execute_with_fields(None::<&str>).await
                        }
                        #[doc = r" Execute the given operation. This will provide a `fields`"]
                        #[doc = r" selector of `*`. This will include every attribute of the"]
                        #[doc = r" response resource and should be limited to use during"]
                        #[doc = r" development or debugging."]
                        pub async fn execute_with_all_fields(
                            self,
                        ) -> Result<
                            crate::schemas::GoogleCloudIntegrationsV1AlphaSfdcChannel,
                            crate::Error,
                        > {
                            self.execute_with_fields(Some("*")).await
                        }
                        #[doc = r" Execute the given operation. This will use the `fields`"]
                        #[doc = r" selector provided and will deserialize the response into"]
                        #[doc = r" whatever return value is provided."]
                        pub async fn execute_with_fields<T, F>(
                            mut self,
                            fields: ::std::option::Option<F>,
                        ) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                            F: Into<String>,
                        {
                            self.fields = fields.map(Into::into);
                            self._execute().await
                        }
                        async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                        where
                            T: ::serde::de::DeserializeOwned,
                        {
                            let req = self._request(&self._path()).await?;
                            let req = req.json(&self.request);
                            Ok(req.send().await?.error_for_status()?.json().await?)
                        }
                        fn _path(&self) -> String {
                            let mut output = "https://integrations.googleapis.com/".to_owned();
                            output.push_str("v1alpha/");
                            {
                                let var_as_str = &self.name;
                                output.extend(::percent_encoding::utf8_percent_encode(
                                    &var_as_str,
                                    crate::RESERVED,
                                ));
                            }
                            output
                        }
                        async fn _request(
                            &self,
                            path: &str,
                        ) -> Result<::reqwest::RequestBuilder, crate::Error>
                        {
                            let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                            req = req.query(&[("updateMask", &self.update_mask)]);
                            req = req.query(&[("access_token", &self.access_token)]);
                            req = req.query(&[("alt", &self.alt)]);
                            req = req.query(&[("callback", &self.callback)]);
                            req = req.query(&[("fields", &self.fields)]);
                            req = req.query(&[("key", &self.key)]);
                            req = req.query(&[("oauth_token", &self.oauth_token)]);
                            req = req.query(&[("prettyPrint", &self.pretty_print)]);
                            req = req.query(&[("quotaUser", &self.quota_user)]);
                            req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                            req = req.query(&[("uploadType", &self.upload_type)]);
                            req = req.query(&[("$.xgafv", &self.xgafv)]);
                            let access_token = self
                                .auth
                                .access_token()
                                .await
                                .map_err(|err| crate::Error::OAuth2(err))?;
                            req = req.bearer_auth(access_token);
                            Ok(req)
                        }
                    }
                }
            }
        }
    }
}
#[derive(Debug)]
pub enum Error {
    OAuth2(Box<dyn ::std::error::Error + Send + Sync>),
    JSON(::serde_json::Error),
    Reqwest {
        reqwest_err: ::reqwest::Error,
        body: Option<String>,
    },
    IO(std::io::Error),
    Other(Box<dyn ::std::error::Error + Send + Sync>),
}

impl Error {
    pub fn json_error(&self) -> Option<&::serde_json::Error> {
        match self {
            Error::OAuth2(_) => None,
            Error::JSON(err) => Some(err),
            Error::Reqwest { .. } => None,
            Error::IO(_) => None,
            Error::Other(_) => None,
        }
    }
}

impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            Error::OAuth2(err) => write!(f, "OAuth2 Error: {}", err),
            Error::JSON(err) => write!(f, "JSON Error: {}", err),
            Error::Reqwest { reqwest_err, body } => {
                write!(f, "Reqwest Error: {}", reqwest_err)?;
                if let Some(body) = body {
                    write!(f, ": {}", body)?;
                }
                Ok(())
            }
            Error::IO(err) => write!(f, "IO Error: {}", err),
            Error::Other(err) => write!(f, "Uknown Error: {}", err),
        }
    }
}

impl ::std::error::Error for Error {}

impl From<::serde_json::Error> for Error {
    fn from(err: ::serde_json::Error) -> Error {
        Error::JSON(err)
    }
}

impl From<::reqwest::Error> for Error {
    fn from(reqwest_err: ::reqwest::Error) -> Error {
        Error::Reqwest {
            reqwest_err,
            body: None,
        }
    }
}

impl From<std::io::Error> for Error {
    fn from(err: std::io::Error) -> Error {
        Error::IO(err)
    }
}
#[allow(dead_code)]
const SIMPLE: &::percent_encoding::AsciiSet = &::percent_encoding::NON_ALPHANUMERIC
    .remove(b'-')
    .remove(b'.')
    .remove(b'_')
    .remove(b'~');

#[allow(dead_code)]
const RESERVED: &::percent_encoding::AsciiSet = &SIMPLE
    .remove(b'%')
    .remove(b':')
    .remove(b'/')
    .remove(b'?')
    .remove(b'#')
    .remove(b'[')
    .remove(b']')
    .remove(b'@')
    .remove(b'!')
    .remove(b'$')
    .remove(b'&')
    .remove(b'\'')
    .remove(b'(')
    .remove(b')')
    .remove(b'*')
    .remove(b'+')
    .remove(b',')
    .remove(b';')
    .remove(b'=');
#[allow(dead_code)]
mod multipart {
    pub(crate) struct RelatedMultiPart {
        parts: Vec<Part>,
        boundary: String,
    }

    impl RelatedMultiPart {
        pub(crate) fn new() -> Self {
            RelatedMultiPart {
                parts: Vec::new(),
                boundary: ::textnonce::TextNonce::sized(68).unwrap().0,
            }
        }

        pub(crate) fn new_part(&mut self, part: Part) {
            self.parts.push(part);
        }

        pub(crate) fn boundary(&self) -> &str {
            &self.boundary
        }

        pub(crate) fn into_reader(self) -> RelatedMultiPartReader {
            let boundary_marker = boundary_marker(&self.boundary);
            RelatedMultiPartReader {
                state: RelatedMultiPartReaderState::WriteBoundary {
                    start: 0,
                    boundary: format!("{}\r\n", &boundary_marker),
                },
                boundary: boundary_marker,
                next_body: None,
                parts: self.parts.into_iter(),
            }
        }
    }

    pub(crate) struct Part {
        content_type: ::mime::Mime,
        body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
    }

    impl Part {
        pub(crate) fn new(
            content_type: ::mime::Mime,
            body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
        ) -> Part {
            Part { content_type, body }
        }
    }

    pub(crate) struct RelatedMultiPartReader {
        state: RelatedMultiPartReaderState,
        boundary: String,
        next_body: Option<Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>>,
        parts: std::vec::IntoIter<Part>,
    }

    enum RelatedMultiPartReaderState {
        WriteBoundary {
            start: usize,
            boundary: String,
        },
        WriteContentType {
            start: usize,
            content_type: Vec<u8>,
        },
        WriteBody {
            body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
        },
    }

    impl futures::io::AsyncRead for RelatedMultiPartReader {
        fn poll_read(
            mut self: std::pin::Pin<&mut Self>,
            ctx: &mut futures::task::Context,
            buf: &mut [u8],
        ) -> futures::task::Poll<Result<usize, futures::io::Error>> {
            use RelatedMultiPartReaderState::*;

            let mut bytes_written: usize = 0;
            loop {
                let rem_buf = &mut buf[bytes_written..];
                match &mut self.state {
                    WriteBoundary { start, boundary } => {
                        let bytes_to_copy = std::cmp::min(boundary.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&boundary.as_bytes()[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == boundary.len() {
                            let next_part = match self.parts.next() {
                                None => break,
                                Some(part) => part,
                            };
                            self.next_body = Some(next_part.body);
                            self.state = WriteContentType {
                                start: 0,
                                content_type: format!(
                                    "Content-Type: {}\r\n\r\n",
                                    next_part.content_type
                                )
                                .into_bytes(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteContentType {
                        start,
                        content_type,
                    } => {
                        let bytes_to_copy =
                            std::cmp::min(content_type.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&content_type[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == content_type.len() {
                            self.state = WriteBody {
                                body: self.next_body.take().unwrap(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteBody { body } => {
                        let body = std::pin::Pin::new(body);
                        let written = match futures::io::AsyncRead::poll_read(body, ctx, rem_buf) {
                            futures::task::Poll::Ready(Ok(n)) => n,
                            futures::task::Poll::Ready(Err(err)) => {
                                return futures::task::Poll::Ready(Err(err));
                            }
                            futures::task::Poll::Pending => return futures::task::Poll::Pending,
                        };
                        bytes_written += written;
                        if written == 0 {
                            self.state = WriteBoundary {
                                start: 0,
                                boundary: format!("\r\n{}\r\n", &self.boundary),
                            };
                        } else {
                            break;
                        }
                    }
                }
            }

            futures::task::Poll::Ready(Ok(bytes_written))
        }
    }

    fn boundary_marker(boundary: &str) -> String {
        let mut marker = String::with_capacity(boundary.len() + 2);
        marker.push_str("--");
        marker.push_str(boundary);
        marker
    }
}
// A serde helper module that can be used with the `with` attribute
// to deserialize any string to a FromStr type and serialize any
// Display type to a String. Google API's encode i64, u64 values as
// strings.
#[allow(dead_code)]
mod parsed_string {
    pub fn serialize<T, S>(
        value: &Option<T>,
        serializer: S,
    ) -> ::std::result::Result<S::Ok, S::Error>
    where
        T: ::std::fmt::Display,
        S: ::serde::Serializer,
    {
        use ::serde::Serialize;
        value.as_ref().map(|x| x.to_string()).serialize(serializer)
    }

    pub fn deserialize<'de, T, D>(deserializer: D) -> ::std::result::Result<Option<T>, D::Error>
    where
        T: ::std::str::FromStr,
        T::Err: ::std::fmt::Display,
        D: ::serde::de::Deserializer<'de>,
    {
        use ::serde::Deserialize;
        match Option::<String>::deserialize(deserializer)? {
            Some(x) => Ok(Some(x.parse().map_err(::serde::de::Error::custom)?)),
            None => Ok(None),
        }
    }
}
/// Represent the ability to extract the `nextPageToken` from a response.
pub trait GetNextPageToken<T> {
    /// Get the `nextPageToken` from a response if present.
    fn next_page_token(&self) -> ::std::option::Option<T>;
}

impl<T: ::std::convert::From<::std::string::String>> GetNextPageToken<T>
    for ::serde_json::Map<::std::string::String, ::serde_json::Value>
{
    fn next_page_token(&self) -> ::std::option::Option<T> {
        self.get("nextPageToken")
            .and_then(|t| t.as_str())
            .map(|s| s.to_owned().into())
    }
}
/// Traits and functions to improve streamable (multiple page) API method handling.
pub mod stream {
    use super::GetNextPageToken;

    /// Extract the items embedded in a page like response.
    pub trait IntoPageItems {
        /// Type of the items list in the page.
        type Items: IntoIterator;

        /// Consume the response and return the embedded items.
        fn into_page_items(self) -> Self::Items;
    }

    /// Represent a API method which can be invoked multiple times to retrieve
    /// multiple pages of items.
    #[async_trait::async_trait]
    pub trait StreamableMethod {
        /// Type of the `pageToken` and `nextPageToken` fields.
        type PageToken;

        /// Update the current page token of the request.
        fn set_page_token(&mut self, value: Self::PageToken);

        /// Execute the request.
        async fn execute<T>(&mut self) -> Result<T, crate::Error>
        where
            T: GetNextPageToken<Self::PageToken> + ::serde::de::DeserializeOwned;
    }

    /// Return a [`Stream`](::futures::Stream) over all pages of the given API
    /// method.
    pub fn page_stream<M, T>(method: M) -> impl ::futures::Stream<Item = Result<T, crate::Error>>
    where
        M: StreamableMethod,
        T: GetNextPageToken<M::PageToken> + ::serde::de::DeserializeOwned,
    {
        ::futures::stream::unfold((method, false), |(mut method, mut finished)| async move {
            if finished {
                return None;
            }
            let response = match method.execute::<T>().await {
                Ok(r) => r,
                Err(err) => return Some((Err(err), (method, false))),
            };
            if let Some(next_page_token) = response.next_page_token() {
                method.set_page_token(next_page_token);
            } else {
                finished = true;
            }

            Some((Ok(response), (method, finished)))
        })
    }

    /// Return a [`Stream`](::futures::Stream) over the items in all pages of
    /// the given API method.
    pub fn page_item_stream<M, T>(
        method: M,
    ) -> impl ::futures::Stream<Item = Result<<T::Items as IntoIterator>::Item, crate::Error>>
    where
        M: StreamableMethod,
        T: GetNextPageToken<M::PageToken> + ::serde::de::DeserializeOwned + IntoPageItems,
    {
        use ::futures::StreamExt;
        use ::futures::TryStreamExt;

        page_stream::<M, T>(method)
            .map_ok(|page| ::futures::stream::iter(page.into_page_items()).map(Ok))
            .try_flatten()
    }
}
