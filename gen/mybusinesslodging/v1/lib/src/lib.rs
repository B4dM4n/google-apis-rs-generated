#![doc = "# Resources and Methods\n* [locations](resources/locations/struct.LocationsActions.html)\n  * [*getLodging*](resources/locations/struct.GetLodgingRequestBuilder.html), [*updateLodging*](resources/locations/struct.UpdateLodgingRequestBuilder.html)\n  * [lodging](resources/locations/lodging/struct.LodgingActions.html)\n    * [*getGoogleUpdated*](resources/locations/lodging/struct.GetGoogleUpdatedRequestBuilder.html)\n"]
pub mod scopes {}
pub mod schemas {
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Accessibility {
        #[doc = "Mobility accessible. Throughout the property there are physical adaptations to ease the stay of a person in a wheelchair, such as auto-opening doors, wide elevators, wide bathrooms or ramps."]
        #[serde(
            rename = "mobilityAccessible",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible: ::std::option::Option<bool>,
        #[doc = "Mobility accessible elevator. A lift that transports people from one level to another and is built to accommodate a wheelchair-using passenger owing to the width of its doors and placement of call buttons."]
        #[serde(
            rename = "mobilityAccessibleElevator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_elevator: ::std::option::Option<bool>,
        #[doc = "Mobility accessible elevator exception."]
        #[serde(
            rename = "mobilityAccessibleElevatorException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_elevator_exception:
            ::std::option::Option<crate::schemas::AccessibilityMobilityAccessibleElevatorException>,
        #[doc = "Mobility accessible exception."]
        #[serde(
            rename = "mobilityAccessibleException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_exception:
            ::std::option::Option<crate::schemas::AccessibilityMobilityAccessibleException>,
        #[doc = "Mobility accessible parking. The presence of a marked, designated area of prescribed size in which only registered, labeled vehicles transporting a person with physical challenges may park."]
        #[serde(
            rename = "mobilityAccessibleParking",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_parking: ::std::option::Option<bool>,
        #[doc = "Mobility accessible parking exception."]
        #[serde(
            rename = "mobilityAccessibleParkingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_parking_exception:
            ::std::option::Option<crate::schemas::AccessibilityMobilityAccessibleParkingException>,
        #[doc = "Mobility accessible pool. A swimming pool equipped with a mechanical chair that can be lowered and raised for the purpose of moving physically challenged guests into and out of the pool. May be powered by electricity or water. Also known as pool lift."]
        #[serde(
            rename = "mobilityAccessiblePool",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_pool: ::std::option::Option<bool>,
        #[doc = "Mobility accessible pool exception."]
        #[serde(
            rename = "mobilityAccessiblePoolException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_pool_exception:
            ::std::option::Option<crate::schemas::AccessibilityMobilityAccessiblePoolException>,
    }
    impl ::google_field_selector::FieldSelector for Accessibility {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Accessibility {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AccessibilityMobilityAccessibleElevatorException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl AccessibilityMobilityAccessibleElevatorException {
        pub fn as_str(self) -> &'static str {
            match self {
                AccessibilityMobilityAccessibleElevatorException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                AccessibilityMobilityAccessibleElevatorException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                AccessibilityMobilityAccessibleElevatorException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                AccessibilityMobilityAccessibleElevatorException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AccessibilityMobilityAccessibleElevatorException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AccessibilityMobilityAccessibleElevatorException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AccessibilityMobilityAccessibleElevatorException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    AccessibilityMobilityAccessibleElevatorException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    AccessibilityMobilityAccessibleElevatorException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    AccessibilityMobilityAccessibleElevatorException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    AccessibilityMobilityAccessibleElevatorException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AccessibilityMobilityAccessibleElevatorException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AccessibilityMobilityAccessibleElevatorException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AccessibilityMobilityAccessibleElevatorException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    AccessibilityMobilityAccessibleElevatorException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    AccessibilityMobilityAccessibleElevatorException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    AccessibilityMobilityAccessibleElevatorException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    AccessibilityMobilityAccessibleElevatorException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AccessibilityMobilityAccessibleElevatorException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AccessibilityMobilityAccessibleElevatorException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AccessibilityMobilityAccessibleException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl AccessibilityMobilityAccessibleException {
        pub fn as_str(self) -> &'static str {
            match self {
                AccessibilityMobilityAccessibleException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                AccessibilityMobilityAccessibleException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                AccessibilityMobilityAccessibleException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                AccessibilityMobilityAccessibleException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for AccessibilityMobilityAccessibleException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AccessibilityMobilityAccessibleException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AccessibilityMobilityAccessibleException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    AccessibilityMobilityAccessibleException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    AccessibilityMobilityAccessibleException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    AccessibilityMobilityAccessibleException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => AccessibilityMobilityAccessibleException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AccessibilityMobilityAccessibleException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AccessibilityMobilityAccessibleException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AccessibilityMobilityAccessibleException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    AccessibilityMobilityAccessibleException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    AccessibilityMobilityAccessibleException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    AccessibilityMobilityAccessibleException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => AccessibilityMobilityAccessibleException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AccessibilityMobilityAccessibleException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AccessibilityMobilityAccessibleException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AccessibilityMobilityAccessibleParkingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl AccessibilityMobilityAccessibleParkingException {
        pub fn as_str(self) -> &'static str {
            match self {
                AccessibilityMobilityAccessibleParkingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                AccessibilityMobilityAccessibleParkingException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                AccessibilityMobilityAccessibleParkingException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                AccessibilityMobilityAccessibleParkingException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AccessibilityMobilityAccessibleParkingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AccessibilityMobilityAccessibleParkingException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AccessibilityMobilityAccessibleParkingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    AccessibilityMobilityAccessibleParkingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    AccessibilityMobilityAccessibleParkingException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    AccessibilityMobilityAccessibleParkingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    AccessibilityMobilityAccessibleParkingException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AccessibilityMobilityAccessibleParkingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AccessibilityMobilityAccessibleParkingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AccessibilityMobilityAccessibleParkingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    AccessibilityMobilityAccessibleParkingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    AccessibilityMobilityAccessibleParkingException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    AccessibilityMobilityAccessibleParkingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    AccessibilityMobilityAccessibleParkingException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AccessibilityMobilityAccessibleParkingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AccessibilityMobilityAccessibleParkingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum AccessibilityMobilityAccessiblePoolException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl AccessibilityMobilityAccessiblePoolException {
        pub fn as_str(self) -> &'static str {
            match self {
                AccessibilityMobilityAccessiblePoolException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                AccessibilityMobilityAccessiblePoolException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                AccessibilityMobilityAccessiblePoolException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                AccessibilityMobilityAccessiblePoolException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for AccessibilityMobilityAccessiblePoolException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for AccessibilityMobilityAccessiblePoolException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<AccessibilityMobilityAccessiblePoolException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    AccessibilityMobilityAccessiblePoolException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    AccessibilityMobilityAccessiblePoolException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    AccessibilityMobilityAccessiblePoolException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    AccessibilityMobilityAccessiblePoolException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for AccessibilityMobilityAccessiblePoolException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for AccessibilityMobilityAccessiblePoolException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AccessibilityMobilityAccessiblePoolException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    AccessibilityMobilityAccessiblePoolException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    AccessibilityMobilityAccessiblePoolException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    AccessibilityMobilityAccessiblePoolException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    AccessibilityMobilityAccessiblePoolException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for AccessibilityMobilityAccessiblePoolException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for AccessibilityMobilityAccessiblePoolException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Activities {
        #[doc = "Beach access. The hotel property is in close proximity to a beach and offers a way to get to that beach. This can include a route to the beach such as stairs down if hotel is on a bluff, or a short trail. Not the same as beachfront (with beach access, the hotel's proximity is close to but not right on the beach)."]
        #[serde(
            rename = "beachAccess",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub beach_access: ::std::option::Option<bool>,
        #[doc = "Beach access exception."]
        #[serde(
            rename = "beachAccessException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub beach_access_exception:
            ::std::option::Option<crate::schemas::ActivitiesBeachAccessException>,
        #[doc = "Breach front. The hotel property is physically located on the beach alongside an ocean, sea, gulf, or bay. It is not on a lake, river, stream, or pond. The hotel is not separated from the beach by a public road allowing vehicular, pedestrian, or bicycle traffic."]
        #[serde(
            rename = "beachFront",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub beach_front: ::std::option::Option<bool>,
        #[doc = "Beach front exception."]
        #[serde(
            rename = "beachFrontException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub beach_front_exception:
            ::std::option::Option<crate::schemas::ActivitiesBeachFrontException>,
        #[doc = "Bicycle rental. The hotel owns bicycles that it permits guests to borrow and use. Can be free or for a fee."]
        #[serde(
            rename = "bicycleRental",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bicycle_rental: ::std::option::Option<bool>,
        #[doc = "Bicycle rental exception."]
        #[serde(
            rename = "bicycleRentalException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bicycle_rental_exception:
            ::std::option::Option<crate::schemas::ActivitiesBicycleRentalException>,
        #[doc = "Boutique stores. There are stores selling clothing, jewelry, art and decor either on hotel premises or very close by. Does not refer to the hotel gift shop or convenience store."]
        #[serde(
            rename = "boutiqueStores",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boutique_stores: ::std::option::Option<bool>,
        #[doc = "Boutique stores exception."]
        #[serde(
            rename = "boutiqueStoresException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub boutique_stores_exception:
            ::std::option::Option<crate::schemas::ActivitiesBoutiqueStoresException>,
        #[doc = "Casino. A space designated for gambling and gaming featuring croupier-run table and card games, as well as electronic slot machines. May be on hotel premises or located nearby."]
        #[serde(
            rename = "casino",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub casino: ::std::option::Option<bool>,
        #[doc = "Casino exception."]
        #[serde(
            rename = "casinoException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub casino_exception: ::std::option::Option<crate::schemas::ActivitiesCasinoException>,
        #[doc = "Free bicycle rental. The hotel owns bicycles that it permits guests to borrow and use for free."]
        #[serde(
            rename = "freeBicycleRental",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_bicycle_rental: ::std::option::Option<bool>,
        #[doc = "Free bicycle rental exception."]
        #[serde(
            rename = "freeBicycleRentalException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_bicycle_rental_exception:
            ::std::option::Option<crate::schemas::ActivitiesFreeBicycleRentalException>,
        #[doc = "Free watercraft rental. The hotel owns watercraft that it permits guests to borrow and use for free."]
        #[serde(
            rename = "freeWatercraftRental",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_watercraft_rental: ::std::option::Option<bool>,
        #[doc = "Free Watercraft rental exception."]
        #[serde(
            rename = "freeWatercraftRentalException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_watercraft_rental_exception:
            ::std::option::Option<crate::schemas::ActivitiesFreeWatercraftRentalException>,
        #[doc = "Game room. There is a room at the hotel containing electronic machines for play such as pinball, prize machines, driving simulators, and other items commonly found at a family fun center or arcade. May also include non-electronic games like pool, foosball, darts, and more. May or may not be designed for children. Also known as arcade, fun room, or family fun center."]
        #[serde(
            rename = "gameRoom",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub game_room: ::std::option::Option<bool>,
        #[doc = "Game room exception."]
        #[serde(
            rename = "gameRoomException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub game_room_exception: ::std::option::Option<crate::schemas::ActivitiesGameRoomException>,
        #[doc = "Golf. There is a golf course on hotel grounds or there is a nearby, independently run golf course that allows use by hotel guests. Can be free or for a fee."]
        #[serde(
            rename = "golf",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub golf: ::std::option::Option<bool>,
        #[doc = "Golf exception."]
        #[serde(
            rename = "golfException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub golf_exception: ::std::option::Option<crate::schemas::ActivitiesGolfException>,
        #[doc = "Horseback riding. The hotel has a horse barn onsite or an affiliation with a nearby barn to allow for guests to sit astride a horse and direct it to walk, trot, cantor, gallop and/or jump. Can be in a riding ring, on designated paths, or in the wilderness. May or may not involve instruction."]
        #[serde(
            rename = "horsebackRiding",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub horseback_riding: ::std::option::Option<bool>,
        #[doc = "Horseback riding exception."]
        #[serde(
            rename = "horsebackRidingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub horseback_riding_exception:
            ::std::option::Option<crate::schemas::ActivitiesHorsebackRidingException>,
        #[doc = "Nightclub. There is a room at the hotel with a bar, a dance floor, and seating where designated staffers play dance music. There may also be a designated area for the performance of live music, singing and comedy acts."]
        #[serde(
            rename = "nightclub",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub nightclub: ::std::option::Option<bool>,
        #[doc = "Nightclub exception."]
        #[serde(
            rename = "nightclubException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub nightclub_exception:
            ::std::option::Option<crate::schemas::ActivitiesNightclubException>,
        #[doc = "Private beach. The beach which is in close proximity to the hotel is open only to guests."]
        #[serde(
            rename = "privateBeach",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_beach: ::std::option::Option<bool>,
        #[doc = "Private beach exception."]
        #[serde(
            rename = "privateBeachException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_beach_exception:
            ::std::option::Option<crate::schemas::ActivitiesPrivateBeachException>,
        #[doc = "Scuba. The provision for guests to dive under naturally occurring water fitted with a self-contained underwater breathing apparatus (SCUBA) for the purpose of exploring underwater life. Apparatus consists of a tank providing oxygen to the diver through a mask. Requires certification of the diver and supervision. The hotel may have the activity at its own waterfront or have an affiliation with a nearby facility. Required equipment is most often supplied to guests. Can be free or for a fee. Not snorkeling. Not done in a swimming pool."]
        #[serde(
            rename = "scuba",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scuba: ::std::option::Option<bool>,
        #[doc = "Scuba exception."]
        #[serde(
            rename = "scubaException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub scuba_exception: ::std::option::Option<crate::schemas::ActivitiesScubaException>,
        #[doc = "Snorkeling. The provision for guests to participate in a recreational water activity in which swimmers wear a diving mask, a simple, shaped breathing tube and flippers/swim fins for the purpose of exploring below the surface of an ocean, gulf or lake. Does not usually require user certification or professional supervision. Equipment may or may not be available for rent or purchase. Not scuba diving."]
        #[serde(
            rename = "snorkeling",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snorkeling: ::std::option::Option<bool>,
        #[doc = "Snorkeling exception."]
        #[serde(
            rename = "snorkelingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snorkeling_exception:
            ::std::option::Option<crate::schemas::ActivitiesSnorkelingException>,
        #[doc = "Tennis. The hotel has the requisite court(s) on site or has an affiliation with a nearby facility for the purpose of providing guests with the opportunity to play a two-sided court-based game in which players use a stringed racquet to hit a ball across a net to the side of the opposing player. The court can be indoors or outdoors. Instructors, racquets and balls may or may not be provided."]
        #[serde(
            rename = "tennis",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tennis: ::std::option::Option<bool>,
        #[doc = "Tennis exception."]
        #[serde(
            rename = "tennisException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tennis_exception: ::std::option::Option<crate::schemas::ActivitiesTennisException>,
        #[doc = "Water skiing. The provision of giving guests the opportunity to be pulled across naturally occurring water while standing on skis and holding a tow rope attached to a motorboat. Can occur on hotel premises or at a nearby waterfront. Most often performed in a lake or ocean."]
        #[serde(
            rename = "waterSkiing",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_skiing: ::std::option::Option<bool>,
        #[doc = "Water skiing exception."]
        #[serde(
            rename = "waterSkiingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_skiing_exception:
            ::std::option::Option<crate::schemas::ActivitiesWaterSkiingException>,
        #[doc = "Watercraft rental. The hotel owns water vessels that it permits guests to borrow and use. Can be free or for a fee. Watercraft may include boats, pedal boats, rowboats, sailboats, powerboats, canoes, kayaks, or personal watercraft (such as a Jet Ski)."]
        #[serde(
            rename = "watercraftRental",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub watercraft_rental: ::std::option::Option<bool>,
        #[doc = "Watercraft rental exception."]
        #[serde(
            rename = "watercraftRentalException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub watercraft_rental_exception:
            ::std::option::Option<crate::schemas::ActivitiesWatercraftRentalException>,
    }
    impl ::google_field_selector::FieldSelector for Activities {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Activities {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesBeachAccessException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesBeachAccessException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesBeachAccessException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesBeachAccessException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesBeachAccessException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesBeachAccessException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesBeachAccessException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesBeachAccessException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesBeachAccessException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesBeachAccessException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesBeachAccessException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesBeachAccessException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesBeachAccessException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesBeachAccessException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesBeachAccessException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesBeachAccessException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesBeachAccessException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesBeachAccessException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesBeachAccessException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesBeachAccessException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesBeachAccessException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesBeachAccessException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesBeachFrontException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesBeachFrontException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesBeachFrontException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesBeachFrontException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesBeachFrontException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesBeachFrontException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesBeachFrontException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesBeachFrontException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesBeachFrontException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesBeachFrontException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesBeachFrontException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesBeachFrontException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesBeachFrontException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesBeachFrontException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesBeachFrontException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesBeachFrontException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesBeachFrontException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesBeachFrontException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesBeachFrontException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesBeachFrontException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesBeachFrontException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesBeachFrontException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesBicycleRentalException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesBicycleRentalException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesBicycleRentalException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ActivitiesBicycleRentalException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesBicycleRentalException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesBicycleRentalException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesBicycleRentalException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesBicycleRentalException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesBicycleRentalException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesBicycleRentalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesBicycleRentalException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesBicycleRentalException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesBicycleRentalException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesBicycleRentalException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesBicycleRentalException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesBicycleRentalException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesBicycleRentalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesBicycleRentalException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesBicycleRentalException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesBicycleRentalException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesBicycleRentalException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesBicycleRentalException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesBoutiqueStoresException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesBoutiqueStoresException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesBoutiqueStoresException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ActivitiesBoutiqueStoresException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesBoutiqueStoresException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesBoutiqueStoresException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesBoutiqueStoresException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesBoutiqueStoresException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesBoutiqueStoresException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesBoutiqueStoresException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesBoutiqueStoresException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesBoutiqueStoresException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesBoutiqueStoresException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesBoutiqueStoresException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesBoutiqueStoresException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesBoutiqueStoresException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesBoutiqueStoresException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesBoutiqueStoresException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesBoutiqueStoresException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesBoutiqueStoresException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesBoutiqueStoresException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesBoutiqueStoresException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesCasinoException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesCasinoException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesCasinoException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesCasinoException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesCasinoException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesCasinoException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesCasinoException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesCasinoException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesCasinoException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesCasinoException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesCasinoException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesCasinoException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesCasinoException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesCasinoException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesCasinoException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesCasinoException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesCasinoException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesCasinoException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesCasinoException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesCasinoException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesCasinoException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesCasinoException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesFreeBicycleRentalException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesFreeBicycleRentalException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesFreeBicycleRentalException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ActivitiesFreeBicycleRentalException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesFreeBicycleRentalException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ActivitiesFreeBicycleRentalException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesFreeBicycleRentalException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesFreeBicycleRentalException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesFreeBicycleRentalException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesFreeBicycleRentalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesFreeBicycleRentalException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ActivitiesFreeBicycleRentalException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ActivitiesFreeBicycleRentalException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesFreeBicycleRentalException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesFreeBicycleRentalException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesFreeBicycleRentalException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesFreeBicycleRentalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesFreeBicycleRentalException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ActivitiesFreeBicycleRentalException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ActivitiesFreeBicycleRentalException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesFreeBicycleRentalException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesFreeBicycleRentalException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesFreeWatercraftRentalException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesFreeWatercraftRentalException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesFreeWatercraftRentalException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ActivitiesFreeWatercraftRentalException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesFreeWatercraftRentalException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ActivitiesFreeWatercraftRentalException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesFreeWatercraftRentalException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesFreeWatercraftRentalException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesFreeWatercraftRentalException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesFreeWatercraftRentalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesFreeWatercraftRentalException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ActivitiesFreeWatercraftRentalException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ActivitiesFreeWatercraftRentalException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesFreeWatercraftRentalException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesFreeWatercraftRentalException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesFreeWatercraftRentalException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesFreeWatercraftRentalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesFreeWatercraftRentalException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ActivitiesFreeWatercraftRentalException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ActivitiesFreeWatercraftRentalException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesFreeWatercraftRentalException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesFreeWatercraftRentalException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesGameRoomException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesGameRoomException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesGameRoomException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesGameRoomException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesGameRoomException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesGameRoomException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesGameRoomException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesGameRoomException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesGameRoomException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesGameRoomException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesGameRoomException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesGameRoomException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesGameRoomException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesGameRoomException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesGameRoomException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesGameRoomException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesGameRoomException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesGameRoomException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesGameRoomException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesGameRoomException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesGameRoomException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesGameRoomException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesGolfException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesGolfException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesGolfException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesGolfException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesGolfException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesGolfException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesGolfException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesGolfException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesGolfException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesGolfException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesGolfException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesGolfException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesGolfException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesGolfException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesGolfException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesGolfException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesGolfException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesGolfException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesGolfException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesGolfException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesGolfException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesGolfException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesHorsebackRidingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesHorsebackRidingException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesHorsebackRidingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ActivitiesHorsebackRidingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesHorsebackRidingException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesHorsebackRidingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesHorsebackRidingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesHorsebackRidingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesHorsebackRidingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesHorsebackRidingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesHorsebackRidingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesHorsebackRidingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesHorsebackRidingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesHorsebackRidingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesHorsebackRidingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesHorsebackRidingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesHorsebackRidingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesHorsebackRidingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesHorsebackRidingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesHorsebackRidingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesHorsebackRidingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesHorsebackRidingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesNightclubException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesNightclubException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesNightclubException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesNightclubException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesNightclubException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesNightclubException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesNightclubException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesNightclubException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesNightclubException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesNightclubException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesNightclubException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesNightclubException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesNightclubException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesNightclubException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesNightclubException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesNightclubException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesNightclubException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesNightclubException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesNightclubException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesNightclubException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesNightclubException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesNightclubException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesPrivateBeachException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesPrivateBeachException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesPrivateBeachException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesPrivateBeachException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesPrivateBeachException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesPrivateBeachException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesPrivateBeachException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesPrivateBeachException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesPrivateBeachException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesPrivateBeachException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesPrivateBeachException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesPrivateBeachException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesPrivateBeachException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesPrivateBeachException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesPrivateBeachException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesPrivateBeachException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesPrivateBeachException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesPrivateBeachException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesPrivateBeachException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesPrivateBeachException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesPrivateBeachException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesPrivateBeachException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesScubaException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesScubaException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesScubaException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesScubaException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesScubaException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesScubaException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesScubaException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesScubaException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesScubaException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesScubaException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesScubaException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesScubaException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesScubaException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesScubaException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesScubaException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesScubaException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesScubaException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesScubaException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesScubaException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesScubaException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesScubaException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesScubaException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesSnorkelingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesSnorkelingException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesSnorkelingException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesSnorkelingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesSnorkelingException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesSnorkelingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesSnorkelingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesSnorkelingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesSnorkelingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesSnorkelingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesSnorkelingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesSnorkelingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesSnorkelingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesSnorkelingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesSnorkelingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesSnorkelingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesSnorkelingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesSnorkelingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesSnorkelingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesSnorkelingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesSnorkelingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesSnorkelingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesTennisException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesTennisException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesTennisException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesTennisException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesTennisException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesTennisException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesTennisException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesTennisException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesTennisException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesTennisException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesTennisException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesTennisException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesTennisException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesTennisException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesTennisException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesTennisException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesTennisException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesTennisException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesTennisException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesTennisException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesTennisException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesTennisException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesWaterSkiingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesWaterSkiingException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesWaterSkiingException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ActivitiesWaterSkiingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesWaterSkiingException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ActivitiesWaterSkiingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesWaterSkiingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesWaterSkiingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesWaterSkiingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesWaterSkiingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesWaterSkiingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesWaterSkiingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesWaterSkiingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesWaterSkiingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesWaterSkiingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesWaterSkiingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ActivitiesWaterSkiingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ActivitiesWaterSkiingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ActivitiesWaterSkiingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ActivitiesWaterSkiingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesWaterSkiingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesWaterSkiingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ActivitiesWatercraftRentalException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ActivitiesWatercraftRentalException {
        pub fn as_str(self) -> &'static str {
            match self {
                ActivitiesWatercraftRentalException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ActivitiesWatercraftRentalException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ActivitiesWatercraftRentalException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ActivitiesWatercraftRentalException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ActivitiesWatercraftRentalException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ActivitiesWatercraftRentalException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ActivitiesWatercraftRentalException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesWatercraftRentalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesWatercraftRentalException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ActivitiesWatercraftRentalException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ActivitiesWatercraftRentalException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ActivitiesWatercraftRentalException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ActivitiesWatercraftRentalException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivitiesWatercraftRentalException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ActivitiesWatercraftRentalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ActivitiesWatercraftRentalException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ActivitiesWatercraftRentalException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ActivitiesWatercraftRentalException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ActivitiesWatercraftRentalException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ActivitiesWatercraftRentalException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Business {
        #[doc = "Business center. A designated room at the hotel with one or more desks and equipped with guest-use computers, printers, fax machines and/or photocopiers. May or may not be open 24/7. May or may not require a key to access. Not a meeting room or conference room."]
        #[serde(
            rename = "businessCenter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub business_center: ::std::option::Option<bool>,
        #[doc = "Business center exception."]
        #[serde(
            rename = "businessCenterException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub business_center_exception:
            ::std::option::Option<crate::schemas::BusinessBusinessCenterException>,
        #[doc = "Meeting rooms. Rooms at the hotel designated for business-related gatherings. Rooms are usually equipped with tables or desks, office chairs and audio/visual facilities to allow for presentations and conference calls. Also known as conference rooms."]
        #[serde(
            rename = "meetingRooms",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_rooms: ::std::option::Option<bool>,
        #[doc = "Meeting rooms count. The number of meeting rooms at the property."]
        #[serde(
            rename = "meetingRoomsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_rooms_count: ::std::option::Option<i32>,
        #[doc = "Meeting rooms count exception."]
        #[serde(
            rename = "meetingRoomsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_rooms_count_exception:
            ::std::option::Option<crate::schemas::BusinessMeetingRoomsCountException>,
        #[doc = "Meeting rooms exception."]
        #[serde(
            rename = "meetingRoomsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub meeting_rooms_exception:
            ::std::option::Option<crate::schemas::BusinessMeetingRoomsException>,
    }
    impl ::google_field_selector::FieldSelector for Business {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Business {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BusinessBusinessCenterException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl BusinessBusinessCenterException {
        pub fn as_str(self) -> &'static str {
            match self {
                BusinessBusinessCenterException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                BusinessBusinessCenterException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                BusinessBusinessCenterException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                BusinessBusinessCenterException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BusinessBusinessCenterException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BusinessBusinessCenterException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BusinessBusinessCenterException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => BusinessBusinessCenterException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => BusinessBusinessCenterException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => BusinessBusinessCenterException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => BusinessBusinessCenterException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BusinessBusinessCenterException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BusinessBusinessCenterException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BusinessBusinessCenterException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => BusinessBusinessCenterException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => BusinessBusinessCenterException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => BusinessBusinessCenterException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => BusinessBusinessCenterException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BusinessBusinessCenterException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BusinessBusinessCenterException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BusinessMeetingRoomsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl BusinessMeetingRoomsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                BusinessMeetingRoomsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                BusinessMeetingRoomsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                BusinessMeetingRoomsCountException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                BusinessMeetingRoomsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BusinessMeetingRoomsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BusinessMeetingRoomsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BusinessMeetingRoomsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    BusinessMeetingRoomsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => BusinessMeetingRoomsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => BusinessMeetingRoomsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => BusinessMeetingRoomsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BusinessMeetingRoomsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BusinessMeetingRoomsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BusinessMeetingRoomsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    BusinessMeetingRoomsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => BusinessMeetingRoomsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => BusinessMeetingRoomsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => BusinessMeetingRoomsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BusinessMeetingRoomsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BusinessMeetingRoomsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum BusinessMeetingRoomsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl BusinessMeetingRoomsException {
        pub fn as_str(self) -> &'static str {
            match self {
                BusinessMeetingRoomsException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                BusinessMeetingRoomsException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                BusinessMeetingRoomsException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                BusinessMeetingRoomsException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for BusinessMeetingRoomsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for BusinessMeetingRoomsException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<BusinessMeetingRoomsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => BusinessMeetingRoomsException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => BusinessMeetingRoomsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => BusinessMeetingRoomsException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => BusinessMeetingRoomsException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for BusinessMeetingRoomsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for BusinessMeetingRoomsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BusinessMeetingRoomsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => BusinessMeetingRoomsException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => BusinessMeetingRoomsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => BusinessMeetingRoomsException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => BusinessMeetingRoomsException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for BusinessMeetingRoomsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for BusinessMeetingRoomsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Connectivity {
        #[doc = "Free wifi. The hotel offers guests wifi for free."]
        #[serde(
            rename = "freeWifi",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_wifi: ::std::option::Option<bool>,
        #[doc = "Free wifi exception."]
        #[serde(
            rename = "freeWifiException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_wifi_exception:
            ::std::option::Option<crate::schemas::ConnectivityFreeWifiException>,
        #[doc = "Public area wifi available. Guests have the ability to wirelessly connect to the internet in the areas of the hotel accessible to anyone. Can be free or for a fee."]
        #[serde(
            rename = "publicAreaWifiAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub public_area_wifi_available: ::std::option::Option<bool>,
        #[doc = "Public area wifi available exception."]
        #[serde(
            rename = "publicAreaWifiAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub public_area_wifi_available_exception:
            ::std::option::Option<crate::schemas::ConnectivityPublicAreaWifiAvailableException>,
        #[doc = "Public internet terminal. An area of the hotel supplied with computers and designated for the purpose of providing guests with the ability to access the internet."]
        #[serde(
            rename = "publicInternetTerminal",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub public_internet_terminal: ::std::option::Option<bool>,
        #[doc = "Public internet terminal exception."]
        #[serde(
            rename = "publicInternetTerminalException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub public_internet_terminal_exception:
            ::std::option::Option<crate::schemas::ConnectivityPublicInternetTerminalException>,
        #[doc = "Wifi available. The hotel provides the ability for guests to wirelessly connect to the internet. Can be in the public areas of the hotel and/or in the guest rooms. Can be free or for a fee."]
        #[serde(
            rename = "wifiAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wifi_available: ::std::option::Option<bool>,
        #[doc = "Wifi available exception."]
        #[serde(
            rename = "wifiAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wifi_available_exception:
            ::std::option::Option<crate::schemas::ConnectivityWifiAvailableException>,
    }
    impl ::google_field_selector::FieldSelector for Connectivity {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Connectivity {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ConnectivityFreeWifiException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ConnectivityFreeWifiException {
        pub fn as_str(self) -> &'static str {
            match self {
                ConnectivityFreeWifiException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ConnectivityFreeWifiException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ConnectivityFreeWifiException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ConnectivityFreeWifiException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ConnectivityFreeWifiException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ConnectivityFreeWifiException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ConnectivityFreeWifiException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ConnectivityFreeWifiException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ConnectivityFreeWifiException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ConnectivityFreeWifiException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ConnectivityFreeWifiException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ConnectivityFreeWifiException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ConnectivityFreeWifiException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ConnectivityFreeWifiException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ConnectivityFreeWifiException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ConnectivityFreeWifiException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ConnectivityFreeWifiException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ConnectivityFreeWifiException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ConnectivityFreeWifiException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ConnectivityFreeWifiException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ConnectivityPublicAreaWifiAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ConnectivityPublicAreaWifiAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                ConnectivityPublicAreaWifiAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ConnectivityPublicAreaWifiAvailableException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                ConnectivityPublicAreaWifiAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ConnectivityPublicAreaWifiAvailableException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for ConnectivityPublicAreaWifiAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ConnectivityPublicAreaWifiAvailableException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<ConnectivityPublicAreaWifiAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ConnectivityPublicAreaWifiAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    ConnectivityPublicAreaWifiAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    ConnectivityPublicAreaWifiAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    ConnectivityPublicAreaWifiAvailableException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ConnectivityPublicAreaWifiAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ConnectivityPublicAreaWifiAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ConnectivityPublicAreaWifiAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ConnectivityPublicAreaWifiAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    ConnectivityPublicAreaWifiAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    ConnectivityPublicAreaWifiAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    ConnectivityPublicAreaWifiAvailableException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ConnectivityPublicAreaWifiAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ConnectivityPublicAreaWifiAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ConnectivityPublicInternetTerminalException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ConnectivityPublicInternetTerminalException {
        pub fn as_str(self) -> &'static str {
            match self {
                ConnectivityPublicInternetTerminalException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ConnectivityPublicInternetTerminalException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                ConnectivityPublicInternetTerminalException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ConnectivityPublicInternetTerminalException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for ConnectivityPublicInternetTerminalException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ConnectivityPublicInternetTerminalException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<ConnectivityPublicInternetTerminalException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ConnectivityPublicInternetTerminalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    ConnectivityPublicInternetTerminalException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    ConnectivityPublicInternetTerminalException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    ConnectivityPublicInternetTerminalException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ConnectivityPublicInternetTerminalException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ConnectivityPublicInternetTerminalException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ConnectivityPublicInternetTerminalException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ConnectivityPublicInternetTerminalException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    ConnectivityPublicInternetTerminalException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    ConnectivityPublicInternetTerminalException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    ConnectivityPublicInternetTerminalException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ConnectivityPublicInternetTerminalException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ConnectivityPublicInternetTerminalException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ConnectivityWifiAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ConnectivityWifiAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                ConnectivityWifiAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ConnectivityWifiAvailableException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ConnectivityWifiAvailableException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ConnectivityWifiAvailableException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ConnectivityWifiAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ConnectivityWifiAvailableException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ConnectivityWifiAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ConnectivityWifiAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ConnectivityWifiAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ConnectivityWifiAvailableException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ConnectivityWifiAvailableException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ConnectivityWifiAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ConnectivityWifiAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ConnectivityWifiAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ConnectivityWifiAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ConnectivityWifiAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ConnectivityWifiAvailableException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ConnectivityWifiAvailableException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ConnectivityWifiAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ConnectivityWifiAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EcoCertification {
        #[doc = "Whether the eco certificate was awarded or not."]
        #[serde(
            rename = "awarded",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub awarded: ::std::option::Option<bool>,
        #[doc = "Awarded exception."]
        #[serde(
            rename = "awardedException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub awarded_exception:
            ::std::option::Option<crate::schemas::EcoCertificationAwardedException>,
        #[doc = "Required. The eco certificate."]
        #[serde(
            rename = "ecoCertificate",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub eco_certificate: ::std::option::Option<crate::schemas::EcoCertificationEcoCertificate>,
    }
    impl ::google_field_selector::FieldSelector for EcoCertification {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EcoCertification {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EcoCertificationAwardedException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EcoCertificationAwardedException {
        pub fn as_str(self) -> &'static str {
            match self {
                EcoCertificationAwardedException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EcoCertificationAwardedException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                EcoCertificationAwardedException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                EcoCertificationAwardedException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for EcoCertificationAwardedException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EcoCertificationAwardedException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<EcoCertificationAwardedException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EcoCertificationAwardedException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => EcoCertificationAwardedException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => EcoCertificationAwardedException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => EcoCertificationAwardedException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EcoCertificationAwardedException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EcoCertificationAwardedException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EcoCertificationAwardedException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EcoCertificationAwardedException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => EcoCertificationAwardedException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => EcoCertificationAwardedException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => EcoCertificationAwardedException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EcoCertificationAwardedException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EcoCertificationAwardedException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EcoCertificationEcoCertificate {
        #[doc = "Asian Ecotourism Standard for Accommodations (AESA)."]
        AsianEcotourism,
        #[doc = "Biosphere Responsible Tourism Standard."]
        BiosphereResposnibleTourism,
        #[doc = "Bureau Veritas."]
        BureauVeritas,
        #[doc = "Control Union."]
        ControlUnion,
        #[doc = "EarthCheck."]
        Earthcheck,
        #[doc = "Default EcoCertificate. Do not use."]
        EcoCertificateUnspecified,
        #[doc = "Eco-Certification Malta Standard."]
        EcoCertificationMalta,
        #[doc = "Ecotourism Australia's ECO Certification Standard."]
        EcotourismAustraliasEco,
        #[doc = "GREAT Green Deal Certification."]
        GreatGreenDeal,
        #[doc = "Green Globe."]
        GreenGlobe,
        #[doc = "Green Growth 2050 Standard."]
        GreenGrowth2050,
        #[doc = "Green Key."]
        GreenKey,
        #[doc = "Geen Key Eco Rating."]
        GreenKeyEcoRating,
        #[doc = "Green Seal."]
        GreenSeal,
        #[doc = "Green Star Hotel Standard."]
        GreenStar,
        #[doc = "Green Tourism Active Standard."]
        GreenTourismActive,
        #[doc = "Hilton LightStay."]
        HiltonLightstay,
        #[doc = "Hostelling International's Quality and Sustainability Standard."]
        HostellingInternationalsQualityAndSustainability,
        #[doc = "Hoteles más Verdes (AHT) Standard."]
        HotelesMasVerdes,
        #[doc = "ISO14001."]
        Iso14001,
        #[doc = "ISO50001."]
        Iso50001,
        #[doc = "Nordic Swan Ecolabel."]
        NordicSwanEcolabel,
        #[doc = "Preferred by Nature Sustainable Tourism Standard for Accommodation."]
        PreferredByNatureSustainableTourism,
        #[doc = "Sustainable Travel Ireland – GSTC Industry Criteria."]
        SustainableTravelIreland,
        #[doc = "TOFTigers Initiative's Pug Standard."]
        TofTigersInititivesPug,
        #[doc = "Travelife Standard for Hotels & Accommodations."]
        Travelife,
        #[doc = "United Certification Systems Limited."]
        UnitedCertificationSystemsLimited,
        #[doc = "Vireo Srl."]
        VireoSrl,
    }
    impl EcoCertificationEcoCertificate {
        pub fn as_str(self) -> &'static str {
            match self { EcoCertificationEcoCertificate :: AsianEcotourism => "ASIAN_ECOTOURISM" , EcoCertificationEcoCertificate :: BiosphereResposnibleTourism => "BIOSPHERE_RESPOSNIBLE_TOURISM" , EcoCertificationEcoCertificate :: BureauVeritas => "BUREAU_VERITAS" , EcoCertificationEcoCertificate :: ControlUnion => "CONTROL_UNION" , EcoCertificationEcoCertificate :: Earthcheck => "EARTHCHECK" , EcoCertificationEcoCertificate :: EcoCertificateUnspecified => "ECO_CERTIFICATE_UNSPECIFIED" , EcoCertificationEcoCertificate :: EcoCertificationMalta => "ECO_CERTIFICATION_MALTA" , EcoCertificationEcoCertificate :: EcotourismAustraliasEco => "ECOTOURISM_AUSTRALIAS_ECO" , EcoCertificationEcoCertificate :: GreatGreenDeal => "GREAT_GREEN_DEAL" , EcoCertificationEcoCertificate :: GreenGlobe => "GREEN_GLOBE" , EcoCertificationEcoCertificate :: GreenGrowth2050 => "GREEN_GROWTH2050" , EcoCertificationEcoCertificate :: GreenKey => "GREEN_KEY" , EcoCertificationEcoCertificate :: GreenKeyEcoRating => "GREEN_KEY_ECO_RATING" , EcoCertificationEcoCertificate :: GreenSeal => "GREEN_SEAL" , EcoCertificationEcoCertificate :: GreenStar => "GREEN_STAR" , EcoCertificationEcoCertificate :: GreenTourismActive => "GREEN_TOURISM_ACTIVE" , EcoCertificationEcoCertificate :: HiltonLightstay => "HILTON_LIGHTSTAY" , EcoCertificationEcoCertificate :: HostellingInternationalsQualityAndSustainability => "HOSTELLING_INTERNATIONALS_QUALITY_AND_SUSTAINABILITY" , EcoCertificationEcoCertificate :: HotelesMasVerdes => "HOTELES_MAS_VERDES" , EcoCertificationEcoCertificate :: Iso14001 => "ISO14001" , EcoCertificationEcoCertificate :: Iso50001 => "ISO50001" , EcoCertificationEcoCertificate :: NordicSwanEcolabel => "NORDIC_SWAN_ECOLABEL" , EcoCertificationEcoCertificate :: PreferredByNatureSustainableTourism => "PREFERRED_BY_NATURE_SUSTAINABLE_TOURISM" , EcoCertificationEcoCertificate :: SustainableTravelIreland => "SUSTAINABLE_TRAVEL_IRELAND" , EcoCertificationEcoCertificate :: TofTigersInititivesPug => "TOF_TIGERS_INITITIVES_PUG" , EcoCertificationEcoCertificate :: Travelife => "TRAVELIFE" , EcoCertificationEcoCertificate :: UnitedCertificationSystemsLimited => "UNITED_CERTIFICATION_SYSTEMS_LIMITED" , EcoCertificationEcoCertificate :: VireoSrl => "VIREO_SRL" , }
        }
    }
    impl ::std::convert::AsRef<str> for EcoCertificationEcoCertificate {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EcoCertificationEcoCertificate {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<EcoCertificationEcoCertificate, ()> {
            Ok(match s {
                "ASIAN_ECOTOURISM" => EcoCertificationEcoCertificate::AsianEcotourism,
                "BIOSPHERE_RESPOSNIBLE_TOURISM" => {
                    EcoCertificationEcoCertificate::BiosphereResposnibleTourism
                }
                "BUREAU_VERITAS" => EcoCertificationEcoCertificate::BureauVeritas,
                "CONTROL_UNION" => EcoCertificationEcoCertificate::ControlUnion,
                "EARTHCHECK" => EcoCertificationEcoCertificate::Earthcheck,
                "ECO_CERTIFICATE_UNSPECIFIED" => {
                    EcoCertificationEcoCertificate::EcoCertificateUnspecified
                }
                "ECO_CERTIFICATION_MALTA" => EcoCertificationEcoCertificate::EcoCertificationMalta,
                "ECOTOURISM_AUSTRALIAS_ECO" => {
                    EcoCertificationEcoCertificate::EcotourismAustraliasEco
                }
                "GREAT_GREEN_DEAL" => EcoCertificationEcoCertificate::GreatGreenDeal,
                "GREEN_GLOBE" => EcoCertificationEcoCertificate::GreenGlobe,
                "GREEN_GROWTH2050" => EcoCertificationEcoCertificate::GreenGrowth2050,
                "GREEN_KEY" => EcoCertificationEcoCertificate::GreenKey,
                "GREEN_KEY_ECO_RATING" => EcoCertificationEcoCertificate::GreenKeyEcoRating,
                "GREEN_SEAL" => EcoCertificationEcoCertificate::GreenSeal,
                "GREEN_STAR" => EcoCertificationEcoCertificate::GreenStar,
                "GREEN_TOURISM_ACTIVE" => EcoCertificationEcoCertificate::GreenTourismActive,
                "HILTON_LIGHTSTAY" => EcoCertificationEcoCertificate::HiltonLightstay,
                "HOSTELLING_INTERNATIONALS_QUALITY_AND_SUSTAINABILITY" => {
                    EcoCertificationEcoCertificate::HostellingInternationalsQualityAndSustainability
                }
                "HOTELES_MAS_VERDES" => EcoCertificationEcoCertificate::HotelesMasVerdes,
                "ISO14001" => EcoCertificationEcoCertificate::Iso14001,
                "ISO50001" => EcoCertificationEcoCertificate::Iso50001,
                "NORDIC_SWAN_ECOLABEL" => EcoCertificationEcoCertificate::NordicSwanEcolabel,
                "PREFERRED_BY_NATURE_SUSTAINABLE_TOURISM" => {
                    EcoCertificationEcoCertificate::PreferredByNatureSustainableTourism
                }
                "SUSTAINABLE_TRAVEL_IRELAND" => {
                    EcoCertificationEcoCertificate::SustainableTravelIreland
                }
                "TOF_TIGERS_INITITIVES_PUG" => {
                    EcoCertificationEcoCertificate::TofTigersInititivesPug
                }
                "TRAVELIFE" => EcoCertificationEcoCertificate::Travelife,
                "UNITED_CERTIFICATION_SYSTEMS_LIMITED" => {
                    EcoCertificationEcoCertificate::UnitedCertificationSystemsLimited
                }
                "VIREO_SRL" => EcoCertificationEcoCertificate::VireoSrl,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EcoCertificationEcoCertificate {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EcoCertificationEcoCertificate {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EcoCertificationEcoCertificate {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "ASIAN_ECOTOURISM" => EcoCertificationEcoCertificate::AsianEcotourism,
                "BIOSPHERE_RESPOSNIBLE_TOURISM" => {
                    EcoCertificationEcoCertificate::BiosphereResposnibleTourism
                }
                "BUREAU_VERITAS" => EcoCertificationEcoCertificate::BureauVeritas,
                "CONTROL_UNION" => EcoCertificationEcoCertificate::ControlUnion,
                "EARTHCHECK" => EcoCertificationEcoCertificate::Earthcheck,
                "ECO_CERTIFICATE_UNSPECIFIED" => {
                    EcoCertificationEcoCertificate::EcoCertificateUnspecified
                }
                "ECO_CERTIFICATION_MALTA" => EcoCertificationEcoCertificate::EcoCertificationMalta,
                "ECOTOURISM_AUSTRALIAS_ECO" => {
                    EcoCertificationEcoCertificate::EcotourismAustraliasEco
                }
                "GREAT_GREEN_DEAL" => EcoCertificationEcoCertificate::GreatGreenDeal,
                "GREEN_GLOBE" => EcoCertificationEcoCertificate::GreenGlobe,
                "GREEN_GROWTH2050" => EcoCertificationEcoCertificate::GreenGrowth2050,
                "GREEN_KEY" => EcoCertificationEcoCertificate::GreenKey,
                "GREEN_KEY_ECO_RATING" => EcoCertificationEcoCertificate::GreenKeyEcoRating,
                "GREEN_SEAL" => EcoCertificationEcoCertificate::GreenSeal,
                "GREEN_STAR" => EcoCertificationEcoCertificate::GreenStar,
                "GREEN_TOURISM_ACTIVE" => EcoCertificationEcoCertificate::GreenTourismActive,
                "HILTON_LIGHTSTAY" => EcoCertificationEcoCertificate::HiltonLightstay,
                "HOSTELLING_INTERNATIONALS_QUALITY_AND_SUSTAINABILITY" => {
                    EcoCertificationEcoCertificate::HostellingInternationalsQualityAndSustainability
                }
                "HOTELES_MAS_VERDES" => EcoCertificationEcoCertificate::HotelesMasVerdes,
                "ISO14001" => EcoCertificationEcoCertificate::Iso14001,
                "ISO50001" => EcoCertificationEcoCertificate::Iso50001,
                "NORDIC_SWAN_ECOLABEL" => EcoCertificationEcoCertificate::NordicSwanEcolabel,
                "PREFERRED_BY_NATURE_SUSTAINABLE_TOURISM" => {
                    EcoCertificationEcoCertificate::PreferredByNatureSustainableTourism
                }
                "SUSTAINABLE_TRAVEL_IRELAND" => {
                    EcoCertificationEcoCertificate::SustainableTravelIreland
                }
                "TOF_TIGERS_INITITIVES_PUG" => {
                    EcoCertificationEcoCertificate::TofTigersInititivesPug
                }
                "TRAVELIFE" => EcoCertificationEcoCertificate::Travelife,
                "UNITED_CERTIFICATION_SYSTEMS_LIMITED" => {
                    EcoCertificationEcoCertificate::UnitedCertificationSystemsLimited
                }
                "VIREO_SRL" => EcoCertificationEcoCertificate::VireoSrl,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EcoCertificationEcoCertificate {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EcoCertificationEcoCertificate {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnergyEfficiency {
        #[doc = "Carbon free energy sources. Property sources carbon-free electricity via at least one of the following methods: on-site clean energy generation, power purchase agreement(s) with clean energy generators, green power provided by electricity supplier, or purchases of Energy Attribute Certificates (such as Renewable Energy Certificates or Guarantees of Origin)."]
        #[serde(
            rename = "carbonFreeEnergySources",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub carbon_free_energy_sources: ::std::option::Option<bool>,
        #[doc = "Carbon free energy sources exception."]
        #[serde(
            rename = "carbonFreeEnergySourcesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub carbon_free_energy_sources_exception:
            ::std::option::Option<crate::schemas::EnergyEfficiencyCarbonFreeEnergySourcesException>,
        #[doc = "Energy conservation program. The property tracks corporate-level Scope 1 and 2 GHG emissions, and Scope 3 emissions if available. The property has a commitment to implement initiatives that reduce GHG emissions year over year. The property has shown an absolute reduction in emissions for at least 2 years. Emissions are either verfied by a third-party and/or published in external communications."]
        #[serde(
            rename = "energyConservationProgram",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_conservation_program: ::std::option::Option<bool>,
        #[doc = "Energy conservation program exception."]
        #[serde(
            rename = "energyConservationProgramException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_conservation_program_exception: ::std::option::Option<
            crate::schemas::EnergyEfficiencyEnergyConservationProgramException,
        >,
        #[doc = "Energy efficient heating and cooling systems. The property doesn't use chlorofluorocarbon (CFC)-based refrigerants in heating, ventilating, and air-conditioning systems unless a third-party audit shows it's not economically feasible. The CFC-based refrigerants which are used should have a Global Warming Potential (GWP) ≤ 10. The property uses occupancy sensors on HVAC systems in back-of-house spaces, meeting rooms, and other low-traffic areas."]
        #[serde(
            rename = "energyEfficientHeatingAndCoolingSystems",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_efficient_heating_and_cooling_systems: ::std::option::Option<bool>,
        #[doc = "Energy efficient heating and cooling systems exception."]
        #[serde(
            rename = "energyEfficientHeatingAndCoolingSystemsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_efficient_heating_and_cooling_systems_exception: ::std::option::Option<
            crate::schemas::EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException,
        >,
        #[doc = "Energy efficient lighting. At least 75% of the property's lighting is energy efficient, using lighting that is more than 45 lumens per watt – typically LED or CFL lightbulbs."]
        #[serde(
            rename = "energyEfficientLighting",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_efficient_lighting: ::std::option::Option<bool>,
        #[doc = "Energy efficient lighting exception."]
        #[serde(
            rename = "energyEfficientLightingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_efficient_lighting_exception:
            ::std::option::Option<crate::schemas::EnergyEfficiencyEnergyEfficientLightingException>,
        #[doc = "Energy saving thermostats. The property installed energy-saving thermostats throughout the building to conserve energy when rooms or areas are not in use. Energy-saving thermostats are devices that control heating/cooling in the building by learning temperature preferences and automatically adjusting to energy-saving temperatures as the default. The thermostats are automatically set to a temperature between 68-78 degrees F (20-26 °C), depending on seasonality. In the winter, set the thermostat to 68°F (20°C) when the room is occupied, lowering room temperature when unoccupied. In the summer, set the thermostat to 78°F (26°C) when the room is occupied."]
        #[serde(
            rename = "energySavingThermostats",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_saving_thermostats: ::std::option::Option<bool>,
        #[doc = "Energy saving thermostats exception."]
        #[serde(
            rename = "energySavingThermostatsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_saving_thermostats_exception:
            ::std::option::Option<crate::schemas::EnergyEfficiencyEnergySavingThermostatsException>,
        #[doc = "Output only. Green building design. True if BREEAM-* or LEED-* certified."]
        #[serde(
            rename = "greenBuildingDesign",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub green_building_design: ::std::option::Option<bool>,
        #[doc = "Output only. Green building design exception."]
        #[serde(
            rename = "greenBuildingDesignException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub green_building_design_exception:
            ::std::option::Option<crate::schemas::EnergyEfficiencyGreenBuildingDesignException>,
        #[doc = "Independent organization audits energy use. The property conducts an energy audit at least every 5 years, the results of which are either verified by a third-party and/or published in external communications. An energy audit is a detailed assessment of the facility which provides recommendations to existing operations and procedures to improve energy efficiency, available incentives or rebates,and opportunities for improvements through renovations or upgrades. Examples of organizations that conduct credible third party audits include: Engie Impact, DNV GL (EU), Dexma, and local utility providers (they often provide energy and water audits)."]
        #[serde(
            rename = "independentOrganizationAuditsEnergyUse",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub independent_organization_audits_energy_use: ::std::option::Option<bool>,
        #[doc = "Independent organization audits energy use exception."]
        #[serde(
            rename = "independentOrganizationAuditsEnergyUseException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub independent_organization_audits_energy_use_exception: ::std::option::Option<
            crate::schemas::EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnergyEfficiency {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnergyEfficiency {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnergyEfficiencyCarbonFreeEnergySourcesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnergyEfficiencyCarbonFreeEnergySourcesException {
        pub fn as_str(self) -> &'static str {
            match self {
                EnergyEfficiencyCarbonFreeEnergySourcesException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EnergyEfficiencyCarbonFreeEnergySourcesException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                EnergyEfficiencyCarbonFreeEnergySourcesException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                EnergyEfficiencyCarbonFreeEnergySourcesException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnergyEfficiencyCarbonFreeEnergySourcesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnergyEfficiencyCarbonFreeEnergySourcesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnergyEfficiencyCarbonFreeEnergySourcesException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyCarbonFreeEnergySourcesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyCarbonFreeEnergySourcesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyCarbonFreeEnergySourcesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyCarbonFreeEnergySourcesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnergyEfficiencyCarbonFreeEnergySourcesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnergyEfficiencyCarbonFreeEnergySourcesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnergyEfficiencyCarbonFreeEnergySourcesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyCarbonFreeEnergySourcesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyCarbonFreeEnergySourcesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyCarbonFreeEnergySourcesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyCarbonFreeEnergySourcesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnergyEfficiencyCarbonFreeEnergySourcesException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnergyEfficiencyCarbonFreeEnergySourcesException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnergyEfficiencyEnergyConservationProgramException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnergyEfficiencyEnergyConservationProgramException {
        pub fn as_str(self) -> &'static str {
            match self {
                EnergyEfficiencyEnergyConservationProgramException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EnergyEfficiencyEnergyConservationProgramException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                EnergyEfficiencyEnergyConservationProgramException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                EnergyEfficiencyEnergyConservationProgramException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnergyEfficiencyEnergyConservationProgramException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnergyEfficiencyEnergyConservationProgramException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnergyEfficiencyEnergyConservationProgramException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyEnergyConservationProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyEnergyConservationProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyEnergyConservationProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyEnergyConservationProgramException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnergyEfficiencyEnergyConservationProgramException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnergyEfficiencyEnergyConservationProgramException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnergyEfficiencyEnergyConservationProgramException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyEnergyConservationProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyEnergyConservationProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyEnergyConservationProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyEnergyConservationProgramException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnergyEfficiencyEnergyConservationProgramException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnergyEfficiencyEnergyConservationProgramException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException {
        pub fn as_str(self) -> &'static str {
            match self { EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException,
            (),
        > {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnergyEfficiencyEnergyEfficientHeatingAndCoolingSystemsException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnergyEfficiencyEnergyEfficientLightingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnergyEfficiencyEnergyEfficientLightingException {
        pub fn as_str(self) -> &'static str {
            match self {
                EnergyEfficiencyEnergyEfficientLightingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EnergyEfficiencyEnergyEfficientLightingException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                EnergyEfficiencyEnergyEfficientLightingException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                EnergyEfficiencyEnergyEfficientLightingException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnergyEfficiencyEnergyEfficientLightingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnergyEfficiencyEnergyEfficientLightingException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnergyEfficiencyEnergyEfficientLightingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyEnergyEfficientLightingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyEnergyEfficientLightingException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyEnergyEfficientLightingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyEnergyEfficientLightingException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnergyEfficiencyEnergyEfficientLightingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnergyEfficiencyEnergyEfficientLightingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnergyEfficiencyEnergyEfficientLightingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyEnergyEfficientLightingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyEnergyEfficientLightingException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyEnergyEfficientLightingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyEnergyEfficientLightingException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnergyEfficiencyEnergyEfficientLightingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnergyEfficiencyEnergyEfficientLightingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnergyEfficiencyEnergySavingThermostatsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnergyEfficiencyEnergySavingThermostatsException {
        pub fn as_str(self) -> &'static str {
            match self {
                EnergyEfficiencyEnergySavingThermostatsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EnergyEfficiencyEnergySavingThermostatsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                EnergyEfficiencyEnergySavingThermostatsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                EnergyEfficiencyEnergySavingThermostatsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnergyEfficiencyEnergySavingThermostatsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnergyEfficiencyEnergySavingThermostatsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnergyEfficiencyEnergySavingThermostatsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyEnergySavingThermostatsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyEnergySavingThermostatsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyEnergySavingThermostatsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyEnergySavingThermostatsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnergyEfficiencyEnergySavingThermostatsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnergyEfficiencyEnergySavingThermostatsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnergyEfficiencyEnergySavingThermostatsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyEnergySavingThermostatsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyEnergySavingThermostatsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyEnergySavingThermostatsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyEnergySavingThermostatsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnergyEfficiencyEnergySavingThermostatsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnergyEfficiencyEnergySavingThermostatsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnergyEfficiencyGreenBuildingDesignException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnergyEfficiencyGreenBuildingDesignException {
        pub fn as_str(self) -> &'static str {
            match self {
                EnergyEfficiencyGreenBuildingDesignException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EnergyEfficiencyGreenBuildingDesignException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                EnergyEfficiencyGreenBuildingDesignException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                EnergyEfficiencyGreenBuildingDesignException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnergyEfficiencyGreenBuildingDesignException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnergyEfficiencyGreenBuildingDesignException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnergyEfficiencyGreenBuildingDesignException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyGreenBuildingDesignException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyGreenBuildingDesignException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyGreenBuildingDesignException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyGreenBuildingDesignException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnergyEfficiencyGreenBuildingDesignException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnergyEfficiencyGreenBuildingDesignException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnergyEfficiencyGreenBuildingDesignException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnergyEfficiencyGreenBuildingDesignException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnergyEfficiencyGreenBuildingDesignException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnergyEfficiencyGreenBuildingDesignException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnergyEfficiencyGreenBuildingDesignException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for EnergyEfficiencyGreenBuildingDesignException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnergyEfficiencyGreenBuildingDesignException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException {
        pub fn as_str(self) -> &'static str {
            match self { EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException,
            (),
        > {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnergyEfficiencyIndependentOrganizationAuditsEnergyUseException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct EnhancedCleaning {
        #[doc = "Commercial-grade disinfectant used to clean the property."]
        #[serde(
            rename = "commercialGradeDisinfectantCleaning",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub commercial_grade_disinfectant_cleaning: ::std::option::Option<bool>,
        #[doc = "Commercial grade disinfectant cleaning exception."]
        #[serde(
            rename = "commercialGradeDisinfectantCleaningException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub commercial_grade_disinfectant_cleaning_exception: ::std::option::Option<
            crate::schemas::EnhancedCleaningCommercialGradeDisinfectantCleaningException,
        >,
        #[doc = "Enhanced cleaning of common areas."]
        #[serde(
            rename = "commonAreasEnhancedCleaning",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_areas_enhanced_cleaning: ::std::option::Option<bool>,
        #[doc = "Common areas enhanced cleaning exception."]
        #[serde(
            rename = "commonAreasEnhancedCleaningException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_areas_enhanced_cleaning_exception: ::std::option::Option<
            crate::schemas::EnhancedCleaningCommonAreasEnhancedCleaningException,
        >,
        #[doc = "Employees trained in COVID-19 cleaning procedures."]
        #[serde(
            rename = "employeesTrainedCleaningProcedures",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub employees_trained_cleaning_procedures: ::std::option::Option<bool>,
        #[doc = "Employees trained cleaning procedures exception."]
        #[serde(
            rename = "employeesTrainedCleaningProceduresException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub employees_trained_cleaning_procedures_exception: ::std::option::Option<
            crate::schemas::EnhancedCleaningEmployeesTrainedCleaningProceduresException,
        >,
        #[doc = "Employees trained in thorough hand-washing."]
        #[serde(
            rename = "employeesTrainedThoroughHandWashing",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub employees_trained_thorough_hand_washing: ::std::option::Option<bool>,
        #[doc = "Employees trained thorough hand washing exception."]
        #[serde(
            rename = "employeesTrainedThoroughHandWashingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub employees_trained_thorough_hand_washing_exception: ::std::option::Option<
            crate::schemas::EnhancedCleaningEmployeesTrainedThoroughHandWashingException,
        >,
        #[doc = "Employees wear masks, face shields, and/or gloves."]
        #[serde(
            rename = "employeesWearProtectiveEquipment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub employees_wear_protective_equipment: ::std::option::Option<bool>,
        #[doc = "Employees wear protective equipment exception."]
        #[serde(
            rename = "employeesWearProtectiveEquipmentException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub employees_wear_protective_equipment_exception: ::std::option::Option<
            crate::schemas::EnhancedCleaningEmployeesWearProtectiveEquipmentException,
        >,
        #[doc = "Enhanced cleaning of guest rooms."]
        #[serde(
            rename = "guestRoomsEnhancedCleaning",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub guest_rooms_enhanced_cleaning: ::std::option::Option<bool>,
        #[doc = "Guest rooms enhanced cleaning exception."]
        #[serde(
            rename = "guestRoomsEnhancedCleaningException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub guest_rooms_enhanced_cleaning_exception: ::std::option::Option<
            crate::schemas::EnhancedCleaningGuestRoomsEnhancedCleaningException,
        >,
    }
    impl ::google_field_selector::FieldSelector for EnhancedCleaning {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnhancedCleaning {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnhancedCleaningCommercialGradeDisinfectantCleaningException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnhancedCleaningCommercialGradeDisinfectantCleaningException {
        pub fn as_str(self) -> &'static str {
            match self { EnhancedCleaningCommercialGradeDisinfectantCleaningException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , EnhancedCleaningCommercialGradeDisinfectantCleaningException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , EnhancedCleaningCommercialGradeDisinfectantCleaningException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , EnhancedCleaningCommercialGradeDisinfectantCleaningException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnhancedCleaningCommercialGradeDisinfectantCleaningException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnhancedCleaningCommercialGradeDisinfectantCleaningException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnhancedCleaningCommercialGradeDisinfectantCleaningException, ()>
        {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => EnhancedCleaningCommercialGradeDisinfectantCleaningException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnhancedCleaningCommercialGradeDisinfectantCleaningException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnhancedCleaningCommercialGradeDisinfectantCleaningException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnhancedCleaningCommercialGradeDisinfectantCleaningException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnhancedCleaningCommercialGradeDisinfectantCleaningException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnhancedCleaningCommercialGradeDisinfectantCleaningException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnhancedCleaningCommercialGradeDisinfectantCleaningException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => EnhancedCleaningCommercialGradeDisinfectantCleaningException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnhancedCleaningCommercialGradeDisinfectantCleaningException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnhancedCleaningCommercialGradeDisinfectantCleaningException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnhancedCleaningCommercialGradeDisinfectantCleaningException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnhancedCleaningCommercialGradeDisinfectantCleaningException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnhancedCleaningCommercialGradeDisinfectantCleaningException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnhancedCleaningCommonAreasEnhancedCleaningException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnhancedCleaningCommonAreasEnhancedCleaningException {
        pub fn as_str(self) -> &'static str {
            match self {
                EnhancedCleaningCommonAreasEnhancedCleaningException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EnhancedCleaningCommonAreasEnhancedCleaningException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                EnhancedCleaningCommonAreasEnhancedCleaningException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                EnhancedCleaningCommonAreasEnhancedCleaningException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnhancedCleaningCommonAreasEnhancedCleaningException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnhancedCleaningCommonAreasEnhancedCleaningException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnhancedCleaningCommonAreasEnhancedCleaningException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnhancedCleaningCommonAreasEnhancedCleaningException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnhancedCleaningCommonAreasEnhancedCleaningException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnhancedCleaningCommonAreasEnhancedCleaningException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnhancedCleaningCommonAreasEnhancedCleaningException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnhancedCleaningCommonAreasEnhancedCleaningException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnhancedCleaningCommonAreasEnhancedCleaningException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnhancedCleaningCommonAreasEnhancedCleaningException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnhancedCleaningCommonAreasEnhancedCleaningException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnhancedCleaningCommonAreasEnhancedCleaningException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnhancedCleaningCommonAreasEnhancedCleaningException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnhancedCleaningCommonAreasEnhancedCleaningException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnhancedCleaningCommonAreasEnhancedCleaningException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnhancedCleaningCommonAreasEnhancedCleaningException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnhancedCleaningEmployeesTrainedCleaningProceduresException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnhancedCleaningEmployeesTrainedCleaningProceduresException {
        pub fn as_str(self) -> &'static str {
            match self { EnhancedCleaningEmployeesTrainedCleaningProceduresException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , EnhancedCleaningEmployeesTrainedCleaningProceduresException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , EnhancedCleaningEmployeesTrainedCleaningProceduresException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , EnhancedCleaningEmployeesTrainedCleaningProceduresException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnhancedCleaningEmployeesTrainedCleaningProceduresException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnhancedCleaningEmployeesTrainedCleaningProceduresException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnhancedCleaningEmployeesTrainedCleaningProceduresException, ()>
        {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => EnhancedCleaningEmployeesTrainedCleaningProceduresException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnhancedCleaningEmployeesTrainedCleaningProceduresException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnhancedCleaningEmployeesTrainedCleaningProceduresException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnhancedCleaningEmployeesTrainedCleaningProceduresException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnhancedCleaningEmployeesTrainedCleaningProceduresException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnhancedCleaningEmployeesTrainedCleaningProceduresException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnhancedCleaningEmployeesTrainedCleaningProceduresException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => EnhancedCleaningEmployeesTrainedCleaningProceduresException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnhancedCleaningEmployeesTrainedCleaningProceduresException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnhancedCleaningEmployeesTrainedCleaningProceduresException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnhancedCleaningEmployeesTrainedCleaningProceduresException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnhancedCleaningEmployeesTrainedCleaningProceduresException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnhancedCleaningEmployeesTrainedCleaningProceduresException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnhancedCleaningEmployeesTrainedThoroughHandWashingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnhancedCleaningEmployeesTrainedThoroughHandWashingException {
        pub fn as_str(self) -> &'static str {
            match self { EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str> for EnhancedCleaningEmployeesTrainedThoroughHandWashingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnhancedCleaningEmployeesTrainedThoroughHandWashingException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnhancedCleaningEmployeesTrainedThoroughHandWashingException, ()>
        {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for EnhancedCleaningEmployeesTrainedThoroughHandWashingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnhancedCleaningEmployeesTrainedThoroughHandWashingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EnhancedCleaningEmployeesTrainedThoroughHandWashingException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => EnhancedCleaningEmployeesTrainedThoroughHandWashingException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnhancedCleaningEmployeesTrainedThoroughHandWashingException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnhancedCleaningEmployeesTrainedThoroughHandWashingException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnhancedCleaningEmployeesWearProtectiveEquipmentException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnhancedCleaningEmployeesWearProtectiveEquipmentException {
        pub fn as_str(self) -> &'static str {
            match self {
                EnhancedCleaningEmployeesWearProtectiveEquipmentException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EnhancedCleaningEmployeesWearProtectiveEquipmentException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                EnhancedCleaningEmployeesWearProtectiveEquipmentException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                EnhancedCleaningEmployeesWearProtectiveEquipmentException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnhancedCleaningEmployeesWearProtectiveEquipmentException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnhancedCleaningEmployeesWearProtectiveEquipmentException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnhancedCleaningEmployeesWearProtectiveEquipmentException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnhancedCleaningEmployeesWearProtectiveEquipmentException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnhancedCleaningEmployeesWearProtectiveEquipmentException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnhancedCleaningEmployeesWearProtectiveEquipmentException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnhancedCleaningEmployeesWearProtectiveEquipmentException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnhancedCleaningEmployeesWearProtectiveEquipmentException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnhancedCleaningEmployeesWearProtectiveEquipmentException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnhancedCleaningEmployeesWearProtectiveEquipmentException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnhancedCleaningEmployeesWearProtectiveEquipmentException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnhancedCleaningEmployeesWearProtectiveEquipmentException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnhancedCleaningEmployeesWearProtectiveEquipmentException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnhancedCleaningEmployeesWearProtectiveEquipmentException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnhancedCleaningEmployeesWearProtectiveEquipmentException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for EnhancedCleaningEmployeesWearProtectiveEquipmentException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum EnhancedCleaningGuestRoomsEnhancedCleaningException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl EnhancedCleaningGuestRoomsEnhancedCleaningException {
        pub fn as_str(self) -> &'static str {
            match self {
                EnhancedCleaningGuestRoomsEnhancedCleaningException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                EnhancedCleaningGuestRoomsEnhancedCleaningException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                EnhancedCleaningGuestRoomsEnhancedCleaningException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                EnhancedCleaningGuestRoomsEnhancedCleaningException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for EnhancedCleaningGuestRoomsEnhancedCleaningException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for EnhancedCleaningGuestRoomsEnhancedCleaningException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<EnhancedCleaningGuestRoomsEnhancedCleaningException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnhancedCleaningGuestRoomsEnhancedCleaningException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnhancedCleaningGuestRoomsEnhancedCleaningException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnhancedCleaningGuestRoomsEnhancedCleaningException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnhancedCleaningGuestRoomsEnhancedCleaningException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for EnhancedCleaningGuestRoomsEnhancedCleaningException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for EnhancedCleaningGuestRoomsEnhancedCleaningException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnhancedCleaningGuestRoomsEnhancedCleaningException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    EnhancedCleaningGuestRoomsEnhancedCleaningException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    EnhancedCleaningGuestRoomsEnhancedCleaningException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    EnhancedCleaningGuestRoomsEnhancedCleaningException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    EnhancedCleaningGuestRoomsEnhancedCleaningException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for EnhancedCleaningGuestRoomsEnhancedCleaningException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for EnhancedCleaningGuestRoomsEnhancedCleaningException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Families {
        #[doc = "Babysitting. Child care that is offered by hotel staffers or coordinated by hotel staffers with local child care professionals. Can be free or for a fee."]
        #[serde(
            rename = "babysitting",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub babysitting: ::std::option::Option<bool>,
        #[doc = "Babysitting exception."]
        #[serde(
            rename = "babysittingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub babysitting_exception:
            ::std::option::Option<crate::schemas::FamiliesBabysittingException>,
        #[doc = "Kids activities. Recreational options such as sports, films, crafts and games designed for the enjoyment of children and offered at the hotel. May or may not be supervised. May or may not be at a designated time or place. Cab be free or for a fee."]
        #[serde(
            rename = "kidsActivities",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kids_activities: ::std::option::Option<bool>,
        #[doc = "Kids activities exception."]
        #[serde(
            rename = "kidsActivitiesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kids_activities_exception:
            ::std::option::Option<crate::schemas::FamiliesKidsActivitiesException>,
        #[doc = "Kids club. An organized program of group activities held at the hotel and designed for the enjoyment of children. Facilitated by hotel staff (or staff procured by the hotel) in an area(s) designated for the purpose of entertaining children without their parents. May include games, outings, water sports, team sports, arts and crafts, and films. Usually has set hours. Can be free or for a fee. Also known as Kids Camp or Kids program."]
        #[serde(
            rename = "kidsClub",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kids_club: ::std::option::Option<bool>,
        #[doc = "Kids club exception."]
        #[serde(
            rename = "kidsClubException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kids_club_exception: ::std::option::Option<crate::schemas::FamiliesKidsClubException>,
    }
    impl ::google_field_selector::FieldSelector for Families {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Families {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FamiliesBabysittingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FamiliesBabysittingException {
        pub fn as_str(self) -> &'static str {
            match self {
                FamiliesBabysittingException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                FamiliesBabysittingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FamiliesBabysittingException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FamiliesBabysittingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FamiliesBabysittingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FamiliesBabysittingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FamiliesBabysittingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => FamiliesBabysittingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FamiliesBabysittingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FamiliesBabysittingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FamiliesBabysittingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FamiliesBabysittingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FamiliesBabysittingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FamiliesBabysittingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => FamiliesBabysittingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FamiliesBabysittingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FamiliesBabysittingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FamiliesBabysittingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FamiliesBabysittingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FamiliesBabysittingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FamiliesKidsActivitiesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FamiliesKidsActivitiesException {
        pub fn as_str(self) -> &'static str {
            match self {
                FamiliesKidsActivitiesException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                FamiliesKidsActivitiesException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FamiliesKidsActivitiesException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FamiliesKidsActivitiesException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FamiliesKidsActivitiesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FamiliesKidsActivitiesException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FamiliesKidsActivitiesException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => FamiliesKidsActivitiesException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FamiliesKidsActivitiesException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FamiliesKidsActivitiesException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FamiliesKidsActivitiesException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FamiliesKidsActivitiesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FamiliesKidsActivitiesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FamiliesKidsActivitiesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => FamiliesKidsActivitiesException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FamiliesKidsActivitiesException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FamiliesKidsActivitiesException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FamiliesKidsActivitiesException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FamiliesKidsActivitiesException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FamiliesKidsActivitiesException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FamiliesKidsClubException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FamiliesKidsClubException {
        pub fn as_str(self) -> &'static str {
            match self {
                FamiliesKidsClubException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                FamiliesKidsClubException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FamiliesKidsClubException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FamiliesKidsClubException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FamiliesKidsClubException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FamiliesKidsClubException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FamiliesKidsClubException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => FamiliesKidsClubException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FamiliesKidsClubException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FamiliesKidsClubException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FamiliesKidsClubException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FamiliesKidsClubException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FamiliesKidsClubException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FamiliesKidsClubException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => FamiliesKidsClubException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FamiliesKidsClubException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FamiliesKidsClubException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FamiliesKidsClubException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FamiliesKidsClubException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FamiliesKidsClubException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FoodAndDrink {
        #[doc = "Bar. A designated room, lounge or area of an on-site restaurant with seating at a counter behind which a hotel staffer takes the guest's order and provides the requested alcoholic drink. Can be indoors or outdoors. Also known as Pub."]
        #[serde(
            rename = "bar",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bar: ::std::option::Option<bool>,
        #[doc = "Bar exception."]
        #[serde(
            rename = "barException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bar_exception: ::std::option::Option<crate::schemas::FoodAndDrinkBarException>,
        #[doc = "Breakfast available. The morning meal is offered to all guests. Can be free or for a fee."]
        #[serde(
            rename = "breakfastAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub breakfast_available: ::std::option::Option<bool>,
        #[doc = "Breakfast available exception."]
        #[serde(
            rename = "breakfastAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub breakfast_available_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkBreakfastAvailableException>,
        #[doc = "Breakfast buffet. Breakfast meal service where guests serve themselves from a variety of dishes/foods that are put out on a table."]
        #[serde(
            rename = "breakfastBuffet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub breakfast_buffet: ::std::option::Option<bool>,
        #[doc = "Breakfast buffet exception."]
        #[serde(
            rename = "breakfastBuffetException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub breakfast_buffet_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkBreakfastBuffetException>,
        #[doc = "Buffet. A type of meal where guests serve themselves from a variety of dishes/foods that are put out on a table. Includes lunch and/or dinner meals. A breakfast-only buffet is not sufficient."]
        #[serde(
            rename = "buffet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub buffet: ::std::option::Option<bool>,
        #[doc = "Buffet exception."]
        #[serde(
            rename = "buffetException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub buffet_exception: ::std::option::Option<crate::schemas::FoodAndDrinkBuffetException>,
        #[doc = "Dinner buffet. Dinner meal service where guests serve themselves from a variety of dishes/foods that are put out on a table."]
        #[serde(
            rename = "dinnerBuffet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dinner_buffet: ::std::option::Option<bool>,
        #[doc = "Dinner buffet exception."]
        #[serde(
            rename = "dinnerBuffetException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dinner_buffet_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkDinnerBuffetException>,
        #[doc = "Free breakfast. Breakfast is offered for free to all guests. Does not apply if limited to certain room packages."]
        #[serde(
            rename = "freeBreakfast",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_breakfast: ::std::option::Option<bool>,
        #[doc = "Free breakfast exception."]
        #[serde(
            rename = "freeBreakfastException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_breakfast_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkFreeBreakfastException>,
        #[doc = "Restaurant. A business onsite at the hotel that is open to the public as well as guests, and offers meals and beverages to consume at tables or counters. May or may not include table service. Also known as cafe, buffet, eatery. A \"breakfast room\" where the hotel serves breakfast only to guests (not the general public) does not count as a restaurant."]
        #[serde(
            rename = "restaurant",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub restaurant: ::std::option::Option<bool>,
        #[doc = "Restaurant exception."]
        #[serde(
            rename = "restaurantException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub restaurant_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkRestaurantException>,
        #[doc = "Restaurants count. The number of restaurants at the hotel."]
        #[serde(
            rename = "restaurantsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub restaurants_count: ::std::option::Option<i32>,
        #[doc = "Restaurants count exception."]
        #[serde(
            rename = "restaurantsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub restaurants_count_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkRestaurantsCountException>,
        #[doc = "Room service. A hotel staffer delivers meals prepared onsite to a guest's room as per their request. May or may not be available during specific hours. Services should be available to all guests (not based on rate/room booked/reward program, etc)."]
        #[serde(
            rename = "roomService",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub room_service: ::std::option::Option<bool>,
        #[doc = "Room service exception."]
        #[serde(
            rename = "roomServiceException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub room_service_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkRoomServiceException>,
        #[doc = "Table service. A restaurant in which a staff member is assigned to a guest's table to take their order, deliver and clear away food, and deliver the bill, if applicable. Also known as sit-down restaurant."]
        #[serde(
            rename = "tableService",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub table_service: ::std::option::Option<bool>,
        #[doc = "Table service exception."]
        #[serde(
            rename = "tableServiceException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub table_service_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkTableServiceException>,
        #[doc = "24hr room service. Room service is available 24 hours a day."]
        #[serde(
            rename = "twentyFourHourRoomService",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub twenty_four_hour_room_service: ::std::option::Option<bool>,
        #[doc = "24hr room service exception."]
        #[serde(
            rename = "twentyFourHourRoomServiceException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub twenty_four_hour_room_service_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkTwentyFourHourRoomServiceException>,
        #[doc = "Vending machine. A glass-fronted mechanized cabinet displaying and dispensing snacks and beverages for purchase by coins, paper money and/or credit cards."]
        #[serde(
            rename = "vendingMachine",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vending_machine: ::std::option::Option<bool>,
        #[doc = "Vending machine exception."]
        #[serde(
            rename = "vendingMachineException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vending_machine_exception:
            ::std::option::Option<crate::schemas::FoodAndDrinkVendingMachineException>,
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrink {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrink {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkBarException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkBarException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkBarException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                FoodAndDrinkBarException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkBarException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FoodAndDrinkBarException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkBarException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkBarException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkBarException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => FoodAndDrinkBarException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FoodAndDrinkBarException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkBarException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkBarException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkBarException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkBarException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkBarException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => FoodAndDrinkBarException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FoodAndDrinkBarException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkBarException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkBarException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkBarException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkBarException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkBreakfastAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkBreakfastAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkBreakfastAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkBreakfastAvailableException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkBreakfastAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                FoodAndDrinkBreakfastAvailableException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkBreakfastAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkBreakfastAvailableException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkBreakfastAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkBreakfastAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkBreakfastAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkBreakfastAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => FoodAndDrinkBreakfastAvailableException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkBreakfastAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkBreakfastAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkBreakfastAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkBreakfastAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkBreakfastAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkBreakfastAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => FoodAndDrinkBreakfastAvailableException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkBreakfastAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkBreakfastAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkBreakfastBuffetException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkBreakfastBuffetException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkBreakfastBuffetException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkBreakfastBuffetException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkBreakfastBuffetException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                FoodAndDrinkBreakfastBuffetException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkBreakfastBuffetException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkBreakfastBuffetException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkBreakfastBuffetException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkBreakfastBuffetException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkBreakfastBuffetException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkBreakfastBuffetException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => FoodAndDrinkBreakfastBuffetException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkBreakfastBuffetException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkBreakfastBuffetException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkBreakfastBuffetException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkBreakfastBuffetException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkBreakfastBuffetException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkBreakfastBuffetException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => FoodAndDrinkBreakfastBuffetException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkBreakfastBuffetException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkBreakfastBuffetException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkBuffetException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkBuffetException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkBuffetException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                FoodAndDrinkBuffetException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkBuffetException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FoodAndDrinkBuffetException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkBuffetException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkBuffetException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkBuffetException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => FoodAndDrinkBuffetException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FoodAndDrinkBuffetException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkBuffetException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkBuffetException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkBuffetException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkBuffetException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkBuffetException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => FoodAndDrinkBuffetException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FoodAndDrinkBuffetException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkBuffetException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkBuffetException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkBuffetException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkBuffetException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkDinnerBuffetException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkDinnerBuffetException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkDinnerBuffetException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkDinnerBuffetException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkDinnerBuffetException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FoodAndDrinkDinnerBuffetException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkDinnerBuffetException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkDinnerBuffetException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkDinnerBuffetException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkDinnerBuffetException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkDinnerBuffetException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkDinnerBuffetException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkDinnerBuffetException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkDinnerBuffetException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkDinnerBuffetException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkDinnerBuffetException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkDinnerBuffetException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkDinnerBuffetException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkDinnerBuffetException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkDinnerBuffetException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkDinnerBuffetException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkDinnerBuffetException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkFreeBreakfastException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkFreeBreakfastException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkFreeBreakfastException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkFreeBreakfastException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkFreeBreakfastException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FoodAndDrinkFreeBreakfastException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkFreeBreakfastException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkFreeBreakfastException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkFreeBreakfastException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkFreeBreakfastException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkFreeBreakfastException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkFreeBreakfastException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkFreeBreakfastException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkFreeBreakfastException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkFreeBreakfastException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkFreeBreakfastException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkFreeBreakfastException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkFreeBreakfastException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkFreeBreakfastException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkFreeBreakfastException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkFreeBreakfastException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkFreeBreakfastException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkRestaurantException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkRestaurantException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkRestaurantException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                FoodAndDrinkRestaurantException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkRestaurantException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FoodAndDrinkRestaurantException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkRestaurantException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkRestaurantException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkRestaurantException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => FoodAndDrinkRestaurantException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FoodAndDrinkRestaurantException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkRestaurantException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkRestaurantException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkRestaurantException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkRestaurantException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkRestaurantException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => FoodAndDrinkRestaurantException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => FoodAndDrinkRestaurantException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkRestaurantException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkRestaurantException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkRestaurantException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkRestaurantException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkRestaurantsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkRestaurantsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkRestaurantsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkRestaurantsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkRestaurantsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                FoodAndDrinkRestaurantsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkRestaurantsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkRestaurantsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkRestaurantsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkRestaurantsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkRestaurantsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkRestaurantsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => FoodAndDrinkRestaurantsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkRestaurantsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkRestaurantsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkRestaurantsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkRestaurantsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkRestaurantsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkRestaurantsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => FoodAndDrinkRestaurantsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkRestaurantsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkRestaurantsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkRoomServiceException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkRoomServiceException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkRoomServiceException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkRoomServiceException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkRoomServiceException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FoodAndDrinkRoomServiceException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkRoomServiceException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkRoomServiceException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkRoomServiceException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkRoomServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkRoomServiceException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkRoomServiceException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkRoomServiceException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkRoomServiceException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkRoomServiceException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkRoomServiceException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkRoomServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkRoomServiceException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkRoomServiceException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkRoomServiceException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkRoomServiceException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkRoomServiceException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkTableServiceException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkTableServiceException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkTableServiceException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkTableServiceException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkTableServiceException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                FoodAndDrinkTableServiceException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkTableServiceException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkTableServiceException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkTableServiceException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkTableServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkTableServiceException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkTableServiceException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkTableServiceException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkTableServiceException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkTableServiceException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkTableServiceException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkTableServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkTableServiceException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => FoodAndDrinkTableServiceException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => FoodAndDrinkTableServiceException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkTableServiceException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkTableServiceException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkTwentyFourHourRoomServiceException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkTwentyFourHourRoomServiceException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkTwentyFourHourRoomServiceException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkTwentyFourHourRoomServiceException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                FoodAndDrinkTwentyFourHourRoomServiceException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                FoodAndDrinkTwentyFourHourRoomServiceException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkTwentyFourHourRoomServiceException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkTwentyFourHourRoomServiceException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<FoodAndDrinkTwentyFourHourRoomServiceException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkTwentyFourHourRoomServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    FoodAndDrinkTwentyFourHourRoomServiceException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkTwentyFourHourRoomServiceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    FoodAndDrinkTwentyFourHourRoomServiceException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkTwentyFourHourRoomServiceException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkTwentyFourHourRoomServiceException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkTwentyFourHourRoomServiceException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkTwentyFourHourRoomServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    FoodAndDrinkTwentyFourHourRoomServiceException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkTwentyFourHourRoomServiceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    FoodAndDrinkTwentyFourHourRoomServiceException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkTwentyFourHourRoomServiceException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkTwentyFourHourRoomServiceException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum FoodAndDrinkVendingMachineException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl FoodAndDrinkVendingMachineException {
        pub fn as_str(self) -> &'static str {
            match self {
                FoodAndDrinkVendingMachineException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                FoodAndDrinkVendingMachineException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                FoodAndDrinkVendingMachineException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                FoodAndDrinkVendingMachineException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for FoodAndDrinkVendingMachineException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for FoodAndDrinkVendingMachineException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<FoodAndDrinkVendingMachineException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkVendingMachineException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkVendingMachineException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkVendingMachineException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => FoodAndDrinkVendingMachineException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for FoodAndDrinkVendingMachineException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for FoodAndDrinkVendingMachineException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FoodAndDrinkVendingMachineException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    FoodAndDrinkVendingMachineException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => FoodAndDrinkVendingMachineException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    FoodAndDrinkVendingMachineException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => FoodAndDrinkVendingMachineException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for FoodAndDrinkVendingMachineException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for FoodAndDrinkVendingMachineException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GetGoogleUpdatedLodgingResponse {
        #[doc = "Required. The fields in the Lodging that have been updated by Google. Repeated field items are not individually specified."]
        #[serde(
            rename = "diffMask",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub diff_mask: ::std::option::Option<String>,
        #[doc = "Required. The Google updated Lodging."]
        #[serde(
            rename = "lodging",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lodging: ::std::option::Option<crate::schemas::Lodging>,
    }
    impl ::google_field_selector::FieldSelector for GetGoogleUpdatedLodgingResponse {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GetGoogleUpdatedLodgingResponse {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GuestUnitFeatures {
        #[doc = "Bungalow or villa. An independent structure that is part of a hotel or resort that is rented to one party for a vacation stay. The hotel or resort may be completely comprised of bungalows or villas, or they may be one of several guestroom options. Guests in the bungalows or villas most often have the same, if not more, amenities and services offered to guests in other guestroom types."]
        #[serde(
            rename = "bungalowOrVilla",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bungalow_or_villa: ::std::option::Option<bool>,
        #[doc = "Bungalow or villa exception."]
        #[serde(
            rename = "bungalowOrVillaException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bungalow_or_villa_exception:
            ::std::option::Option<crate::schemas::GuestUnitFeaturesBungalowOrVillaException>,
        #[doc = "Connecting unit available. A guestroom type that features access to an adjacent guestroom for the purpose of booking both rooms. Most often used by families who need more than one room to accommodate the number of people in their group."]
        #[serde(
            rename = "connectingUnitAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connecting_unit_available: ::std::option::Option<bool>,
        #[doc = "Connecting unit available exception."]
        #[serde(
            rename = "connectingUnitAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connecting_unit_available_exception: ::std::option::Option<
            crate::schemas::GuestUnitFeaturesConnectingUnitAvailableException,
        >,
        #[doc = "Executive floor. A floor of the hotel where the guestrooms are only bookable by members of the hotel's frequent guest membership program. Benefits of this room class include access to a designated lounge which may or may not feature free breakfast, cocktails or other perks specific to members of the program."]
        #[serde(
            rename = "executiveFloor",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub executive_floor: ::std::option::Option<bool>,
        #[doc = "Executive floor exception."]
        #[serde(
            rename = "executiveFloorException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub executive_floor_exception:
            ::std::option::Option<crate::schemas::GuestUnitFeaturesExecutiveFloorException>,
        #[doc = "Max adult occupants count. The total number of adult guests allowed to stay overnight in the guestroom."]
        #[serde(
            rename = "maxAdultOccupantsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_adult_occupants_count: ::std::option::Option<i32>,
        #[doc = "Max adult occupants count exception."]
        #[serde(
            rename = "maxAdultOccupantsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_adult_occupants_count_exception:
            ::std::option::Option<crate::schemas::GuestUnitFeaturesMaxAdultOccupantsCountException>,
        #[doc = "Max child occupants count. The total number of children allowed to stay overnight in the room."]
        #[serde(
            rename = "maxChildOccupantsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_child_occupants_count: ::std::option::Option<i32>,
        #[doc = "Max child occupants count exception."]
        #[serde(
            rename = "maxChildOccupantsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_child_occupants_count_exception:
            ::std::option::Option<crate::schemas::GuestUnitFeaturesMaxChildOccupantsCountException>,
        #[doc = "Max occupants count. The total number of guests allowed to stay overnight in the guestroom."]
        #[serde(
            rename = "maxOccupantsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_occupants_count: ::std::option::Option<i32>,
        #[doc = "Max occupants count exception."]
        #[serde(
            rename = "maxOccupantsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_occupants_count_exception:
            ::std::option::Option<crate::schemas::GuestUnitFeaturesMaxOccupantsCountException>,
        #[doc = "Private home. A privately owned home (house, townhouse, apartment, cabin, bungalow etc) that may or not serve as the owner's residence, but is rented out in its entirety or by the room(s) to paying guest(s) for vacation stays. Not for lease-based, long-term residency."]
        #[serde(
            rename = "privateHome",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_home: ::std::option::Option<bool>,
        #[doc = "Private home exception."]
        #[serde(
            rename = "privateHomeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_home_exception:
            ::std::option::Option<crate::schemas::GuestUnitFeaturesPrivateHomeException>,
        #[doc = "Suite. A guestroom category that implies both a bedroom area and a separate living area. There may or may not be full walls and doors separating the two areas, but regardless, they are very distinct. Does not mean a couch or chair in a bedroom."]
        #[serde(
            rename = "suite",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suite: ::std::option::Option<bool>,
        #[doc = "Suite exception."]
        #[serde(
            rename = "suiteException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub suite_exception: ::std::option::Option<crate::schemas::GuestUnitFeaturesSuiteException>,
        #[doc = "Tier. Classification of the unit based on available features/amenities. A non-standard tier is only permitted if at least one other unit type falls under the standard tier."]
        #[serde(
            rename = "tier",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tier: ::std::option::Option<crate::schemas::GuestUnitFeaturesTier>,
        #[doc = "Tier exception."]
        #[serde(
            rename = "tierException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tier_exception: ::std::option::Option<crate::schemas::GuestUnitFeaturesTierException>,
        #[doc = "Features available in the living areas in the guest unit."]
        #[serde(
            rename = "totalLivingAreas",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub total_living_areas: ::std::option::Option<crate::schemas::LivingArea>,
        #[doc = "Views available from the guest unit itself."]
        #[serde(
            rename = "views",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub views: ::std::option::Option<crate::schemas::ViewsFromUnit>,
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeatures {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeatures {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesBungalowOrVillaException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesBungalowOrVillaException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesBungalowOrVillaException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                GuestUnitFeaturesBungalowOrVillaException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                GuestUnitFeaturesBungalowOrVillaException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                GuestUnitFeaturesBungalowOrVillaException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesBungalowOrVillaException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesBungalowOrVillaException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GuestUnitFeaturesBungalowOrVillaException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesBungalowOrVillaException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesBungalowOrVillaException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesBungalowOrVillaException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesBungalowOrVillaException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesBungalowOrVillaException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesBungalowOrVillaException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesBungalowOrVillaException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesBungalowOrVillaException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesBungalowOrVillaException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesBungalowOrVillaException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesBungalowOrVillaException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesBungalowOrVillaException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesBungalowOrVillaException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesConnectingUnitAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesConnectingUnitAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesConnectingUnitAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                GuestUnitFeaturesConnectingUnitAvailableException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                GuestUnitFeaturesConnectingUnitAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                GuestUnitFeaturesConnectingUnitAvailableException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesConnectingUnitAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesConnectingUnitAvailableException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GuestUnitFeaturesConnectingUnitAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesConnectingUnitAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesConnectingUnitAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesConnectingUnitAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesConnectingUnitAvailableException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesConnectingUnitAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesConnectingUnitAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesConnectingUnitAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesConnectingUnitAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesConnectingUnitAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesConnectingUnitAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesConnectingUnitAvailableException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesConnectingUnitAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesConnectingUnitAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesExecutiveFloorException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesExecutiveFloorException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesExecutiveFloorException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                GuestUnitFeaturesExecutiveFloorException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                GuestUnitFeaturesExecutiveFloorException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                GuestUnitFeaturesExecutiveFloorException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesExecutiveFloorException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesExecutiveFloorException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GuestUnitFeaturesExecutiveFloorException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesExecutiveFloorException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesExecutiveFloorException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesExecutiveFloorException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => GuestUnitFeaturesExecutiveFloorException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesExecutiveFloorException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesExecutiveFloorException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesExecutiveFloorException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesExecutiveFloorException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesExecutiveFloorException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesExecutiveFloorException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => GuestUnitFeaturesExecutiveFloorException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesExecutiveFloorException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesExecutiveFloorException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesMaxAdultOccupantsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesMaxAdultOccupantsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesMaxAdultOccupantsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                GuestUnitFeaturesMaxAdultOccupantsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                GuestUnitFeaturesMaxAdultOccupantsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                GuestUnitFeaturesMaxAdultOccupantsCountException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesMaxAdultOccupantsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesMaxAdultOccupantsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GuestUnitFeaturesMaxAdultOccupantsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesMaxAdultOccupantsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesMaxAdultOccupantsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesMaxAdultOccupantsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesMaxAdultOccupantsCountException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesMaxAdultOccupantsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesMaxAdultOccupantsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesMaxAdultOccupantsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesMaxAdultOccupantsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesMaxAdultOccupantsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesMaxAdultOccupantsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesMaxAdultOccupantsCountException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesMaxAdultOccupantsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesMaxAdultOccupantsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesMaxChildOccupantsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesMaxChildOccupantsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesMaxChildOccupantsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                GuestUnitFeaturesMaxChildOccupantsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                GuestUnitFeaturesMaxChildOccupantsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                GuestUnitFeaturesMaxChildOccupantsCountException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesMaxChildOccupantsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesMaxChildOccupantsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GuestUnitFeaturesMaxChildOccupantsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesMaxChildOccupantsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesMaxChildOccupantsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesMaxChildOccupantsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesMaxChildOccupantsCountException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesMaxChildOccupantsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesMaxChildOccupantsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesMaxChildOccupantsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesMaxChildOccupantsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesMaxChildOccupantsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesMaxChildOccupantsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesMaxChildOccupantsCountException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesMaxChildOccupantsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesMaxChildOccupantsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesMaxOccupantsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesMaxOccupantsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesMaxOccupantsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                GuestUnitFeaturesMaxOccupantsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                GuestUnitFeaturesMaxOccupantsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                GuestUnitFeaturesMaxOccupantsCountException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesMaxOccupantsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesMaxOccupantsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<GuestUnitFeaturesMaxOccupantsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesMaxOccupantsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesMaxOccupantsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesMaxOccupantsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesMaxOccupantsCountException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesMaxOccupantsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesMaxOccupantsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesMaxOccupantsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesMaxOccupantsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    GuestUnitFeaturesMaxOccupantsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesMaxOccupantsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    GuestUnitFeaturesMaxOccupantsCountException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesMaxOccupantsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesMaxOccupantsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesPrivateHomeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesPrivateHomeException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesPrivateHomeException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                GuestUnitFeaturesPrivateHomeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                GuestUnitFeaturesPrivateHomeException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                GuestUnitFeaturesPrivateHomeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesPrivateHomeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesPrivateHomeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GuestUnitFeaturesPrivateHomeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesPrivateHomeException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => GuestUnitFeaturesPrivateHomeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesPrivateHomeException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => GuestUnitFeaturesPrivateHomeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesPrivateHomeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesPrivateHomeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesPrivateHomeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    GuestUnitFeaturesPrivateHomeException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => GuestUnitFeaturesPrivateHomeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    GuestUnitFeaturesPrivateHomeException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => GuestUnitFeaturesPrivateHomeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesPrivateHomeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesPrivateHomeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesSuiteException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesSuiteException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesSuiteException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                GuestUnitFeaturesSuiteException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                GuestUnitFeaturesSuiteException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                GuestUnitFeaturesSuiteException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesSuiteException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesSuiteException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GuestUnitFeaturesSuiteException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => GuestUnitFeaturesSuiteException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => GuestUnitFeaturesSuiteException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => GuestUnitFeaturesSuiteException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => GuestUnitFeaturesSuiteException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesSuiteException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesSuiteException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesSuiteException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => GuestUnitFeaturesSuiteException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => GuestUnitFeaturesSuiteException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => GuestUnitFeaturesSuiteException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => GuestUnitFeaturesSuiteException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesSuiteException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesSuiteException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesTier {
        #[doc = "Deluxe unit. A guestroom type that builds on the features of the standard guestroom by offering additional amenities and/or more space, and/or views. The room rate is higher than that of the standard room type. Also known as Superior. Only allowed if another unit type is a standard tier."]
        DeluxeUnit,
        #[doc = "Standard unit. The predominant and most basic guestroom type available at the hotel. All other guestroom types include the features/amenities of this room, as well as additional features/amenities."]
        StandardUnit,
        #[doc = "Default tier. Equivalent to STANDARD. Prefer using STANDARD directly."]
        UnitTierUnspecified,
    }
    impl GuestUnitFeaturesTier {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesTier::DeluxeUnit => "DELUXE_UNIT",
                GuestUnitFeaturesTier::StandardUnit => "STANDARD_UNIT",
                GuestUnitFeaturesTier::UnitTierUnspecified => "UNIT_TIER_UNSPECIFIED",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesTier {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesTier {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GuestUnitFeaturesTier, ()> {
            Ok(match s {
                "DELUXE_UNIT" => GuestUnitFeaturesTier::DeluxeUnit,
                "STANDARD_UNIT" => GuestUnitFeaturesTier::StandardUnit,
                "UNIT_TIER_UNSPECIFIED" => GuestUnitFeaturesTier::UnitTierUnspecified,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesTier {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesTier {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DELUXE_UNIT" => GuestUnitFeaturesTier::DeluxeUnit,
                "STANDARD_UNIT" => GuestUnitFeaturesTier::StandardUnit,
                "UNIT_TIER_UNSPECIFIED" => GuestUnitFeaturesTier::UnitTierUnspecified,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesTier {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesTier {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum GuestUnitFeaturesTierException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl GuestUnitFeaturesTierException {
        pub fn as_str(self) -> &'static str {
            match self {
                GuestUnitFeaturesTierException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                GuestUnitFeaturesTierException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                GuestUnitFeaturesTierException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                GuestUnitFeaturesTierException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for GuestUnitFeaturesTierException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for GuestUnitFeaturesTierException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<GuestUnitFeaturesTierException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => GuestUnitFeaturesTierException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => GuestUnitFeaturesTierException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => GuestUnitFeaturesTierException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => GuestUnitFeaturesTierException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for GuestUnitFeaturesTierException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for GuestUnitFeaturesTierException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GuestUnitFeaturesTierException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => GuestUnitFeaturesTierException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => GuestUnitFeaturesTierException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => GuestUnitFeaturesTierException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => GuestUnitFeaturesTierException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for GuestUnitFeaturesTierException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitFeaturesTierException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct GuestUnitType {
        #[doc = "Required. Unit or room code identifiers for a single GuestUnitType. Each code must be unique within a Lodging instance."]
        #[serde(
            rename = "codes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub codes: ::std::option::Option<Vec<String>>,
        #[doc = "Features and available amenities of the GuestUnitType."]
        #[serde(
            rename = "features",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub features: ::std::option::Option<crate::schemas::GuestUnitFeatures>,
        #[doc = "Required. Short, English label or name of the GuestUnitType. Target <50 chars."]
        #[serde(
            rename = "label",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub label: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for GuestUnitType {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for GuestUnitType {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct HealthAndSafety {
        #[doc = "Enhanced cleaning measures implemented by the hotel during COVID-19."]
        #[serde(
            rename = "enhancedCleaning",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub enhanced_cleaning: ::std::option::Option<crate::schemas::EnhancedCleaning>,
        #[doc = "Increased food safety measures implemented by the hotel during COVID-19."]
        #[serde(
            rename = "increasedFoodSafety",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub increased_food_safety: ::std::option::Option<crate::schemas::IncreasedFoodSafety>,
        #[doc = "Minimized contact measures implemented by the hotel during COVID-19."]
        #[serde(
            rename = "minimizedContact",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub minimized_contact: ::std::option::Option<crate::schemas::MinimizedContact>,
        #[doc = "Personal protection measures implemented by the hotel during COVID-19."]
        #[serde(
            rename = "personalProtection",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub personal_protection: ::std::option::Option<crate::schemas::PersonalProtection>,
        #[doc = "Physical distancing measures implemented by the hotel during COVID-19."]
        #[serde(
            rename = "physicalDistancing",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub physical_distancing: ::std::option::Option<crate::schemas::PhysicalDistancing>,
    }
    impl ::google_field_selector::FieldSelector for HealthAndSafety {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HealthAndSafety {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Housekeeping {
        #[doc = "Daily housekeeping. Guest units are cleaned by hotel staff daily during guest's stay."]
        #[serde(
            rename = "dailyHousekeeping",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub daily_housekeeping: ::std::option::Option<bool>,
        #[doc = "Daily housekeeping exception."]
        #[serde(
            rename = "dailyHousekeepingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub daily_housekeeping_exception:
            ::std::option::Option<crate::schemas::HousekeepingDailyHousekeepingException>,
        #[doc = "Housekeeping available. Guest units are cleaned by hotel staff during guest's stay. Schedule may vary from daily, weekly, or specific days of the week."]
        #[serde(
            rename = "housekeepingAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub housekeeping_available: ::std::option::Option<bool>,
        #[doc = "Housekeeping available exception."]
        #[serde(
            rename = "housekeepingAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub housekeeping_available_exception:
            ::std::option::Option<crate::schemas::HousekeepingHousekeepingAvailableException>,
        #[doc = "Turndown service. Hotel staff enters guest units to prepare the bed for sleep use. May or may not include some light housekeeping. May or may not include an evening snack or candy. Also known as evening service."]
        #[serde(
            rename = "turndownService",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub turndown_service: ::std::option::Option<bool>,
        #[doc = "Turndown service exception."]
        #[serde(
            rename = "turndownServiceException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub turndown_service_exception:
            ::std::option::Option<crate::schemas::HousekeepingTurndownServiceException>,
    }
    impl ::google_field_selector::FieldSelector for Housekeeping {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Housekeeping {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum HousekeepingDailyHousekeepingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl HousekeepingDailyHousekeepingException {
        pub fn as_str(self) -> &'static str {
            match self {
                HousekeepingDailyHousekeepingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                HousekeepingDailyHousekeepingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                HousekeepingDailyHousekeepingException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                HousekeepingDailyHousekeepingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for HousekeepingDailyHousekeepingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for HousekeepingDailyHousekeepingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<HousekeepingDailyHousekeepingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    HousekeepingDailyHousekeepingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => HousekeepingDailyHousekeepingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    HousekeepingDailyHousekeepingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => HousekeepingDailyHousekeepingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for HousekeepingDailyHousekeepingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for HousekeepingDailyHousekeepingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HousekeepingDailyHousekeepingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    HousekeepingDailyHousekeepingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => HousekeepingDailyHousekeepingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    HousekeepingDailyHousekeepingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => HousekeepingDailyHousekeepingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for HousekeepingDailyHousekeepingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HousekeepingDailyHousekeepingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum HousekeepingHousekeepingAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl HousekeepingHousekeepingAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                HousekeepingHousekeepingAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                HousekeepingHousekeepingAvailableException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                HousekeepingHousekeepingAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                HousekeepingHousekeepingAvailableException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for HousekeepingHousekeepingAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for HousekeepingHousekeepingAvailableException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<HousekeepingHousekeepingAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    HousekeepingHousekeepingAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    HousekeepingHousekeepingAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    HousekeepingHousekeepingAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    HousekeepingHousekeepingAvailableException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for HousekeepingHousekeepingAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for HousekeepingHousekeepingAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HousekeepingHousekeepingAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    HousekeepingHousekeepingAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    HousekeepingHousekeepingAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    HousekeepingHousekeepingAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    HousekeepingHousekeepingAvailableException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for HousekeepingHousekeepingAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HousekeepingHousekeepingAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum HousekeepingTurndownServiceException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl HousekeepingTurndownServiceException {
        pub fn as_str(self) -> &'static str {
            match self {
                HousekeepingTurndownServiceException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                HousekeepingTurndownServiceException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                HousekeepingTurndownServiceException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                HousekeepingTurndownServiceException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for HousekeepingTurndownServiceException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for HousekeepingTurndownServiceException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<HousekeepingTurndownServiceException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    HousekeepingTurndownServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => HousekeepingTurndownServiceException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    HousekeepingTurndownServiceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => HousekeepingTurndownServiceException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for HousekeepingTurndownServiceException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for HousekeepingTurndownServiceException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HousekeepingTurndownServiceException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    HousekeepingTurndownServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => HousekeepingTurndownServiceException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    HousekeepingTurndownServiceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => HousekeepingTurndownServiceException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for HousekeepingTurndownServiceException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for HousekeepingTurndownServiceException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct IncreasedFoodSafety {
        #[doc = "Additional sanitation in dining areas."]
        #[serde(
            rename = "diningAreasAdditionalSanitation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dining_areas_additional_sanitation: ::std::option::Option<bool>,
        #[doc = "Dining areas additional sanitation exception."]
        #[serde(
            rename = "diningAreasAdditionalSanitationException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dining_areas_additional_sanitation_exception: ::std::option::Option<
            crate::schemas::IncreasedFoodSafetyDiningAreasAdditionalSanitationException,
        >,
        #[doc = "Disposable flatware."]
        #[serde(
            rename = "disposableFlatware",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disposable_flatware: ::std::option::Option<bool>,
        #[doc = "Disposable flatware exception."]
        #[serde(
            rename = "disposableFlatwareException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub disposable_flatware_exception:
            ::std::option::Option<crate::schemas::IncreasedFoodSafetyDisposableFlatwareException>,
        #[doc = "Additional safety measures during food prep and serving."]
        #[serde(
            rename = "foodPreparationAndServingAdditionalSafety",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub food_preparation_and_serving_additional_safety: ::std::option::Option<bool>,
        #[doc = "Food preparation and serving additional safety exception."]
        #[serde(
            rename = "foodPreparationAndServingAdditionalSafetyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub food_preparation_and_serving_additional_safety_exception: ::std::option::Option<
            crate::schemas::IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException,
        >,
        #[doc = "Individually-packaged meals."]
        #[serde(
            rename = "individualPackagedMeals",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub individual_packaged_meals: ::std::option::Option<bool>,
        #[doc = "Individual packaged meals exception."]
        #[serde(
            rename = "individualPackagedMealsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub individual_packaged_meals_exception: ::std::option::Option<
            crate::schemas::IncreasedFoodSafetyIndividualPackagedMealsException,
        >,
        #[doc = "Single-use menus."]
        #[serde(
            rename = "singleUseFoodMenus",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub single_use_food_menus: ::std::option::Option<bool>,
        #[doc = "Single use food menus exception."]
        #[serde(
            rename = "singleUseFoodMenusException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub single_use_food_menus_exception:
            ::std::option::Option<crate::schemas::IncreasedFoodSafetySingleUseFoodMenusException>,
    }
    impl ::google_field_selector::FieldSelector for IncreasedFoodSafety {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IncreasedFoodSafety {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IncreasedFoodSafetyDiningAreasAdditionalSanitationException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl IncreasedFoodSafetyDiningAreasAdditionalSanitationException {
        pub fn as_str(self) -> &'static str {
            match self { IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str> for IncreasedFoodSafetyDiningAreasAdditionalSanitationException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IncreasedFoodSafetyDiningAreasAdditionalSanitationException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<IncreasedFoodSafetyDiningAreasAdditionalSanitationException, ()>
        {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for IncreasedFoodSafetyDiningAreasAdditionalSanitationException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IncreasedFoodSafetyDiningAreasAdditionalSanitationException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for IncreasedFoodSafetyDiningAreasAdditionalSanitationException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => IncreasedFoodSafetyDiningAreasAdditionalSanitationException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for IncreasedFoodSafetyDiningAreasAdditionalSanitationException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for IncreasedFoodSafetyDiningAreasAdditionalSanitationException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IncreasedFoodSafetyDisposableFlatwareException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl IncreasedFoodSafetyDisposableFlatwareException {
        pub fn as_str(self) -> &'static str {
            match self {
                IncreasedFoodSafetyDisposableFlatwareException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                IncreasedFoodSafetyDisposableFlatwareException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                IncreasedFoodSafetyDisposableFlatwareException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                IncreasedFoodSafetyDisposableFlatwareException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for IncreasedFoodSafetyDisposableFlatwareException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IncreasedFoodSafetyDisposableFlatwareException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<IncreasedFoodSafetyDisposableFlatwareException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    IncreasedFoodSafetyDisposableFlatwareException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    IncreasedFoodSafetyDisposableFlatwareException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    IncreasedFoodSafetyDisposableFlatwareException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    IncreasedFoodSafetyDisposableFlatwareException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for IncreasedFoodSafetyDisposableFlatwareException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IncreasedFoodSafetyDisposableFlatwareException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for IncreasedFoodSafetyDisposableFlatwareException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    IncreasedFoodSafetyDisposableFlatwareException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    IncreasedFoodSafetyDisposableFlatwareException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    IncreasedFoodSafetyDisposableFlatwareException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    IncreasedFoodSafetyDisposableFlatwareException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for IncreasedFoodSafetyDisposableFlatwareException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IncreasedFoodSafetyDisposableFlatwareException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException {
        pub fn as_str(self) -> &'static str {
            match self { IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException,
            (),
        > {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for IncreasedFoodSafetyFoodPreparationAndServingAdditionalSafetyException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IncreasedFoodSafetyIndividualPackagedMealsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl IncreasedFoodSafetyIndividualPackagedMealsException {
        pub fn as_str(self) -> &'static str {
            match self {
                IncreasedFoodSafetyIndividualPackagedMealsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                IncreasedFoodSafetyIndividualPackagedMealsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                IncreasedFoodSafetyIndividualPackagedMealsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                IncreasedFoodSafetyIndividualPackagedMealsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for IncreasedFoodSafetyIndividualPackagedMealsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IncreasedFoodSafetyIndividualPackagedMealsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<IncreasedFoodSafetyIndividualPackagedMealsException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    IncreasedFoodSafetyIndividualPackagedMealsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    IncreasedFoodSafetyIndividualPackagedMealsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    IncreasedFoodSafetyIndividualPackagedMealsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    IncreasedFoodSafetyIndividualPackagedMealsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for IncreasedFoodSafetyIndividualPackagedMealsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IncreasedFoodSafetyIndividualPackagedMealsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for IncreasedFoodSafetyIndividualPackagedMealsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    IncreasedFoodSafetyIndividualPackagedMealsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    IncreasedFoodSafetyIndividualPackagedMealsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    IncreasedFoodSafetyIndividualPackagedMealsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    IncreasedFoodSafetyIndividualPackagedMealsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for IncreasedFoodSafetyIndividualPackagedMealsException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IncreasedFoodSafetyIndividualPackagedMealsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum IncreasedFoodSafetySingleUseFoodMenusException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl IncreasedFoodSafetySingleUseFoodMenusException {
        pub fn as_str(self) -> &'static str {
            match self {
                IncreasedFoodSafetySingleUseFoodMenusException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                IncreasedFoodSafetySingleUseFoodMenusException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                IncreasedFoodSafetySingleUseFoodMenusException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                IncreasedFoodSafetySingleUseFoodMenusException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for IncreasedFoodSafetySingleUseFoodMenusException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for IncreasedFoodSafetySingleUseFoodMenusException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<IncreasedFoodSafetySingleUseFoodMenusException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    IncreasedFoodSafetySingleUseFoodMenusException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    IncreasedFoodSafetySingleUseFoodMenusException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    IncreasedFoodSafetySingleUseFoodMenusException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    IncreasedFoodSafetySingleUseFoodMenusException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for IncreasedFoodSafetySingleUseFoodMenusException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for IncreasedFoodSafetySingleUseFoodMenusException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for IncreasedFoodSafetySingleUseFoodMenusException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    IncreasedFoodSafetySingleUseFoodMenusException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    IncreasedFoodSafetySingleUseFoodMenusException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    IncreasedFoodSafetySingleUseFoodMenusException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    IncreasedFoodSafetySingleUseFoodMenusException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for IncreasedFoodSafetySingleUseFoodMenusException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for IncreasedFoodSafetySingleUseFoodMenusException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LanguageSpoken {
        #[doc = "Required. The BCP-47 language code for the spoken language. Currently accepted codes: ar, de, en, es, fil, fr, hi, id, it, ja, ko, nl, pt, ru, vi, yue, zh."]
        #[serde(
            rename = "languageCode",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub language_code: ::std::option::Option<String>,
        #[doc = "At least one member of the staff can speak the language."]
        #[serde(
            rename = "spoken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub spoken: ::std::option::Option<bool>,
        #[doc = "Spoken exception."]
        #[serde(
            rename = "spokenException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub spoken_exception: ::std::option::Option<crate::schemas::LanguageSpokenSpokenException>,
    }
    impl ::google_field_selector::FieldSelector for LanguageSpoken {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LanguageSpoken {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LanguageSpokenSpokenException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LanguageSpokenSpokenException {
        pub fn as_str(self) -> &'static str {
            match self {
                LanguageSpokenSpokenException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LanguageSpokenSpokenException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LanguageSpokenSpokenException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LanguageSpokenSpokenException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LanguageSpokenSpokenException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LanguageSpokenSpokenException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LanguageSpokenSpokenException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LanguageSpokenSpokenException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LanguageSpokenSpokenException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LanguageSpokenSpokenException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LanguageSpokenSpokenException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LanguageSpokenSpokenException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LanguageSpokenSpokenException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LanguageSpokenSpokenException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LanguageSpokenSpokenException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LanguageSpokenSpokenException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LanguageSpokenSpokenException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LanguageSpokenSpokenException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LanguageSpokenSpokenException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LanguageSpokenSpokenException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct LivingArea {
        #[doc = "Accessibility features of the living area."]
        #[serde(
            rename = "accessibility",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub accessibility: ::std::option::Option<crate::schemas::LivingAreaAccessibility>,
        #[doc = "Information about eating features in the living area."]
        #[serde(
            rename = "eating",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub eating: ::std::option::Option<crate::schemas::LivingAreaEating>,
        #[doc = "Features in the living area."]
        #[serde(
            rename = "features",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub features: ::std::option::Option<crate::schemas::LivingAreaFeatures>,
        #[doc = "Information about the layout of the living area."]
        #[serde(
            rename = "layout",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub layout: ::std::option::Option<crate::schemas::LivingAreaLayout>,
        #[doc = "Information about sleeping features in the living area."]
        #[serde(
            rename = "sleeping",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sleeping: ::std::option::Option<crate::schemas::LivingAreaSleeping>,
    }
    impl ::google_field_selector::FieldSelector for LivingArea {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingArea {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LivingAreaAccessibility {
        #[doc = "ADA compliant unit. A guestroom designed to accommodate the physical challenges of a guest with mobility and/or auditory and/or visual issues, as determined by legislative policy. Usually features enlarged doorways, roll-in showers with seats, bathroom grab bars, and communication equipment for the hearing and sight challenged."]
        #[serde(
            rename = "adaCompliantUnit",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ada_compliant_unit: ::std::option::Option<bool>,
        #[doc = "ADA compliant unit exception."]
        #[serde(
            rename = "adaCompliantUnitException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ada_compliant_unit_exception:
            ::std::option::Option<crate::schemas::LivingAreaAccessibilityAdaCompliantUnitException>,
        #[doc = "Hearing-accessible doorbell. A visual indicator(s) of a knock or ring at the door."]
        #[serde(
            rename = "hearingAccessibleDoorbell",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hearing_accessible_doorbell: ::std::option::Option<bool>,
        #[doc = "Hearing-accessible doorbell exception."]
        #[serde(
            rename = "hearingAccessibleDoorbellException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hearing_accessible_doorbell_exception: ::std::option::Option<
            crate::schemas::LivingAreaAccessibilityHearingAccessibleDoorbellException,
        >,
        #[doc = "Hearing-accessible fire alarm. A device that gives warning of a fire through flashing lights."]
        #[serde(
            rename = "hearingAccessibleFireAlarm",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hearing_accessible_fire_alarm: ::std::option::Option<bool>,
        #[doc = "Hearing-accessible fire alarm exception."]
        #[serde(
            rename = "hearingAccessibleFireAlarmException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hearing_accessible_fire_alarm_exception: ::std::option::Option<
            crate::schemas::LivingAreaAccessibilityHearingAccessibleFireAlarmException,
        >,
        #[doc = "Hearing-accessible unit. A guestroom designed to accommodate the physical challenges of a guest with auditory issues."]
        #[serde(
            rename = "hearingAccessibleUnit",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hearing_accessible_unit: ::std::option::Option<bool>,
        #[doc = "Hearing-accessible unit exception."]
        #[serde(
            rename = "hearingAccessibleUnitException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hearing_accessible_unit_exception: ::std::option::Option<
            crate::schemas::LivingAreaAccessibilityHearingAccessibleUnitException,
        >,
        #[doc = "Mobility-accessible bathtub. A bathtub that accomodates the physically challenged with additional railings or hand grips, a transfer seat or lift, and/or a door to enable walking into the tub."]
        #[serde(
            rename = "mobilityAccessibleBathtub",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_bathtub: ::std::option::Option<bool>,
        #[doc = "Mobility-accessible bathtub exception."]
        #[serde(
            rename = "mobilityAccessibleBathtubException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_bathtub_exception: ::std::option::Option<
            crate::schemas::LivingAreaAccessibilityMobilityAccessibleBathtubException,
        >,
        #[doc = "Mobility-accessible shower. A shower with an enlarged door or access point to accommodate a wheelchair or a waterproof seat for the physically challenged."]
        #[serde(
            rename = "mobilityAccessibleShower",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_shower: ::std::option::Option<bool>,
        #[doc = "Mobility-accessible shower exception."]
        #[serde(
            rename = "mobilityAccessibleShowerException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_shower_exception: ::std::option::Option<
            crate::schemas::LivingAreaAccessibilityMobilityAccessibleShowerException,
        >,
        #[doc = "Mobility-accessible toilet. A toilet with a higher seat, grab bars, and/or a larger area around it to accommodate the physically challenged."]
        #[serde(
            rename = "mobilityAccessibleToilet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_toilet: ::std::option::Option<bool>,
        #[doc = "Mobility-accessible toilet exception."]
        #[serde(
            rename = "mobilityAccessibleToiletException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_toilet_exception: ::std::option::Option<
            crate::schemas::LivingAreaAccessibilityMobilityAccessibleToiletException,
        >,
        #[doc = "Mobility-accessible unit. A guestroom designed to accommodate the physical challenges of a guest with mobility and/or auditory and/or visual issues. Usually features enlarged doorways, roll-in showers with seats, bathroom grab bars, and communication equipment for the hearing and sight challenged."]
        #[serde(
            rename = "mobilityAccessibleUnit",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_unit: ::std::option::Option<bool>,
        #[doc = "Mobility-accessible unit exception."]
        #[serde(
            rename = "mobilityAccessibleUnitException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobility_accessible_unit_exception: ::std::option::Option<
            crate::schemas::LivingAreaAccessibilityMobilityAccessibleUnitException,
        >,
    }
    impl ::google_field_selector::FieldSelector for LivingAreaAccessibility {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaAccessibility {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaAccessibilityAdaCompliantUnitException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaAccessibilityAdaCompliantUnitException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaAccessibilityAdaCompliantUnitException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaAccessibilityAdaCompliantUnitException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaAccessibilityAdaCompliantUnitException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaAccessibilityAdaCompliantUnitException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaAccessibilityAdaCompliantUnitException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaAccessibilityAdaCompliantUnitException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaAccessibilityAdaCompliantUnitException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityAdaCompliantUnitException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityAdaCompliantUnitException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityAdaCompliantUnitException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityAdaCompliantUnitException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaAccessibilityAdaCompliantUnitException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaAccessibilityAdaCompliantUnitException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaAccessibilityAdaCompliantUnitException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityAdaCompliantUnitException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityAdaCompliantUnitException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityAdaCompliantUnitException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityAdaCompliantUnitException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaAccessibilityAdaCompliantUnitException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaAccessibilityAdaCompliantUnitException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaAccessibilityHearingAccessibleDoorbellException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaAccessibilityHearingAccessibleDoorbellException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaAccessibilityHearingAccessibleDoorbellException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaAccessibilityHearingAccessibleDoorbellException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaAccessibilityHearingAccessibleDoorbellException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaAccessibilityHearingAccessibleDoorbellException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaAccessibilityHearingAccessibleDoorbellException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaAccessibilityHearingAccessibleDoorbellException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaAccessibilityHearingAccessibleDoorbellException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityHearingAccessibleDoorbellException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityHearingAccessibleDoorbellException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityHearingAccessibleDoorbellException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityHearingAccessibleDoorbellException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaAccessibilityHearingAccessibleDoorbellException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaAccessibilityHearingAccessibleDoorbellException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaAccessibilityHearingAccessibleDoorbellException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityHearingAccessibleDoorbellException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityHearingAccessibleDoorbellException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityHearingAccessibleDoorbellException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityHearingAccessibleDoorbellException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for LivingAreaAccessibilityHearingAccessibleDoorbellException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for LivingAreaAccessibilityHearingAccessibleDoorbellException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaAccessibilityHearingAccessibleFireAlarmException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaAccessibilityHearingAccessibleFireAlarmException {
        pub fn as_str(self) -> &'static str {
            match self { LivingAreaAccessibilityHearingAccessibleFireAlarmException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , LivingAreaAccessibilityHearingAccessibleFireAlarmException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , LivingAreaAccessibilityHearingAccessibleFireAlarmException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , LivingAreaAccessibilityHearingAccessibleFireAlarmException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaAccessibilityHearingAccessibleFireAlarmException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaAccessibilityHearingAccessibleFireAlarmException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaAccessibilityHearingAccessibleFireAlarmException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityHearingAccessibleFireAlarmException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityHearingAccessibleFireAlarmException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityHearingAccessibleFireAlarmException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityHearingAccessibleFireAlarmException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaAccessibilityHearingAccessibleFireAlarmException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaAccessibilityHearingAccessibleFireAlarmException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaAccessibilityHearingAccessibleFireAlarmException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityHearingAccessibleFireAlarmException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityHearingAccessibleFireAlarmException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityHearingAccessibleFireAlarmException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityHearingAccessibleFireAlarmException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for LivingAreaAccessibilityHearingAccessibleFireAlarmException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for LivingAreaAccessibilityHearingAccessibleFireAlarmException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaAccessibilityHearingAccessibleUnitException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaAccessibilityHearingAccessibleUnitException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaAccessibilityHearingAccessibleUnitException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaAccessibilityHearingAccessibleUnitException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaAccessibilityHearingAccessibleUnitException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaAccessibilityHearingAccessibleUnitException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaAccessibilityHearingAccessibleUnitException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaAccessibilityHearingAccessibleUnitException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaAccessibilityHearingAccessibleUnitException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityHearingAccessibleUnitException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityHearingAccessibleUnitException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityHearingAccessibleUnitException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityHearingAccessibleUnitException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaAccessibilityHearingAccessibleUnitException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaAccessibilityHearingAccessibleUnitException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaAccessibilityHearingAccessibleUnitException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityHearingAccessibleUnitException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityHearingAccessibleUnitException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityHearingAccessibleUnitException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityHearingAccessibleUnitException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for LivingAreaAccessibilityHearingAccessibleUnitException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for LivingAreaAccessibilityHearingAccessibleUnitException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaAccessibilityMobilityAccessibleBathtubException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaAccessibilityMobilityAccessibleBathtubException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaAccessibilityMobilityAccessibleBathtubException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaAccessibilityMobilityAccessibleBathtubException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaAccessibilityMobilityAccessibleBathtubException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaAccessibilityMobilityAccessibleBathtubException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaAccessibilityMobilityAccessibleBathtubException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaAccessibilityMobilityAccessibleBathtubException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaAccessibilityMobilityAccessibleBathtubException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityMobilityAccessibleBathtubException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityMobilityAccessibleBathtubException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityMobilityAccessibleBathtubException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityMobilityAccessibleBathtubException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaAccessibilityMobilityAccessibleBathtubException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaAccessibilityMobilityAccessibleBathtubException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaAccessibilityMobilityAccessibleBathtubException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityMobilityAccessibleBathtubException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityMobilityAccessibleBathtubException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityMobilityAccessibleBathtubException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityMobilityAccessibleBathtubException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for LivingAreaAccessibilityMobilityAccessibleBathtubException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for LivingAreaAccessibilityMobilityAccessibleBathtubException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaAccessibilityMobilityAccessibleShowerException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaAccessibilityMobilityAccessibleShowerException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaAccessibilityMobilityAccessibleShowerException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaAccessibilityMobilityAccessibleShowerException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaAccessibilityMobilityAccessibleShowerException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaAccessibilityMobilityAccessibleShowerException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaAccessibilityMobilityAccessibleShowerException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaAccessibilityMobilityAccessibleShowerException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaAccessibilityMobilityAccessibleShowerException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityMobilityAccessibleShowerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityMobilityAccessibleShowerException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityMobilityAccessibleShowerException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityMobilityAccessibleShowerException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaAccessibilityMobilityAccessibleShowerException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaAccessibilityMobilityAccessibleShowerException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaAccessibilityMobilityAccessibleShowerException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityMobilityAccessibleShowerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityMobilityAccessibleShowerException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityMobilityAccessibleShowerException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityMobilityAccessibleShowerException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for LivingAreaAccessibilityMobilityAccessibleShowerException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for LivingAreaAccessibilityMobilityAccessibleShowerException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaAccessibilityMobilityAccessibleToiletException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaAccessibilityMobilityAccessibleToiletException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaAccessibilityMobilityAccessibleToiletException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaAccessibilityMobilityAccessibleToiletException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaAccessibilityMobilityAccessibleToiletException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaAccessibilityMobilityAccessibleToiletException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaAccessibilityMobilityAccessibleToiletException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaAccessibilityMobilityAccessibleToiletException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaAccessibilityMobilityAccessibleToiletException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityMobilityAccessibleToiletException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityMobilityAccessibleToiletException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityMobilityAccessibleToiletException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityMobilityAccessibleToiletException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaAccessibilityMobilityAccessibleToiletException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaAccessibilityMobilityAccessibleToiletException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaAccessibilityMobilityAccessibleToiletException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityMobilityAccessibleToiletException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityMobilityAccessibleToiletException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityMobilityAccessibleToiletException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityMobilityAccessibleToiletException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for LivingAreaAccessibilityMobilityAccessibleToiletException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for LivingAreaAccessibilityMobilityAccessibleToiletException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaAccessibilityMobilityAccessibleUnitException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaAccessibilityMobilityAccessibleUnitException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaAccessibilityMobilityAccessibleUnitException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaAccessibilityMobilityAccessibleUnitException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaAccessibilityMobilityAccessibleUnitException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaAccessibilityMobilityAccessibleUnitException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaAccessibilityMobilityAccessibleUnitException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaAccessibilityMobilityAccessibleUnitException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaAccessibilityMobilityAccessibleUnitException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityMobilityAccessibleUnitException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityMobilityAccessibleUnitException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityMobilityAccessibleUnitException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityMobilityAccessibleUnitException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaAccessibilityMobilityAccessibleUnitException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaAccessibilityMobilityAccessibleUnitException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaAccessibilityMobilityAccessibleUnitException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaAccessibilityMobilityAccessibleUnitException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaAccessibilityMobilityAccessibleUnitException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaAccessibilityMobilityAccessibleUnitException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaAccessibilityMobilityAccessibleUnitException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for LivingAreaAccessibilityMobilityAccessibleUnitException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for LivingAreaAccessibilityMobilityAccessibleUnitException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LivingAreaEating {
        #[doc = "Coffee maker. An electric appliance that brews coffee by heating and forcing water through ground coffee."]
        #[serde(
            rename = "coffeeMaker",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub coffee_maker: ::std::option::Option<bool>,
        #[doc = "Coffee maker exception."]
        #[serde(
            rename = "coffeeMakerException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub coffee_maker_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingCoffeeMakerException>,
        #[doc = "Cookware. Kitchen pots, pans and utensils used in connection with the preparation of food."]
        #[serde(
            rename = "cookware",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cookware: ::std::option::Option<bool>,
        #[doc = "Cookware exception."]
        #[serde(
            rename = "cookwareException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cookware_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingCookwareException>,
        #[doc = "Dishwasher. A counter-height electrical cabinet containing racks for dirty dishware, cookware and cutlery, and a dispenser for soap built into the pull-down door. The cabinet is attached to the plumbing system to facilitate the automatic cleaning of its contents."]
        #[serde(
            rename = "dishwasher",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dishwasher: ::std::option::Option<bool>,
        #[doc = "Dishwasher exception."]
        #[serde(
            rename = "dishwasherException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dishwasher_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingDishwasherException>,
        #[doc = "Indoor grill. Metal grates built into an indoor cooktop on which food is cooked over an open flame or electric heat source."]
        #[serde(
            rename = "indoorGrill",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub indoor_grill: ::std::option::Option<bool>,
        #[doc = "Indoor grill exception."]
        #[serde(
            rename = "indoorGrillException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub indoor_grill_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingIndoorGrillException>,
        #[doc = "Kettle. A covered container with a handle and a spout used for boiling water."]
        #[serde(
            rename = "kettle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kettle: ::std::option::Option<bool>,
        #[doc = "Kettle exception."]
        #[serde(
            rename = "kettleException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kettle_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingKettleException>,
        #[doc = "Kitchen available. An area of the guestroom designated for the preparation and storage of food via the presence of a refrigerator, cook top, oven and sink, as well as cutlery, dishes and cookware. Usually includes small appliances such a coffee maker and a microwave. May or may not include an automatic dishwasher."]
        #[serde(
            rename = "kitchenAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kitchen_available: ::std::option::Option<bool>,
        #[doc = "Kitchen available exception."]
        #[serde(
            rename = "kitchenAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kitchen_available_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingKitchenAvailableException>,
        #[doc = "Microwave. An electric oven that quickly cooks and heats food by microwave energy. Smaller than a standing or wall mounted oven. Usually placed on a kitchen counter, a shelf or tabletop or mounted above a cooktop."]
        #[serde(
            rename = "microwave",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub microwave: ::std::option::Option<bool>,
        #[doc = "Microwave exception."]
        #[serde(
            rename = "microwaveException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub microwave_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingMicrowaveException>,
        #[doc = "Minibar. A small refrigerated cabinet in the guestroom containing bottles/cans of soft drinks, mini bottles of alcohol, and snacks. The items are most commonly available for a fee."]
        #[serde(
            rename = "minibar",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub minibar: ::std::option::Option<bool>,
        #[doc = "Minibar exception."]
        #[serde(
            rename = "minibarException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub minibar_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingMinibarException>,
        #[doc = "Outdoor grill. Metal grates on which food is cooked over an open flame or electric heat source. Part of an outdoor apparatus that supports the grates. Also known as barbecue grill or barbecue."]
        #[serde(
            rename = "outdoorGrill",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub outdoor_grill: ::std::option::Option<bool>,
        #[doc = "Outdoor grill exception."]
        #[serde(
            rename = "outdoorGrillException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub outdoor_grill_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingOutdoorGrillException>,
        #[doc = "Oven. A temperature controlled, heated metal cabinet powered by gas or electricity in which food is placed for the purpose of cooking or reheating."]
        #[serde(
            rename = "oven",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oven: ::std::option::Option<bool>,
        #[doc = "Oven exception."]
        #[serde(
            rename = "ovenException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub oven_exception: ::std::option::Option<crate::schemas::LivingAreaEatingOvenException>,
        #[doc = "Refrigerator. A large, climate-controlled electrical cabinet with vertical doors. Built for the purpose of chilling and storing perishable foods."]
        #[serde(
            rename = "refrigerator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub refrigerator: ::std::option::Option<bool>,
        #[doc = "Refrigerator exception."]
        #[serde(
            rename = "refrigeratorException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub refrigerator_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingRefrigeratorException>,
        #[doc = "Sink. A basin with a faucet attached to a water source and used for the purpose of washing and rinsing."]
        #[serde(
            rename = "sink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sink: ::std::option::Option<bool>,
        #[doc = "Sink exception."]
        #[serde(
            rename = "sinkException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sink_exception: ::std::option::Option<crate::schemas::LivingAreaEatingSinkException>,
        #[doc = "Snackbar. A small cabinet in the guestroom containing snacks. The items are most commonly available for a fee."]
        #[serde(
            rename = "snackbar",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snackbar: ::std::option::Option<bool>,
        #[doc = "Snackbar exception."]
        #[serde(
            rename = "snackbarException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub snackbar_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingSnackbarException>,
        #[doc = "Stove. A kitchen appliance powered by gas or electricity for the purpose of creating a flame or hot surface on which pots of food can be cooked. Also known as cooktop or hob."]
        #[serde(
            rename = "stove",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stove: ::std::option::Option<bool>,
        #[doc = "Stove exception."]
        #[serde(
            rename = "stoveException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stove_exception: ::std::option::Option<crate::schemas::LivingAreaEatingStoveException>,
        #[doc = "Tea station. A small area with the supplies needed to heat water and make tea."]
        #[serde(
            rename = "teaStation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tea_station: ::std::option::Option<bool>,
        #[doc = "Tea station exception."]
        #[serde(
            rename = "teaStationException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tea_station_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingTeaStationException>,
        #[doc = "Toaster. A small, temperature controlled electric appliance with rectangular slots at the top that are lined with heated coils for the purpose of browning slices of bread products."]
        #[serde(
            rename = "toaster",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub toaster: ::std::option::Option<bool>,
        #[doc = "Toaster exception."]
        #[serde(
            rename = "toasterException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub toaster_exception:
            ::std::option::Option<crate::schemas::LivingAreaEatingToasterException>,
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEating {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEating {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingCoffeeMakerException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingCoffeeMakerException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingCoffeeMakerException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingCoffeeMakerException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingCoffeeMakerException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaEatingCoffeeMakerException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingCoffeeMakerException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingCoffeeMakerException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingCoffeeMakerException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingCoffeeMakerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingCoffeeMakerException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingCoffeeMakerException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingCoffeeMakerException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingCoffeeMakerException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingCoffeeMakerException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingCoffeeMakerException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingCoffeeMakerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingCoffeeMakerException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingCoffeeMakerException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingCoffeeMakerException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingCoffeeMakerException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingCoffeeMakerException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingCookwareException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingCookwareException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingCookwareException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingCookwareException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingCookwareException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingCookwareException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingCookwareException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingCookwareException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingCookwareException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingCookwareException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingCookwareException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingCookwareException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingCookwareException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingCookwareException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingCookwareException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingCookwareException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingCookwareException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingCookwareException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingCookwareException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingCookwareException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingCookwareException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingCookwareException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingDishwasherException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingDishwasherException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingDishwasherException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingDishwasherException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingDishwasherException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaEatingDishwasherException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingDishwasherException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingDishwasherException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingDishwasherException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingDishwasherException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingDishwasherException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingDishwasherException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingDishwasherException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingDishwasherException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingDishwasherException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingDishwasherException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingDishwasherException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingDishwasherException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingDishwasherException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingDishwasherException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingDishwasherException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingDishwasherException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingIndoorGrillException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingIndoorGrillException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingIndoorGrillException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingIndoorGrillException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingIndoorGrillException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaEatingIndoorGrillException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingIndoorGrillException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingIndoorGrillException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingIndoorGrillException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingIndoorGrillException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingIndoorGrillException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingIndoorGrillException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingIndoorGrillException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingIndoorGrillException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingIndoorGrillException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingIndoorGrillException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingIndoorGrillException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingIndoorGrillException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingIndoorGrillException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingIndoorGrillException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingIndoorGrillException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingIndoorGrillException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingKettleException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingKettleException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingKettleException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LivingAreaEatingKettleException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingKettleException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingKettleException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingKettleException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingKettleException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingKettleException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaEatingKettleException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaEatingKettleException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingKettleException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingKettleException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingKettleException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingKettleException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingKettleException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaEatingKettleException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaEatingKettleException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingKettleException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingKettleException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingKettleException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingKettleException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingKitchenAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingKitchenAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingKitchenAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingKitchenAvailableException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaEatingKitchenAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaEatingKitchenAvailableException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingKitchenAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingKitchenAvailableException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaEatingKitchenAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingKitchenAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaEatingKitchenAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingKitchenAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaEatingKitchenAvailableException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingKitchenAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingKitchenAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingKitchenAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingKitchenAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaEatingKitchenAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingKitchenAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaEatingKitchenAvailableException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingKitchenAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingKitchenAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingMicrowaveException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingMicrowaveException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingMicrowaveException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingMicrowaveException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingMicrowaveException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingMicrowaveException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingMicrowaveException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingMicrowaveException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingMicrowaveException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingMicrowaveException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingMicrowaveException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingMicrowaveException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingMicrowaveException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingMicrowaveException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingMicrowaveException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingMicrowaveException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingMicrowaveException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingMicrowaveException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingMicrowaveException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingMicrowaveException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingMicrowaveException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingMicrowaveException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingMinibarException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingMinibarException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingMinibarException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingMinibarException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingMinibarException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingMinibarException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingMinibarException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingMinibarException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingMinibarException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingMinibarException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingMinibarException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingMinibarException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingMinibarException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingMinibarException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingMinibarException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingMinibarException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingMinibarException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingMinibarException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingMinibarException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingMinibarException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingMinibarException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingMinibarException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingOutdoorGrillException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingOutdoorGrillException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingOutdoorGrillException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingOutdoorGrillException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingOutdoorGrillException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaEatingOutdoorGrillException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingOutdoorGrillException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingOutdoorGrillException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingOutdoorGrillException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingOutdoorGrillException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingOutdoorGrillException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingOutdoorGrillException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingOutdoorGrillException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingOutdoorGrillException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingOutdoorGrillException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingOutdoorGrillException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingOutdoorGrillException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingOutdoorGrillException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingOutdoorGrillException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingOutdoorGrillException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingOutdoorGrillException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingOutdoorGrillException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingOvenException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingOvenException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingOvenException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LivingAreaEatingOvenException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingOvenException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingOvenException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingOvenException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingOvenException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingOvenException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaEatingOvenException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaEatingOvenException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingOvenException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingOvenException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingOvenException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingOvenException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingOvenException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaEatingOvenException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaEatingOvenException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingOvenException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingOvenException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingOvenException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingOvenException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingRefrigeratorException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingRefrigeratorException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingRefrigeratorException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingRefrigeratorException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingRefrigeratorException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaEatingRefrigeratorException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingRefrigeratorException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingRefrigeratorException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingRefrigeratorException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingRefrigeratorException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingRefrigeratorException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingRefrigeratorException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingRefrigeratorException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingRefrigeratorException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingRefrigeratorException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingRefrigeratorException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingRefrigeratorException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingRefrigeratorException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingRefrigeratorException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingRefrigeratorException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingRefrigeratorException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingRefrigeratorException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingSinkException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingSinkException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingSinkException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LivingAreaEatingSinkException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingSinkException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingSinkException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingSinkException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingSinkException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingSinkException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaEatingSinkException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaEatingSinkException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingSinkException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingSinkException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingSinkException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingSinkException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingSinkException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaEatingSinkException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaEatingSinkException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingSinkException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingSinkException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingSinkException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingSinkException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingSnackbarException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingSnackbarException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingSnackbarException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingSnackbarException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingSnackbarException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingSnackbarException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingSnackbarException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingSnackbarException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingSnackbarException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingSnackbarException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingSnackbarException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingSnackbarException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingSnackbarException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingSnackbarException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingSnackbarException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingSnackbarException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingSnackbarException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingSnackbarException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingSnackbarException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingSnackbarException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingSnackbarException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingSnackbarException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingStoveException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingStoveException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingStoveException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LivingAreaEatingStoveException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingStoveException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingStoveException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingStoveException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingStoveException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingStoveException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaEatingStoveException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaEatingStoveException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingStoveException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingStoveException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingStoveException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingStoveException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingStoveException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaEatingStoveException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaEatingStoveException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingStoveException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingStoveException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingStoveException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingStoveException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingTeaStationException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingTeaStationException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingTeaStationException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingTeaStationException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingTeaStationException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaEatingTeaStationException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingTeaStationException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingTeaStationException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingTeaStationException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingTeaStationException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingTeaStationException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingTeaStationException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingTeaStationException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingTeaStationException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingTeaStationException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingTeaStationException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingTeaStationException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingTeaStationException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaEatingTeaStationException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaEatingTeaStationException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingTeaStationException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingTeaStationException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaEatingToasterException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaEatingToasterException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaEatingToasterException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaEatingToasterException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaEatingToasterException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaEatingToasterException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaEatingToasterException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaEatingToasterException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaEatingToasterException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingToasterException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingToasterException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingToasterException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingToasterException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaEatingToasterException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaEatingToasterException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaEatingToasterException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaEatingToasterException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaEatingToasterException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaEatingToasterException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaEatingToasterException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaEatingToasterException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaEatingToasterException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LivingAreaFeatures {
        #[doc = "Air conditioning. An electrical machine used to cool the temperature of the guestroom."]
        #[serde(
            rename = "airConditioning",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub air_conditioning: ::std::option::Option<bool>,
        #[doc = "Air conditioning exception."]
        #[serde(
            rename = "airConditioningException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub air_conditioning_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesAirConditioningException>,
        #[doc = "Bathtub. A fixed plumbing feature set on the floor and consisting of a large container that accommodates the body of an adult for the purpose of seated bathing. Includes knobs or fixtures to control the temperature of the water, a faucet through which the water flows, and a drain that can be closed for filling and opened for draining."]
        #[serde(
            rename = "bathtub",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bathtub: ::std::option::Option<bool>,
        #[doc = "Bathtub exception."]
        #[serde(
            rename = "bathtubException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bathtub_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesBathtubException>,
        #[doc = "Bidet. A plumbing fixture attached to a toilet or a low, fixed sink designed for the purpose of washing after toilet use."]
        #[serde(
            rename = "bidet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bidet: ::std::option::Option<bool>,
        #[doc = "Bidet exception."]
        #[serde(
            rename = "bidetException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bidet_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesBidetException>,
        #[doc = "Dryer. An electrical machine designed to dry clothing."]
        #[serde(
            rename = "dryer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dryer: ::std::option::Option<bool>,
        #[doc = "Dryer exception."]
        #[serde(
            rename = "dryerException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dryer_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesDryerException>,
        #[doc = "Electronic room key. A card coded by the check-in computer that is read by the lock on the hotel guestroom door to allow for entry."]
        #[serde(
            rename = "electronicRoomKey",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub electronic_room_key: ::std::option::Option<bool>,
        #[doc = "Electronic room key exception."]
        #[serde(
            rename = "electronicRoomKeyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub electronic_room_key_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesElectronicRoomKeyException>,
        #[doc = "Fireplace. A framed opening (aka hearth) at the base of a chimney in which logs or an electrical fire feature are burned to provide a relaxing ambiance or to heat the room. Often made of bricks or stone."]
        #[serde(
            rename = "fireplace",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fireplace: ::std::option::Option<bool>,
        #[doc = "Fireplace exception."]
        #[serde(
            rename = "fireplaceException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fireplace_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesFireplaceException>,
        #[doc = "Hairdryer. A handheld electric appliance that blows temperature-controlled air for the purpose of drying wet hair. Can be mounted to a bathroom wall or a freestanding device stored in the guestroom's bathroom or closet."]
        #[serde(
            rename = "hairdryer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hairdryer: ::std::option::Option<bool>,
        #[doc = "Hairdryer exception."]
        #[serde(
            rename = "hairdryerException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hairdryer_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesHairdryerException>,
        #[doc = "Heating. An electrical machine used to warm the temperature of the guestroom."]
        #[serde(
            rename = "heating",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub heating: ::std::option::Option<bool>,
        #[doc = "Heating exception."]
        #[serde(
            rename = "heatingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub heating_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesHeatingException>,
        #[doc = "In-unit safe. A strong fireproof cabinet with a programmable lock, used for the protected storage of valuables in a guestroom. Often built into a closet."]
        #[serde(
            rename = "inunitSafe",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub inunit_safe: ::std::option::Option<bool>,
        #[doc = "In-unit safe exception."]
        #[serde(
            rename = "inunitSafeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub inunit_safe_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesInunitSafeException>,
        #[doc = "In-unit Wifi available. Guests can wirelessly connect to the Internet in the guestroom. Can be free or for a fee."]
        #[serde(
            rename = "inunitWifiAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub inunit_wifi_available: ::std::option::Option<bool>,
        #[doc = "In-unit Wifi available exception."]
        #[serde(
            rename = "inunitWifiAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub inunit_wifi_available_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesInunitWifiAvailableException>,
        #[doc = "Ironing equipment. A device, usually with a flat metal base, that is heated to smooth, finish, or press clothes and a flat, padded, cloth-covered surface on which the clothes are worked."]
        #[serde(
            rename = "ironingEquipment",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ironing_equipment: ::std::option::Option<bool>,
        #[doc = "Ironing equipment exception."]
        #[serde(
            rename = "ironingEquipmentException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ironing_equipment_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesIroningEquipmentException>,
        #[doc = "Pay per view movies. Televisions with channels that offer films that can be viewed for a fee, and have an interface to allow the viewer to accept the terms and approve payment."]
        #[serde(
            rename = "payPerViewMovies",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pay_per_view_movies: ::std::option::Option<bool>,
        #[doc = "Pay per view movies exception."]
        #[serde(
            rename = "payPerViewMoviesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pay_per_view_movies_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesPayPerViewMoviesException>,
        #[doc = "Private bathroom. A bathroom designated for the express use of the guests staying in a specific guestroom."]
        #[serde(
            rename = "privateBathroom",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_bathroom: ::std::option::Option<bool>,
        #[doc = "Private bathroom exception."]
        #[serde(
            rename = "privateBathroomException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_bathroom_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesPrivateBathroomException>,
        #[doc = "Shower. A fixed plumbing fixture for standing bathing that features a tall spray spout or faucet through which water flows, a knob or knobs that control the water's temperature, and a drain in the floor."]
        #[serde(
            rename = "shower",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shower: ::std::option::Option<bool>,
        #[doc = "Shower exception."]
        #[serde(
            rename = "showerException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shower_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesShowerException>,
        #[doc = "Toilet. A fixed bathroom feature connected to a sewer or septic system and consisting of a water-flushed bowl with a seat, as well as a device that elicites the water-flushing action. Used for the process and disposal of human waste."]
        #[serde(
            rename = "toilet",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub toilet: ::std::option::Option<bool>,
        #[doc = "Toilet exception."]
        #[serde(
            rename = "toiletException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub toilet_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesToiletException>,
        #[doc = "TV. A television is available in the guestroom."]
        #[serde(
            rename = "tv",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tv: ::std::option::Option<bool>,
        #[doc = "TV casting. A television equipped with a device through which the video entertainment accessed on a personal computer, phone or tablet can be wirelessly delivered to and viewed on the guestroom's television."]
        #[serde(
            rename = "tvCasting",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tv_casting: ::std::option::Option<bool>,
        #[doc = "TV exception."]
        #[serde(
            rename = "tvCastingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tv_casting_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesTvCastingException>,
        #[doc = "TV exception."]
        #[serde(
            rename = "tvException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tv_exception: ::std::option::Option<crate::schemas::LivingAreaFeaturesTvException>,
        #[doc = "TV streaming. Televisions that embed a range of web-based apps to allow for watching media from those apps."]
        #[serde(
            rename = "tvStreaming",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tv_streaming: ::std::option::Option<bool>,
        #[doc = "TV streaming exception."]
        #[serde(
            rename = "tvStreamingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub tv_streaming_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesTvStreamingException>,
        #[doc = "Universal power adapters. A power supply for electronic devices which plugs into a wall for the purpose of converting AC to a single DC voltage. Also know as AC adapter or charger."]
        #[serde(
            rename = "universalPowerAdapters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub universal_power_adapters: ::std::option::Option<bool>,
        #[doc = "Universal power adapters exception."]
        #[serde(
            rename = "universalPowerAdaptersException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub universal_power_adapters_exception: ::std::option::Option<
            crate::schemas::LivingAreaFeaturesUniversalPowerAdaptersException,
        >,
        #[doc = "Washer. An electrical machine connected to a running water source designed to launder clothing."]
        #[serde(
            rename = "washer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub washer: ::std::option::Option<bool>,
        #[doc = "Washer exception."]
        #[serde(
            rename = "washerException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub washer_exception:
            ::std::option::Option<crate::schemas::LivingAreaFeaturesWasherException>,
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeatures {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeatures {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesAirConditioningException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesAirConditioningException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesAirConditioningException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesAirConditioningException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaFeaturesAirConditioningException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesAirConditioningException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesAirConditioningException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesAirConditioningException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaFeaturesAirConditioningException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesAirConditioningException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesAirConditioningException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesAirConditioningException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesAirConditioningException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesAirConditioningException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesAirConditioningException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesAirConditioningException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesAirConditioningException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesAirConditioningException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesAirConditioningException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesAirConditioningException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesAirConditioningException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesAirConditioningException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesBathtubException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesBathtubException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesBathtubException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesBathtubException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesBathtubException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaFeaturesBathtubException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesBathtubException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesBathtubException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesBathtubException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesBathtubException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesBathtubException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesBathtubException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesBathtubException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesBathtubException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesBathtubException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesBathtubException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesBathtubException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesBathtubException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesBathtubException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesBathtubException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesBathtubException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesBathtubException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesBidetException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesBidetException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesBidetException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesBidetException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesBidetException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaFeaturesBidetException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesBidetException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesBidetException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesBidetException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesBidetException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesBidetException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesBidetException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesBidetException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesBidetException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesBidetException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesBidetException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesBidetException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesBidetException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesBidetException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesBidetException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesBidetException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesBidetException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesDryerException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesDryerException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesDryerException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesDryerException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesDryerException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaFeaturesDryerException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesDryerException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesDryerException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesDryerException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesDryerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesDryerException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesDryerException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesDryerException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesDryerException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesDryerException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesDryerException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesDryerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesDryerException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesDryerException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesDryerException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesDryerException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesDryerException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesElectronicRoomKeyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesElectronicRoomKeyException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesElectronicRoomKeyException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesElectronicRoomKeyException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaFeaturesElectronicRoomKeyException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesElectronicRoomKeyException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesElectronicRoomKeyException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesElectronicRoomKeyException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaFeaturesElectronicRoomKeyException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesElectronicRoomKeyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesElectronicRoomKeyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesElectronicRoomKeyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesElectronicRoomKeyException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesElectronicRoomKeyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesElectronicRoomKeyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesElectronicRoomKeyException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesElectronicRoomKeyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesElectronicRoomKeyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesElectronicRoomKeyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesElectronicRoomKeyException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesElectronicRoomKeyException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesElectronicRoomKeyException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesFireplaceException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesFireplaceException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesFireplaceException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesFireplaceException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesFireplaceException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesFireplaceException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesFireplaceException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesFireplaceException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesFireplaceException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesFireplaceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesFireplaceException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesFireplaceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesFireplaceException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesFireplaceException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesFireplaceException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesFireplaceException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesFireplaceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesFireplaceException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesFireplaceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesFireplaceException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesFireplaceException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesFireplaceException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesHairdryerException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesHairdryerException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesHairdryerException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesHairdryerException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesHairdryerException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesHairdryerException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesHairdryerException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesHairdryerException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesHairdryerException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesHairdryerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesHairdryerException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesHairdryerException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesHairdryerException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesHairdryerException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesHairdryerException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesHairdryerException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesHairdryerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesHairdryerException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesHairdryerException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesHairdryerException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesHairdryerException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesHairdryerException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesHeatingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesHeatingException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesHeatingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesHeatingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesHeatingException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaFeaturesHeatingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesHeatingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesHeatingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesHeatingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesHeatingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesHeatingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesHeatingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesHeatingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesHeatingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesHeatingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesHeatingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesHeatingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesHeatingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesHeatingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesHeatingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesHeatingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesHeatingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesInunitSafeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesInunitSafeException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesInunitSafeException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesInunitSafeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesInunitSafeException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesInunitSafeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesInunitSafeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesInunitSafeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesInunitSafeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesInunitSafeException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesInunitSafeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesInunitSafeException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesInunitSafeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesInunitSafeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesInunitSafeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesInunitSafeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesInunitSafeException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesInunitSafeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesInunitSafeException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesInunitSafeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesInunitSafeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesInunitSafeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesInunitWifiAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesInunitWifiAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesInunitWifiAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesInunitWifiAvailableException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaFeaturesInunitWifiAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesInunitWifiAvailableException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesInunitWifiAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesInunitWifiAvailableException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaFeaturesInunitWifiAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesInunitWifiAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesInunitWifiAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesInunitWifiAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesInunitWifiAvailableException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesInunitWifiAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesInunitWifiAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesInunitWifiAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesInunitWifiAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesInunitWifiAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesInunitWifiAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesInunitWifiAvailableException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesInunitWifiAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesInunitWifiAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesIroningEquipmentException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesIroningEquipmentException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesIroningEquipmentException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesIroningEquipmentException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaFeaturesIroningEquipmentException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesIroningEquipmentException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesIroningEquipmentException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesIroningEquipmentException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaFeaturesIroningEquipmentException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesIroningEquipmentException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesIroningEquipmentException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesIroningEquipmentException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesIroningEquipmentException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesIroningEquipmentException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesIroningEquipmentException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesIroningEquipmentException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesIroningEquipmentException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesIroningEquipmentException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesIroningEquipmentException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesIroningEquipmentException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesIroningEquipmentException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesIroningEquipmentException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesPayPerViewMoviesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesPayPerViewMoviesException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesPayPerViewMoviesException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesPayPerViewMoviesException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaFeaturesPayPerViewMoviesException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesPayPerViewMoviesException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesPayPerViewMoviesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesPayPerViewMoviesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaFeaturesPayPerViewMoviesException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesPayPerViewMoviesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesPayPerViewMoviesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesPayPerViewMoviesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesPayPerViewMoviesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesPayPerViewMoviesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesPayPerViewMoviesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesPayPerViewMoviesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesPayPerViewMoviesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesPayPerViewMoviesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesPayPerViewMoviesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesPayPerViewMoviesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesPayPerViewMoviesException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesPayPerViewMoviesException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesPrivateBathroomException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesPrivateBathroomException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesPrivateBathroomException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesPrivateBathroomException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaFeaturesPrivateBathroomException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesPrivateBathroomException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesPrivateBathroomException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesPrivateBathroomException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaFeaturesPrivateBathroomException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesPrivateBathroomException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesPrivateBathroomException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesPrivateBathroomException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesPrivateBathroomException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesPrivateBathroomException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesPrivateBathroomException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesPrivateBathroomException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesPrivateBathroomException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesPrivateBathroomException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesPrivateBathroomException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesPrivateBathroomException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesPrivateBathroomException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesPrivateBathroomException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesShowerException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesShowerException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesShowerException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesShowerException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesShowerException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaFeaturesShowerException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesShowerException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesShowerException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesShowerException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesShowerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesShowerException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesShowerException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesShowerException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesShowerException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesShowerException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesShowerException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesShowerException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesShowerException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesShowerException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesShowerException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesShowerException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesShowerException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesToiletException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesToiletException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesToiletException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesToiletException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesToiletException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaFeaturesToiletException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesToiletException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesToiletException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesToiletException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesToiletException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesToiletException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesToiletException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesToiletException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesToiletException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesToiletException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesToiletException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesToiletException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesToiletException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesToiletException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesToiletException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesToiletException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesToiletException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesTvCastingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesTvCastingException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesTvCastingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesTvCastingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesTvCastingException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesTvCastingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesTvCastingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesTvCastingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesTvCastingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesTvCastingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesTvCastingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesTvCastingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesTvCastingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesTvCastingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesTvCastingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesTvCastingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesTvCastingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesTvCastingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesTvCastingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesTvCastingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesTvCastingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesTvCastingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesTvException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesTvException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesTvException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LivingAreaFeaturesTvException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesTvException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaFeaturesTvException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesTvException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesTvException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesTvException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaFeaturesTvException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesTvException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesTvException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesTvException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesTvException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesTvException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesTvException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaFeaturesTvException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesTvException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesTvException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesTvException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesTvException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesTvException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesTvStreamingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesTvStreamingException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesTvStreamingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesTvStreamingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesTvStreamingException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesTvStreamingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesTvStreamingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesTvStreamingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesTvStreamingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesTvStreamingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesTvStreamingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesTvStreamingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesTvStreamingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesTvStreamingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesTvStreamingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesTvStreamingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesTvStreamingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesTvStreamingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesTvStreamingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesTvStreamingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesTvStreamingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesTvStreamingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesUniversalPowerAdaptersException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesUniversalPowerAdaptersException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesUniversalPowerAdaptersException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesUniversalPowerAdaptersException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaFeaturesUniversalPowerAdaptersException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaFeaturesUniversalPowerAdaptersException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesUniversalPowerAdaptersException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesUniversalPowerAdaptersException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaFeaturesUniversalPowerAdaptersException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesUniversalPowerAdaptersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesUniversalPowerAdaptersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesUniversalPowerAdaptersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesUniversalPowerAdaptersException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesUniversalPowerAdaptersException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesUniversalPowerAdaptersException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesUniversalPowerAdaptersException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesUniversalPowerAdaptersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaFeaturesUniversalPowerAdaptersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaFeaturesUniversalPowerAdaptersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaFeaturesUniversalPowerAdaptersException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesUniversalPowerAdaptersException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesUniversalPowerAdaptersException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaFeaturesWasherException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaFeaturesWasherException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaFeaturesWasherException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaFeaturesWasherException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaFeaturesWasherException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaFeaturesWasherException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaFeaturesWasherException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaFeaturesWasherException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaFeaturesWasherException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesWasherException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesWasherException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesWasherException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesWasherException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaFeaturesWasherException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaFeaturesWasherException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaFeaturesWasherException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaFeaturesWasherException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaFeaturesWasherException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaFeaturesWasherException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaFeaturesWasherException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaFeaturesWasherException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaFeaturesWasherException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct LivingAreaLayout {
        #[doc = "Balcony. An outdoor platform attached to a building and surrounded by a short wall, fence or other safety railing. The balcony is accessed through a door in a guestroom or suite and is for use by the guest staying in that room. May or may not include seating or outdoor furniture. Is not located on the ground floor. Also lanai."]
        #[serde(
            rename = "balcony",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub balcony: ::std::option::Option<bool>,
        #[doc = "Balcony exception."]
        #[serde(
            rename = "balconyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub balcony_exception:
            ::std::option::Option<crate::schemas::LivingAreaLayoutBalconyException>,
        #[doc = "Living area sq meters. The measurement in meters of the area of a guestroom's living space."]
        #[serde(
            rename = "livingAreaSqMeters",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub living_area_sq_meters: ::std::option::Option<f32>,
        #[doc = "Living area sq meters exception."]
        #[serde(
            rename = "livingAreaSqMetersException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub living_area_sq_meters_exception:
            ::std::option::Option<crate::schemas::LivingAreaLayoutLivingAreaSqMetersException>,
        #[doc = "Loft. A three-walled upper area accessed by stairs or a ladder that overlooks the lower area of a room."]
        #[serde(
            rename = "loft",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub loft: ::std::option::Option<bool>,
        #[doc = "Loft exception."]
        #[serde(
            rename = "loftException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub loft_exception: ::std::option::Option<crate::schemas::LivingAreaLayoutLoftException>,
        #[doc = "Non smoking. A guestroom in which the smoking of cigarettes, cigars and pipes is prohibited."]
        #[serde(
            rename = "nonSmoking",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub non_smoking: ::std::option::Option<bool>,
        #[doc = "Non smoking exception."]
        #[serde(
            rename = "nonSmokingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub non_smoking_exception:
            ::std::option::Option<crate::schemas::LivingAreaLayoutNonSmokingException>,
        #[doc = "Patio. A paved, outdoor area with seating attached to and accessed through a ground-floor guestroom for use by the occupants of the guestroom."]
        #[serde(
            rename = "patio",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub patio: ::std::option::Option<bool>,
        #[doc = "Patio exception."]
        #[serde(
            rename = "patioException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub patio_exception: ::std::option::Option<crate::schemas::LivingAreaLayoutPatioException>,
        #[doc = "Stairs. There are steps leading from one level or story to another in the unit."]
        #[serde(
            rename = "stairs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stairs: ::std::option::Option<bool>,
        #[doc = "Stairs exception."]
        #[serde(
            rename = "stairsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub stairs_exception:
            ::std::option::Option<crate::schemas::LivingAreaLayoutStairsException>,
    }
    impl ::google_field_selector::FieldSelector for LivingAreaLayout {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaLayout {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaLayoutBalconyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaLayoutBalconyException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaLayoutBalconyException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaLayoutBalconyException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaLayoutBalconyException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaLayoutBalconyException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaLayoutBalconyException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaLayoutBalconyException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaLayoutBalconyException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaLayoutBalconyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutBalconyException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaLayoutBalconyException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaLayoutBalconyException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaLayoutBalconyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaLayoutBalconyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaLayoutBalconyException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaLayoutBalconyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutBalconyException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaLayoutBalconyException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaLayoutBalconyException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaLayoutBalconyException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaLayoutBalconyException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaLayoutLivingAreaSqMetersException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaLayoutLivingAreaSqMetersException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaLayoutLivingAreaSqMetersException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaLayoutLivingAreaSqMetersException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaLayoutLivingAreaSqMetersException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaLayoutLivingAreaSqMetersException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaLayoutLivingAreaSqMetersException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaLayoutLivingAreaSqMetersException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaLayoutLivingAreaSqMetersException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaLayoutLivingAreaSqMetersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaLayoutLivingAreaSqMetersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaLayoutLivingAreaSqMetersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaLayoutLivingAreaSqMetersException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaLayoutLivingAreaSqMetersException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaLayoutLivingAreaSqMetersException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaLayoutLivingAreaSqMetersException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaLayoutLivingAreaSqMetersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaLayoutLivingAreaSqMetersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaLayoutLivingAreaSqMetersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaLayoutLivingAreaSqMetersException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaLayoutLivingAreaSqMetersException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaLayoutLivingAreaSqMetersException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaLayoutLoftException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaLayoutLoftException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaLayoutLoftException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LivingAreaLayoutLoftException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaLayoutLoftException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaLayoutLoftException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaLayoutLoftException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaLayoutLoftException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaLayoutLoftException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaLayoutLoftException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutLoftException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaLayoutLoftException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaLayoutLoftException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaLayoutLoftException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaLayoutLoftException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaLayoutLoftException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaLayoutLoftException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutLoftException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaLayoutLoftException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaLayoutLoftException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaLayoutLoftException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaLayoutLoftException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaLayoutNonSmokingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaLayoutNonSmokingException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaLayoutNonSmokingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaLayoutNonSmokingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaLayoutNonSmokingException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaLayoutNonSmokingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaLayoutNonSmokingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaLayoutNonSmokingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaLayoutNonSmokingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaLayoutNonSmokingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutNonSmokingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaLayoutNonSmokingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaLayoutNonSmokingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaLayoutNonSmokingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaLayoutNonSmokingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaLayoutNonSmokingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaLayoutNonSmokingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutNonSmokingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaLayoutNonSmokingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaLayoutNonSmokingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaLayoutNonSmokingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaLayoutNonSmokingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaLayoutPatioException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaLayoutPatioException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaLayoutPatioException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LivingAreaLayoutPatioException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaLayoutPatioException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaLayoutPatioException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaLayoutPatioException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaLayoutPatioException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaLayoutPatioException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaLayoutPatioException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutPatioException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaLayoutPatioException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaLayoutPatioException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaLayoutPatioException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaLayoutPatioException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaLayoutPatioException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaLayoutPatioException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutPatioException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaLayoutPatioException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaLayoutPatioException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaLayoutPatioException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaLayoutPatioException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaLayoutStairsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaLayoutStairsException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaLayoutStairsException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                LivingAreaLayoutStairsException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaLayoutStairsException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                LivingAreaLayoutStairsException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaLayoutStairsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaLayoutStairsException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaLayoutStairsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaLayoutStairsException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutStairsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaLayoutStairsException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaLayoutStairsException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaLayoutStairsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaLayoutStairsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaLayoutStairsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => LivingAreaLayoutStairsException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => LivingAreaLayoutStairsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => LivingAreaLayoutStairsException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => LivingAreaLayoutStairsException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaLayoutStairsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaLayoutStairsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LivingAreaSleeping {
        #[doc = "Beds count. The number of permanent beds present in a guestroom. Does not include rollaway beds, cribs or sofabeds."]
        #[serde(
            rename = "bedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub beds_count: ::std::option::Option<i32>,
        #[doc = "Beds count exception."]
        #[serde(
            rename = "bedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingBedsCountException>,
        #[doc = "Bunk beds count. The number of furniture pieces in which one framed mattress is fixed directly above another by means of a physical frame. This allows one person(s) to sleep in the bottom bunk and one person(s) to sleep in the top bunk. Also known as double decker bed."]
        #[serde(
            rename = "bunkBedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bunk_beds_count: ::std::option::Option<i32>,
        #[doc = "Bunk beds count exception."]
        #[serde(
            rename = "bunkBedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub bunk_beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingBunkBedsCountException>,
        #[doc = "Cribs count. The number of small beds for an infant or toddler that the guestroom can obtain. The bed is surrounded by a high railing to prevent the child from falling or climbing out of the bed"]
        #[serde(
            rename = "cribsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cribs_count: ::std::option::Option<i32>,
        #[doc = "Cribs count exception."]
        #[serde(
            rename = "cribsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cribs_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingCribsCountException>,
        #[doc = "Double beds count. The number of medium beds measuring 53\"W x 75\"L (135cm x 191cm). Also known as full size bed."]
        #[serde(
            rename = "doubleBedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_beds_count: ::std::option::Option<i32>,
        #[doc = "Double beds count exception."]
        #[serde(
            rename = "doubleBedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub double_beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingDoubleBedsCountException>,
        #[doc = "Feather pillows. The option for guests to obtain bed pillows that are stuffed with the feathers and down of ducks or geese."]
        #[serde(
            rename = "featherPillows",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feather_pillows: ::std::option::Option<bool>,
        #[doc = "Feather pillows exception."]
        #[serde(
            rename = "featherPillowsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub feather_pillows_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingFeatherPillowsException>,
        #[doc = "Hypoallergenic bedding. Bedding such as linens, pillows, mattress covers and/or mattresses that are made of materials known to be resistant to allergens such as mold, dust and dander."]
        #[serde(
            rename = "hypoallergenicBedding",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hypoallergenic_bedding: ::std::option::Option<bool>,
        #[doc = "Hypoallergenic bedding exception."]
        #[serde(
            rename = "hypoallergenicBeddingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hypoallergenic_bedding_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingHypoallergenicBeddingException>,
        #[doc = "King beds count. The number of large beds measuring 76\"W x 80\"L (193cm x 102cm). Most often meant to accompany two people. Includes California king and super king."]
        #[serde(
            rename = "kingBedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub king_beds_count: ::std::option::Option<i32>,
        #[doc = "King beds count exception."]
        #[serde(
            rename = "kingBedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub king_beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingKingBedsCountException>,
        #[doc = "Memory foam pillows. The option for guests to obtain bed pillows that are stuffed with a man-made foam that responds to body heat by conforming to the body closely, and then recovers its shape when the pillow cools down."]
        #[serde(
            rename = "memoryFoamPillows",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub memory_foam_pillows: ::std::option::Option<bool>,
        #[doc = "Memory foam pillows exception."]
        #[serde(
            rename = "memoryFoamPillowsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub memory_foam_pillows_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingMemoryFoamPillowsException>,
        #[doc = "Other beds count. The number of beds that are not standard mattress and boxspring setups such as Japanese tatami mats, trundle beds, air mattresses and cots."]
        #[serde(
            rename = "otherBedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub other_beds_count: ::std::option::Option<i32>,
        #[doc = "Other beds count exception."]
        #[serde(
            rename = "otherBedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub other_beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingOtherBedsCountException>,
        #[doc = "Queen beds count. The number of medium-large beds measuring 60\"W x 80\"L (152cm x 102cm)."]
        #[serde(
            rename = "queenBedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub queen_beds_count: ::std::option::Option<i32>,
        #[doc = "Queen beds count exception."]
        #[serde(
            rename = "queenBedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub queen_beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingQueenBedsCountException>,
        #[doc = "Roll away beds count. The number of mattresses on wheeled frames that can be folded in half and rolled away for easy storage that the guestroom can obtain upon request."]
        #[serde(
            rename = "rollAwayBedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub roll_away_beds_count: ::std::option::Option<i32>,
        #[doc = "Roll away beds count exception."]
        #[serde(
            rename = "rollAwayBedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub roll_away_beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingRollAwayBedsCountException>,
        #[doc = "Single or twin count beds. The number of smaller beds measuring 38\"W x 75\"L (97cm x 191cm) that can accommodate one adult."]
        #[serde(
            rename = "singleOrTwinBedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub single_or_twin_beds_count: ::std::option::Option<i32>,
        #[doc = "Single or twin beds count exception."]
        #[serde(
            rename = "singleOrTwinBedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub single_or_twin_beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingSingleOrTwinBedsCountException>,
        #[doc = "Sofa beds count. The number of specially designed sofas that can be made to serve as a bed by lowering its hinged upholstered back to horizontal position or by pulling out a concealed mattress."]
        #[serde(
            rename = "sofaBedsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sofa_beds_count: ::std::option::Option<i32>,
        #[doc = "Sofa beds count exception."]
        #[serde(
            rename = "sofaBedsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sofa_beds_count_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingSofaBedsCountException>,
        #[doc = "Synthetic pillows. The option for guests to obtain bed pillows stuffed with polyester material crafted to reproduce the feel of a pillow stuffed with down and feathers."]
        #[serde(
            rename = "syntheticPillows",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub synthetic_pillows: ::std::option::Option<bool>,
        #[doc = "Synthetic pillows exception."]
        #[serde(
            rename = "syntheticPillowsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub synthetic_pillows_exception:
            ::std::option::Option<crate::schemas::LivingAreaSleepingSyntheticPillowsException>,
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleeping {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleeping {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingBedsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaSleepingBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingBedsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingBedsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaSleepingBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaSleepingBedsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingBedsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaSleepingBedsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingBedsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingBunkBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingBunkBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingBunkBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingBunkBedsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingBunkBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingBunkBedsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingBunkBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingBunkBedsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingBunkBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingBunkBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingBunkBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingBunkBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingBunkBedsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingBunkBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingBunkBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingBunkBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingBunkBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingBunkBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingBunkBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingBunkBedsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingBunkBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingBunkBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingCribsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingCribsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingCribsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingCribsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                LivingAreaSleepingCribsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingCribsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingCribsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingCribsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<LivingAreaSleepingCribsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingCribsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaSleepingCribsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingCribsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingCribsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingCribsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingCribsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingCribsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingCribsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => LivingAreaSleepingCribsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingCribsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingCribsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingCribsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingCribsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingDoubleBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingDoubleBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingDoubleBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingDoubleBedsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingDoubleBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingDoubleBedsCountException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingDoubleBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingDoubleBedsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingDoubleBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingDoubleBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingDoubleBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingDoubleBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingDoubleBedsCountException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingDoubleBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingDoubleBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingDoubleBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingDoubleBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingDoubleBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingDoubleBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingDoubleBedsCountException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingDoubleBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingDoubleBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingFeatherPillowsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingFeatherPillowsException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingFeatherPillowsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingFeatherPillowsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingFeatherPillowsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingFeatherPillowsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingFeatherPillowsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingFeatherPillowsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingFeatherPillowsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingFeatherPillowsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingFeatherPillowsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingFeatherPillowsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingFeatherPillowsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingFeatherPillowsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingFeatherPillowsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingFeatherPillowsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingFeatherPillowsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingFeatherPillowsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingFeatherPillowsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingFeatherPillowsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingFeatherPillowsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingFeatherPillowsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingHypoallergenicBeddingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingHypoallergenicBeddingException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingHypoallergenicBeddingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingHypoallergenicBeddingException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingHypoallergenicBeddingException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingHypoallergenicBeddingException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingHypoallergenicBeddingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingHypoallergenicBeddingException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingHypoallergenicBeddingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingHypoallergenicBeddingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingHypoallergenicBeddingException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingHypoallergenicBeddingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingHypoallergenicBeddingException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingHypoallergenicBeddingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingHypoallergenicBeddingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingHypoallergenicBeddingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingHypoallergenicBeddingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingHypoallergenicBeddingException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingHypoallergenicBeddingException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingHypoallergenicBeddingException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingHypoallergenicBeddingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingHypoallergenicBeddingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingKingBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingKingBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingKingBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingKingBedsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingKingBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingKingBedsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingKingBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingKingBedsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingKingBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingKingBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingKingBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingKingBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingKingBedsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingKingBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingKingBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingKingBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingKingBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingKingBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingKingBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingKingBedsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingKingBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingKingBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingMemoryFoamPillowsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingMemoryFoamPillowsException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingMemoryFoamPillowsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingMemoryFoamPillowsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingMemoryFoamPillowsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingMemoryFoamPillowsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingMemoryFoamPillowsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingMemoryFoamPillowsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingMemoryFoamPillowsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingMemoryFoamPillowsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingMemoryFoamPillowsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingMemoryFoamPillowsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingMemoryFoamPillowsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingMemoryFoamPillowsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingMemoryFoamPillowsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingMemoryFoamPillowsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingMemoryFoamPillowsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingMemoryFoamPillowsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingMemoryFoamPillowsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingMemoryFoamPillowsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingMemoryFoamPillowsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingMemoryFoamPillowsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingOtherBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingOtherBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingOtherBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingOtherBedsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingOtherBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingOtherBedsCountException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingOtherBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingOtherBedsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingOtherBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingOtherBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingOtherBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingOtherBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingOtherBedsCountException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingOtherBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingOtherBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingOtherBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingOtherBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingOtherBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingOtherBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingOtherBedsCountException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingOtherBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingOtherBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingQueenBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingQueenBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingQueenBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingQueenBedsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingQueenBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingQueenBedsCountException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingQueenBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingQueenBedsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingQueenBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingQueenBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingQueenBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingQueenBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingQueenBedsCountException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingQueenBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingQueenBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingQueenBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingQueenBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingQueenBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingQueenBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingQueenBedsCountException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingQueenBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingQueenBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingRollAwayBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingRollAwayBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingRollAwayBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingRollAwayBedsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingRollAwayBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingRollAwayBedsCountException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingRollAwayBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingRollAwayBedsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingRollAwayBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingRollAwayBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingRollAwayBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingRollAwayBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingRollAwayBedsCountException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingRollAwayBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingRollAwayBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingRollAwayBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingRollAwayBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingRollAwayBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingRollAwayBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingRollAwayBedsCountException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingRollAwayBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingRollAwayBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingSingleOrTwinBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingSingleOrTwinBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingSingleOrTwinBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingSingleOrTwinBedsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingSingleOrTwinBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingSingleOrTwinBedsCountException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingSingleOrTwinBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingSingleOrTwinBedsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingSingleOrTwinBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingSingleOrTwinBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingSingleOrTwinBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingSingleOrTwinBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingSingleOrTwinBedsCountException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingSingleOrTwinBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingSingleOrTwinBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingSingleOrTwinBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingSingleOrTwinBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingSingleOrTwinBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingSingleOrTwinBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingSingleOrTwinBedsCountException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingSingleOrTwinBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingSingleOrTwinBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingSofaBedsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingSofaBedsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingSofaBedsCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingSofaBedsCountException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingSofaBedsCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingSofaBedsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingSofaBedsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingSofaBedsCountException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingSofaBedsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingSofaBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingSofaBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingSofaBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingSofaBedsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingSofaBedsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingSofaBedsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingSofaBedsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingSofaBedsCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingSofaBedsCountException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingSofaBedsCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => LivingAreaSleepingSofaBedsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingSofaBedsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingSofaBedsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum LivingAreaSleepingSyntheticPillowsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl LivingAreaSleepingSyntheticPillowsException {
        pub fn as_str(self) -> &'static str {
            match self {
                LivingAreaSleepingSyntheticPillowsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                LivingAreaSleepingSyntheticPillowsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                LivingAreaSleepingSyntheticPillowsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                LivingAreaSleepingSyntheticPillowsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for LivingAreaSleepingSyntheticPillowsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for LivingAreaSleepingSyntheticPillowsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<LivingAreaSleepingSyntheticPillowsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingSyntheticPillowsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingSyntheticPillowsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingSyntheticPillowsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingSyntheticPillowsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for LivingAreaSleepingSyntheticPillowsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for LivingAreaSleepingSyntheticPillowsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LivingAreaSleepingSyntheticPillowsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    LivingAreaSleepingSyntheticPillowsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    LivingAreaSleepingSyntheticPillowsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    LivingAreaSleepingSyntheticPillowsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    LivingAreaSleepingSyntheticPillowsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for LivingAreaSleepingSyntheticPillowsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LivingAreaSleepingSyntheticPillowsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Lodging {
        #[doc = "Physical adaptations made to the property in consideration of varying levels of human physical ability."]
        #[serde(
            rename = "accessibility",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub accessibility: ::std::option::Option<crate::schemas::Accessibility>,
        #[doc = "Amenities and features related to leisure and play."]
        #[serde(
            rename = "activities",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub activities: ::std::option::Option<crate::schemas::Activities>,
        #[doc = "Output only. All units on the property have at least these attributes."]
        #[serde(
            rename = "allUnits",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub all_units: ::std::option::Option<crate::schemas::GuestUnitFeatures>,
        #[doc = "Features of the property of specific interest to the business traveler."]
        #[serde(
            rename = "business",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub business: ::std::option::Option<crate::schemas::Business>,
        #[doc = "Features of the shared living areas available in this Lodging."]
        #[serde(
            rename = "commonLivingArea",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_living_area: ::std::option::Option<crate::schemas::LivingArea>,
        #[doc = "The ways in which the property provides guests with the ability to access the internet."]
        #[serde(
            rename = "connectivity",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub connectivity: ::std::option::Option<crate::schemas::Connectivity>,
        #[doc = "Services and amenities for families and young guests."]
        #[serde(
            rename = "families",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub families: ::std::option::Option<crate::schemas::Families>,
        #[doc = "Meals, snacks, and beverages available at the property."]
        #[serde(
            rename = "foodAndDrink",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub food_and_drink: ::std::option::Option<crate::schemas::FoodAndDrink>,
        #[doc = "Individual GuestUnitTypes that are available in this Lodging."]
        #[serde(
            rename = "guestUnits",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub guest_units: ::std::option::Option<Vec<crate::schemas::GuestUnitType>>,
        #[doc = "Health and safety measures implemented by the hotel during COVID-19."]
        #[serde(
            rename = "healthAndSafety",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub health_and_safety: ::std::option::Option<crate::schemas::HealthAndSafety>,
        #[doc = "Conveniences provided in guest units to facilitate an easier, more comfortable stay."]
        #[serde(
            rename = "housekeeping",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub housekeeping: ::std::option::Option<crate::schemas::Housekeeping>,
        #[doc = "Required. Metadata for the lodging."]
        #[serde(
            rename = "metadata",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub metadata: ::std::option::Option<crate::schemas::LodgingMetadata>,
        #[doc = "Required. Google identifier for this location in the form: `locations/{location_id}/lodging`"]
        #[serde(
            rename = "name",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub name: ::std::option::Option<String>,
        #[doc = "Parking options at the property."]
        #[serde(
            rename = "parking",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parking: ::std::option::Option<crate::schemas::Parking>,
        #[doc = "Policies regarding guest-owned animals."]
        #[serde(
            rename = "pets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pets: ::std::option::Option<crate::schemas::Pets>,
        #[doc = "Property rules that impact guests."]
        #[serde(
            rename = "policies",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub policies: ::std::option::Option<crate::schemas::Policies>,
        #[doc = "Swimming pool or recreational water facilities available at the hotel."]
        #[serde(
            rename = "pools",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pools: ::std::option::Option<crate::schemas::Pools>,
        #[doc = "General factual information about the property's physical structure and important dates."]
        #[serde(
            rename = "property",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub property: ::std::option::Option<crate::schemas::Property>,
        #[doc = "Conveniences or help provided by the property to facilitate an easier, more comfortable stay."]
        #[serde(
            rename = "services",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub services: ::std::option::Option<crate::schemas::Services>,
        #[doc = "Output only. Some units on the property have as much as these attributes."]
        #[serde(
            rename = "someUnits",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub some_units: ::std::option::Option<crate::schemas::GuestUnitFeatures>,
        #[doc = "Sustainability practices implemented at the hotel."]
        #[serde(
            rename = "sustainability",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sustainability: ::std::option::Option<crate::schemas::Sustainability>,
        #[doc = "Vehicles or vehicular services facilitated or owned by the property."]
        #[serde(
            rename = "transportation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transportation: ::std::option::Option<crate::schemas::Transportation>,
        #[doc = "Guest facilities at the property to promote or maintain health, beauty, and fitness."]
        #[serde(
            rename = "wellness",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wellness: ::std::option::Option<crate::schemas::Wellness>,
    }
    impl ::google_field_selector::FieldSelector for Lodging {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Lodging {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct LodgingMetadata {
        #[doc = "Required. The latest time at which the Lodging data is asserted to be true in the real world. This is not necessarily the time at which the request is made."]
        #[serde(
            rename = "updateTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub update_time: ::std::option::Option<String>,
    }
    impl ::google_field_selector::FieldSelector for LodgingMetadata {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for LodgingMetadata {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MinimizedContact {
        #[doc = "No-contact check-in and check-out."]
        #[serde(
            rename = "contactlessCheckinCheckout",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contactless_checkin_checkout: ::std::option::Option<bool>,
        #[doc = "Contactless check-in check-out exception."]
        #[serde(
            rename = "contactlessCheckinCheckoutException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub contactless_checkin_checkout_exception: ::std::option::Option<
            crate::schemas::MinimizedContactContactlessCheckinCheckoutException,
        >,
        #[doc = "Keyless mobile entry to guest rooms."]
        #[serde(
            rename = "digitalGuestRoomKeys",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub digital_guest_room_keys: ::std::option::Option<bool>,
        #[doc = "Digital guest room keys exception."]
        #[serde(
            rename = "digitalGuestRoomKeysException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub digital_guest_room_keys_exception:
            ::std::option::Option<crate::schemas::MinimizedContactDigitalGuestRoomKeysException>,
        #[doc = "Housekeeping scheduled by request only."]
        #[serde(
            rename = "housekeepingScheduledRequestOnly",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub housekeeping_scheduled_request_only: ::std::option::Option<bool>,
        #[doc = "Housekeeping scheduled request only exception."]
        #[serde(
            rename = "housekeepingScheduledRequestOnlyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub housekeeping_scheduled_request_only_exception: ::std::option::Option<
            crate::schemas::MinimizedContactHousekeepingScheduledRequestOnlyException,
        >,
        #[doc = "High-touch items, such as magazines, removed from common areas."]
        #[serde(
            rename = "noHighTouchItemsCommonAreas",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_high_touch_items_common_areas: ::std::option::Option<bool>,
        #[doc = "No high touch items common areas exception."]
        #[serde(
            rename = "noHighTouchItemsCommonAreasException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_high_touch_items_common_areas_exception: ::std::option::Option<
            crate::schemas::MinimizedContactNoHighTouchItemsCommonAreasException,
        >,
        #[doc = "High-touch items, such as decorative pillows, removed from guest rooms."]
        #[serde(
            rename = "noHighTouchItemsGuestRooms",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_high_touch_items_guest_rooms: ::std::option::Option<bool>,
        #[doc = "No high touch items guest rooms exception."]
        #[serde(
            rename = "noHighTouchItemsGuestRoomsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_high_touch_items_guest_rooms_exception: ::std::option::Option<
            crate::schemas::MinimizedContactNoHighTouchItemsGuestRoomsException,
        >,
        #[doc = "Plastic key cards are disinfected or discarded."]
        #[serde(
            rename = "plasticKeycardsDisinfected",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub plastic_keycards_disinfected: ::std::option::Option<bool>,
        #[doc = "Plastic keycards disinfected exception."]
        #[serde(
            rename = "plasticKeycardsDisinfectedException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub plastic_keycards_disinfected_exception: ::std::option::Option<
            crate::schemas::MinimizedContactPlasticKeycardsDisinfectedException,
        >,
        #[doc = "Buffer maintained between room bookings."]
        #[serde(
            rename = "roomBookingsBuffer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub room_bookings_buffer: ::std::option::Option<bool>,
        #[doc = "Room bookings buffer exception."]
        #[serde(
            rename = "roomBookingsBufferException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub room_bookings_buffer_exception:
            ::std::option::Option<crate::schemas::MinimizedContactRoomBookingsBufferException>,
    }
    impl ::google_field_selector::FieldSelector for MinimizedContact {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MinimizedContact {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MinimizedContactContactlessCheckinCheckoutException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl MinimizedContactContactlessCheckinCheckoutException {
        pub fn as_str(self) -> &'static str {
            match self {
                MinimizedContactContactlessCheckinCheckoutException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                MinimizedContactContactlessCheckinCheckoutException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                MinimizedContactContactlessCheckinCheckoutException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                MinimizedContactContactlessCheckinCheckoutException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MinimizedContactContactlessCheckinCheckoutException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MinimizedContactContactlessCheckinCheckoutException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<MinimizedContactContactlessCheckinCheckoutException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactContactlessCheckinCheckoutException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactContactlessCheckinCheckoutException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactContactlessCheckinCheckoutException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactContactlessCheckinCheckoutException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MinimizedContactContactlessCheckinCheckoutException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MinimizedContactContactlessCheckinCheckoutException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MinimizedContactContactlessCheckinCheckoutException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactContactlessCheckinCheckoutException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactContactlessCheckinCheckoutException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactContactlessCheckinCheckoutException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactContactlessCheckinCheckoutException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for MinimizedContactContactlessCheckinCheckoutException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MinimizedContactContactlessCheckinCheckoutException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MinimizedContactDigitalGuestRoomKeysException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl MinimizedContactDigitalGuestRoomKeysException {
        pub fn as_str(self) -> &'static str {
            match self {
                MinimizedContactDigitalGuestRoomKeysException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                MinimizedContactDigitalGuestRoomKeysException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                MinimizedContactDigitalGuestRoomKeysException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                MinimizedContactDigitalGuestRoomKeysException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MinimizedContactDigitalGuestRoomKeysException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MinimizedContactDigitalGuestRoomKeysException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<MinimizedContactDigitalGuestRoomKeysException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactDigitalGuestRoomKeysException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactDigitalGuestRoomKeysException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactDigitalGuestRoomKeysException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactDigitalGuestRoomKeysException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MinimizedContactDigitalGuestRoomKeysException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MinimizedContactDigitalGuestRoomKeysException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MinimizedContactDigitalGuestRoomKeysException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactDigitalGuestRoomKeysException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactDigitalGuestRoomKeysException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactDigitalGuestRoomKeysException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactDigitalGuestRoomKeysException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MinimizedContactDigitalGuestRoomKeysException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MinimizedContactDigitalGuestRoomKeysException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MinimizedContactHousekeepingScheduledRequestOnlyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl MinimizedContactHousekeepingScheduledRequestOnlyException {
        pub fn as_str(self) -> &'static str {
            match self {
                MinimizedContactHousekeepingScheduledRequestOnlyException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                MinimizedContactHousekeepingScheduledRequestOnlyException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                MinimizedContactHousekeepingScheduledRequestOnlyException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                MinimizedContactHousekeepingScheduledRequestOnlyException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MinimizedContactHousekeepingScheduledRequestOnlyException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MinimizedContactHousekeepingScheduledRequestOnlyException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<MinimizedContactHousekeepingScheduledRequestOnlyException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactHousekeepingScheduledRequestOnlyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactHousekeepingScheduledRequestOnlyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactHousekeepingScheduledRequestOnlyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactHousekeepingScheduledRequestOnlyException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MinimizedContactHousekeepingScheduledRequestOnlyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MinimizedContactHousekeepingScheduledRequestOnlyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MinimizedContactHousekeepingScheduledRequestOnlyException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactHousekeepingScheduledRequestOnlyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactHousekeepingScheduledRequestOnlyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactHousekeepingScheduledRequestOnlyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactHousekeepingScheduledRequestOnlyException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for MinimizedContactHousekeepingScheduledRequestOnlyException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for MinimizedContactHousekeepingScheduledRequestOnlyException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MinimizedContactNoHighTouchItemsCommonAreasException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl MinimizedContactNoHighTouchItemsCommonAreasException {
        pub fn as_str(self) -> &'static str {
            match self {
                MinimizedContactNoHighTouchItemsCommonAreasException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                MinimizedContactNoHighTouchItemsCommonAreasException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                MinimizedContactNoHighTouchItemsCommonAreasException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                MinimizedContactNoHighTouchItemsCommonAreasException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MinimizedContactNoHighTouchItemsCommonAreasException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MinimizedContactNoHighTouchItemsCommonAreasException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<MinimizedContactNoHighTouchItemsCommonAreasException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactNoHighTouchItemsCommonAreasException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactNoHighTouchItemsCommonAreasException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactNoHighTouchItemsCommonAreasException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactNoHighTouchItemsCommonAreasException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MinimizedContactNoHighTouchItemsCommonAreasException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MinimizedContactNoHighTouchItemsCommonAreasException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MinimizedContactNoHighTouchItemsCommonAreasException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactNoHighTouchItemsCommonAreasException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactNoHighTouchItemsCommonAreasException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactNoHighTouchItemsCommonAreasException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactNoHighTouchItemsCommonAreasException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for MinimizedContactNoHighTouchItemsCommonAreasException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MinimizedContactNoHighTouchItemsCommonAreasException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MinimizedContactNoHighTouchItemsGuestRoomsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl MinimizedContactNoHighTouchItemsGuestRoomsException {
        pub fn as_str(self) -> &'static str {
            match self {
                MinimizedContactNoHighTouchItemsGuestRoomsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                MinimizedContactNoHighTouchItemsGuestRoomsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                MinimizedContactNoHighTouchItemsGuestRoomsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                MinimizedContactNoHighTouchItemsGuestRoomsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MinimizedContactNoHighTouchItemsGuestRoomsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MinimizedContactNoHighTouchItemsGuestRoomsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<MinimizedContactNoHighTouchItemsGuestRoomsException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactNoHighTouchItemsGuestRoomsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactNoHighTouchItemsGuestRoomsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactNoHighTouchItemsGuestRoomsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactNoHighTouchItemsGuestRoomsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MinimizedContactNoHighTouchItemsGuestRoomsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MinimizedContactNoHighTouchItemsGuestRoomsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MinimizedContactNoHighTouchItemsGuestRoomsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactNoHighTouchItemsGuestRoomsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactNoHighTouchItemsGuestRoomsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactNoHighTouchItemsGuestRoomsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactNoHighTouchItemsGuestRoomsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for MinimizedContactNoHighTouchItemsGuestRoomsException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MinimizedContactNoHighTouchItemsGuestRoomsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MinimizedContactPlasticKeycardsDisinfectedException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl MinimizedContactPlasticKeycardsDisinfectedException {
        pub fn as_str(self) -> &'static str {
            match self {
                MinimizedContactPlasticKeycardsDisinfectedException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                MinimizedContactPlasticKeycardsDisinfectedException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                MinimizedContactPlasticKeycardsDisinfectedException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                MinimizedContactPlasticKeycardsDisinfectedException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MinimizedContactPlasticKeycardsDisinfectedException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MinimizedContactPlasticKeycardsDisinfectedException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<MinimizedContactPlasticKeycardsDisinfectedException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactPlasticKeycardsDisinfectedException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactPlasticKeycardsDisinfectedException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactPlasticKeycardsDisinfectedException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactPlasticKeycardsDisinfectedException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MinimizedContactPlasticKeycardsDisinfectedException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MinimizedContactPlasticKeycardsDisinfectedException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MinimizedContactPlasticKeycardsDisinfectedException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactPlasticKeycardsDisinfectedException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactPlasticKeycardsDisinfectedException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactPlasticKeycardsDisinfectedException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactPlasticKeycardsDisinfectedException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for MinimizedContactPlasticKeycardsDisinfectedException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MinimizedContactPlasticKeycardsDisinfectedException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum MinimizedContactRoomBookingsBufferException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl MinimizedContactRoomBookingsBufferException {
        pub fn as_str(self) -> &'static str {
            match self {
                MinimizedContactRoomBookingsBufferException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                MinimizedContactRoomBookingsBufferException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                MinimizedContactRoomBookingsBufferException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                MinimizedContactRoomBookingsBufferException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for MinimizedContactRoomBookingsBufferException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for MinimizedContactRoomBookingsBufferException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<MinimizedContactRoomBookingsBufferException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactRoomBookingsBufferException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactRoomBookingsBufferException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactRoomBookingsBufferException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactRoomBookingsBufferException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for MinimizedContactRoomBookingsBufferException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for MinimizedContactRoomBookingsBufferException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MinimizedContactRoomBookingsBufferException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    MinimizedContactRoomBookingsBufferException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    MinimizedContactRoomBookingsBufferException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    MinimizedContactRoomBookingsBufferException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    MinimizedContactRoomBookingsBufferException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for MinimizedContactRoomBookingsBufferException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for MinimizedContactRoomBookingsBufferException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Parking {
        #[doc = "Electric car charging stations. Electric power stations, usually located outdoors, into which guests plug their electric cars to receive a charge."]
        #[serde(
            rename = "electricCarChargingStations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub electric_car_charging_stations: ::std::option::Option<bool>,
        #[doc = "Electric car charging stations exception."]
        #[serde(
            rename = "electricCarChargingStationsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub electric_car_charging_stations_exception:
            ::std::option::Option<crate::schemas::ParkingElectricCarChargingStationsException>,
        #[doc = "Free parking. The hotel allows the cars of guests to be parked for free. Parking facility may be an outdoor lot or an indoor garage, but must be onsite. Nearby parking does not apply. Parking may be performed by the guest or by hotel staff. Free parking must be available to all guests (limited conditions does not apply)."]
        #[serde(
            rename = "freeParking",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_parking: ::std::option::Option<bool>,
        #[doc = "Free parking exception."]
        #[serde(
            rename = "freeParkingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_parking_exception:
            ::std::option::Option<crate::schemas::ParkingFreeParkingException>,
        #[doc = "Free self parking. Guests park their own cars for free. Parking facility may be an outdoor lot or an indoor garage, but must be onsite. Nearby parking does not apply."]
        #[serde(
            rename = "freeSelfParking",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_self_parking: ::std::option::Option<bool>,
        #[doc = "Free self parking exception."]
        #[serde(
            rename = "freeSelfParkingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_self_parking_exception:
            ::std::option::Option<crate::schemas::ParkingFreeSelfParkingException>,
        #[doc = "Free valet parking. Hotel staff member parks the cars of guests. Parking with this service is free."]
        #[serde(
            rename = "freeValetParking",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_valet_parking: ::std::option::Option<bool>,
        #[doc = "Free valet parking exception."]
        #[serde(
            rename = "freeValetParkingException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_valet_parking_exception:
            ::std::option::Option<crate::schemas::ParkingFreeValetParkingException>,
        #[doc = "Parking available. The hotel allows the cars of guests to be parked. Can be free or for a fee. Parking facility may be an outdoor lot or an indoor garage, but must be onsite. Nearby parking does not apply. Parking may be performed by the guest or by hotel staff."]
        #[serde(
            rename = "parkingAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parking_available: ::std::option::Option<bool>,
        #[doc = "Parking available exception."]
        #[serde(
            rename = "parkingAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub parking_available_exception:
            ::std::option::Option<crate::schemas::ParkingParkingAvailableException>,
        #[doc = "Self parking available. Guests park their own cars. Parking facility may be an outdoor lot or an indoor garage, but must be onsite. Nearby parking does not apply. Can be free or for a fee."]
        #[serde(
            rename = "selfParkingAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub self_parking_available: ::std::option::Option<bool>,
        #[doc = "Self parking available exception."]
        #[serde(
            rename = "selfParkingAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub self_parking_available_exception:
            ::std::option::Option<crate::schemas::ParkingSelfParkingAvailableException>,
        #[doc = "Valet parking available. Hotel staff member parks the cars of guests. Parking with this service can be free or for a fee."]
        #[serde(
            rename = "valetParkingAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub valet_parking_available: ::std::option::Option<bool>,
        #[doc = "Valet parking available exception."]
        #[serde(
            rename = "valetParkingAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub valet_parking_available_exception:
            ::std::option::Option<crate::schemas::ParkingValetParkingAvailableException>,
    }
    impl ::google_field_selector::FieldSelector for Parking {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Parking {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ParkingElectricCarChargingStationsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ParkingElectricCarChargingStationsException {
        pub fn as_str(self) -> &'static str {
            match self {
                ParkingElectricCarChargingStationsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ParkingElectricCarChargingStationsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                ParkingElectricCarChargingStationsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ParkingElectricCarChargingStationsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for ParkingElectricCarChargingStationsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ParkingElectricCarChargingStationsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<ParkingElectricCarChargingStationsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingElectricCarChargingStationsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    ParkingElectricCarChargingStationsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    ParkingElectricCarChargingStationsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    ParkingElectricCarChargingStationsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ParkingElectricCarChargingStationsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ParkingElectricCarChargingStationsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ParkingElectricCarChargingStationsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingElectricCarChargingStationsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    ParkingElectricCarChargingStationsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    ParkingElectricCarChargingStationsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    ParkingElectricCarChargingStationsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ParkingElectricCarChargingStationsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ParkingElectricCarChargingStationsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ParkingFreeParkingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ParkingFreeParkingException {
        pub fn as_str(self) -> &'static str {
            match self {
                ParkingFreeParkingException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ParkingFreeParkingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ParkingFreeParkingException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ParkingFreeParkingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ParkingFreeParkingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ParkingFreeParkingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ParkingFreeParkingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ParkingFreeParkingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ParkingFreeParkingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ParkingFreeParkingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ParkingFreeParkingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ParkingFreeParkingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ParkingFreeParkingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ParkingFreeParkingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ParkingFreeParkingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ParkingFreeParkingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ParkingFreeParkingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ParkingFreeParkingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ParkingFreeParkingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ParkingFreeParkingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ParkingFreeSelfParkingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ParkingFreeSelfParkingException {
        pub fn as_str(self) -> &'static str {
            match self {
                ParkingFreeSelfParkingException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ParkingFreeSelfParkingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ParkingFreeSelfParkingException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ParkingFreeSelfParkingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ParkingFreeSelfParkingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ParkingFreeSelfParkingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ParkingFreeSelfParkingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ParkingFreeSelfParkingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ParkingFreeSelfParkingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ParkingFreeSelfParkingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ParkingFreeSelfParkingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ParkingFreeSelfParkingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ParkingFreeSelfParkingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ParkingFreeSelfParkingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ParkingFreeSelfParkingException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ParkingFreeSelfParkingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ParkingFreeSelfParkingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ParkingFreeSelfParkingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ParkingFreeSelfParkingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ParkingFreeSelfParkingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ParkingFreeValetParkingException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ParkingFreeValetParkingException {
        pub fn as_str(self) -> &'static str {
            match self {
                ParkingFreeValetParkingException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ParkingFreeValetParkingException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ParkingFreeValetParkingException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ParkingFreeValetParkingException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ParkingFreeValetParkingException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ParkingFreeValetParkingException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ParkingFreeValetParkingException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingFreeValetParkingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ParkingFreeValetParkingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ParkingFreeValetParkingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ParkingFreeValetParkingException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ParkingFreeValetParkingException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ParkingFreeValetParkingException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ParkingFreeValetParkingException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingFreeValetParkingException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ParkingFreeValetParkingException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ParkingFreeValetParkingException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ParkingFreeValetParkingException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ParkingFreeValetParkingException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ParkingFreeValetParkingException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ParkingParkingAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ParkingParkingAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                ParkingParkingAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ParkingParkingAvailableException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ParkingParkingAvailableException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ParkingParkingAvailableException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ParkingParkingAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ParkingParkingAvailableException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ParkingParkingAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingParkingAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ParkingParkingAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ParkingParkingAvailableException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ParkingParkingAvailableException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ParkingParkingAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ParkingParkingAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ParkingParkingAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingParkingAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ParkingParkingAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ParkingParkingAvailableException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ParkingParkingAvailableException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ParkingParkingAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ParkingParkingAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ParkingSelfParkingAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ParkingSelfParkingAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                ParkingSelfParkingAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ParkingSelfParkingAvailableException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ParkingSelfParkingAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ParkingSelfParkingAvailableException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ParkingSelfParkingAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ParkingSelfParkingAvailableException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ParkingSelfParkingAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingSelfParkingAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ParkingSelfParkingAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ParkingSelfParkingAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ParkingSelfParkingAvailableException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ParkingSelfParkingAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ParkingSelfParkingAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ParkingSelfParkingAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingSelfParkingAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ParkingSelfParkingAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ParkingSelfParkingAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ParkingSelfParkingAvailableException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ParkingSelfParkingAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ParkingSelfParkingAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ParkingValetParkingAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ParkingValetParkingAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                ParkingValetParkingAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ParkingValetParkingAvailableException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ParkingValetParkingAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ParkingValetParkingAvailableException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ParkingValetParkingAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ParkingValetParkingAvailableException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ParkingValetParkingAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingValetParkingAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ParkingValetParkingAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ParkingValetParkingAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ParkingValetParkingAvailableException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ParkingValetParkingAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ParkingValetParkingAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ParkingValetParkingAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ParkingValetParkingAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ParkingValetParkingAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ParkingValetParkingAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ParkingValetParkingAvailableException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ParkingValetParkingAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ParkingValetParkingAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PaymentOptions {
        #[doc = "Cash. The hotel accepts payment by paper/coin currency."]
        #[serde(
            rename = "cash",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cash: ::std::option::Option<bool>,
        #[doc = "Cash exception."]
        #[serde(
            rename = "cashException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cash_exception: ::std::option::Option<crate::schemas::PaymentOptionsCashException>,
        #[doc = "Cheque. The hotel accepts a printed document issued by the guest's bank in the guest's name as a form of payment."]
        #[serde(
            rename = "cheque",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cheque: ::std::option::Option<bool>,
        #[doc = "Cheque exception."]
        #[serde(
            rename = "chequeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cheque_exception: ::std::option::Option<crate::schemas::PaymentOptionsChequeException>,
        #[doc = "Credit card. The hotel accepts payment by a card issued by a bank or credit card company. Also known as charge card, debit card, bank card, or charge plate."]
        #[serde(
            rename = "creditCard",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub credit_card: ::std::option::Option<bool>,
        #[doc = "Credit card exception."]
        #[serde(
            rename = "creditCardException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub credit_card_exception:
            ::std::option::Option<crate::schemas::PaymentOptionsCreditCardException>,
        #[doc = "Debit card. The hotel accepts a bank-issued card that immediately deducts the charged funds from the guest's bank account upon processing."]
        #[serde(
            rename = "debitCard",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debit_card: ::std::option::Option<bool>,
        #[doc = "Debit card exception."]
        #[serde(
            rename = "debitCardException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub debit_card_exception:
            ::std::option::Option<crate::schemas::PaymentOptionsDebitCardException>,
        #[doc = "Mobile nfc. The hotel has the compatible computer hardware terminal that reads and charges a payment app on the guest's smartphone without requiring the two devices to make physical contact. Also known as Apple Pay, Google Pay, Samsung Pay."]
        #[serde(
            rename = "mobileNfc",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobile_nfc: ::std::option::Option<bool>,
        #[doc = "Mobile nfc exception."]
        #[serde(
            rename = "mobileNfcException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub mobile_nfc_exception:
            ::std::option::Option<crate::schemas::PaymentOptionsMobileNfcException>,
    }
    impl ::google_field_selector::FieldSelector for PaymentOptions {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PaymentOptions {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PaymentOptionsCashException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PaymentOptionsCashException {
        pub fn as_str(self) -> &'static str {
            match self {
                PaymentOptionsCashException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PaymentOptionsCashException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PaymentOptionsCashException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PaymentOptionsCashException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PaymentOptionsCashException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PaymentOptionsCashException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PaymentOptionsCashException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PaymentOptionsCashException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PaymentOptionsCashException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsCashException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsCashException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PaymentOptionsCashException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PaymentOptionsCashException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaymentOptionsCashException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PaymentOptionsCashException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PaymentOptionsCashException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsCashException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsCashException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PaymentOptionsCashException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PaymentOptionsCashException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PaymentOptionsChequeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PaymentOptionsChequeException {
        pub fn as_str(self) -> &'static str {
            match self {
                PaymentOptionsChequeException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PaymentOptionsChequeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PaymentOptionsChequeException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PaymentOptionsChequeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PaymentOptionsChequeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PaymentOptionsChequeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PaymentOptionsChequeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PaymentOptionsChequeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PaymentOptionsChequeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsChequeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsChequeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PaymentOptionsChequeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PaymentOptionsChequeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaymentOptionsChequeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PaymentOptionsChequeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PaymentOptionsChequeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsChequeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsChequeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PaymentOptionsChequeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PaymentOptionsChequeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PaymentOptionsCreditCardException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PaymentOptionsCreditCardException {
        pub fn as_str(self) -> &'static str {
            match self {
                PaymentOptionsCreditCardException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PaymentOptionsCreditCardException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PaymentOptionsCreditCardException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PaymentOptionsCreditCardException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PaymentOptionsCreditCardException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PaymentOptionsCreditCardException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PaymentOptionsCreditCardException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PaymentOptionsCreditCardException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PaymentOptionsCreditCardException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsCreditCardException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsCreditCardException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PaymentOptionsCreditCardException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PaymentOptionsCreditCardException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaymentOptionsCreditCardException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PaymentOptionsCreditCardException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PaymentOptionsCreditCardException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsCreditCardException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsCreditCardException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PaymentOptionsCreditCardException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PaymentOptionsCreditCardException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PaymentOptionsDebitCardException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PaymentOptionsDebitCardException {
        pub fn as_str(self) -> &'static str {
            match self {
                PaymentOptionsDebitCardException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PaymentOptionsDebitCardException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PaymentOptionsDebitCardException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PaymentOptionsDebitCardException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PaymentOptionsDebitCardException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PaymentOptionsDebitCardException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PaymentOptionsDebitCardException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PaymentOptionsDebitCardException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PaymentOptionsDebitCardException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsDebitCardException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsDebitCardException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PaymentOptionsDebitCardException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PaymentOptionsDebitCardException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaymentOptionsDebitCardException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PaymentOptionsDebitCardException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PaymentOptionsDebitCardException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsDebitCardException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsDebitCardException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PaymentOptionsDebitCardException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PaymentOptionsDebitCardException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PaymentOptionsMobileNfcException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PaymentOptionsMobileNfcException {
        pub fn as_str(self) -> &'static str {
            match self {
                PaymentOptionsMobileNfcException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PaymentOptionsMobileNfcException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PaymentOptionsMobileNfcException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PaymentOptionsMobileNfcException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PaymentOptionsMobileNfcException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PaymentOptionsMobileNfcException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PaymentOptionsMobileNfcException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PaymentOptionsMobileNfcException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PaymentOptionsMobileNfcException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsMobileNfcException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsMobileNfcException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PaymentOptionsMobileNfcException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PaymentOptionsMobileNfcException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaymentOptionsMobileNfcException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PaymentOptionsMobileNfcException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PaymentOptionsMobileNfcException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PaymentOptionsMobileNfcException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PaymentOptionsMobileNfcException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PaymentOptionsMobileNfcException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PaymentOptionsMobileNfcException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PersonalProtection {
        #[doc = "Hand-sanitizer and/or sanitizing wipes are offered in common areas."]
        #[serde(
            rename = "commonAreasOfferSanitizingItems",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_areas_offer_sanitizing_items: ::std::option::Option<bool>,
        #[doc = "Common areas offer sanitizing items exception."]
        #[serde(
            rename = "commonAreasOfferSanitizingItemsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_areas_offer_sanitizing_items_exception: ::std::option::Option<
            crate::schemas::PersonalProtectionCommonAreasOfferSanitizingItemsException,
        >,
        #[doc = "Masks required on the property."]
        #[serde(
            rename = "faceMaskRequired",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub face_mask_required: ::std::option::Option<bool>,
        #[doc = "Face mask required exception."]
        #[serde(
            rename = "faceMaskRequiredException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub face_mask_required_exception:
            ::std::option::Option<crate::schemas::PersonalProtectionFaceMaskRequiredException>,
        #[doc = "In-room hygiene kits with masks, hand sanitizer, and/or antibacterial wipes."]
        #[serde(
            rename = "guestRoomHygieneKitsAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub guest_room_hygiene_kits_available: ::std::option::Option<bool>,
        #[doc = "Guest room hygiene kits available exception."]
        #[serde(
            rename = "guestRoomHygieneKitsAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub guest_room_hygiene_kits_available_exception: ::std::option::Option<
            crate::schemas::PersonalProtectionGuestRoomHygieneKitsAvailableException,
        >,
        #[doc = "Masks and/or gloves available for guests."]
        #[serde(
            rename = "protectiveEquipmentAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub protective_equipment_available: ::std::option::Option<bool>,
        #[doc = "Protective equipment available exception."]
        #[serde(
            rename = "protectiveEquipmentAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub protective_equipment_available_exception: ::std::option::Option<
            crate::schemas::PersonalProtectionProtectiveEquipmentAvailableException,
        >,
    }
    impl ::google_field_selector::FieldSelector for PersonalProtection {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PersonalProtection {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PersonalProtectionCommonAreasOfferSanitizingItemsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PersonalProtectionCommonAreasOfferSanitizingItemsException {
        pub fn as_str(self) -> &'static str {
            match self { PersonalProtectionCommonAreasOfferSanitizingItemsException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , PersonalProtectionCommonAreasOfferSanitizingItemsException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , PersonalProtectionCommonAreasOfferSanitizingItemsException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , PersonalProtectionCommonAreasOfferSanitizingItemsException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str> for PersonalProtectionCommonAreasOfferSanitizingItemsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PersonalProtectionCommonAreasOfferSanitizingItemsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<PersonalProtectionCommonAreasOfferSanitizingItemsException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PersonalProtectionCommonAreasOfferSanitizingItemsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PersonalProtectionCommonAreasOfferSanitizingItemsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PersonalProtectionCommonAreasOfferSanitizingItemsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PersonalProtectionCommonAreasOfferSanitizingItemsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PersonalProtectionCommonAreasOfferSanitizingItemsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PersonalProtectionCommonAreasOfferSanitizingItemsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PersonalProtectionCommonAreasOfferSanitizingItemsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PersonalProtectionCommonAreasOfferSanitizingItemsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PersonalProtectionCommonAreasOfferSanitizingItemsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PersonalProtectionCommonAreasOfferSanitizingItemsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PersonalProtectionCommonAreasOfferSanitizingItemsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for PersonalProtectionCommonAreasOfferSanitizingItemsException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for PersonalProtectionCommonAreasOfferSanitizingItemsException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PersonalProtectionFaceMaskRequiredException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PersonalProtectionFaceMaskRequiredException {
        pub fn as_str(self) -> &'static str {
            match self {
                PersonalProtectionFaceMaskRequiredException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PersonalProtectionFaceMaskRequiredException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                PersonalProtectionFaceMaskRequiredException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PersonalProtectionFaceMaskRequiredException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for PersonalProtectionFaceMaskRequiredException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PersonalProtectionFaceMaskRequiredException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<PersonalProtectionFaceMaskRequiredException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PersonalProtectionFaceMaskRequiredException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PersonalProtectionFaceMaskRequiredException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PersonalProtectionFaceMaskRequiredException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PersonalProtectionFaceMaskRequiredException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PersonalProtectionFaceMaskRequiredException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PersonalProtectionFaceMaskRequiredException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PersonalProtectionFaceMaskRequiredException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PersonalProtectionFaceMaskRequiredException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PersonalProtectionFaceMaskRequiredException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PersonalProtectionFaceMaskRequiredException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PersonalProtectionFaceMaskRequiredException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PersonalProtectionFaceMaskRequiredException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PersonalProtectionFaceMaskRequiredException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PersonalProtectionGuestRoomHygieneKitsAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PersonalProtectionGuestRoomHygieneKitsAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                PersonalProtectionGuestRoomHygieneKitsAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PersonalProtectionGuestRoomHygieneKitsAvailableException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                PersonalProtectionGuestRoomHygieneKitsAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PersonalProtectionGuestRoomHygieneKitsAvailableException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for PersonalProtectionGuestRoomHygieneKitsAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PersonalProtectionGuestRoomHygieneKitsAvailableException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<PersonalProtectionGuestRoomHygieneKitsAvailableException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PersonalProtectionGuestRoomHygieneKitsAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PersonalProtectionGuestRoomHygieneKitsAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PersonalProtectionGuestRoomHygieneKitsAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PersonalProtectionGuestRoomHygieneKitsAvailableException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PersonalProtectionGuestRoomHygieneKitsAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PersonalProtectionGuestRoomHygieneKitsAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PersonalProtectionGuestRoomHygieneKitsAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PersonalProtectionGuestRoomHygieneKitsAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PersonalProtectionGuestRoomHygieneKitsAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PersonalProtectionGuestRoomHygieneKitsAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PersonalProtectionGuestRoomHygieneKitsAvailableException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for PersonalProtectionGuestRoomHygieneKitsAvailableException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for PersonalProtectionGuestRoomHygieneKitsAvailableException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PersonalProtectionProtectiveEquipmentAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PersonalProtectionProtectiveEquipmentAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                PersonalProtectionProtectiveEquipmentAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PersonalProtectionProtectiveEquipmentAvailableException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                PersonalProtectionProtectiveEquipmentAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PersonalProtectionProtectiveEquipmentAvailableException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for PersonalProtectionProtectiveEquipmentAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PersonalProtectionProtectiveEquipmentAvailableException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<PersonalProtectionProtectiveEquipmentAvailableException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PersonalProtectionProtectiveEquipmentAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PersonalProtectionProtectiveEquipmentAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PersonalProtectionProtectiveEquipmentAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PersonalProtectionProtectiveEquipmentAvailableException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PersonalProtectionProtectiveEquipmentAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PersonalProtectionProtectiveEquipmentAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PersonalProtectionProtectiveEquipmentAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PersonalProtectionProtectiveEquipmentAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PersonalProtectionProtectiveEquipmentAvailableException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PersonalProtectionProtectiveEquipmentAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PersonalProtectionProtectiveEquipmentAvailableException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for PersonalProtectionProtectiveEquipmentAvailableException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for PersonalProtectionProtectiveEquipmentAvailableException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Pets {
        #[doc = "Cats allowed. Domesticated felines are permitted at the property and allowed to stay in the guest room of their owner. May or may not require a fee."]
        #[serde(
            rename = "catsAllowed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cats_allowed: ::std::option::Option<bool>,
        #[doc = "Cats allowed exception."]
        #[serde(
            rename = "catsAllowedException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub cats_allowed_exception: ::std::option::Option<crate::schemas::PetsCatsAllowedException>,
        #[doc = "Dogs allowed. Domesticated canines are permitted at the property and allowed to stay in the guest room of their owner. May or may not require a fee."]
        #[serde(
            rename = "dogsAllowed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dogs_allowed: ::std::option::Option<bool>,
        #[doc = "Dogs allowed exception."]
        #[serde(
            rename = "dogsAllowedException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub dogs_allowed_exception: ::std::option::Option<crate::schemas::PetsDogsAllowedException>,
        #[doc = "Pets allowed. Household animals are allowed at the property and in the specific guest room of their owner. May or may not include dogs, cats, reptiles and/or fish. May or may not require a fee. Service animals are not considered to be pets, so not governed by this policy."]
        #[serde(
            rename = "petsAllowed",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pets_allowed: ::std::option::Option<bool>,
        #[doc = "Pets allowed exception."]
        #[serde(
            rename = "petsAllowedException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pets_allowed_exception: ::std::option::Option<crate::schemas::PetsPetsAllowedException>,
        #[doc = "Pets allowed free. Household animals are allowed at the property and in the specific guest room of their owner for free. May or may not include dogs, cats, reptiles, and/or fish."]
        #[serde(
            rename = "petsAllowedFree",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pets_allowed_free: ::std::option::Option<bool>,
        #[doc = "Pets allowed free exception."]
        #[serde(
            rename = "petsAllowedFreeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pets_allowed_free_exception:
            ::std::option::Option<crate::schemas::PetsPetsAllowedFreeException>,
    }
    impl ::google_field_selector::FieldSelector for Pets {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Pets {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PetsCatsAllowedException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PetsCatsAllowedException {
        pub fn as_str(self) -> &'static str {
            match self {
                PetsCatsAllowedException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PetsCatsAllowedException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PetsCatsAllowedException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PetsCatsAllowedException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PetsCatsAllowedException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PetsCatsAllowedException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PetsCatsAllowedException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PetsCatsAllowedException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PetsCatsAllowedException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PetsCatsAllowedException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PetsCatsAllowedException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PetsCatsAllowedException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PetsCatsAllowedException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PetsCatsAllowedException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PetsCatsAllowedException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PetsCatsAllowedException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PetsCatsAllowedException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PetsCatsAllowedException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PetsCatsAllowedException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PetsCatsAllowedException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PetsDogsAllowedException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PetsDogsAllowedException {
        pub fn as_str(self) -> &'static str {
            match self {
                PetsDogsAllowedException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PetsDogsAllowedException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PetsDogsAllowedException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PetsDogsAllowedException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PetsDogsAllowedException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PetsDogsAllowedException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PetsDogsAllowedException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PetsDogsAllowedException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PetsDogsAllowedException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PetsDogsAllowedException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PetsDogsAllowedException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PetsDogsAllowedException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PetsDogsAllowedException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PetsDogsAllowedException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PetsDogsAllowedException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PetsDogsAllowedException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PetsDogsAllowedException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PetsDogsAllowedException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PetsDogsAllowedException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PetsDogsAllowedException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PetsPetsAllowedException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PetsPetsAllowedException {
        pub fn as_str(self) -> &'static str {
            match self {
                PetsPetsAllowedException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PetsPetsAllowedException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PetsPetsAllowedException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PetsPetsAllowedException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PetsPetsAllowedException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PetsPetsAllowedException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PetsPetsAllowedException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PetsPetsAllowedException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PetsPetsAllowedException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PetsPetsAllowedException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PetsPetsAllowedException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PetsPetsAllowedException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PetsPetsAllowedException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PetsPetsAllowedException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PetsPetsAllowedException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PetsPetsAllowedException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PetsPetsAllowedException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PetsPetsAllowedException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PetsPetsAllowedException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PetsPetsAllowedException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PetsPetsAllowedFreeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PetsPetsAllowedFreeException {
        pub fn as_str(self) -> &'static str {
            match self {
                PetsPetsAllowedFreeException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PetsPetsAllowedFreeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PetsPetsAllowedFreeException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PetsPetsAllowedFreeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PetsPetsAllowedFreeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PetsPetsAllowedFreeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PetsPetsAllowedFreeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PetsPetsAllowedFreeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PetsPetsAllowedFreeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PetsPetsAllowedFreeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PetsPetsAllowedFreeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PetsPetsAllowedFreeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PetsPetsAllowedFreeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PetsPetsAllowedFreeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PetsPetsAllowedFreeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PetsPetsAllowedFreeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PetsPetsAllowedFreeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PetsPetsAllowedFreeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PetsPetsAllowedFreeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PetsPetsAllowedFreeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PhysicalDistancing {
        #[doc = "Common areas arranged to maintain physical distancing."]
        #[serde(
            rename = "commonAreasPhysicalDistancingArranged",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_areas_physical_distancing_arranged: ::std::option::Option<bool>,
        #[doc = "Common areas physical distancing arranged exception."]
        #[serde(
            rename = "commonAreasPhysicalDistancingArrangedException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub common_areas_physical_distancing_arranged_exception: ::std::option::Option<
            crate::schemas::PhysicalDistancingCommonAreasPhysicalDistancingArrangedException,
        >,
        #[doc = "Physical distancing required."]
        #[serde(
            rename = "physicalDistancingRequired",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub physical_distancing_required: ::std::option::Option<bool>,
        #[doc = "Physical distancing required exception."]
        #[serde(
            rename = "physicalDistancingRequiredException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub physical_distancing_required_exception: ::std::option::Option<
            crate::schemas::PhysicalDistancingPhysicalDistancingRequiredException,
        >,
        #[doc = "Safety dividers at front desk and other locations."]
        #[serde(
            rename = "safetyDividers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safety_dividers: ::std::option::Option<bool>,
        #[doc = "Safety dividers exception."]
        #[serde(
            rename = "safetyDividersException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safety_dividers_exception:
            ::std::option::Option<crate::schemas::PhysicalDistancingSafetyDividersException>,
        #[doc = "Guest occupancy limited within shared facilities."]
        #[serde(
            rename = "sharedAreasLimitedOccupancy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shared_areas_limited_occupancy: ::std::option::Option<bool>,
        #[doc = "Shared areas limited occupancy exception."]
        #[serde(
            rename = "sharedAreasLimitedOccupancyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub shared_areas_limited_occupancy_exception: ::std::option::Option<
            crate::schemas::PhysicalDistancingSharedAreasLimitedOccupancyException,
        >,
        #[doc = "Private spaces designated in spa and wellness areas."]
        #[serde(
            rename = "wellnessAreasHavePrivateSpaces",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wellness_areas_have_private_spaces: ::std::option::Option<bool>,
        #[doc = "Wellness areas have private spaces exception."]
        #[serde(
            rename = "wellnessAreasHavePrivateSpacesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wellness_areas_have_private_spaces_exception: ::std::option::Option<
            crate::schemas::PhysicalDistancingWellnessAreasHavePrivateSpacesException,
        >,
    }
    impl ::google_field_selector::FieldSelector for PhysicalDistancing {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PhysicalDistancing {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PhysicalDistancingCommonAreasPhysicalDistancingArrangedException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PhysicalDistancingCommonAreasPhysicalDistancingArrangedException {
        pub fn as_str(self) -> &'static str {
            match self { PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for PhysicalDistancingCommonAreasPhysicalDistancingArrangedException
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PhysicalDistancingCommonAreasPhysicalDistancingArrangedException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            PhysicalDistancingCommonAreasPhysicalDistancingArrangedException,
            (),
        > {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for PhysicalDistancingCommonAreasPhysicalDistancingArrangedException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PhysicalDistancingCommonAreasPhysicalDistancingArrangedException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for PhysicalDistancingCommonAreasPhysicalDistancingArrangedException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => PhysicalDistancingCommonAreasPhysicalDistancingArrangedException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for PhysicalDistancingCommonAreasPhysicalDistancingArrangedException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for PhysicalDistancingCommonAreasPhysicalDistancingArrangedException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PhysicalDistancingPhysicalDistancingRequiredException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PhysicalDistancingPhysicalDistancingRequiredException {
        pub fn as_str(self) -> &'static str {
            match self {
                PhysicalDistancingPhysicalDistancingRequiredException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PhysicalDistancingPhysicalDistancingRequiredException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                PhysicalDistancingPhysicalDistancingRequiredException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PhysicalDistancingPhysicalDistancingRequiredException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for PhysicalDistancingPhysicalDistancingRequiredException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PhysicalDistancingPhysicalDistancingRequiredException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<PhysicalDistancingPhysicalDistancingRequiredException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PhysicalDistancingPhysicalDistancingRequiredException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PhysicalDistancingPhysicalDistancingRequiredException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PhysicalDistancingPhysicalDistancingRequiredException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PhysicalDistancingPhysicalDistancingRequiredException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PhysicalDistancingPhysicalDistancingRequiredException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PhysicalDistancingPhysicalDistancingRequiredException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PhysicalDistancingPhysicalDistancingRequiredException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PhysicalDistancingPhysicalDistancingRequiredException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PhysicalDistancingPhysicalDistancingRequiredException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PhysicalDistancingPhysicalDistancingRequiredException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PhysicalDistancingPhysicalDistancingRequiredException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for PhysicalDistancingPhysicalDistancingRequiredException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for PhysicalDistancingPhysicalDistancingRequiredException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PhysicalDistancingSafetyDividersException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PhysicalDistancingSafetyDividersException {
        pub fn as_str(self) -> &'static str {
            match self {
                PhysicalDistancingSafetyDividersException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PhysicalDistancingSafetyDividersException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                PhysicalDistancingSafetyDividersException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PhysicalDistancingSafetyDividersException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for PhysicalDistancingSafetyDividersException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PhysicalDistancingSafetyDividersException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<PhysicalDistancingSafetyDividersException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PhysicalDistancingSafetyDividersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PhysicalDistancingSafetyDividersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PhysicalDistancingSafetyDividersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PhysicalDistancingSafetyDividersException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PhysicalDistancingSafetyDividersException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PhysicalDistancingSafetyDividersException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PhysicalDistancingSafetyDividersException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PhysicalDistancingSafetyDividersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PhysicalDistancingSafetyDividersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PhysicalDistancingSafetyDividersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PhysicalDistancingSafetyDividersException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PhysicalDistancingSafetyDividersException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PhysicalDistancingSafetyDividersException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PhysicalDistancingSharedAreasLimitedOccupancyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PhysicalDistancingSharedAreasLimitedOccupancyException {
        pub fn as_str(self) -> &'static str {
            match self {
                PhysicalDistancingSharedAreasLimitedOccupancyException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PhysicalDistancingSharedAreasLimitedOccupancyException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                PhysicalDistancingSharedAreasLimitedOccupancyException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PhysicalDistancingSharedAreasLimitedOccupancyException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for PhysicalDistancingSharedAreasLimitedOccupancyException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PhysicalDistancingSharedAreasLimitedOccupancyException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<PhysicalDistancingSharedAreasLimitedOccupancyException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PhysicalDistancingSharedAreasLimitedOccupancyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PhysicalDistancingSharedAreasLimitedOccupancyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PhysicalDistancingSharedAreasLimitedOccupancyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PhysicalDistancingSharedAreasLimitedOccupancyException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PhysicalDistancingSharedAreasLimitedOccupancyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PhysicalDistancingSharedAreasLimitedOccupancyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PhysicalDistancingSharedAreasLimitedOccupancyException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PhysicalDistancingSharedAreasLimitedOccupancyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PhysicalDistancingSharedAreasLimitedOccupancyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PhysicalDistancingSharedAreasLimitedOccupancyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PhysicalDistancingSharedAreasLimitedOccupancyException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for PhysicalDistancingSharedAreasLimitedOccupancyException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for PhysicalDistancingSharedAreasLimitedOccupancyException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PhysicalDistancingWellnessAreasHavePrivateSpacesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PhysicalDistancingWellnessAreasHavePrivateSpacesException {
        pub fn as_str(self) -> &'static str {
            match self {
                PhysicalDistancingWellnessAreasHavePrivateSpacesException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PhysicalDistancingWellnessAreasHavePrivateSpacesException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                PhysicalDistancingWellnessAreasHavePrivateSpacesException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PhysicalDistancingWellnessAreasHavePrivateSpacesException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for PhysicalDistancingWellnessAreasHavePrivateSpacesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PhysicalDistancingWellnessAreasHavePrivateSpacesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<PhysicalDistancingWellnessAreasHavePrivateSpacesException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PhysicalDistancingWellnessAreasHavePrivateSpacesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PhysicalDistancingWellnessAreasHavePrivateSpacesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PhysicalDistancingWellnessAreasHavePrivateSpacesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PhysicalDistancingWellnessAreasHavePrivateSpacesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PhysicalDistancingWellnessAreasHavePrivateSpacesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PhysicalDistancingWellnessAreasHavePrivateSpacesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PhysicalDistancingWellnessAreasHavePrivateSpacesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PhysicalDistancingWellnessAreasHavePrivateSpacesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    PhysicalDistancingWellnessAreasHavePrivateSpacesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    PhysicalDistancingWellnessAreasHavePrivateSpacesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    PhysicalDistancingWellnessAreasHavePrivateSpacesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for PhysicalDistancingWellnessAreasHavePrivateSpacesException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for PhysicalDistancingWellnessAreasHavePrivateSpacesException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Policies {
        #[doc = "All inclusive available. The hotel offers a rate option that includes the cost of the room, meals, activities, and other amenities that might otherwise be charged separately."]
        #[serde(
            rename = "allInclusiveAvailable",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub all_inclusive_available: ::std::option::Option<bool>,
        #[doc = "All inclusive available exception."]
        #[serde(
            rename = "allInclusiveAvailableException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub all_inclusive_available_exception:
            ::std::option::Option<crate::schemas::PoliciesAllInclusiveAvailableException>,
        #[doc = "All inclusive only. The only rate option offered by the hotel is a rate that includes the cost of the room, meals, activities and other amenities that might otherwise be charged separately."]
        #[serde(
            rename = "allInclusiveOnly",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub all_inclusive_only: ::std::option::Option<bool>,
        #[doc = "All inclusive only exception."]
        #[serde(
            rename = "allInclusiveOnlyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub all_inclusive_only_exception:
            ::std::option::Option<crate::schemas::PoliciesAllInclusiveOnlyException>,
        #[doc = "Check-in time. The time of the day at which the hotel begins providing guests access to their unit at the beginning of their stay."]
        #[serde(
            rename = "checkinTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub checkin_time: ::std::option::Option<crate::schemas::TimeOfDay>,
        #[doc = "Check-in time exception."]
        #[serde(
            rename = "checkinTimeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub checkin_time_exception:
            ::std::option::Option<crate::schemas::PoliciesCheckinTimeException>,
        #[doc = "Check-out time. The time of the day on the last day of a guest's reserved stay at which the guest must vacate their room and settle their bill. Some hotels may offer late or early check out for a fee."]
        #[serde(
            rename = "checkoutTime",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub checkout_time: ::std::option::Option<crate::schemas::TimeOfDay>,
        #[doc = "Check-out time exception."]
        #[serde(
            rename = "checkoutTimeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub checkout_time_exception:
            ::std::option::Option<crate::schemas::PoliciesCheckoutTimeException>,
        #[doc = "Kids stay free. The children of guests are allowed to stay in the room/suite of a parent or adult without an additional fee. The policy may or may not stipulate a limit of the child's age or the overall number of children allowed."]
        #[serde(
            rename = "kidsStayFree",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kids_stay_free: ::std::option::Option<bool>,
        #[doc = "Kids stay free exception."]
        #[serde(
            rename = "kidsStayFreeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub kids_stay_free_exception:
            ::std::option::Option<crate::schemas::PoliciesKidsStayFreeException>,
        #[doc = "Max child age. The hotel allows children up to a certain age to stay in the room/suite of a parent or adult without an additional fee."]
        #[serde(
            rename = "maxChildAge",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_child_age: ::std::option::Option<i32>,
        #[doc = "Max child age exception."]
        #[serde(
            rename = "maxChildAgeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_child_age_exception:
            ::std::option::Option<crate::schemas::PoliciesMaxChildAgeException>,
        #[doc = "Max kids stay free count. The hotel allows a specific, defined number of children to stay in the room/suite of a parent or adult without an additional fee."]
        #[serde(
            rename = "maxKidsStayFreeCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_kids_stay_free_count: ::std::option::Option<i32>,
        #[doc = "Max kids stay free count exception."]
        #[serde(
            rename = "maxKidsStayFreeCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub max_kids_stay_free_count_exception:
            ::std::option::Option<crate::schemas::PoliciesMaxKidsStayFreeCountException>,
        #[doc = "Forms of payment accepted at the property."]
        #[serde(
            rename = "paymentOptions",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub payment_options: ::std::option::Option<crate::schemas::PaymentOptions>,
        #[doc = "Smoke free property. Smoking is not allowed inside the building, on balconies, or in outside spaces. Hotels that offer a designated area for guests to smoke are not considered smoke-free properties."]
        #[serde(
            rename = "smokeFreeProperty",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub smoke_free_property: ::std::option::Option<bool>,
        #[doc = "Smoke free property exception."]
        #[serde(
            rename = "smokeFreePropertyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub smoke_free_property_exception:
            ::std::option::Option<crate::schemas::PoliciesSmokeFreePropertyException>,
    }
    impl ::google_field_selector::FieldSelector for Policies {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Policies {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoliciesAllInclusiveAvailableException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoliciesAllInclusiveAvailableException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoliciesAllInclusiveAvailableException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PoliciesAllInclusiveAvailableException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoliciesAllInclusiveAvailableException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PoliciesAllInclusiveAvailableException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoliciesAllInclusiveAvailableException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoliciesAllInclusiveAvailableException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoliciesAllInclusiveAvailableException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PoliciesAllInclusiveAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PoliciesAllInclusiveAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    PoliciesAllInclusiveAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => PoliciesAllInclusiveAvailableException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoliciesAllInclusiveAvailableException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoliciesAllInclusiveAvailableException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoliciesAllInclusiveAvailableException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PoliciesAllInclusiveAvailableException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PoliciesAllInclusiveAvailableException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    PoliciesAllInclusiveAvailableException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => PoliciesAllInclusiveAvailableException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoliciesAllInclusiveAvailableException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoliciesAllInclusiveAvailableException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoliciesAllInclusiveOnlyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoliciesAllInclusiveOnlyException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoliciesAllInclusiveOnlyException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PoliciesAllInclusiveOnlyException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoliciesAllInclusiveOnlyException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoliciesAllInclusiveOnlyException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoliciesAllInclusiveOnlyException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoliciesAllInclusiveOnlyException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoliciesAllInclusiveOnlyException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PoliciesAllInclusiveOnlyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PoliciesAllInclusiveOnlyException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesAllInclusiveOnlyException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesAllInclusiveOnlyException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoliciesAllInclusiveOnlyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoliciesAllInclusiveOnlyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoliciesAllInclusiveOnlyException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PoliciesAllInclusiveOnlyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PoliciesAllInclusiveOnlyException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesAllInclusiveOnlyException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesAllInclusiveOnlyException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoliciesAllInclusiveOnlyException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoliciesAllInclusiveOnlyException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoliciesCheckinTimeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoliciesCheckinTimeException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoliciesCheckinTimeException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoliciesCheckinTimeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoliciesCheckinTimeException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoliciesCheckinTimeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoliciesCheckinTimeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoliciesCheckinTimeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoliciesCheckinTimeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoliciesCheckinTimeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoliciesCheckinTimeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesCheckinTimeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesCheckinTimeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoliciesCheckinTimeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoliciesCheckinTimeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoliciesCheckinTimeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoliciesCheckinTimeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoliciesCheckinTimeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesCheckinTimeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesCheckinTimeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoliciesCheckinTimeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoliciesCheckinTimeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoliciesCheckoutTimeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoliciesCheckoutTimeException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoliciesCheckoutTimeException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoliciesCheckoutTimeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoliciesCheckoutTimeException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoliciesCheckoutTimeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoliciesCheckoutTimeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoliciesCheckoutTimeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoliciesCheckoutTimeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoliciesCheckoutTimeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoliciesCheckoutTimeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesCheckoutTimeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesCheckoutTimeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoliciesCheckoutTimeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoliciesCheckoutTimeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoliciesCheckoutTimeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoliciesCheckoutTimeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoliciesCheckoutTimeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesCheckoutTimeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesCheckoutTimeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoliciesCheckoutTimeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoliciesCheckoutTimeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoliciesKidsStayFreeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoliciesKidsStayFreeException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoliciesKidsStayFreeException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoliciesKidsStayFreeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoliciesKidsStayFreeException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoliciesKidsStayFreeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoliciesKidsStayFreeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoliciesKidsStayFreeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoliciesKidsStayFreeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoliciesKidsStayFreeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoliciesKidsStayFreeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesKidsStayFreeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesKidsStayFreeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoliciesKidsStayFreeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoliciesKidsStayFreeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoliciesKidsStayFreeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoliciesKidsStayFreeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoliciesKidsStayFreeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesKidsStayFreeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesKidsStayFreeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoliciesKidsStayFreeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoliciesKidsStayFreeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoliciesMaxChildAgeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoliciesMaxChildAgeException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoliciesMaxChildAgeException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoliciesMaxChildAgeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoliciesMaxChildAgeException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoliciesMaxChildAgeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoliciesMaxChildAgeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoliciesMaxChildAgeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoliciesMaxChildAgeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoliciesMaxChildAgeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoliciesMaxChildAgeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesMaxChildAgeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesMaxChildAgeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoliciesMaxChildAgeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoliciesMaxChildAgeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoliciesMaxChildAgeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoliciesMaxChildAgeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoliciesMaxChildAgeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesMaxChildAgeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesMaxChildAgeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoliciesMaxChildAgeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoliciesMaxChildAgeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoliciesMaxKidsStayFreeCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoliciesMaxKidsStayFreeCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoliciesMaxKidsStayFreeCountException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PoliciesMaxKidsStayFreeCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoliciesMaxKidsStayFreeCountException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                PoliciesMaxKidsStayFreeCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoliciesMaxKidsStayFreeCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoliciesMaxKidsStayFreeCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoliciesMaxKidsStayFreeCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PoliciesMaxKidsStayFreeCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PoliciesMaxKidsStayFreeCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    PoliciesMaxKidsStayFreeCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => PoliciesMaxKidsStayFreeCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoliciesMaxKidsStayFreeCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoliciesMaxKidsStayFreeCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoliciesMaxKidsStayFreeCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PoliciesMaxKidsStayFreeCountException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PoliciesMaxKidsStayFreeCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    PoliciesMaxKidsStayFreeCountException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => PoliciesMaxKidsStayFreeCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoliciesMaxKidsStayFreeCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoliciesMaxKidsStayFreeCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoliciesSmokeFreePropertyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoliciesSmokeFreePropertyException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoliciesSmokeFreePropertyException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PoliciesSmokeFreePropertyException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoliciesSmokeFreePropertyException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoliciesSmokeFreePropertyException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoliciesSmokeFreePropertyException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoliciesSmokeFreePropertyException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoliciesSmokeFreePropertyException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PoliciesSmokeFreePropertyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PoliciesSmokeFreePropertyException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesSmokeFreePropertyException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesSmokeFreePropertyException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoliciesSmokeFreePropertyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoliciesSmokeFreePropertyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoliciesSmokeFreePropertyException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PoliciesSmokeFreePropertyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PoliciesSmokeFreePropertyException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoliciesSmokeFreePropertyException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoliciesSmokeFreePropertyException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoliciesSmokeFreePropertyException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoliciesSmokeFreePropertyException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Pools {
        #[doc = "Adult pool. A pool restricted for use by adults only. Can be indoors or outdoors."]
        #[serde(
            rename = "adultPool",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub adult_pool: ::std::option::Option<bool>,
        #[doc = "Adult pool exception."]
        #[serde(
            rename = "adultPoolException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub adult_pool_exception: ::std::option::Option<crate::schemas::PoolsAdultPoolException>,
        #[doc = "Hot tub. A man-made pool containing bubbling water maintained at a higher temperature and circulated by aerating jets for the purpose of soaking, relaxation and hydrotherapy. Can be indoors or outdoors. Not used for active swimming. Also known as Jacuzzi. Hot tub must be in a common area where all guests can access it. Does not apply to room-specific hot tubs that are only accessible to guest occupying that room."]
        #[serde(
            rename = "hotTub",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hot_tub: ::std::option::Option<bool>,
        #[doc = "Hot tub exception."]
        #[serde(
            rename = "hotTubException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hot_tub_exception: ::std::option::Option<crate::schemas::PoolsHotTubException>,
        #[doc = "Indoor pool. A pool located inside the hotel and available for guests to use for swimming and/or soaking. Use may or may not be restricted to adults and/or children."]
        #[serde(
            rename = "indoorPool",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub indoor_pool: ::std::option::Option<bool>,
        #[doc = "Indoor pool exception."]
        #[serde(
            rename = "indoorPoolException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub indoor_pool_exception: ::std::option::Option<crate::schemas::PoolsIndoorPoolException>,
        #[doc = "Indoor pools count. The sum of all indoor pools at the hotel."]
        #[serde(
            rename = "indoorPoolsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub indoor_pools_count: ::std::option::Option<i32>,
        #[doc = "Indoor pools count exception."]
        #[serde(
            rename = "indoorPoolsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub indoor_pools_count_exception:
            ::std::option::Option<crate::schemas::PoolsIndoorPoolsCountException>,
        #[doc = "Lazy river. A man-made pool or several interconnected recreational pools built to mimic the shape and current of a winding river where guests float in the water on inflated rubber tubes. Can be indoors or outdoors."]
        #[serde(
            rename = "lazyRiver",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lazy_river: ::std::option::Option<bool>,
        #[doc = "Lazy river exception."]
        #[serde(
            rename = "lazyRiverException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lazy_river_exception: ::std::option::Option<crate::schemas::PoolsLazyRiverException>,
        #[doc = "Lifeguard. A trained member of the hotel staff stationed by the hotel's indoor or outdoor swimming area and responsible for the safety of swimming guests."]
        #[serde(
            rename = "lifeguard",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lifeguard: ::std::option::Option<bool>,
        #[doc = "Lifeguard exception."]
        #[serde(
            rename = "lifeguardException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lifeguard_exception: ::std::option::Option<crate::schemas::PoolsLifeguardException>,
        #[doc = "Outdoor pool. A pool located outside on the grounds of the hotel and available for guests to use for swimming, soaking or recreation. Use may or may not be restricted to adults and/or children."]
        #[serde(
            rename = "outdoorPool",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub outdoor_pool: ::std::option::Option<bool>,
        #[doc = "Outdoor pool exception."]
        #[serde(
            rename = "outdoorPoolException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub outdoor_pool_exception:
            ::std::option::Option<crate::schemas::PoolsOutdoorPoolException>,
        #[doc = "Outdoor pools count. The sum of all outdoor pools at the hotel."]
        #[serde(
            rename = "outdoorPoolsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub outdoor_pools_count: ::std::option::Option<i32>,
        #[doc = "Outdoor pools count exception."]
        #[serde(
            rename = "outdoorPoolsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub outdoor_pools_count_exception:
            ::std::option::Option<crate::schemas::PoolsOutdoorPoolsCountException>,
        #[doc = "Pool. The presence of a pool, either indoors or outdoors, for guests to use for swimming and/or soaking. Use may or may not be restricted to adults and/or children."]
        #[serde(
            rename = "pool",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pool: ::std::option::Option<bool>,
        #[doc = "Pool exception."]
        #[serde(
            rename = "poolException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pool_exception: ::std::option::Option<crate::schemas::PoolsPoolException>,
        #[doc = "Pools count. The sum of all pools at the hotel."]
        #[serde(
            rename = "poolsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pools_count: ::std::option::Option<i32>,
        #[doc = "Pools count exception."]
        #[serde(
            rename = "poolsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pools_count_exception: ::std::option::Option<crate::schemas::PoolsPoolsCountException>,
        #[doc = "Wading pool. A shallow pool designed for small children to play in. Can be indoors or outdoors. Also known as kiddie pool."]
        #[serde(
            rename = "wadingPool",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wading_pool: ::std::option::Option<bool>,
        #[doc = "Wading pool exception."]
        #[serde(
            rename = "wadingPoolException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wading_pool_exception: ::std::option::Option<crate::schemas::PoolsWadingPoolException>,
        #[doc = "Water park. An aquatic recreation area with a large pool or series of pools that has features such as a water slide or tube, wavepool, fountains, rope swings, and/or obstacle course. Can be indoors or outdoors. Also known as adventure pool."]
        #[serde(
            rename = "waterPark",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_park: ::std::option::Option<bool>,
        #[doc = "Water park exception."]
        #[serde(
            rename = "waterParkException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_park_exception: ::std::option::Option<crate::schemas::PoolsWaterParkException>,
        #[doc = "Waterslide. A continuously wetted chute positioned by an indoor or outdoor pool which people slide down into the water."]
        #[serde(
            rename = "waterslide",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub waterslide: ::std::option::Option<bool>,
        #[doc = "Waterslide exception."]
        #[serde(
            rename = "waterslideException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub waterslide_exception: ::std::option::Option<crate::schemas::PoolsWaterslideException>,
        #[doc = "Wave pool. A large indoor or outdoor pool with a machine that produces water currents to mimic the ocean's crests."]
        #[serde(
            rename = "wavePool",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wave_pool: ::std::option::Option<bool>,
        #[doc = "Wave pool exception."]
        #[serde(
            rename = "wavePoolException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wave_pool_exception: ::std::option::Option<crate::schemas::PoolsWavePoolException>,
    }
    impl ::google_field_selector::FieldSelector for Pools {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Pools {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsAdultPoolException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsAdultPoolException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsAdultPoolException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsAdultPoolException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsAdultPoolException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsAdultPoolException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsAdultPoolException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsAdultPoolException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsAdultPoolException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsAdultPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsAdultPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsAdultPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsAdultPoolException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsAdultPoolException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsAdultPoolException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsAdultPoolException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsAdultPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsAdultPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsAdultPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsAdultPoolException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsAdultPoolException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsAdultPoolException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsHotTubException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsHotTubException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsHotTubException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsHotTubException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsHotTubException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsHotTubException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsHotTubException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsHotTubException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsHotTubException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsHotTubException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsHotTubException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsHotTubException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsHotTubException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsHotTubException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsHotTubException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsHotTubException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsHotTubException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsHotTubException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsHotTubException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsHotTubException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsHotTubException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsHotTubException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsIndoorPoolException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsIndoorPoolException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsIndoorPoolException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsIndoorPoolException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsIndoorPoolException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsIndoorPoolException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsIndoorPoolException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsIndoorPoolException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsIndoorPoolException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsIndoorPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsIndoorPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsIndoorPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsIndoorPoolException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsIndoorPoolException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsIndoorPoolException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsIndoorPoolException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsIndoorPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsIndoorPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsIndoorPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsIndoorPoolException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsIndoorPoolException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsIndoorPoolException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsIndoorPoolsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsIndoorPoolsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsIndoorPoolsCountException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsIndoorPoolsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsIndoorPoolsCountException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsIndoorPoolsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsIndoorPoolsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsIndoorPoolsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsIndoorPoolsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsIndoorPoolsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsIndoorPoolsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsIndoorPoolsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsIndoorPoolsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsIndoorPoolsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsIndoorPoolsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsIndoorPoolsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsIndoorPoolsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsIndoorPoolsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsIndoorPoolsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsIndoorPoolsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsIndoorPoolsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsIndoorPoolsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsLazyRiverException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsLazyRiverException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsLazyRiverException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsLazyRiverException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsLazyRiverException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsLazyRiverException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsLazyRiverException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsLazyRiverException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsLazyRiverException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsLazyRiverException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsLazyRiverException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsLazyRiverException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsLazyRiverException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsLazyRiverException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsLazyRiverException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsLazyRiverException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsLazyRiverException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsLazyRiverException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsLazyRiverException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsLazyRiverException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsLazyRiverException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsLazyRiverException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsLifeguardException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsLifeguardException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsLifeguardException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsLifeguardException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsLifeguardException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsLifeguardException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsLifeguardException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsLifeguardException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsLifeguardException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsLifeguardException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsLifeguardException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsLifeguardException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsLifeguardException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsLifeguardException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsLifeguardException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsLifeguardException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsLifeguardException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsLifeguardException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsLifeguardException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsLifeguardException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsLifeguardException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsLifeguardException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsOutdoorPoolException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsOutdoorPoolException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsOutdoorPoolException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsOutdoorPoolException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsOutdoorPoolException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsOutdoorPoolException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsOutdoorPoolException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsOutdoorPoolException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsOutdoorPoolException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsOutdoorPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsOutdoorPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsOutdoorPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsOutdoorPoolException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsOutdoorPoolException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsOutdoorPoolException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsOutdoorPoolException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsOutdoorPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsOutdoorPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsOutdoorPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsOutdoorPoolException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsOutdoorPoolException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsOutdoorPoolException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsOutdoorPoolsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsOutdoorPoolsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsOutdoorPoolsCountException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsOutdoorPoolsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsOutdoorPoolsCountException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsOutdoorPoolsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsOutdoorPoolsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsOutdoorPoolsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsOutdoorPoolsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsOutdoorPoolsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsOutdoorPoolsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsOutdoorPoolsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsOutdoorPoolsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsOutdoorPoolsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsOutdoorPoolsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsOutdoorPoolsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsOutdoorPoolsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsOutdoorPoolsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsOutdoorPoolsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsOutdoorPoolsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsOutdoorPoolsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsOutdoorPoolsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsPoolException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsPoolException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsPoolException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsPoolException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsPoolException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsPoolException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsPoolException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsPoolException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsPoolException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsPoolException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsPoolException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsPoolException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsPoolException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsPoolException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsPoolException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsPoolException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsPoolsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsPoolsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsPoolsCountException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsPoolsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsPoolsCountException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsPoolsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsPoolsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsPoolsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsPoolsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsPoolsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsPoolsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsPoolsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsPoolsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsPoolsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsPoolsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsPoolsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsPoolsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsPoolsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsPoolsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsPoolsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsPoolsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsPoolsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsWadingPoolException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsWadingPoolException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsWadingPoolException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsWadingPoolException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsWadingPoolException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsWadingPoolException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsWadingPoolException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsWadingPoolException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsWadingPoolException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsWadingPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsWadingPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsWadingPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsWadingPoolException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsWadingPoolException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsWadingPoolException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsWadingPoolException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsWadingPoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsWadingPoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsWadingPoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsWadingPoolException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsWadingPoolException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsWadingPoolException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsWaterParkException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsWaterParkException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsWaterParkException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsWaterParkException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsWaterParkException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsWaterParkException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsWaterParkException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsWaterParkException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsWaterParkException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsWaterParkException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsWaterParkException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsWaterParkException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsWaterParkException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsWaterParkException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsWaterParkException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsWaterParkException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsWaterParkException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsWaterParkException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsWaterParkException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsWaterParkException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsWaterParkException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsWaterParkException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsWaterslideException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsWaterslideException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsWaterslideException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsWaterslideException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsWaterslideException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsWaterslideException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsWaterslideException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsWaterslideException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsWaterslideException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsWaterslideException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsWaterslideException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsWaterslideException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsWaterslideException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsWaterslideException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsWaterslideException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsWaterslideException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsWaterslideException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsWaterslideException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsWaterslideException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsWaterslideException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsWaterslideException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsWaterslideException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PoolsWavePoolException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PoolsWavePoolException {
        pub fn as_str(self) -> &'static str {
            match self {
                PoolsWavePoolException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PoolsWavePoolException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PoolsWavePoolException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PoolsWavePoolException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PoolsWavePoolException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PoolsWavePoolException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PoolsWavePoolException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsWavePoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsWavePoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsWavePoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsWavePoolException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PoolsWavePoolException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PoolsWavePoolException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PoolsWavePoolException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PoolsWavePoolException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PoolsWavePoolException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PoolsWavePoolException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PoolsWavePoolException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PoolsWavePoolException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PoolsWavePoolException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Property {
        #[doc = "Built year. The year that construction of the property was completed."]
        #[serde(
            rename = "builtYear",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub built_year: ::std::option::Option<i32>,
        #[doc = "Built year exception."]
        #[serde(
            rename = "builtYearException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub built_year_exception: ::std::option::Option<crate::schemas::PropertyBuiltYearException>,
        #[doc = "Floors count. The number of stories the building has from the ground floor to the top floor that are accessible to guests."]
        #[serde(
            rename = "floorsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub floors_count: ::std::option::Option<i32>,
        #[doc = "Floors count exception."]
        #[serde(
            rename = "floorsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub floors_count_exception:
            ::std::option::Option<crate::schemas::PropertyFloorsCountException>,
        #[doc = "Last renovated year. The year when the most recent renovation of the property was completed. Renovation may include all or any combination of the following: the units, the public spaces, the exterior, or the interior."]
        #[serde(
            rename = "lastRenovatedYear",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_renovated_year: ::std::option::Option<i32>,
        #[doc = "Last renovated year exception."]
        #[serde(
            rename = "lastRenovatedYearException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub last_renovated_year_exception:
            ::std::option::Option<crate::schemas::PropertyLastRenovatedYearException>,
        #[doc = "Rooms count. The total number of rooms and suites bookable by guests for an overnight stay. Does not include event space, public spaces, conference rooms, fitness rooms, business centers, spa, salon, restaurants/bars, or shops."]
        #[serde(
            rename = "roomsCount",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rooms_count: ::std::option::Option<i32>,
        #[doc = "Rooms count exception."]
        #[serde(
            rename = "roomsCountException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub rooms_count_exception:
            ::std::option::Option<crate::schemas::PropertyRoomsCountException>,
    }
    impl ::google_field_selector::FieldSelector for Property {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Property {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PropertyBuiltYearException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PropertyBuiltYearException {
        pub fn as_str(self) -> &'static str {
            match self {
                PropertyBuiltYearException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PropertyBuiltYearException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PropertyBuiltYearException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PropertyBuiltYearException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PropertyBuiltYearException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PropertyBuiltYearException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PropertyBuiltYearException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PropertyBuiltYearException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PropertyBuiltYearException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PropertyBuiltYearException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PropertyBuiltYearException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PropertyBuiltYearException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PropertyBuiltYearException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PropertyBuiltYearException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PropertyBuiltYearException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PropertyBuiltYearException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PropertyBuiltYearException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PropertyBuiltYearException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PropertyBuiltYearException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PropertyBuiltYearException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PropertyFloorsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PropertyFloorsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                PropertyFloorsCountException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PropertyFloorsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PropertyFloorsCountException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PropertyFloorsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PropertyFloorsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PropertyFloorsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PropertyFloorsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PropertyFloorsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PropertyFloorsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PropertyFloorsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PropertyFloorsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PropertyFloorsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PropertyFloorsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PropertyFloorsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PropertyFloorsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PropertyFloorsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PropertyFloorsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PropertyFloorsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PropertyFloorsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PropertyFloorsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PropertyLastRenovatedYearException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PropertyLastRenovatedYearException {
        pub fn as_str(self) -> &'static str {
            match self {
                PropertyLastRenovatedYearException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                PropertyLastRenovatedYearException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PropertyLastRenovatedYearException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PropertyLastRenovatedYearException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PropertyLastRenovatedYearException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PropertyLastRenovatedYearException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PropertyLastRenovatedYearException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PropertyLastRenovatedYearException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PropertyLastRenovatedYearException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PropertyLastRenovatedYearException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PropertyLastRenovatedYearException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PropertyLastRenovatedYearException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PropertyLastRenovatedYearException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PropertyLastRenovatedYearException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    PropertyLastRenovatedYearException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => PropertyLastRenovatedYearException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PropertyLastRenovatedYearException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PropertyLastRenovatedYearException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PropertyLastRenovatedYearException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PropertyLastRenovatedYearException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum PropertyRoomsCountException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl PropertyRoomsCountException {
        pub fn as_str(self) -> &'static str {
            match self {
                PropertyRoomsCountException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                PropertyRoomsCountException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                PropertyRoomsCountException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                PropertyRoomsCountException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for PropertyRoomsCountException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for PropertyRoomsCountException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<PropertyRoomsCountException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => PropertyRoomsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PropertyRoomsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PropertyRoomsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PropertyRoomsCountException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for PropertyRoomsCountException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for PropertyRoomsCountException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PropertyRoomsCountException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => PropertyRoomsCountException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => PropertyRoomsCountException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => PropertyRoomsCountException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => PropertyRoomsCountException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for PropertyRoomsCountException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for PropertyRoomsCountException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Services {
        #[doc = "Baggage storage. A provision for guests to leave their bags at the hotel when they arrive for their stay before the official check-in time. May or may not apply for guests who wish to leave their bags after check-out and before departing the locale. Also known as bag dropoff."]
        #[serde(
            rename = "baggageStorage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub baggage_storage: ::std::option::Option<bool>,
        #[doc = "Baggage storage exception."]
        #[serde(
            rename = "baggageStorageException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub baggage_storage_exception:
            ::std::option::Option<crate::schemas::ServicesBaggageStorageException>,
        #[doc = "Concierge. Hotel staff member(s) responsible for facilitating an easy, comfortable stay through making reservations for meals, sourcing theater tickets, arranging tours, finding a doctor, making recommendations, and answering questions."]
        #[serde(
            rename = "concierge",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub concierge: ::std::option::Option<bool>,
        #[doc = "Concierge exception."]
        #[serde(
            rename = "conciergeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub concierge_exception: ::std::option::Option<crate::schemas::ServicesConciergeException>,
        #[doc = "Convenience store. A shop at the hotel primarily selling snacks, drinks, non-prescription medicines, health and beauty aids, magazines and newspapers."]
        #[serde(
            rename = "convenienceStore",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub convenience_store: ::std::option::Option<bool>,
        #[doc = "Convenience store exception."]
        #[serde(
            rename = "convenienceStoreException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub convenience_store_exception:
            ::std::option::Option<crate::schemas::ServicesConvenienceStoreException>,
        #[doc = "Currency exchange. A staff member or automated machine tasked with the transaction of providing the native currency of the hotel's locale in exchange for the foreign currency provided by a guest."]
        #[serde(
            rename = "currencyExchange",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub currency_exchange: ::std::option::Option<bool>,
        #[doc = "Currency exchange exception."]
        #[serde(
            rename = "currencyExchangeException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub currency_exchange_exception:
            ::std::option::Option<crate::schemas::ServicesCurrencyExchangeException>,
        #[doc = "Elevator. A passenger elevator that transports guests from one story to another. Also known as lift."]
        #[serde(
            rename = "elevator",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub elevator: ::std::option::Option<bool>,
        #[doc = "Elevator exception."]
        #[serde(
            rename = "elevatorException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub elevator_exception: ::std::option::Option<crate::schemas::ServicesElevatorException>,
        #[doc = "Front desk. A counter or desk in the lobby or the immediate interior of the hotel where a member of the staff greets guests and processes the information related to their stay (including check-in and check-out). May or may not be manned and open 24/7."]
        #[serde(
            rename = "frontDesk",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub front_desk: ::std::option::Option<bool>,
        #[doc = "Front desk exception."]
        #[serde(
            rename = "frontDeskException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub front_desk_exception: ::std::option::Option<crate::schemas::ServicesFrontDeskException>,
        #[doc = "Full service laundry. Laundry and dry cleaning facilitated and handled by the hotel on behalf of the guest. Does not include the provision for guests to do their own laundry in on-site machines."]
        #[serde(
            rename = "fullServiceLaundry",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub full_service_laundry: ::std::option::Option<bool>,
        #[doc = "Full service laundry exception."]
        #[serde(
            rename = "fullServiceLaundryException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub full_service_laundry_exception:
            ::std::option::Option<crate::schemas::ServicesFullServiceLaundryException>,
        #[doc = "Gift shop. An on-site store primarily selling souvenirs, mementos and other gift items. May or may not also sell sundries, magazines and newspapers, clothing, or snacks."]
        #[serde(
            rename = "giftShop",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gift_shop: ::std::option::Option<bool>,
        #[doc = "Gift shop exception."]
        #[serde(
            rename = "giftShopException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub gift_shop_exception: ::std::option::Option<crate::schemas::ServicesGiftShopException>,
        #[doc = "Languages spoken by at least one staff member."]
        #[serde(
            rename = "languagesSpoken",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub languages_spoken: ::std::option::Option<Vec<crate::schemas::LanguageSpoken>>,
        #[doc = "Self service laundry. On-site clothes washers and dryers accessible to guests for the purpose of washing and drying their own clothes. May or may not require payment to use the machines."]
        #[serde(
            rename = "selfServiceLaundry",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub self_service_laundry: ::std::option::Option<bool>,
        #[doc = "Self service laundry exception."]
        #[serde(
            rename = "selfServiceLaundryException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub self_service_laundry_exception:
            ::std::option::Option<crate::schemas::ServicesSelfServiceLaundryException>,
        #[doc = "Social hour. A reception with complimentary soft drinks, tea, coffee, wine and/or cocktails in the afternoon or evening. Can be hosted by hotel staff or guests may serve themselves. Also known as wine hour. The availability of coffee/tea in the lobby throughout the day does not constitute a social or wine hour."]
        #[serde(
            rename = "socialHour",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub social_hour: ::std::option::Option<bool>,
        #[doc = "Social hour exception."]
        #[serde(
            rename = "socialHourException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub social_hour_exception:
            ::std::option::Option<crate::schemas::ServicesSocialHourException>,
        #[doc = "24hr front desk. Front desk is staffed 24 hours a day."]
        #[serde(
            rename = "twentyFourHourFrontDesk",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub twenty_four_hour_front_desk: ::std::option::Option<bool>,
        #[doc = "24hr front desk exception."]
        #[serde(
            rename = "twentyFourHourFrontDeskException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub twenty_four_hour_front_desk_exception:
            ::std::option::Option<crate::schemas::ServicesTwentyFourHourFrontDeskException>,
        #[doc = "Wake up calls. By direction of the guest, a hotel staff member will phone the guest unit at the requested hour. Also known as morning call."]
        #[serde(
            rename = "wakeUpCalls",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wake_up_calls: ::std::option::Option<bool>,
        #[doc = "Wake up calls exception."]
        #[serde(
            rename = "wakeUpCallsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub wake_up_calls_exception:
            ::std::option::Option<crate::schemas::ServicesWakeUpCallsException>,
    }
    impl ::google_field_selector::FieldSelector for Services {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Services {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesBaggageStorageException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesBaggageStorageException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesBaggageStorageException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ServicesBaggageStorageException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesBaggageStorageException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesBaggageStorageException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesBaggageStorageException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesBaggageStorageException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesBaggageStorageException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesBaggageStorageException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesBaggageStorageException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesBaggageStorageException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesBaggageStorageException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesBaggageStorageException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesBaggageStorageException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesBaggageStorageException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesBaggageStorageException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesBaggageStorageException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesBaggageStorageException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesBaggageStorageException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesBaggageStorageException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesBaggageStorageException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesConciergeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesConciergeException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesConciergeException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ServicesConciergeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesConciergeException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesConciergeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesConciergeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesConciergeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesConciergeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesConciergeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesConciergeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesConciergeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesConciergeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesConciergeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesConciergeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesConciergeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesConciergeException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesConciergeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesConciergeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesConciergeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesConciergeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesConciergeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesConvenienceStoreException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesConvenienceStoreException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesConvenienceStoreException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ServicesConvenienceStoreException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesConvenienceStoreException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesConvenienceStoreException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesConvenienceStoreException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesConvenienceStoreException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesConvenienceStoreException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesConvenienceStoreException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ServicesConvenienceStoreException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesConvenienceStoreException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesConvenienceStoreException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesConvenienceStoreException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesConvenienceStoreException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesConvenienceStoreException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesConvenienceStoreException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ServicesConvenienceStoreException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesConvenienceStoreException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesConvenienceStoreException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesConvenienceStoreException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesConvenienceStoreException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesCurrencyExchangeException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesCurrencyExchangeException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesCurrencyExchangeException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ServicesCurrencyExchangeException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesCurrencyExchangeException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesCurrencyExchangeException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesCurrencyExchangeException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesCurrencyExchangeException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesCurrencyExchangeException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesCurrencyExchangeException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ServicesCurrencyExchangeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesCurrencyExchangeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesCurrencyExchangeException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesCurrencyExchangeException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesCurrencyExchangeException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesCurrencyExchangeException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesCurrencyExchangeException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ServicesCurrencyExchangeException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesCurrencyExchangeException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesCurrencyExchangeException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesCurrencyExchangeException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesCurrencyExchangeException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesElevatorException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesElevatorException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesElevatorException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ServicesElevatorException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesElevatorException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesElevatorException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesElevatorException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesElevatorException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesElevatorException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesElevatorException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesElevatorException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesElevatorException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesElevatorException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesElevatorException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesElevatorException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesElevatorException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesElevatorException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesElevatorException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesElevatorException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesElevatorException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesElevatorException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesElevatorException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesFrontDeskException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesFrontDeskException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesFrontDeskException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ServicesFrontDeskException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesFrontDeskException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesFrontDeskException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesFrontDeskException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesFrontDeskException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesFrontDeskException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesFrontDeskException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesFrontDeskException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesFrontDeskException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesFrontDeskException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesFrontDeskException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesFrontDeskException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesFrontDeskException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesFrontDeskException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesFrontDeskException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesFrontDeskException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesFrontDeskException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesFrontDeskException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesFrontDeskException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesFullServiceLaundryException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesFullServiceLaundryException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesFullServiceLaundryException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ServicesFullServiceLaundryException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesFullServiceLaundryException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ServicesFullServiceLaundryException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesFullServiceLaundryException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesFullServiceLaundryException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesFullServiceLaundryException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesFullServiceLaundryException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ServicesFullServiceLaundryException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ServicesFullServiceLaundryException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ServicesFullServiceLaundryException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesFullServiceLaundryException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesFullServiceLaundryException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesFullServiceLaundryException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesFullServiceLaundryException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ServicesFullServiceLaundryException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ServicesFullServiceLaundryException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ServicesFullServiceLaundryException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesFullServiceLaundryException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesFullServiceLaundryException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesGiftShopException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesGiftShopException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesGiftShopException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ServicesGiftShopException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesGiftShopException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesGiftShopException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesGiftShopException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesGiftShopException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesGiftShopException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesGiftShopException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesGiftShopException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesGiftShopException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesGiftShopException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesGiftShopException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesGiftShopException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesGiftShopException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesGiftShopException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesGiftShopException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesGiftShopException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesGiftShopException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesGiftShopException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesGiftShopException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesSelfServiceLaundryException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesSelfServiceLaundryException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesSelfServiceLaundryException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ServicesSelfServiceLaundryException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesSelfServiceLaundryException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ServicesSelfServiceLaundryException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesSelfServiceLaundryException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesSelfServiceLaundryException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesSelfServiceLaundryException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesSelfServiceLaundryException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ServicesSelfServiceLaundryException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ServicesSelfServiceLaundryException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ServicesSelfServiceLaundryException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesSelfServiceLaundryException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesSelfServiceLaundryException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesSelfServiceLaundryException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesSelfServiceLaundryException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ServicesSelfServiceLaundryException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    ServicesSelfServiceLaundryException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ServicesSelfServiceLaundryException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesSelfServiceLaundryException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesSelfServiceLaundryException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesSocialHourException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesSocialHourException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesSocialHourException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ServicesSocialHourException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesSocialHourException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesSocialHourException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesSocialHourException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesSocialHourException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesSocialHourException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesSocialHourException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesSocialHourException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesSocialHourException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesSocialHourException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesSocialHourException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesSocialHourException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesSocialHourException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesSocialHourException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesSocialHourException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesSocialHourException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesSocialHourException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesSocialHourException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesSocialHourException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesTwentyFourHourFrontDeskException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesTwentyFourHourFrontDeskException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesTwentyFourHourFrontDeskException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ServicesTwentyFourHourFrontDeskException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                ServicesTwentyFourHourFrontDeskException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                ServicesTwentyFourHourFrontDeskException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesTwentyFourHourFrontDeskException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesTwentyFourHourFrontDeskException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<ServicesTwentyFourHourFrontDeskException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesTwentyFourHourFrontDeskException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    ServicesTwentyFourHourFrontDeskException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    ServicesTwentyFourHourFrontDeskException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ServicesTwentyFourHourFrontDeskException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesTwentyFourHourFrontDeskException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesTwentyFourHourFrontDeskException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesTwentyFourHourFrontDeskException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ServicesTwentyFourHourFrontDeskException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    ServicesTwentyFourHourFrontDeskException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    ServicesTwentyFourHourFrontDeskException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => ServicesTwentyFourHourFrontDeskException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesTwentyFourHourFrontDeskException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesTwentyFourHourFrontDeskException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ServicesWakeUpCallsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ServicesWakeUpCallsException {
        pub fn as_str(self) -> &'static str {
            match self {
                ServicesWakeUpCallsException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ServicesWakeUpCallsException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ServicesWakeUpCallsException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ServicesWakeUpCallsException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ServicesWakeUpCallsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ServicesWakeUpCallsException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ServicesWakeUpCallsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesWakeUpCallsException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesWakeUpCallsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesWakeUpCallsException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesWakeUpCallsException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ServicesWakeUpCallsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ServicesWakeUpCallsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ServicesWakeUpCallsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ServicesWakeUpCallsException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ServicesWakeUpCallsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ServicesWakeUpCallsException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ServicesWakeUpCallsException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ServicesWakeUpCallsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ServicesWakeUpCallsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Sustainability {
        #[doc = "Energy efficiency practices implemented at the hotel."]
        #[serde(
            rename = "energyEfficiency",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub energy_efficiency: ::std::option::Option<crate::schemas::EnergyEfficiency>,
        #[doc = "Sustainability certifications the hotel has been awarded."]
        #[serde(
            rename = "sustainabilityCertifications",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sustainability_certifications:
            ::std::option::Option<crate::schemas::SustainabilityCertifications>,
        #[doc = "Sustainable sourcing practices implemented at the hotel."]
        #[serde(
            rename = "sustainableSourcing",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sustainable_sourcing: ::std::option::Option<crate::schemas::SustainableSourcing>,
        #[doc = "Waste reduction practices implemented at the hotel."]
        #[serde(
            rename = "wasteReduction",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub waste_reduction: ::std::option::Option<crate::schemas::WasteReduction>,
        #[doc = "Water conservation practices implemented at the hotel."]
        #[serde(
            rename = "waterConservation",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_conservation: ::std::option::Option<crate::schemas::WaterConservation>,
    }
    impl ::google_field_selector::FieldSelector for Sustainability {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Sustainability {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SustainabilityCertifications {
        #[doc = "BREEAM certification."]
        #[serde(
            rename = "breeamCertification",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub breeam_certification:
            ::std::option::Option<crate::schemas::SustainabilityCertificationsBreeamCertification>,
        #[doc = "BREEAM certification exception."]
        #[serde(
            rename = "breeamCertificationException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub breeam_certification_exception: ::std::option::Option<
            crate::schemas::SustainabilityCertificationsBreeamCertificationException,
        >,
        #[doc = "The eco certificates awarded to the hotel."]
        #[serde(
            rename = "ecoCertifications",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub eco_certifications: ::std::option::Option<Vec<crate::schemas::EcoCertification>>,
        #[doc = "LEED certification."]
        #[serde(
            rename = "leedCertification",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub leed_certification:
            ::std::option::Option<crate::schemas::SustainabilityCertificationsLeedCertification>,
        #[doc = "LEED certification exception."]
        #[serde(
            rename = "leedCertificationException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub leed_certification_exception: ::std::option::Option<
            crate::schemas::SustainabilityCertificationsLeedCertificationException,
        >,
    }
    impl ::google_field_selector::FieldSelector for SustainabilityCertifications {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainabilityCertifications {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainabilityCertificationsBreeamCertification {
        #[doc = "Default BreeamCertification. Do not use."]
        BreeamCertificationUnspecified,
        #[doc = "BREEAM Excellent."]
        BreeamExcellent,
        #[doc = "BREEAM Good."]
        BreeamGood,
        #[doc = "BREEAM Outstanding."]
        BreeamOutstanding,
        #[doc = "BREEAM Pass."]
        BreeamPass,
        #[doc = "BREEAM Very Good."]
        BreeamVeryGood,
        #[doc = "Not certified."]
        NoBreeamCertification,
    }
    impl SustainabilityCertificationsBreeamCertification {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainabilityCertificationsBreeamCertification::BreeamCertificationUnspecified => {
                    "BREEAM_CERTIFICATION_UNSPECIFIED"
                }
                SustainabilityCertificationsBreeamCertification::BreeamExcellent => {
                    "BREEAM_EXCELLENT"
                }
                SustainabilityCertificationsBreeamCertification::BreeamGood => "BREEAM_GOOD",
                SustainabilityCertificationsBreeamCertification::BreeamOutstanding => {
                    "BREEAM_OUTSTANDING"
                }
                SustainabilityCertificationsBreeamCertification::BreeamPass => "BREEAM_PASS",
                SustainabilityCertificationsBreeamCertification::BreeamVeryGood => {
                    "BREEAM_VERY_GOOD"
                }
                SustainabilityCertificationsBreeamCertification::NoBreeamCertification => {
                    "NO_BREEAM_CERTIFICATION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainabilityCertificationsBreeamCertification {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainabilityCertificationsBreeamCertification {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainabilityCertificationsBreeamCertification, ()> {
            Ok(match s {
                "BREEAM_CERTIFICATION_UNSPECIFIED" => {
                    SustainabilityCertificationsBreeamCertification::BreeamCertificationUnspecified
                }
                "BREEAM_EXCELLENT" => {
                    SustainabilityCertificationsBreeamCertification::BreeamExcellent
                }
                "BREEAM_GOOD" => SustainabilityCertificationsBreeamCertification::BreeamGood,
                "BREEAM_OUTSTANDING" => {
                    SustainabilityCertificationsBreeamCertification::BreeamOutstanding
                }
                "BREEAM_PASS" => SustainabilityCertificationsBreeamCertification::BreeamPass,
                "BREEAM_VERY_GOOD" => {
                    SustainabilityCertificationsBreeamCertification::BreeamVeryGood
                }
                "NO_BREEAM_CERTIFICATION" => {
                    SustainabilityCertificationsBreeamCertification::NoBreeamCertification
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainabilityCertificationsBreeamCertification {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainabilityCertificationsBreeamCertification {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainabilityCertificationsBreeamCertification {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "BREEAM_CERTIFICATION_UNSPECIFIED" => {
                    SustainabilityCertificationsBreeamCertification::BreeamCertificationUnspecified
                }
                "BREEAM_EXCELLENT" => {
                    SustainabilityCertificationsBreeamCertification::BreeamExcellent
                }
                "BREEAM_GOOD" => SustainabilityCertificationsBreeamCertification::BreeamGood,
                "BREEAM_OUTSTANDING" => {
                    SustainabilityCertificationsBreeamCertification::BreeamOutstanding
                }
                "BREEAM_PASS" => SustainabilityCertificationsBreeamCertification::BreeamPass,
                "BREEAM_VERY_GOOD" => {
                    SustainabilityCertificationsBreeamCertification::BreeamVeryGood
                }
                "NO_BREEAM_CERTIFICATION" => {
                    SustainabilityCertificationsBreeamCertification::NoBreeamCertification
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SustainabilityCertificationsBreeamCertification {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainabilityCertificationsBreeamCertification {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainabilityCertificationsBreeamCertificationException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainabilityCertificationsBreeamCertificationException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainabilityCertificationsBreeamCertificationException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainabilityCertificationsBreeamCertificationException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                SustainabilityCertificationsBreeamCertificationException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainabilityCertificationsBreeamCertificationException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainabilityCertificationsBreeamCertificationException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainabilityCertificationsBreeamCertificationException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainabilityCertificationsBreeamCertificationException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainabilityCertificationsBreeamCertificationException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainabilityCertificationsBreeamCertificationException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainabilityCertificationsBreeamCertificationException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainabilityCertificationsBreeamCertificationException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainabilityCertificationsBreeamCertificationException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainabilityCertificationsBreeamCertificationException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainabilityCertificationsBreeamCertificationException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainabilityCertificationsBreeamCertificationException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainabilityCertificationsBreeamCertificationException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainabilityCertificationsBreeamCertificationException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainabilityCertificationsBreeamCertificationException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for SustainabilityCertificationsBreeamCertificationException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for SustainabilityCertificationsBreeamCertificationException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainabilityCertificationsLeedCertification {
        #[doc = "Default LeedCertification. Do not use."]
        LeedCertificationUnspecified,
        #[doc = "LEED Certified."]
        LeedCertified,
        #[doc = "LEED Gold."]
        LeedGold,
        #[doc = "LEED Platinum."]
        LeedPlatinum,
        #[doc = "LEED Silver."]
        LeedSilver,
        #[doc = "Not certified."]
        NoLeedCertification,
    }
    impl SustainabilityCertificationsLeedCertification {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainabilityCertificationsLeedCertification::LeedCertificationUnspecified => {
                    "LEED_CERTIFICATION_UNSPECIFIED"
                }
                SustainabilityCertificationsLeedCertification::LeedCertified => "LEED_CERTIFIED",
                SustainabilityCertificationsLeedCertification::LeedGold => "LEED_GOLD",
                SustainabilityCertificationsLeedCertification::LeedPlatinum => "LEED_PLATINUM",
                SustainabilityCertificationsLeedCertification::LeedSilver => "LEED_SILVER",
                SustainabilityCertificationsLeedCertification::NoLeedCertification => {
                    "NO_LEED_CERTIFICATION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainabilityCertificationsLeedCertification {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainabilityCertificationsLeedCertification {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainabilityCertificationsLeedCertification, ()> {
            Ok(match s {
                "LEED_CERTIFICATION_UNSPECIFIED" => {
                    SustainabilityCertificationsLeedCertification::LeedCertificationUnspecified
                }
                "LEED_CERTIFIED" => SustainabilityCertificationsLeedCertification::LeedCertified,
                "LEED_GOLD" => SustainabilityCertificationsLeedCertification::LeedGold,
                "LEED_PLATINUM" => SustainabilityCertificationsLeedCertification::LeedPlatinum,
                "LEED_SILVER" => SustainabilityCertificationsLeedCertification::LeedSilver,
                "NO_LEED_CERTIFICATION" => {
                    SustainabilityCertificationsLeedCertification::NoLeedCertification
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainabilityCertificationsLeedCertification {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainabilityCertificationsLeedCertification {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainabilityCertificationsLeedCertification {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "LEED_CERTIFICATION_UNSPECIFIED" => {
                    SustainabilityCertificationsLeedCertification::LeedCertificationUnspecified
                }
                "LEED_CERTIFIED" => SustainabilityCertificationsLeedCertification::LeedCertified,
                "LEED_GOLD" => SustainabilityCertificationsLeedCertification::LeedGold,
                "LEED_PLATINUM" => SustainabilityCertificationsLeedCertification::LeedPlatinum,
                "LEED_SILVER" => SustainabilityCertificationsLeedCertification::LeedSilver,
                "NO_LEED_CERTIFICATION" => {
                    SustainabilityCertificationsLeedCertification::NoLeedCertification
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SustainabilityCertificationsLeedCertification {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainabilityCertificationsLeedCertification {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainabilityCertificationsLeedCertificationException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainabilityCertificationsLeedCertificationException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainabilityCertificationsLeedCertificationException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainabilityCertificationsLeedCertificationException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                SustainabilityCertificationsLeedCertificationException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainabilityCertificationsLeedCertificationException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainabilityCertificationsLeedCertificationException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainabilityCertificationsLeedCertificationException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainabilityCertificationsLeedCertificationException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainabilityCertificationsLeedCertificationException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainabilityCertificationsLeedCertificationException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainabilityCertificationsLeedCertificationException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainabilityCertificationsLeedCertificationException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainabilityCertificationsLeedCertificationException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainabilityCertificationsLeedCertificationException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainabilityCertificationsLeedCertificationException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainabilityCertificationsLeedCertificationException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainabilityCertificationsLeedCertificationException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainabilityCertificationsLeedCertificationException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainabilityCertificationsLeedCertificationException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for SustainabilityCertificationsLeedCertificationException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for SustainabilityCertificationsLeedCertificationException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SustainableSourcing {
        #[doc = "Eco friendly toiletries. Soap, shampoo, lotion, and other toiletries provided for guests have a nationally or internationally recognized sustainability certification, such as USDA Organic, EU Organic, or cruelty-free."]
        #[serde(
            rename = "ecoFriendlyToiletries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub eco_friendly_toiletries: ::std::option::Option<bool>,
        #[doc = "Eco friendly toiletries exception."]
        #[serde(
            rename = "ecoFriendlyToiletriesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub eco_friendly_toiletries_exception: ::std::option::Option<
            crate::schemas::SustainableSourcingEcoFriendlyToiletriesException,
        >,
        #[doc = "Locally sourced food and beverages. Property sources locally in order to lower the environmental footprint from reduced transportation and to stimulate the local economy. Products produced less than 62 miles from the establishment are normally considered as locally produced."]
        #[serde(
            rename = "locallySourcedFoodAndBeverages",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub locally_sourced_food_and_beverages: ::std::option::Option<bool>,
        #[doc = "Locally sourced food and beverages exception."]
        #[serde(
            rename = "locallySourcedFoodAndBeveragesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub locally_sourced_food_and_beverages_exception: ::std::option::Option<
            crate::schemas::SustainableSourcingLocallySourcedFoodAndBeveragesException,
        >,
        #[doc = "Organic cage free eggs. The property sources 100% certified organic and cage-free eggs (shell, liquid, and egg products). Cage-free means hens are able to walk, spread their wings and lay their eggs in nests)."]
        #[serde(
            rename = "organicCageFreeEggs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub organic_cage_free_eggs: ::std::option::Option<bool>,
        #[doc = "Organic cage free eggs exception."]
        #[serde(
            rename = "organicCageFreeEggsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub organic_cage_free_eggs_exception:
            ::std::option::Option<crate::schemas::SustainableSourcingOrganicCageFreeEggsException>,
        #[doc = "Organic food and beverages. At least 25% of food and beverages, by spend, are certified organic. Organic means products that are certified to one of the organic standard listed in the IFOAM family of standards. Qualifying certifications include USDA Organic and EU Organic, among others."]
        #[serde(
            rename = "organicFoodAndBeverages",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub organic_food_and_beverages: ::std::option::Option<bool>,
        #[doc = "Organic food and beverages exception."]
        #[serde(
            rename = "organicFoodAndBeveragesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub organic_food_and_beverages_exception: ::std::option::Option<
            crate::schemas::SustainableSourcingOrganicFoodAndBeveragesException,
        >,
        #[doc = "Responsible purchasing policy. The property has a responsible procurement policy in place. Responsible means integration of social, ethical, and/or environmental performance factors into the procurement process when selecting suppliers."]
        #[serde(
            rename = "responsiblePurchasingPolicy",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub responsible_purchasing_policy: ::std::option::Option<bool>,
        #[doc = "Responsible purchasing policy exception."]
        #[serde(
            rename = "responsiblePurchasingPolicyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub responsible_purchasing_policy_exception: ::std::option::Option<
            crate::schemas::SustainableSourcingResponsiblePurchasingPolicyException,
        >,
        #[doc = "Responsibly sources seafood. The property does not source seafood from the Monterey Bay Aquarium Seafood Watch \"avoid\" list, and must sustainably source seafood listed as \"good alternative,\" \"eco-certified,\" and \"best choice\". The property has a policy outlining a commitment to source Marine Stewardship Council (MSC) and/or Aquaculture Stewardship Council (ASC) Chain of Custody certified seafood."]
        #[serde(
            rename = "responsiblySourcesSeafood",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub responsibly_sources_seafood: ::std::option::Option<bool>,
        #[doc = "Responsibly sources seafood exception."]
        #[serde(
            rename = "responsiblySourcesSeafoodException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub responsibly_sources_seafood_exception: ::std::option::Option<
            crate::schemas::SustainableSourcingResponsiblySourcesSeafoodException,
        >,
        #[doc = "Vegan meals. The property provides vegan menu options for guests. Vegan food does not contain animal products or byproducts."]
        #[serde(
            rename = "veganMeals",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vegan_meals: ::std::option::Option<bool>,
        #[doc = "Vegan meals exception."]
        #[serde(
            rename = "veganMealsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vegan_meals_exception:
            ::std::option::Option<crate::schemas::SustainableSourcingVeganMealsException>,
        #[doc = "Vegetarian meals. The property provides vegetarian menu options for guests. Vegetarian food does not contain meat, poultry, fish, or seafood."]
        #[serde(
            rename = "vegetarianMeals",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vegetarian_meals: ::std::option::Option<bool>,
        #[doc = "Vegetarian meals exception."]
        #[serde(
            rename = "vegetarianMealsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub vegetarian_meals_exception:
            ::std::option::Option<crate::schemas::SustainableSourcingVegetarianMealsException>,
    }
    impl ::google_field_selector::FieldSelector for SustainableSourcing {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainableSourcing {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainableSourcingEcoFriendlyToiletriesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainableSourcingEcoFriendlyToiletriesException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainableSourcingEcoFriendlyToiletriesException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainableSourcingEcoFriendlyToiletriesException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                SustainableSourcingEcoFriendlyToiletriesException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainableSourcingEcoFriendlyToiletriesException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainableSourcingEcoFriendlyToiletriesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainableSourcingEcoFriendlyToiletriesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainableSourcingEcoFriendlyToiletriesException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingEcoFriendlyToiletriesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingEcoFriendlyToiletriesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingEcoFriendlyToiletriesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingEcoFriendlyToiletriesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainableSourcingEcoFriendlyToiletriesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainableSourcingEcoFriendlyToiletriesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainableSourcingEcoFriendlyToiletriesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingEcoFriendlyToiletriesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingEcoFriendlyToiletriesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingEcoFriendlyToiletriesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingEcoFriendlyToiletriesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SustainableSourcingEcoFriendlyToiletriesException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainableSourcingEcoFriendlyToiletriesException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainableSourcingLocallySourcedFoodAndBeveragesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainableSourcingLocallySourcedFoodAndBeveragesException {
        pub fn as_str(self) -> &'static str {
            match self { SustainableSourcingLocallySourcedFoodAndBeveragesException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , SustainableSourcingLocallySourcedFoodAndBeveragesException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , SustainableSourcingLocallySourcedFoodAndBeveragesException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , SustainableSourcingLocallySourcedFoodAndBeveragesException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str> for SustainableSourcingLocallySourcedFoodAndBeveragesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainableSourcingLocallySourcedFoodAndBeveragesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainableSourcingLocallySourcedFoodAndBeveragesException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingLocallySourcedFoodAndBeveragesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingLocallySourcedFoodAndBeveragesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingLocallySourcedFoodAndBeveragesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingLocallySourcedFoodAndBeveragesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainableSourcingLocallySourcedFoodAndBeveragesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainableSourcingLocallySourcedFoodAndBeveragesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainableSourcingLocallySourcedFoodAndBeveragesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingLocallySourcedFoodAndBeveragesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingLocallySourcedFoodAndBeveragesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingLocallySourcedFoodAndBeveragesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingLocallySourcedFoodAndBeveragesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for SustainableSourcingLocallySourcedFoodAndBeveragesException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for SustainableSourcingLocallySourcedFoodAndBeveragesException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainableSourcingOrganicCageFreeEggsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainableSourcingOrganicCageFreeEggsException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainableSourcingOrganicCageFreeEggsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainableSourcingOrganicCageFreeEggsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                SustainableSourcingOrganicCageFreeEggsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainableSourcingOrganicCageFreeEggsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainableSourcingOrganicCageFreeEggsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainableSourcingOrganicCageFreeEggsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainableSourcingOrganicCageFreeEggsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingOrganicCageFreeEggsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingOrganicCageFreeEggsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingOrganicCageFreeEggsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingOrganicCageFreeEggsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainableSourcingOrganicCageFreeEggsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainableSourcingOrganicCageFreeEggsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainableSourcingOrganicCageFreeEggsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingOrganicCageFreeEggsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingOrganicCageFreeEggsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingOrganicCageFreeEggsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingOrganicCageFreeEggsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SustainableSourcingOrganicCageFreeEggsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainableSourcingOrganicCageFreeEggsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainableSourcingOrganicFoodAndBeveragesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainableSourcingOrganicFoodAndBeveragesException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainableSourcingOrganicFoodAndBeveragesException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainableSourcingOrganicFoodAndBeveragesException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                SustainableSourcingOrganicFoodAndBeveragesException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainableSourcingOrganicFoodAndBeveragesException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainableSourcingOrganicFoodAndBeveragesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainableSourcingOrganicFoodAndBeveragesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainableSourcingOrganicFoodAndBeveragesException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingOrganicFoodAndBeveragesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingOrganicFoodAndBeveragesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingOrganicFoodAndBeveragesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingOrganicFoodAndBeveragesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainableSourcingOrganicFoodAndBeveragesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainableSourcingOrganicFoodAndBeveragesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainableSourcingOrganicFoodAndBeveragesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingOrganicFoodAndBeveragesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingOrganicFoodAndBeveragesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingOrganicFoodAndBeveragesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingOrganicFoodAndBeveragesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for SustainableSourcingOrganicFoodAndBeveragesException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainableSourcingOrganicFoodAndBeveragesException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainableSourcingResponsiblePurchasingPolicyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainableSourcingResponsiblePurchasingPolicyException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainableSourcingResponsiblePurchasingPolicyException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainableSourcingResponsiblePurchasingPolicyException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                SustainableSourcingResponsiblePurchasingPolicyException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainableSourcingResponsiblePurchasingPolicyException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainableSourcingResponsiblePurchasingPolicyException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainableSourcingResponsiblePurchasingPolicyException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainableSourcingResponsiblePurchasingPolicyException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingResponsiblePurchasingPolicyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingResponsiblePurchasingPolicyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingResponsiblePurchasingPolicyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingResponsiblePurchasingPolicyException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainableSourcingResponsiblePurchasingPolicyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainableSourcingResponsiblePurchasingPolicyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainableSourcingResponsiblePurchasingPolicyException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingResponsiblePurchasingPolicyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingResponsiblePurchasingPolicyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingResponsiblePurchasingPolicyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingResponsiblePurchasingPolicyException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for SustainableSourcingResponsiblePurchasingPolicyException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for SustainableSourcingResponsiblePurchasingPolicyException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainableSourcingResponsiblySourcesSeafoodException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainableSourcingResponsiblySourcesSeafoodException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainableSourcingResponsiblySourcesSeafoodException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainableSourcingResponsiblySourcesSeafoodException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                SustainableSourcingResponsiblySourcesSeafoodException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainableSourcingResponsiblySourcesSeafoodException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainableSourcingResponsiblySourcesSeafoodException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainableSourcingResponsiblySourcesSeafoodException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainableSourcingResponsiblySourcesSeafoodException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingResponsiblySourcesSeafoodException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingResponsiblySourcesSeafoodException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingResponsiblySourcesSeafoodException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingResponsiblySourcesSeafoodException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainableSourcingResponsiblySourcesSeafoodException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainableSourcingResponsiblySourcesSeafoodException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainableSourcingResponsiblySourcesSeafoodException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingResponsiblySourcesSeafoodException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingResponsiblySourcesSeafoodException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingResponsiblySourcesSeafoodException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingResponsiblySourcesSeafoodException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for SustainableSourcingResponsiblySourcesSeafoodException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for SustainableSourcingResponsiblySourcesSeafoodException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainableSourcingVeganMealsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainableSourcingVeganMealsException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainableSourcingVeganMealsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainableSourcingVeganMealsException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                SustainableSourcingVeganMealsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainableSourcingVeganMealsException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainableSourcingVeganMealsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainableSourcingVeganMealsException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<SustainableSourcingVeganMealsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingVeganMealsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => SustainableSourcingVeganMealsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingVeganMealsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => SustainableSourcingVeganMealsException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainableSourcingVeganMealsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainableSourcingVeganMealsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainableSourcingVeganMealsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingVeganMealsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => SustainableSourcingVeganMealsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingVeganMealsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => SustainableSourcingVeganMealsException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SustainableSourcingVeganMealsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainableSourcingVeganMealsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum SustainableSourcingVegetarianMealsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl SustainableSourcingVegetarianMealsException {
        pub fn as_str(self) -> &'static str {
            match self {
                SustainableSourcingVegetarianMealsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                SustainableSourcingVegetarianMealsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                SustainableSourcingVegetarianMealsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                SustainableSourcingVegetarianMealsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for SustainableSourcingVegetarianMealsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for SustainableSourcingVegetarianMealsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<SustainableSourcingVegetarianMealsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingVegetarianMealsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingVegetarianMealsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingVegetarianMealsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingVegetarianMealsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for SustainableSourcingVegetarianMealsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for SustainableSourcingVegetarianMealsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SustainableSourcingVegetarianMealsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    SustainableSourcingVegetarianMealsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    SustainableSourcingVegetarianMealsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    SustainableSourcingVegetarianMealsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    SustainableSourcingVegetarianMealsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for SustainableSourcingVegetarianMealsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for SustainableSourcingVegetarianMealsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TimeOfDay {
        #[doc = "Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value \"24:00:00\" for scenarios like business closing time."]
        #[serde(
            rename = "hours",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub hours: ::std::option::Option<i32>,
        #[doc = "Minutes of hour of day. Must be from 0 to 59."]
        #[serde(
            rename = "minutes",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub minutes: ::std::option::Option<i32>,
        #[doc = "Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999."]
        #[serde(
            rename = "nanos",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub nanos: ::std::option::Option<i32>,
        #[doc = "Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds."]
        #[serde(
            rename = "seconds",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub seconds: ::std::option::Option<i32>,
    }
    impl ::google_field_selector::FieldSelector for TimeOfDay {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TimeOfDay {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Transportation {
        #[doc = "Airport shuttle. The hotel provides guests with a chauffeured van or bus to and from the airport. Can be free or for a fee. Guests may share the vehicle with other guests unknown to them. Applies if the hotel has a third-party shuttle service (office/desk etc.) within the hotel. As long as hotel provides this service, it doesn't matter if it's directly with them or a third party they work with. Does not apply if guest has to coordinate with an entity outside/other than the hotel."]
        #[serde(
            rename = "airportShuttle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub airport_shuttle: ::std::option::Option<bool>,
        #[doc = "Airport shuttle exception."]
        #[serde(
            rename = "airportShuttleException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub airport_shuttle_exception:
            ::std::option::Option<crate::schemas::TransportationAirportShuttleException>,
        #[doc = "Car rental on property. A branch of a rental car company with a processing desk in the hotel. Available cars for rent may be awaiting at the hotel or in a nearby lot."]
        #[serde(
            rename = "carRentalOnProperty",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub car_rental_on_property: ::std::option::Option<bool>,
        #[doc = "Car rental on property exception."]
        #[serde(
            rename = "carRentalOnPropertyException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub car_rental_on_property_exception:
            ::std::option::Option<crate::schemas::TransportationCarRentalOnPropertyException>,
        #[doc = "Free airport shuttle. Airport shuttle is free to guests. Must be free to all guests without any conditions."]
        #[serde(
            rename = "freeAirportShuttle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_airport_shuttle: ::std::option::Option<bool>,
        #[doc = "Free airport shuttle exception."]
        #[serde(
            rename = "freeAirportShuttleException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_airport_shuttle_exception:
            ::std::option::Option<crate::schemas::TransportationFreeAirportShuttleException>,
        #[doc = "Free private car service. Private chauffeured car service is free to guests."]
        #[serde(
            rename = "freePrivateCarService",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_private_car_service: ::std::option::Option<bool>,
        #[doc = "Free private car service exception."]
        #[serde(
            rename = "freePrivateCarServiceException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_private_car_service_exception:
            ::std::option::Option<crate::schemas::TransportationFreePrivateCarServiceException>,
        #[doc = "Local shuttle. A car, van or bus provided by the hotel to transport guests to destinations within a specified range of distance around the hotel. Usually shopping and/or convention centers, downtown districts, or beaches. Can be free or for a fee."]
        #[serde(
            rename = "localShuttle",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub local_shuttle: ::std::option::Option<bool>,
        #[doc = "Local shuttle exception."]
        #[serde(
            rename = "localShuttleException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub local_shuttle_exception:
            ::std::option::Option<crate::schemas::TransportationLocalShuttleException>,
        #[doc = "Private car service. Hotel provides a private chauffeured car to transport guests to destinations. Passengers in the car are either alone or are known to one another and have requested the car together. Service can be free or for a fee and travel distance is usually limited to a specific range. Not a taxi."]
        #[serde(
            rename = "privateCarService",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_car_service: ::std::option::Option<bool>,
        #[doc = "Private car service exception."]
        #[serde(
            rename = "privateCarServiceException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub private_car_service_exception:
            ::std::option::Option<crate::schemas::TransportationPrivateCarServiceException>,
        #[doc = "Transfer. Hotel provides a shuttle service or car service to take guests to and from the nearest airport or train station. Can be free or for a fee. Guests may share the vehicle with other guests unknown to them."]
        #[serde(
            rename = "transfer",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transfer: ::std::option::Option<bool>,
        #[doc = "Transfer exception."]
        #[serde(
            rename = "transferException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub transfer_exception:
            ::std::option::Option<crate::schemas::TransportationTransferException>,
    }
    impl ::google_field_selector::FieldSelector for Transportation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Transportation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TransportationAirportShuttleException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl TransportationAirportShuttleException {
        pub fn as_str(self) -> &'static str {
            match self {
                TransportationAirportShuttleException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                TransportationAirportShuttleException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                TransportationAirportShuttleException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                TransportationAirportShuttleException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TransportationAirportShuttleException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TransportationAirportShuttleException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<TransportationAirportShuttleException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationAirportShuttleException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => TransportationAirportShuttleException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationAirportShuttleException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => TransportationAirportShuttleException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TransportationAirportShuttleException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TransportationAirportShuttleException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TransportationAirportShuttleException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationAirportShuttleException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => TransportationAirportShuttleException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationAirportShuttleException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => TransportationAirportShuttleException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TransportationAirportShuttleException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransportationAirportShuttleException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TransportationCarRentalOnPropertyException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl TransportationCarRentalOnPropertyException {
        pub fn as_str(self) -> &'static str {
            match self {
                TransportationCarRentalOnPropertyException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                TransportationCarRentalOnPropertyException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                TransportationCarRentalOnPropertyException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                TransportationCarRentalOnPropertyException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for TransportationCarRentalOnPropertyException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TransportationCarRentalOnPropertyException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<TransportationCarRentalOnPropertyException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationCarRentalOnPropertyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    TransportationCarRentalOnPropertyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationCarRentalOnPropertyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    TransportationCarRentalOnPropertyException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TransportationCarRentalOnPropertyException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TransportationCarRentalOnPropertyException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TransportationCarRentalOnPropertyException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationCarRentalOnPropertyException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    TransportationCarRentalOnPropertyException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationCarRentalOnPropertyException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    TransportationCarRentalOnPropertyException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TransportationCarRentalOnPropertyException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransportationCarRentalOnPropertyException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TransportationFreeAirportShuttleException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl TransportationFreeAirportShuttleException {
        pub fn as_str(self) -> &'static str {
            match self {
                TransportationFreeAirportShuttleException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                TransportationFreeAirportShuttleException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                TransportationFreeAirportShuttleException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                TransportationFreeAirportShuttleException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for TransportationFreeAirportShuttleException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TransportationFreeAirportShuttleException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<TransportationFreeAirportShuttleException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationFreeAirportShuttleException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    TransportationFreeAirportShuttleException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationFreeAirportShuttleException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    TransportationFreeAirportShuttleException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TransportationFreeAirportShuttleException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TransportationFreeAirportShuttleException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TransportationFreeAirportShuttleException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationFreeAirportShuttleException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    TransportationFreeAirportShuttleException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationFreeAirportShuttleException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    TransportationFreeAirportShuttleException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TransportationFreeAirportShuttleException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransportationFreeAirportShuttleException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TransportationFreePrivateCarServiceException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl TransportationFreePrivateCarServiceException {
        pub fn as_str(self) -> &'static str {
            match self {
                TransportationFreePrivateCarServiceException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                TransportationFreePrivateCarServiceException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                TransportationFreePrivateCarServiceException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                TransportationFreePrivateCarServiceException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for TransportationFreePrivateCarServiceException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TransportationFreePrivateCarServiceException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<TransportationFreePrivateCarServiceException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationFreePrivateCarServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    TransportationFreePrivateCarServiceException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationFreePrivateCarServiceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    TransportationFreePrivateCarServiceException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TransportationFreePrivateCarServiceException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TransportationFreePrivateCarServiceException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TransportationFreePrivateCarServiceException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationFreePrivateCarServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    TransportationFreePrivateCarServiceException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationFreePrivateCarServiceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    TransportationFreePrivateCarServiceException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TransportationFreePrivateCarServiceException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransportationFreePrivateCarServiceException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TransportationLocalShuttleException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl TransportationLocalShuttleException {
        pub fn as_str(self) -> &'static str {
            match self {
                TransportationLocalShuttleException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                TransportationLocalShuttleException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                TransportationLocalShuttleException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                TransportationLocalShuttleException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TransportationLocalShuttleException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TransportationLocalShuttleException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<TransportationLocalShuttleException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationLocalShuttleException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => TransportationLocalShuttleException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationLocalShuttleException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => TransportationLocalShuttleException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TransportationLocalShuttleException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TransportationLocalShuttleException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TransportationLocalShuttleException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationLocalShuttleException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => TransportationLocalShuttleException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationLocalShuttleException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => TransportationLocalShuttleException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TransportationLocalShuttleException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransportationLocalShuttleException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TransportationPrivateCarServiceException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl TransportationPrivateCarServiceException {
        pub fn as_str(self) -> &'static str {
            match self {
                TransportationPrivateCarServiceException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                TransportationPrivateCarServiceException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                TransportationPrivateCarServiceException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                TransportationPrivateCarServiceException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TransportationPrivateCarServiceException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TransportationPrivateCarServiceException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<TransportationPrivateCarServiceException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationPrivateCarServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    TransportationPrivateCarServiceException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationPrivateCarServiceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => TransportationPrivateCarServiceException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TransportationPrivateCarServiceException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TransportationPrivateCarServiceException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TransportationPrivateCarServiceException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    TransportationPrivateCarServiceException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    TransportationPrivateCarServiceException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    TransportationPrivateCarServiceException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => TransportationPrivateCarServiceException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TransportationPrivateCarServiceException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransportationPrivateCarServiceException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum TransportationTransferException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl TransportationTransferException {
        pub fn as_str(self) -> &'static str {
            match self {
                TransportationTransferException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                TransportationTransferException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                TransportationTransferException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                TransportationTransferException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for TransportationTransferException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for TransportationTransferException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<TransportationTransferException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => TransportationTransferException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => TransportationTransferException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => TransportationTransferException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => TransportationTransferException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for TransportationTransferException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for TransportationTransferException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TransportationTransferException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => TransportationTransferException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => TransportationTransferException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => TransportationTransferException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => TransportationTransferException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for TransportationTransferException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for TransportationTransferException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ViewsFromUnit {
        #[doc = "Beach view. A guestroom that features a window through which guests can see the beach."]
        #[serde(
            rename = "beachView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub beach_view: ::std::option::Option<bool>,
        #[doc = "Beach view exception."]
        #[serde(
            rename = "beachViewException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub beach_view_exception:
            ::std::option::Option<crate::schemas::ViewsFromUnitBeachViewException>,
        #[doc = "City view. A guestroom that features a window through which guests can see the buildings, parks and/or streets of the city."]
        #[serde(
            rename = "cityView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub city_view: ::std::option::Option<bool>,
        #[doc = "City view exception."]
        #[serde(
            rename = "cityViewException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub city_view_exception:
            ::std::option::Option<crate::schemas::ViewsFromUnitCityViewException>,
        #[doc = "Garden view. A guestroom that features a window through which guests can see a garden."]
        #[serde(
            rename = "gardenView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub garden_view: ::std::option::Option<bool>,
        #[doc = "Garden view exception."]
        #[serde(
            rename = "gardenViewException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub garden_view_exception:
            ::std::option::Option<crate::schemas::ViewsFromUnitGardenViewException>,
        #[doc = "Lake view."]
        #[serde(
            rename = "lakeView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lake_view: ::std::option::Option<bool>,
        #[doc = "Lake view exception."]
        #[serde(
            rename = "lakeViewException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub lake_view_exception:
            ::std::option::Option<crate::schemas::ViewsFromUnitLakeViewException>,
        #[doc = "Landmark view. A guestroom that features a window through which guests can see a landmark such as the countryside, a golf course, the forest, a park, a rain forst, a mountain or a slope."]
        #[serde(
            rename = "landmarkView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub landmark_view: ::std::option::Option<bool>,
        #[doc = "Landmark view exception."]
        #[serde(
            rename = "landmarkViewException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub landmark_view_exception:
            ::std::option::Option<crate::schemas::ViewsFromUnitLandmarkViewException>,
        #[doc = "Ocean view. A guestroom that features a window through which guests can see the ocean."]
        #[serde(
            rename = "oceanView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ocean_view: ::std::option::Option<bool>,
        #[doc = "Ocean view exception."]
        #[serde(
            rename = "oceanViewException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub ocean_view_exception:
            ::std::option::Option<crate::schemas::ViewsFromUnitOceanViewException>,
        #[doc = "Pool view. A guestroom that features a window through which guests can see the hotel's swimming pool."]
        #[serde(
            rename = "poolView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pool_view: ::std::option::Option<bool>,
        #[doc = "Pool view exception."]
        #[serde(
            rename = "poolViewException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub pool_view_exception:
            ::std::option::Option<crate::schemas::ViewsFromUnitPoolViewException>,
        #[doc = "Valley view. A guestroom that features a window through which guests can see over a valley."]
        #[serde(
            rename = "valleyView",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub valley_view: ::std::option::Option<bool>,
        #[doc = "Valley view exception."]
        #[serde(
            rename = "valleyViewException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub valley_view_exception:
            ::std::option::Option<crate::schemas::ViewsFromUnitValleyViewException>,
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnit {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnit {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ViewsFromUnitBeachViewException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ViewsFromUnitBeachViewException {
        pub fn as_str(self) -> &'static str {
            match self {
                ViewsFromUnitBeachViewException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ViewsFromUnitBeachViewException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ViewsFromUnitBeachViewException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ViewsFromUnitBeachViewException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ViewsFromUnitBeachViewException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ViewsFromUnitBeachViewException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ViewsFromUnitBeachViewException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitBeachViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitBeachViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitBeachViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitBeachViewException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ViewsFromUnitBeachViewException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ViewsFromUnitBeachViewException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ViewsFromUnitBeachViewException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitBeachViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitBeachViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitBeachViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitBeachViewException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnitBeachViewException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnitBeachViewException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ViewsFromUnitCityViewException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ViewsFromUnitCityViewException {
        pub fn as_str(self) -> &'static str {
            match self {
                ViewsFromUnitCityViewException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ViewsFromUnitCityViewException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ViewsFromUnitCityViewException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ViewsFromUnitCityViewException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ViewsFromUnitCityViewException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ViewsFromUnitCityViewException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ViewsFromUnitCityViewException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitCityViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitCityViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitCityViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitCityViewException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ViewsFromUnitCityViewException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ViewsFromUnitCityViewException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ViewsFromUnitCityViewException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitCityViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitCityViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitCityViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitCityViewException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnitCityViewException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnitCityViewException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ViewsFromUnitGardenViewException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ViewsFromUnitGardenViewException {
        pub fn as_str(self) -> &'static str {
            match self {
                ViewsFromUnitGardenViewException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ViewsFromUnitGardenViewException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ViewsFromUnitGardenViewException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ViewsFromUnitGardenViewException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ViewsFromUnitGardenViewException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ViewsFromUnitGardenViewException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ViewsFromUnitGardenViewException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ViewsFromUnitGardenViewException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ViewsFromUnitGardenViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitGardenViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitGardenViewException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ViewsFromUnitGardenViewException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ViewsFromUnitGardenViewException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ViewsFromUnitGardenViewException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ViewsFromUnitGardenViewException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ViewsFromUnitGardenViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitGardenViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitGardenViewException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnitGardenViewException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnitGardenViewException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ViewsFromUnitLakeViewException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ViewsFromUnitLakeViewException {
        pub fn as_str(self) -> &'static str {
            match self {
                ViewsFromUnitLakeViewException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ViewsFromUnitLakeViewException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ViewsFromUnitLakeViewException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ViewsFromUnitLakeViewException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ViewsFromUnitLakeViewException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ViewsFromUnitLakeViewException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ViewsFromUnitLakeViewException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitLakeViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitLakeViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitLakeViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitLakeViewException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ViewsFromUnitLakeViewException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ViewsFromUnitLakeViewException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ViewsFromUnitLakeViewException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitLakeViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitLakeViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitLakeViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitLakeViewException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnitLakeViewException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnitLakeViewException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ViewsFromUnitLandmarkViewException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ViewsFromUnitLandmarkViewException {
        pub fn as_str(self) -> &'static str {
            match self {
                ViewsFromUnitLandmarkViewException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ViewsFromUnitLandmarkViewException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ViewsFromUnitLandmarkViewException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ViewsFromUnitLandmarkViewException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ViewsFromUnitLandmarkViewException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ViewsFromUnitLandmarkViewException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ViewsFromUnitLandmarkViewException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ViewsFromUnitLandmarkViewException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ViewsFromUnitLandmarkViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitLandmarkViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitLandmarkViewException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ViewsFromUnitLandmarkViewException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ViewsFromUnitLandmarkViewException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ViewsFromUnitLandmarkViewException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ViewsFromUnitLandmarkViewException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ViewsFromUnitLandmarkViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitLandmarkViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitLandmarkViewException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnitLandmarkViewException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnitLandmarkViewException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ViewsFromUnitOceanViewException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ViewsFromUnitOceanViewException {
        pub fn as_str(self) -> &'static str {
            match self {
                ViewsFromUnitOceanViewException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ViewsFromUnitOceanViewException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ViewsFromUnitOceanViewException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ViewsFromUnitOceanViewException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ViewsFromUnitOceanViewException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ViewsFromUnitOceanViewException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ViewsFromUnitOceanViewException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitOceanViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitOceanViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitOceanViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitOceanViewException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ViewsFromUnitOceanViewException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ViewsFromUnitOceanViewException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ViewsFromUnitOceanViewException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitOceanViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitOceanViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitOceanViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitOceanViewException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnitOceanViewException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnitOceanViewException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ViewsFromUnitPoolViewException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ViewsFromUnitPoolViewException {
        pub fn as_str(self) -> &'static str {
            match self {
                ViewsFromUnitPoolViewException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                ViewsFromUnitPoolViewException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ViewsFromUnitPoolViewException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ViewsFromUnitPoolViewException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ViewsFromUnitPoolViewException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ViewsFromUnitPoolViewException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ViewsFromUnitPoolViewException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitPoolViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitPoolViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitPoolViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitPoolViewException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ViewsFromUnitPoolViewException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ViewsFromUnitPoolViewException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ViewsFromUnitPoolViewException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => ViewsFromUnitPoolViewException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => ViewsFromUnitPoolViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitPoolViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitPoolViewException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnitPoolViewException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnitPoolViewException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum ViewsFromUnitValleyViewException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl ViewsFromUnitValleyViewException {
        pub fn as_str(self) -> &'static str {
            match self {
                ViewsFromUnitValleyViewException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                ViewsFromUnitValleyViewException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                ViewsFromUnitValleyViewException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                ViewsFromUnitValleyViewException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for ViewsFromUnitValleyViewException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for ViewsFromUnitValleyViewException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<ViewsFromUnitValleyViewException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ViewsFromUnitValleyViewException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ViewsFromUnitValleyViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitValleyViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitValleyViewException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for ViewsFromUnitValleyViewException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for ViewsFromUnitValleyViewException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ViewsFromUnitValleyViewException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    ViewsFromUnitValleyViewException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => ViewsFromUnitValleyViewException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => ViewsFromUnitValleyViewException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => ViewsFromUnitValleyViewException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for ViewsFromUnitValleyViewException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for ViewsFromUnitValleyViewException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct WasteReduction {
        #[doc = "Compostable food containers and cutlery. 100% of food service containers and to-go cutlery are compostable, and reusable utensils are offered wherever possible. Compostable materials are capable of undergoing biological decomposition in a compost site, such that material is not visually distinguishable and breaks down into carbon dioxide, water, inorganic compounds, and biomass."]
        #[serde(
            rename = "compostableFoodContainersAndCutlery",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub compostable_food_containers_and_cutlery: ::std::option::Option<bool>,
        #[doc = "Compostable food containers and cutlery exception."]
        #[serde(
            rename = "compostableFoodContainersAndCutleryException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub compostable_food_containers_and_cutlery_exception: ::std::option::Option<
            crate::schemas::WasteReductionCompostableFoodContainersAndCutleryException,
        >,
        #[doc = "Composts excess food. The property has a program and/or policy for diverting waste from landfill by composting food and yard waste, either through compost collection and off-site processing or on-site compost processing."]
        #[serde(
            rename = "compostsExcessFood",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub composts_excess_food: ::std::option::Option<bool>,
        #[doc = "Composts excess food exception."]
        #[serde(
            rename = "compostsExcessFoodException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub composts_excess_food_exception:
            ::std::option::Option<crate::schemas::WasteReductionCompostsExcessFoodException>,
        #[doc = "Donates excess food. The property has a program and/or policy for diverting waste from landfill that may include efforts to donate for human consumption or divert food for animal feed."]
        #[serde(
            rename = "donatesExcessFood",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub donates_excess_food: ::std::option::Option<bool>,
        #[doc = "Donates excess food exception."]
        #[serde(
            rename = "donatesExcessFoodException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub donates_excess_food_exception:
            ::std::option::Option<crate::schemas::WasteReductionDonatesExcessFoodException>,
        #[doc = "Food waste reduction program. The property has established a food waste reduction and donation program, aiming to reduce food waste by half. These programs typically use tools such as the Hotel Kitchen Toolkit and others to track waste and measure progress."]
        #[serde(
            rename = "foodWasteReductionProgram",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub food_waste_reduction_program: ::std::option::Option<bool>,
        #[doc = "Food waste reduction program exception."]
        #[serde(
            rename = "foodWasteReductionProgramException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub food_waste_reduction_program_exception:
            ::std::option::Option<crate::schemas::WasteReductionFoodWasteReductionProgramException>,
        #[doc = "No single use plastic straws. The property bans single-use plastic straws."]
        #[serde(
            rename = "noSingleUsePlasticStraws",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_single_use_plastic_straws: ::std::option::Option<bool>,
        #[doc = "No single use plastic straws exception."]
        #[serde(
            rename = "noSingleUsePlasticStrawsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_single_use_plastic_straws_exception:
            ::std::option::Option<crate::schemas::WasteReductionNoSingleUsePlasticStrawsException>,
        #[doc = "No single use plastic water bottles. The property bans single-use plastic water bottles."]
        #[serde(
            rename = "noSingleUsePlasticWaterBottles",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_single_use_plastic_water_bottles: ::std::option::Option<bool>,
        #[doc = "No single use plastic water bottles exception."]
        #[serde(
            rename = "noSingleUsePlasticWaterBottlesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_single_use_plastic_water_bottles_exception: ::std::option::Option<
            crate::schemas::WasteReductionNoSingleUsePlasticWaterBottlesException,
        >,
        #[doc = "No styrofoam food containers. The property eliminates the use of Styrofoam in disposable food service items."]
        #[serde(
            rename = "noStyrofoamFoodContainers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_styrofoam_food_containers: ::std::option::Option<bool>,
        #[doc = "No styrofoam food containers exception."]
        #[serde(
            rename = "noStyrofoamFoodContainersException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub no_styrofoam_food_containers_exception:
            ::std::option::Option<crate::schemas::WasteReductionNoStyrofoamFoodContainersException>,
        #[doc = "Recycling program. The property has a recycling program, aligned with LEED waste requirements, and a policy outlining efforts to send less than 50% of waste to landfill. The recycling program includes storage locations for recyclable materials, including mixed paper, corrugated cardboard, glass, plastics, and metals."]
        #[serde(
            rename = "recyclingProgram",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recycling_program: ::std::option::Option<bool>,
        #[doc = "Recycling program exception."]
        #[serde(
            rename = "recyclingProgramException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub recycling_program_exception:
            ::std::option::Option<crate::schemas::WasteReductionRecyclingProgramException>,
        #[doc = "Refillable toiletry containers. The property has replaced miniature individual containers with refillable amenity dispensers for shampoo, conditioner, soap, and lotion."]
        #[serde(
            rename = "refillableToiletryContainers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub refillable_toiletry_containers: ::std::option::Option<bool>,
        #[doc = "Refillable toiletry containers exception."]
        #[serde(
            rename = "refillableToiletryContainersException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub refillable_toiletry_containers_exception: ::std::option::Option<
            crate::schemas::WasteReductionRefillableToiletryContainersException,
        >,
        #[doc = "Safely disposes batteries. The property safely stores and disposes batteries."]
        #[serde(
            rename = "safelyDisposesBatteries",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safely_disposes_batteries: ::std::option::Option<bool>,
        #[doc = "Safely disposes batteries exception."]
        #[serde(
            rename = "safelyDisposesBatteriesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safely_disposes_batteries_exception:
            ::std::option::Option<crate::schemas::WasteReductionSafelyDisposesBatteriesException>,
        #[doc = "Safely disposes electronics. The property has a reputable recycling program that keeps hazardous electronic parts and chemical compounds out of landfills, dumps and other unauthorized abandonment sites, and recycles/reuses applicable materials. (e.g. certified electronics recyclers)."]
        #[serde(
            rename = "safelyDisposesElectronics",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safely_disposes_electronics: ::std::option::Option<bool>,
        #[doc = "Safely disposes electronics exception."]
        #[serde(
            rename = "safelyDisposesElectronicsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safely_disposes_electronics_exception:
            ::std::option::Option<crate::schemas::WasteReductionSafelyDisposesElectronicsException>,
        #[doc = "Safely disposes lightbulbs. The property safely stores and disposes lightbulbs."]
        #[serde(
            rename = "safelyDisposesLightbulbs",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safely_disposes_lightbulbs: ::std::option::Option<bool>,
        #[doc = "Safely disposes lightbulbs exception."]
        #[serde(
            rename = "safelyDisposesLightbulbsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safely_disposes_lightbulbs_exception:
            ::std::option::Option<crate::schemas::WasteReductionSafelyDisposesLightbulbsException>,
        #[doc = "Safely handles hazardous substances. The property has a hazardous waste management program aligned wit GreenSeal and LEED requirements, and meets all regulatory requirements for hazardous waste disposal and recycling. Hazardous means substances that are classified as \"hazardous\" by an authoritative body (such as OSHA or DOT), are labeled with signal words such as \"Danger,\" \"Caution,\" \"Warning,\" or are flammable, corrosive, or ignitable. Requirements include: - The property shall maintain records of the efforts it has made to replace the hazardous substances it uses with less hazardous alternatives. - An inventory of the hazardous materials stored on-site. - Products intended for cleaning, dishwashing, laundry, and pool maintenance shall be stored in clearly labeled containers. These containers shall be checked regularly for leaks, and replaced a necessary. - Spill containment devices shall be installed to collect spills, drips, or leaching of chemicals."]
        #[serde(
            rename = "safelyHandlesHazardousSubstances",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safely_handles_hazardous_substances: ::std::option::Option<bool>,
        #[doc = "Safely handles hazardous substances exception."]
        #[serde(
            rename = "safelyHandlesHazardousSubstancesException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub safely_handles_hazardous_substances_exception: ::std::option::Option<
            crate::schemas::WasteReductionSafelyHandlesHazardousSubstancesException,
        >,
        #[doc = "Soap donation program. The property participates in a soap donation program such as Clean the World or something similar."]
        #[serde(
            rename = "soapDonationProgram",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub soap_donation_program: ::std::option::Option<bool>,
        #[doc = "Soap donation program exception."]
        #[serde(
            rename = "soapDonationProgramException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub soap_donation_program_exception:
            ::std::option::Option<crate::schemas::WasteReductionSoapDonationProgramException>,
        #[doc = "Toiletry donation program. The property participates in a toiletry donation program such as Clean the World or something similar."]
        #[serde(
            rename = "toiletryDonationProgram",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub toiletry_donation_program: ::std::option::Option<bool>,
        #[doc = "Toiletry donation program exception."]
        #[serde(
            rename = "toiletryDonationProgramException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub toiletry_donation_program_exception:
            ::std::option::Option<crate::schemas::WasteReductionToiletryDonationProgramException>,
        #[doc = "Water bottle filling stations. The property offers water stations throughout the building for guest use."]
        #[serde(
            rename = "waterBottleFillingStations",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_bottle_filling_stations: ::std::option::Option<bool>,
        #[doc = "Water bottle filling stations exception."]
        #[serde(
            rename = "waterBottleFillingStationsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_bottle_filling_stations_exception: ::std::option::Option<
            crate::schemas::WasteReductionWaterBottleFillingStationsException,
        >,
    }
    impl ::google_field_selector::FieldSelector for WasteReduction {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReduction {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionCompostableFoodContainersAndCutleryException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionCompostableFoodContainersAndCutleryException {
        pub fn as_str(self) -> &'static str {
            match self { WasteReductionCompostableFoodContainersAndCutleryException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , WasteReductionCompostableFoodContainersAndCutleryException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , WasteReductionCompostableFoodContainersAndCutleryException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , WasteReductionCompostableFoodContainersAndCutleryException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionCompostableFoodContainersAndCutleryException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionCompostableFoodContainersAndCutleryException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionCompostableFoodContainersAndCutleryException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionCompostableFoodContainersAndCutleryException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionCompostableFoodContainersAndCutleryException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionCompostableFoodContainersAndCutleryException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionCompostableFoodContainersAndCutleryException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionCompostableFoodContainersAndCutleryException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionCompostableFoodContainersAndCutleryException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionCompostableFoodContainersAndCutleryException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionCompostableFoodContainersAndCutleryException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionCompostableFoodContainersAndCutleryException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionCompostableFoodContainersAndCutleryException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionCompostableFoodContainersAndCutleryException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for WasteReductionCompostableFoodContainersAndCutleryException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for WasteReductionCompostableFoodContainersAndCutleryException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionCompostsExcessFoodException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionCompostsExcessFoodException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionCompostsExcessFoodException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionCompostsExcessFoodException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionCompostsExcessFoodException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionCompostsExcessFoodException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionCompostsExcessFoodException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionCompostsExcessFoodException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionCompostsExcessFoodException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionCompostsExcessFoodException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionCompostsExcessFoodException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionCompostsExcessFoodException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionCompostsExcessFoodException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionCompostsExcessFoodException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionCompostsExcessFoodException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionCompostsExcessFoodException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionCompostsExcessFoodException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionCompostsExcessFoodException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionCompostsExcessFoodException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionCompostsExcessFoodException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionCompostsExcessFoodException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionCompostsExcessFoodException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionDonatesExcessFoodException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionDonatesExcessFoodException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionDonatesExcessFoodException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionDonatesExcessFoodException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionDonatesExcessFoodException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionDonatesExcessFoodException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionDonatesExcessFoodException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionDonatesExcessFoodException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionDonatesExcessFoodException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionDonatesExcessFoodException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionDonatesExcessFoodException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionDonatesExcessFoodException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => WasteReductionDonatesExcessFoodException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionDonatesExcessFoodException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionDonatesExcessFoodException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionDonatesExcessFoodException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionDonatesExcessFoodException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionDonatesExcessFoodException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionDonatesExcessFoodException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => WasteReductionDonatesExcessFoodException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionDonatesExcessFoodException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionDonatesExcessFoodException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionFoodWasteReductionProgramException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionFoodWasteReductionProgramException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionFoodWasteReductionProgramException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionFoodWasteReductionProgramException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionFoodWasteReductionProgramException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionFoodWasteReductionProgramException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionFoodWasteReductionProgramException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionFoodWasteReductionProgramException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionFoodWasteReductionProgramException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionFoodWasteReductionProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionFoodWasteReductionProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionFoodWasteReductionProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionFoodWasteReductionProgramException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionFoodWasteReductionProgramException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionFoodWasteReductionProgramException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionFoodWasteReductionProgramException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionFoodWasteReductionProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionFoodWasteReductionProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionFoodWasteReductionProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionFoodWasteReductionProgramException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionFoodWasteReductionProgramException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionFoodWasteReductionProgramException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionNoSingleUsePlasticStrawsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionNoSingleUsePlasticStrawsException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionNoSingleUsePlasticStrawsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionNoSingleUsePlasticStrawsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionNoSingleUsePlasticStrawsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionNoSingleUsePlasticStrawsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionNoSingleUsePlasticStrawsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionNoSingleUsePlasticStrawsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionNoSingleUsePlasticStrawsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionNoSingleUsePlasticStrawsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionNoSingleUsePlasticStrawsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionNoSingleUsePlasticStrawsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionNoSingleUsePlasticStrawsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionNoSingleUsePlasticStrawsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionNoSingleUsePlasticStrawsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionNoSingleUsePlasticStrawsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionNoSingleUsePlasticStrawsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionNoSingleUsePlasticStrawsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionNoSingleUsePlasticStrawsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionNoSingleUsePlasticStrawsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionNoSingleUsePlasticStrawsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionNoSingleUsePlasticStrawsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionNoSingleUsePlasticWaterBottlesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionNoSingleUsePlasticWaterBottlesException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionNoSingleUsePlasticWaterBottlesException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionNoSingleUsePlasticWaterBottlesException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionNoSingleUsePlasticWaterBottlesException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionNoSingleUsePlasticWaterBottlesException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionNoSingleUsePlasticWaterBottlesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionNoSingleUsePlasticWaterBottlesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionNoSingleUsePlasticWaterBottlesException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionNoSingleUsePlasticWaterBottlesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionNoSingleUsePlasticWaterBottlesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionNoSingleUsePlasticWaterBottlesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionNoSingleUsePlasticWaterBottlesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionNoSingleUsePlasticWaterBottlesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionNoSingleUsePlasticWaterBottlesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionNoSingleUsePlasticWaterBottlesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionNoSingleUsePlasticWaterBottlesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionNoSingleUsePlasticWaterBottlesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionNoSingleUsePlasticWaterBottlesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionNoSingleUsePlasticWaterBottlesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for WasteReductionNoSingleUsePlasticWaterBottlesException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for WasteReductionNoSingleUsePlasticWaterBottlesException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionNoStyrofoamFoodContainersException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionNoStyrofoamFoodContainersException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionNoStyrofoamFoodContainersException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionNoStyrofoamFoodContainersException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionNoStyrofoamFoodContainersException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionNoStyrofoamFoodContainersException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionNoStyrofoamFoodContainersException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionNoStyrofoamFoodContainersException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionNoStyrofoamFoodContainersException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionNoStyrofoamFoodContainersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionNoStyrofoamFoodContainersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionNoStyrofoamFoodContainersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionNoStyrofoamFoodContainersException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionNoStyrofoamFoodContainersException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionNoStyrofoamFoodContainersException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionNoStyrofoamFoodContainersException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionNoStyrofoamFoodContainersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionNoStyrofoamFoodContainersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionNoStyrofoamFoodContainersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionNoStyrofoamFoodContainersException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionNoStyrofoamFoodContainersException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionNoStyrofoamFoodContainersException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionRecyclingProgramException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionRecyclingProgramException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionRecyclingProgramException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionRecyclingProgramException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WasteReductionRecyclingProgramException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionRecyclingProgramException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionRecyclingProgramException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionRecyclingProgramException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WasteReductionRecyclingProgramException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionRecyclingProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => WasteReductionRecyclingProgramException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionRecyclingProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => WasteReductionRecyclingProgramException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionRecyclingProgramException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionRecyclingProgramException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionRecyclingProgramException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionRecyclingProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => WasteReductionRecyclingProgramException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionRecyclingProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => WasteReductionRecyclingProgramException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionRecyclingProgramException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionRecyclingProgramException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionRefillableToiletryContainersException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionRefillableToiletryContainersException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionRefillableToiletryContainersException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionRefillableToiletryContainersException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionRefillableToiletryContainersException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionRefillableToiletryContainersException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionRefillableToiletryContainersException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionRefillableToiletryContainersException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionRefillableToiletryContainersException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionRefillableToiletryContainersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionRefillableToiletryContainersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionRefillableToiletryContainersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionRefillableToiletryContainersException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionRefillableToiletryContainersException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionRefillableToiletryContainersException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionRefillableToiletryContainersException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionRefillableToiletryContainersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionRefillableToiletryContainersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionRefillableToiletryContainersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionRefillableToiletryContainersException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for WasteReductionRefillableToiletryContainersException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionRefillableToiletryContainersException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionSafelyDisposesBatteriesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionSafelyDisposesBatteriesException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionSafelyDisposesBatteriesException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionSafelyDisposesBatteriesException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionSafelyDisposesBatteriesException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionSafelyDisposesBatteriesException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionSafelyDisposesBatteriesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionSafelyDisposesBatteriesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionSafelyDisposesBatteriesException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSafelyDisposesBatteriesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSafelyDisposesBatteriesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSafelyDisposesBatteriesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSafelyDisposesBatteriesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionSafelyDisposesBatteriesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionSafelyDisposesBatteriesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionSafelyDisposesBatteriesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSafelyDisposesBatteriesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSafelyDisposesBatteriesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSafelyDisposesBatteriesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSafelyDisposesBatteriesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionSafelyDisposesBatteriesException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionSafelyDisposesBatteriesException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionSafelyDisposesElectronicsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionSafelyDisposesElectronicsException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionSafelyDisposesElectronicsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionSafelyDisposesElectronicsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionSafelyDisposesElectronicsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionSafelyDisposesElectronicsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionSafelyDisposesElectronicsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionSafelyDisposesElectronicsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionSafelyDisposesElectronicsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSafelyDisposesElectronicsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSafelyDisposesElectronicsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSafelyDisposesElectronicsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSafelyDisposesElectronicsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionSafelyDisposesElectronicsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionSafelyDisposesElectronicsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionSafelyDisposesElectronicsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSafelyDisposesElectronicsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSafelyDisposesElectronicsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSafelyDisposesElectronicsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSafelyDisposesElectronicsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionSafelyDisposesElectronicsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionSafelyDisposesElectronicsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionSafelyDisposesLightbulbsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionSafelyDisposesLightbulbsException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionSafelyDisposesLightbulbsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionSafelyDisposesLightbulbsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionSafelyDisposesLightbulbsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionSafelyDisposesLightbulbsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionSafelyDisposesLightbulbsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionSafelyDisposesLightbulbsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionSafelyDisposesLightbulbsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSafelyDisposesLightbulbsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSafelyDisposesLightbulbsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSafelyDisposesLightbulbsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSafelyDisposesLightbulbsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionSafelyDisposesLightbulbsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionSafelyDisposesLightbulbsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionSafelyDisposesLightbulbsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSafelyDisposesLightbulbsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSafelyDisposesLightbulbsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSafelyDisposesLightbulbsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSafelyDisposesLightbulbsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionSafelyDisposesLightbulbsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionSafelyDisposesLightbulbsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionSafelyHandlesHazardousSubstancesException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionSafelyHandlesHazardousSubstancesException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionSafelyHandlesHazardousSubstancesException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionSafelyHandlesHazardousSubstancesException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionSafelyHandlesHazardousSubstancesException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionSafelyHandlesHazardousSubstancesException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionSafelyHandlesHazardousSubstancesException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionSafelyHandlesHazardousSubstancesException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionSafelyHandlesHazardousSubstancesException, ()>
        {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSafelyHandlesHazardousSubstancesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSafelyHandlesHazardousSubstancesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSafelyHandlesHazardousSubstancesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSafelyHandlesHazardousSubstancesException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionSafelyHandlesHazardousSubstancesException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionSafelyHandlesHazardousSubstancesException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionSafelyHandlesHazardousSubstancesException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSafelyHandlesHazardousSubstancesException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSafelyHandlesHazardousSubstancesException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSafelyHandlesHazardousSubstancesException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSafelyHandlesHazardousSubstancesException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector
        for WasteReductionSafelyHandlesHazardousSubstancesException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for WasteReductionSafelyHandlesHazardousSubstancesException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionSoapDonationProgramException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionSoapDonationProgramException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionSoapDonationProgramException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionSoapDonationProgramException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionSoapDonationProgramException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionSoapDonationProgramException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionSoapDonationProgramException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionSoapDonationProgramException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionSoapDonationProgramException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSoapDonationProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSoapDonationProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSoapDonationProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSoapDonationProgramException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionSoapDonationProgramException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionSoapDonationProgramException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionSoapDonationProgramException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionSoapDonationProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionSoapDonationProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionSoapDonationProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionSoapDonationProgramException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionSoapDonationProgramException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionSoapDonationProgramException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionToiletryDonationProgramException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionToiletryDonationProgramException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionToiletryDonationProgramException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionToiletryDonationProgramException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionToiletryDonationProgramException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionToiletryDonationProgramException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionToiletryDonationProgramException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionToiletryDonationProgramException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionToiletryDonationProgramException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionToiletryDonationProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionToiletryDonationProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionToiletryDonationProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionToiletryDonationProgramException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionToiletryDonationProgramException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionToiletryDonationProgramException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionToiletryDonationProgramException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionToiletryDonationProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionToiletryDonationProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionToiletryDonationProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionToiletryDonationProgramException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionToiletryDonationProgramException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionToiletryDonationProgramException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WasteReductionWaterBottleFillingStationsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WasteReductionWaterBottleFillingStationsException {
        pub fn as_str(self) -> &'static str {
            match self {
                WasteReductionWaterBottleFillingStationsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WasteReductionWaterBottleFillingStationsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WasteReductionWaterBottleFillingStationsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WasteReductionWaterBottleFillingStationsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WasteReductionWaterBottleFillingStationsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WasteReductionWaterBottleFillingStationsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WasteReductionWaterBottleFillingStationsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionWaterBottleFillingStationsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionWaterBottleFillingStationsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionWaterBottleFillingStationsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionWaterBottleFillingStationsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WasteReductionWaterBottleFillingStationsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WasteReductionWaterBottleFillingStationsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WasteReductionWaterBottleFillingStationsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WasteReductionWaterBottleFillingStationsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WasteReductionWaterBottleFillingStationsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WasteReductionWaterBottleFillingStationsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WasteReductionWaterBottleFillingStationsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WasteReductionWaterBottleFillingStationsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WasteReductionWaterBottleFillingStationsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct WaterConservation {
        #[doc = "Independent organization audits water use. The property conducts a water conservation audit every 5 years, the results of which are either verified by a third-party and/or published in external communications. A water conservation audit is a detailed assessment of the facility, providing recommendations to existing operations and procedures to improve water efficiency, available incentives or rebates, and opportunities for improvements through renovations or upgrades. Examples of organizations who conduct credible third party audits include: Engie Impact, and local utility providers (they often provide energy and water audits)."]
        #[serde(
            rename = "independentOrganizationAuditsWaterUse",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub independent_organization_audits_water_use: ::std::option::Option<bool>,
        #[doc = "Independent organization audits water use exception."]
        #[serde(
            rename = "independentOrganizationAuditsWaterUseException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub independent_organization_audits_water_use_exception: ::std::option::Option<
            crate::schemas::WaterConservationIndependentOrganizationAuditsWaterUseException,
        >,
        #[doc = "Linen reuse program. The property offers a linen reuse program."]
        #[serde(
            rename = "linenReuseProgram",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub linen_reuse_program: ::std::option::Option<bool>,
        #[doc = "Linen reuse program exception."]
        #[serde(
            rename = "linenReuseProgramException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub linen_reuse_program_exception:
            ::std::option::Option<crate::schemas::WaterConservationLinenReuseProgramException>,
        #[doc = "Towel reuse program. The property offers a towel reuse program."]
        #[serde(
            rename = "towelReuseProgram",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub towel_reuse_program: ::std::option::Option<bool>,
        #[doc = "Towel reuse program exception."]
        #[serde(
            rename = "towelReuseProgramException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub towel_reuse_program_exception:
            ::std::option::Option<crate::schemas::WaterConservationTowelReuseProgramException>,
        #[doc = "Water saving showers. All of the property's guest rooms have shower heads that use no more than 2.0 gallons per minute (gpm)."]
        #[serde(
            rename = "waterSavingShowers",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_saving_showers: ::std::option::Option<bool>,
        #[doc = "Water saving showers exception."]
        #[serde(
            rename = "waterSavingShowersException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_saving_showers_exception:
            ::std::option::Option<crate::schemas::WaterConservationWaterSavingShowersException>,
        #[doc = "Water saving sinks. All of the property's guest rooms have bathroom faucets that use a maximum of 1.5 gallons per minute (gpm), public restroom faucets do not exceed 0.5 gpm, and kitchen faucets (excluding faucets used exclusively for filling operations) do not exceed 2.2 gpm."]
        #[serde(
            rename = "waterSavingSinks",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_saving_sinks: ::std::option::Option<bool>,
        #[doc = "Water saving sinks exception."]
        #[serde(
            rename = "waterSavingSinksException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_saving_sinks_exception:
            ::std::option::Option<crate::schemas::WaterConservationWaterSavingSinksException>,
        #[doc = "Water saving toilets. All of the property's toilets use 1.6 gallons per flush, or less."]
        #[serde(
            rename = "waterSavingToilets",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_saving_toilets: ::std::option::Option<bool>,
        #[doc = "Water saving toilets exception."]
        #[serde(
            rename = "waterSavingToiletsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub water_saving_toilets_exception:
            ::std::option::Option<crate::schemas::WaterConservationWaterSavingToiletsException>,
    }
    impl ::google_field_selector::FieldSelector for WaterConservation {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WaterConservation {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WaterConservationIndependentOrganizationAuditsWaterUseException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WaterConservationIndependentOrganizationAuditsWaterUseException {
        pub fn as_str(self) -> &'static str {
            match self { WaterConservationIndependentOrganizationAuditsWaterUseException :: DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK" , WaterConservationIndependentOrganizationAuditsWaterUseException :: DependentOnSeason => "DEPENDENT_ON_SEASON" , WaterConservationIndependentOrganizationAuditsWaterUseException :: ExceptionUnspecified => "EXCEPTION_UNSPECIFIED" , WaterConservationIndependentOrganizationAuditsWaterUseException :: UnderConstruction => "UNDER_CONSTRUCTION" , }
        }
    }
    impl ::std::convert::AsRef<str>
        for WaterConservationIndependentOrganizationAuditsWaterUseException
    {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WaterConservationIndependentOrganizationAuditsWaterUseException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<
            WaterConservationIndependentOrganizationAuditsWaterUseException,
            (),
        > {
            Ok (match s { "DEPENDENT_ON_DAY_OF_WEEK" => WaterConservationIndependentOrganizationAuditsWaterUseException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => WaterConservationIndependentOrganizationAuditsWaterUseException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => WaterConservationIndependentOrganizationAuditsWaterUseException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => WaterConservationIndependentOrganizationAuditsWaterUseException :: UnderConstruction , _ => return Err (()) , })
        }
    }
    impl ::std::fmt::Display for WaterConservationIndependentOrganizationAuditsWaterUseException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WaterConservationIndependentOrganizationAuditsWaterUseException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for WaterConservationIndependentOrganizationAuditsWaterUseException
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok (match value { "DEPENDENT_ON_DAY_OF_WEEK" => WaterConservationIndependentOrganizationAuditsWaterUseException :: DependentOnDayOfWeek , "DEPENDENT_ON_SEASON" => WaterConservationIndependentOrganizationAuditsWaterUseException :: DependentOnSeason , "EXCEPTION_UNSPECIFIED" => WaterConservationIndependentOrganizationAuditsWaterUseException :: ExceptionUnspecified , "UNDER_CONSTRUCTION" => WaterConservationIndependentOrganizationAuditsWaterUseException :: UnderConstruction , _ => return Err (:: serde :: de :: Error :: custom (format ! ("invalid enum for #name: {}" , value))) , })
        }
    }
    impl ::google_field_selector::FieldSelector
        for WaterConservationIndependentOrganizationAuditsWaterUseException
    {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType
        for WaterConservationIndependentOrganizationAuditsWaterUseException
    {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WaterConservationLinenReuseProgramException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WaterConservationLinenReuseProgramException {
        pub fn as_str(self) -> &'static str {
            match self {
                WaterConservationLinenReuseProgramException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WaterConservationLinenReuseProgramException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WaterConservationLinenReuseProgramException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WaterConservationLinenReuseProgramException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WaterConservationLinenReuseProgramException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WaterConservationLinenReuseProgramException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WaterConservationLinenReuseProgramException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationLinenReuseProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationLinenReuseProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationLinenReuseProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationLinenReuseProgramException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WaterConservationLinenReuseProgramException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WaterConservationLinenReuseProgramException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WaterConservationLinenReuseProgramException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationLinenReuseProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationLinenReuseProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationLinenReuseProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationLinenReuseProgramException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WaterConservationLinenReuseProgramException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WaterConservationLinenReuseProgramException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WaterConservationTowelReuseProgramException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WaterConservationTowelReuseProgramException {
        pub fn as_str(self) -> &'static str {
            match self {
                WaterConservationTowelReuseProgramException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WaterConservationTowelReuseProgramException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WaterConservationTowelReuseProgramException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WaterConservationTowelReuseProgramException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WaterConservationTowelReuseProgramException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WaterConservationTowelReuseProgramException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WaterConservationTowelReuseProgramException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationTowelReuseProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationTowelReuseProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationTowelReuseProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationTowelReuseProgramException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WaterConservationTowelReuseProgramException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WaterConservationTowelReuseProgramException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WaterConservationTowelReuseProgramException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationTowelReuseProgramException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationTowelReuseProgramException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationTowelReuseProgramException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationTowelReuseProgramException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WaterConservationTowelReuseProgramException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WaterConservationTowelReuseProgramException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WaterConservationWaterSavingShowersException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WaterConservationWaterSavingShowersException {
        pub fn as_str(self) -> &'static str {
            match self {
                WaterConservationWaterSavingShowersException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WaterConservationWaterSavingShowersException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WaterConservationWaterSavingShowersException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WaterConservationWaterSavingShowersException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WaterConservationWaterSavingShowersException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WaterConservationWaterSavingShowersException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WaterConservationWaterSavingShowersException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationWaterSavingShowersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationWaterSavingShowersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationWaterSavingShowersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationWaterSavingShowersException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WaterConservationWaterSavingShowersException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WaterConservationWaterSavingShowersException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WaterConservationWaterSavingShowersException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationWaterSavingShowersException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationWaterSavingShowersException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationWaterSavingShowersException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationWaterSavingShowersException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WaterConservationWaterSavingShowersException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WaterConservationWaterSavingShowersException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WaterConservationWaterSavingSinksException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WaterConservationWaterSavingSinksException {
        pub fn as_str(self) -> &'static str {
            match self {
                WaterConservationWaterSavingSinksException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WaterConservationWaterSavingSinksException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WaterConservationWaterSavingSinksException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WaterConservationWaterSavingSinksException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WaterConservationWaterSavingSinksException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WaterConservationWaterSavingSinksException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WaterConservationWaterSavingSinksException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationWaterSavingSinksException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationWaterSavingSinksException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationWaterSavingSinksException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationWaterSavingSinksException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WaterConservationWaterSavingSinksException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WaterConservationWaterSavingSinksException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WaterConservationWaterSavingSinksException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationWaterSavingSinksException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationWaterSavingSinksException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationWaterSavingSinksException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationWaterSavingSinksException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WaterConservationWaterSavingSinksException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WaterConservationWaterSavingSinksException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WaterConservationWaterSavingToiletsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WaterConservationWaterSavingToiletsException {
        pub fn as_str(self) -> &'static str {
            match self {
                WaterConservationWaterSavingToiletsException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WaterConservationWaterSavingToiletsException::DependentOnSeason => {
                    "DEPENDENT_ON_SEASON"
                }
                WaterConservationWaterSavingToiletsException::ExceptionUnspecified => {
                    "EXCEPTION_UNSPECIFIED"
                }
                WaterConservationWaterSavingToiletsException::UnderConstruction => {
                    "UNDER_CONSTRUCTION"
                }
            }
        }
    }
    impl ::std::convert::AsRef<str> for WaterConservationWaterSavingToiletsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WaterConservationWaterSavingToiletsException {
        type Err = ();
        fn from_str(
            s: &str,
        ) -> ::std::result::Result<WaterConservationWaterSavingToiletsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationWaterSavingToiletsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationWaterSavingToiletsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationWaterSavingToiletsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationWaterSavingToiletsException::UnderConstruction
                }
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WaterConservationWaterSavingToiletsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WaterConservationWaterSavingToiletsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WaterConservationWaterSavingToiletsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WaterConservationWaterSavingToiletsException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => {
                    WaterConservationWaterSavingToiletsException::DependentOnSeason
                }
                "EXCEPTION_UNSPECIFIED" => {
                    WaterConservationWaterSavingToiletsException::ExceptionUnspecified
                }
                "UNDER_CONSTRUCTION" => {
                    WaterConservationWaterSavingToiletsException::UnderConstruction
                }
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WaterConservationWaterSavingToiletsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WaterConservationWaterSavingToiletsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Wellness {
        #[doc = "Doctor on call. The hotel has a contract with a medical professional who provides services to hotel guests should they fall ill during their stay. The doctor may or may not have an on-site office or be at the hotel at all times."]
        #[serde(
            rename = "doctorOnCall",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub doctor_on_call: ::std::option::Option<bool>,
        #[doc = "Doctor on call exception."]
        #[serde(
            rename = "doctorOnCallException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub doctor_on_call_exception:
            ::std::option::Option<crate::schemas::WellnessDoctorOnCallException>,
        #[doc = "Elliptical machine. An electric, stationary fitness machine with pedals that simulates climbing, walking or running and provides a user-controlled range of speeds and tensions. May not have arm-controlled levers to work out the upper body as well. Commonly found in a gym, fitness room, health center, or health club."]
        #[serde(
            rename = "ellipticalMachine",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub elliptical_machine: ::std::option::Option<bool>,
        #[doc = "Elliptical machine exception."]
        #[serde(
            rename = "ellipticalMachineException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub elliptical_machine_exception:
            ::std::option::Option<crate::schemas::WellnessEllipticalMachineException>,
        #[doc = "Fitness center. A room or building at the hotel containing equipment to promote physical activity, such as treadmills, elliptical machines, stationary bikes, weight machines, free weights, and/or stretching mats. Use of the fitness center can be free or for a fee. May or may not be staffed. May or may not offer instructor-led classes in various styles of physical conditioning. May or may not be open 24/7. May or may not include locker rooms and showers. Also known as health club, gym, fitness room, health center."]
        #[serde(
            rename = "fitnessCenter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fitness_center: ::std::option::Option<bool>,
        #[doc = "Fitness center exception."]
        #[serde(
            rename = "fitnessCenterException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub fitness_center_exception:
            ::std::option::Option<crate::schemas::WellnessFitnessCenterException>,
        #[doc = "Free fitness center. Guests may use the fitness center for free."]
        #[serde(
            rename = "freeFitnessCenter",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_fitness_center: ::std::option::Option<bool>,
        #[doc = "Free fitness center exception."]
        #[serde(
            rename = "freeFitnessCenterException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_fitness_center_exception:
            ::std::option::Option<crate::schemas::WellnessFreeFitnessCenterException>,
        #[doc = "Free weights. Individual handheld fitness equipment of varied weights used for upper body strength training or bodybuilding. Also known as barbells, dumbbells, or kettlebells. Often stored on a rack with the weights arranged from light to heavy. Commonly found in a gym, fitness room, health center, or health club."]
        #[serde(
            rename = "freeWeights",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_weights: ::std::option::Option<bool>,
        #[doc = "Free weights exception."]
        #[serde(
            rename = "freeWeightsException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub free_weights_exception:
            ::std::option::Option<crate::schemas::WellnessFreeWeightsException>,
        #[doc = "Massage. A service provided by a trained massage therapist involving the physical manipulation of a guest's muscles in order to achieve relaxation or pain relief."]
        #[serde(
            rename = "massage",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub massage: ::std::option::Option<bool>,
        #[doc = "Massage exception."]
        #[serde(
            rename = "massageException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub massage_exception: ::std::option::Option<crate::schemas::WellnessMassageException>,
        #[doc = "Salon. A room at the hotel where professionals provide hair styling services such as shampooing, blow drying, hair dos, hair cutting and hair coloring. Also known as hairdresser or beauty salon."]
        #[serde(
            rename = "salon",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub salon: ::std::option::Option<bool>,
        #[doc = "Salon exception."]
        #[serde(
            rename = "salonException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub salon_exception: ::std::option::Option<crate::schemas::WellnessSalonException>,
        #[doc = "Sauna. A wood-paneled room heated to a high temperature where guests sit on built-in wood benches for the purpose of perspiring and relaxing their muscles. Can be dry or slightly wet heat. Not a steam room."]
        #[serde(
            rename = "sauna",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sauna: ::std::option::Option<bool>,
        #[doc = "Sauna exception."]
        #[serde(
            rename = "saunaException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub sauna_exception: ::std::option::Option<crate::schemas::WellnessSaunaException>,
        #[doc = "Spa. A designated area, room or building at the hotel offering health and beauty treatment through such means as steam baths, exercise equipment, and massage. May also offer facials, nail care, and hair care. Services are usually available by appointment and for an additional fee. Does not apply if hotel only offers a steam room; must offer other beauty and/or health treatments as well."]
        #[serde(
            rename = "spa",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub spa: ::std::option::Option<bool>,
        #[doc = "Spa exception."]
        #[serde(
            rename = "spaException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub spa_exception: ::std::option::Option<crate::schemas::WellnessSpaException>,
        #[doc = "Treadmill. An electric stationary fitness machine that simulates a moving path to promote walking or running within a range of user-controlled speeds and inclines. Also known as running machine. Commonly found in a gym, fitness room, health center, or health club."]
        #[serde(
            rename = "treadmill",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub treadmill: ::std::option::Option<bool>,
        #[doc = "Treadmill exception."]
        #[serde(
            rename = "treadmillException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub treadmill_exception: ::std::option::Option<crate::schemas::WellnessTreadmillException>,
        #[doc = "Weight machine. Non-electronic fitness equipment designed for the user to target the exertion of different muscles. Usually incorporates a padded seat, a stack of flat weights and various bars and pulleys. May be designed for toning a specific part of the body or may involve different user-controlled settings, hardware and pulleys so as to provide an overall workout in one machine. Commonly found in a gym, fitness center, fitness room, or health club."]
        #[serde(
            rename = "weightMachine",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub weight_machine: ::std::option::Option<bool>,
        #[doc = "Weight machine exception."]
        #[serde(
            rename = "weightMachineException",
            default,
            skip_serializing_if = "std::option::Option::is_none"
        )]
        pub weight_machine_exception:
            ::std::option::Option<crate::schemas::WellnessWeightMachineException>,
    }
    impl ::google_field_selector::FieldSelector for Wellness {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Wellness {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessDoctorOnCallException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessDoctorOnCallException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessDoctorOnCallException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessDoctorOnCallException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessDoctorOnCallException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessDoctorOnCallException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessDoctorOnCallException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessDoctorOnCallException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessDoctorOnCallException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessDoctorOnCallException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessDoctorOnCallException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessDoctorOnCallException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessDoctorOnCallException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessDoctorOnCallException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessDoctorOnCallException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessDoctorOnCallException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessDoctorOnCallException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessDoctorOnCallException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessDoctorOnCallException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessDoctorOnCallException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessDoctorOnCallException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessDoctorOnCallException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessEllipticalMachineException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessEllipticalMachineException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessEllipticalMachineException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WellnessEllipticalMachineException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessEllipticalMachineException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessEllipticalMachineException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessEllipticalMachineException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessEllipticalMachineException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessEllipticalMachineException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WellnessEllipticalMachineException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => WellnessEllipticalMachineException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessEllipticalMachineException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessEllipticalMachineException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessEllipticalMachineException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessEllipticalMachineException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessEllipticalMachineException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WellnessEllipticalMachineException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => WellnessEllipticalMachineException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessEllipticalMachineException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessEllipticalMachineException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessEllipticalMachineException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessEllipticalMachineException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessFitnessCenterException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessFitnessCenterException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessFitnessCenterException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessFitnessCenterException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessFitnessCenterException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessFitnessCenterException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessFitnessCenterException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessFitnessCenterException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessFitnessCenterException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessFitnessCenterException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessFitnessCenterException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessFitnessCenterException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessFitnessCenterException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessFitnessCenterException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessFitnessCenterException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessFitnessCenterException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessFitnessCenterException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessFitnessCenterException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessFitnessCenterException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessFitnessCenterException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessFitnessCenterException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessFitnessCenterException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessFreeFitnessCenterException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessFreeFitnessCenterException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessFreeFitnessCenterException::DependentOnDayOfWeek => {
                    "DEPENDENT_ON_DAY_OF_WEEK"
                }
                WellnessFreeFitnessCenterException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessFreeFitnessCenterException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessFreeFitnessCenterException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessFreeFitnessCenterException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessFreeFitnessCenterException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessFreeFitnessCenterException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WellnessFreeFitnessCenterException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => WellnessFreeFitnessCenterException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessFreeFitnessCenterException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessFreeFitnessCenterException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessFreeFitnessCenterException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessFreeFitnessCenterException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessFreeFitnessCenterException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => {
                    WellnessFreeFitnessCenterException::DependentOnDayOfWeek
                }
                "DEPENDENT_ON_SEASON" => WellnessFreeFitnessCenterException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessFreeFitnessCenterException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessFreeFitnessCenterException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessFreeFitnessCenterException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessFreeFitnessCenterException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessFreeWeightsException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessFreeWeightsException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessFreeWeightsException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessFreeWeightsException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessFreeWeightsException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessFreeWeightsException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessFreeWeightsException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessFreeWeightsException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessFreeWeightsException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessFreeWeightsException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessFreeWeightsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessFreeWeightsException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessFreeWeightsException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessFreeWeightsException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessFreeWeightsException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessFreeWeightsException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessFreeWeightsException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessFreeWeightsException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessFreeWeightsException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessFreeWeightsException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessFreeWeightsException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessFreeWeightsException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessMassageException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessMassageException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessMassageException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessMassageException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessMassageException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessMassageException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessMassageException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessMassageException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessMassageException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessMassageException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessMassageException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessMassageException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessMassageException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessMassageException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessMassageException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessMassageException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessMassageException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessMassageException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessMassageException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessMassageException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessMassageException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessMassageException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessSalonException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessSalonException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessSalonException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessSalonException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessSalonException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessSalonException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessSalonException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessSalonException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessSalonException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessSalonException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessSalonException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessSalonException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessSalonException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessSalonException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessSalonException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessSalonException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessSalonException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessSalonException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessSalonException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessSalonException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessSalonException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessSalonException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessSaunaException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessSaunaException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessSaunaException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessSaunaException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessSaunaException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessSaunaException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessSaunaException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessSaunaException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessSaunaException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessSaunaException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessSaunaException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessSaunaException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessSaunaException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessSaunaException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessSaunaException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessSaunaException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessSaunaException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessSaunaException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessSaunaException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessSaunaException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessSaunaException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessSaunaException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessSpaException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessSpaException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessSpaException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessSpaException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessSpaException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessSpaException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessSpaException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessSpaException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessSpaException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessSpaException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessSpaException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessSpaException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessSpaException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessSpaException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessSpaException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessSpaException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessSpaException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessSpaException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessSpaException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessSpaException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessSpaException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessSpaException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessTreadmillException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessTreadmillException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessTreadmillException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessTreadmillException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessTreadmillException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessTreadmillException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessTreadmillException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessTreadmillException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessTreadmillException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessTreadmillException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessTreadmillException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessTreadmillException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessTreadmillException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessTreadmillException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessTreadmillException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessTreadmillException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessTreadmillException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessTreadmillException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessTreadmillException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessTreadmillException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessTreadmillException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessTreadmillException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum WellnessWeightMachineException {
        #[doc = "Amenity or service availability depends on the day of the week."]
        DependentOnDayOfWeek,
        #[doc = "Amenity or service availability is seasonal."]
        DependentOnSeason,
        #[doc = "Default unspecified exception. Use this only if a more specific exception does not match."]
        ExceptionUnspecified,
        #[doc = "Amenity or service is unavailable due to ongoing work orders."]
        UnderConstruction,
    }
    impl WellnessWeightMachineException {
        pub fn as_str(self) -> &'static str {
            match self {
                WellnessWeightMachineException::DependentOnDayOfWeek => "DEPENDENT_ON_DAY_OF_WEEK",
                WellnessWeightMachineException::DependentOnSeason => "DEPENDENT_ON_SEASON",
                WellnessWeightMachineException::ExceptionUnspecified => "EXCEPTION_UNSPECIFIED",
                WellnessWeightMachineException::UnderConstruction => "UNDER_CONSTRUCTION",
            }
        }
    }
    impl ::std::convert::AsRef<str> for WellnessWeightMachineException {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for WellnessWeightMachineException {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<WellnessWeightMachineException, ()> {
            Ok(match s {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessWeightMachineException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessWeightMachineException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessWeightMachineException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessWeightMachineException::UnderConstruction,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for WellnessWeightMachineException {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for WellnessWeightMachineException {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WellnessWeightMachineException {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "DEPENDENT_ON_DAY_OF_WEEK" => WellnessWeightMachineException::DependentOnDayOfWeek,
                "DEPENDENT_ON_SEASON" => WellnessWeightMachineException::DependentOnSeason,
                "EXCEPTION_UNSPECIFIED" => WellnessWeightMachineException::ExceptionUnspecified,
                "UNDER_CONSTRUCTION" => WellnessWeightMachineException::UnderConstruction,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for WellnessWeightMachineException {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for WellnessWeightMachineException {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
}
pub mod params {
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Alt {
        #[doc = "Responses with Content-Type of application/json"]
        Json,
        #[doc = "Media download with context-dependent Content-Type"]
        Media,
        #[doc = "Responses with Content-Type of application/x-protobuf"]
        Proto,
    }
    impl Alt {
        pub fn as_str(self) -> &'static str {
            match self {
                Alt::Json => "json",
                Alt::Media => "media",
                Alt::Proto => "proto",
            }
        }
    }
    impl ::std::convert::AsRef<str> for Alt {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for Alt {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<Alt, ()> {
            Ok(match s {
                "json" => Alt::Json,
                "media" => Alt::Media,
                "proto" => Alt::Proto,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for Alt {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Alt {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Alt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "json" => Alt::Json,
                "media" => Alt::Media,
                "proto" => Alt::Proto,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for Alt {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Alt {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Xgafv {
        #[doc = "v1 error format"]
        _1,
        #[doc = "v2 error format"]
        _2,
    }
    impl Xgafv {
        pub fn as_str(self) -> &'static str {
            match self {
                Xgafv::_1 => "1",
                Xgafv::_2 => "2",
            }
        }
    }
    impl ::std::convert::AsRef<str> for Xgafv {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }
    impl ::std::str::FromStr for Xgafv {
        type Err = ();
        fn from_str(s: &str) -> ::std::result::Result<Xgafv, ()> {
            Ok(match s {
                "1" => Xgafv::_1,
                "2" => Xgafv::_2,
                _ => return Err(()),
            })
        }
    }
    impl ::std::fmt::Display for Xgafv {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Xgafv {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Xgafv {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "1" => Xgafv::_1,
                "2" => Xgafv::_2,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::google_field_selector::FieldSelector for Xgafv {
        fn fields() -> Vec<::google_field_selector::Field> {
            Vec::new()
        }
    }
    impl ::google_field_selector::ToFieldType for Xgafv {
        fn field_type() -> ::google_field_selector::FieldType {
            ::google_field_selector::FieldType::Leaf
        }
    }
}
pub struct Client {
    reqwest: ::reqwest::Client,
    auth: Box<dyn ::google_api_auth::GetAccessToken>,
}
impl Client {
    pub fn new<A>(auth: A) -> Self
    where
        A: ::google_api_auth::GetAccessToken + 'static,
    {
        Client::with_reqwest_client(auth, ::reqwest::Client::builder().build().unwrap())
    }
    pub fn with_reqwest_client<A>(auth: A, reqwest: ::reqwest::Client) -> Self
    where
        A: ::google_api_auth::GetAccessToken + 'static,
    {
        Client {
            reqwest,
            auth: Box::new(auth),
        }
    }
    fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
        self.auth.as_ref()
    }
    #[doc = "Actions that can be performed on the locations resource"]
    pub fn locations(&self) -> crate::resources::locations::LocationsActions {
        crate::resources::locations::LocationsActions {
            reqwest: &self.reqwest,
            auth: self.auth_ref(),
        }
    }
}
pub mod resources {
    pub mod locations {
        pub mod params {}
        pub struct LocationsActions<'a> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
        }
        impl<'a> LocationsActions<'a> {
            fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                self.auth
            }
            #[doc = "Returns the Lodging of a specific location."]
            pub fn get_lodging(&self, name: impl Into<String>) -> GetLodgingRequestBuilder {
                GetLodgingRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    name: name.into(),
                    read_mask: None,
                }
            }
            #[doc = "Updates the Lodging of a specific location."]
            pub fn update_lodging(
                &self,
                request: crate::schemas::Lodging,
                name: impl Into<String>,
            ) -> UpdateLodgingRequestBuilder {
                UpdateLodgingRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                    request,
                    access_token: None,
                    alt: None,
                    callback: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    upload_protocol: None,
                    upload_type: None,
                    xgafv: None,
                    name: name.into(),
                    update_mask: None,
                }
            }
            #[doc = "Actions that can be performed on the lodging resource"]
            pub fn lodging(&self) -> crate::resources::locations::lodging::LodgingActions {
                crate::resources::locations::lodging::LodgingActions {
                    reqwest: &self.reqwest,
                    auth: self.auth_ref(),
                }
            }
        }
        #[doc = "Created via [LocationsActions::get_lodging()](struct.LocationsActions.html#method.get_lodging)"]
        #[derive(Debug, Clone)]
        pub struct GetLodgingRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            name: String,
            read_mask: ::std::option::Option<String>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> GetLodgingRequestBuilder<'a> {
            #[doc = "Required. The specific fields to return. Use \"*\" to include all fields. Repeated field items cannot be individually specified."]
            pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                self.read_mask = Some(value.into());
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::Lodging, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::Lodging, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://mybusinesslodging.googleapis.com/".to_owned();
                output.push_str("v1/");
                {
                    let var_as_str = &self.name;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::RESERVED,
                    ));
                }
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                req = req.query(&[("readMask", &self.read_mask)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        #[doc = "Created via [LocationsActions::update_lodging()](struct.LocationsActions.html#method.update_lodging)"]
        #[derive(Debug, Clone)]
        pub struct UpdateLodgingRequestBuilder<'a> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            request: crate::schemas::Lodging,
            name: String,
            update_mask: ::std::option::Option<String>,
            access_token: ::std::option::Option<String>,
            alt: ::std::option::Option<crate::params::Alt>,
            callback: ::std::option::Option<String>,
            fields: ::std::option::Option<String>,
            key: ::std::option::Option<String>,
            oauth_token: ::std::option::Option<String>,
            pretty_print: ::std::option::Option<bool>,
            quota_user: ::std::option::Option<String>,
            upload_protocol: ::std::option::Option<String>,
            upload_type: ::std::option::Option<String>,
            xgafv: ::std::option::Option<crate::params::Xgafv>,
        }
        impl<'a> UpdateLodgingRequestBuilder<'a> {
            #[doc = "Required. The specific fields to update. Use \"*\" to update all fields, which may include unsetting empty fields in the request. Repeated field items cannot be individually updated."]
            pub fn update_mask(mut self, value: impl Into<String>) -> Self {
                self.update_mask = Some(value.into());
                self
            }
            #[doc = "OAuth access token."]
            pub fn access_token(mut self, value: impl Into<String>) -> Self {
                self.access_token = Some(value.into());
                self
            }
            #[doc = "JSONP"]
            pub fn callback(mut self, value: impl Into<String>) -> Self {
                self.callback = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
            pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                self.upload_protocol = Some(value.into());
                self
            }
            #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
            pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                self.upload_type = Some(value.into());
                self
            }
            #[doc = "V1 error format."]
            pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                self.xgafv = Some(value);
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub async fn execute<T>(self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
            {
                let fields = ::google_field_selector::to_string::<T>();
                let fields: ::std::option::Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_with_fields(fields).await
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub async fn execute_with_default_fields(
                self,
            ) -> Result<crate::schemas::Lodging, crate::Error> {
                self.execute_with_fields(None::<&str>).await
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub async fn execute_with_all_fields(
                self,
            ) -> Result<crate::schemas::Lodging, crate::Error> {
                self.execute_with_fields(Some("*")).await
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub async fn execute_with_fields<T, F>(
                mut self,
                fields: ::std::option::Option<F>,
            ) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute().await
            }
            async fn _execute<T>(&mut self) -> Result<T, crate::Error>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path()).await?;
                let req = req.json(&self.request);
                Ok(req.send().await?.error_for_status()?.json().await?)
            }
            fn _path(&self) -> String {
                let mut output = "https://mybusinesslodging.googleapis.com/".to_owned();
                output.push_str("v1/");
                {
                    let var_as_str = &self.name;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::RESERVED,
                    ));
                }
                output
            }
            async fn _request(
                &self,
                path: &str,
            ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                let mut req = self.reqwest.request(::reqwest::Method::PATCH, path);
                req = req.query(&[("updateMask", &self.update_mask)]);
                req = req.query(&[("access_token", &self.access_token)]);
                req = req.query(&[("alt", &self.alt)]);
                req = req.query(&[("callback", &self.callback)]);
                req = req.query(&[("fields", &self.fields)]);
                req = req.query(&[("key", &self.key)]);
                req = req.query(&[("oauth_token", &self.oauth_token)]);
                req = req.query(&[("prettyPrint", &self.pretty_print)]);
                req = req.query(&[("quotaUser", &self.quota_user)]);
                req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                req = req.query(&[("uploadType", &self.upload_type)]);
                req = req.query(&[("$.xgafv", &self.xgafv)]);
                let access_token = self
                    .auth
                    .access_token()
                    .await
                    .map_err(|err| crate::Error::OAuth2(err))?;
                req = req.bearer_auth(access_token);
                Ok(req)
            }
        }
        pub mod lodging {
            pub mod params {}
            pub struct LodgingActions<'a> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
            }
            impl<'a> LodgingActions<'a> {
                fn auth_ref(&self) -> &dyn ::google_api_auth::GetAccessToken {
                    self.auth
                }
                #[doc = "Returns the Google updated Lodging of a specific location."]
                pub fn get_google_updated(
                    &self,
                    name: impl Into<String>,
                ) -> GetGoogleUpdatedRequestBuilder {
                    GetGoogleUpdatedRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: self.auth_ref(),
                        access_token: None,
                        alt: None,
                        callback: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        upload_protocol: None,
                        upload_type: None,
                        xgafv: None,
                        name: name.into(),
                        read_mask: None,
                    }
                }
            }
            #[doc = "Created via [LodgingActions::get_google_updated()](struct.LodgingActions.html#method.get_google_updated)"]
            #[derive(Debug, Clone)]
            pub struct GetGoogleUpdatedRequestBuilder<'a> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a dyn ::google_api_auth::GetAccessToken,
                name: String,
                read_mask: ::std::option::Option<String>,
                access_token: ::std::option::Option<String>,
                alt: ::std::option::Option<crate::params::Alt>,
                callback: ::std::option::Option<String>,
                fields: ::std::option::Option<String>,
                key: ::std::option::Option<String>,
                oauth_token: ::std::option::Option<String>,
                pretty_print: ::std::option::Option<bool>,
                quota_user: ::std::option::Option<String>,
                upload_protocol: ::std::option::Option<String>,
                upload_type: ::std::option::Option<String>,
                xgafv: ::std::option::Option<crate::params::Xgafv>,
            }
            impl<'a> GetGoogleUpdatedRequestBuilder<'a> {
                #[doc = "Required. The specific fields to return. Use \"*\" to include all fields. Repeated field items cannot be individually specified."]
                pub fn read_mask(mut self, value: impl Into<String>) -> Self {
                    self.read_mask = Some(value.into());
                    self
                }
                #[doc = "OAuth access token."]
                pub fn access_token(mut self, value: impl Into<String>) -> Self {
                    self.access_token = Some(value.into());
                    self
                }
                #[doc = "JSONP"]
                pub fn callback(mut self, value: impl Into<String>) -> Self {
                    self.callback = Some(value.into());
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Upload protocol for media (e.g. \"raw\", \"multipart\")."]
                pub fn upload_protocol(mut self, value: impl Into<String>) -> Self {
                    self.upload_protocol = Some(value.into());
                    self
                }
                #[doc = "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."]
                pub fn upload_type(mut self, value: impl Into<String>) -> Self {
                    self.upload_type = Some(value.into());
                    self
                }
                #[doc = "V1 error format."]
                pub fn xgafv(mut self, value: crate::params::Xgafv) -> Self {
                    self.xgafv = Some(value);
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub async fn execute<T>(self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned + ::google_field_selector::FieldSelector,
                {
                    let fields = ::google_field_selector::to_string::<T>();
                    let fields: ::std::option::Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_with_fields(fields).await
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub async fn execute_with_default_fields(
                    self,
                ) -> Result<crate::schemas::GetGoogleUpdatedLodgingResponse, crate::Error>
                {
                    self.execute_with_fields(None::<&str>).await
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub async fn execute_with_all_fields(
                    self,
                ) -> Result<crate::schemas::GetGoogleUpdatedLodgingResponse, crate::Error>
                {
                    self.execute_with_fields(Some("*")).await
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub async fn execute_with_fields<T, F>(
                    mut self,
                    fields: ::std::option::Option<F>,
                ) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute().await
                }
                async fn _execute<T>(&mut self) -> Result<T, crate::Error>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path()).await?;
                    Ok(req.send().await?.error_for_status()?.json().await?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://mybusinesslodging.googleapis.com/".to_owned();
                    output.push_str("v1/");
                    {
                        let var_as_str = &self.name;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::RESERVED,
                        ));
                    }
                    output.push_str(":getGoogleUpdated");
                    output
                }
                async fn _request(
                    &self,
                    path: &str,
                ) -> Result<::reqwest::RequestBuilder, crate::Error> {
                    let mut req = self.reqwest.request(::reqwest::Method::GET, path);
                    req = req.query(&[("readMask", &self.read_mask)]);
                    req = req.query(&[("access_token", &self.access_token)]);
                    req = req.query(&[("alt", &self.alt)]);
                    req = req.query(&[("callback", &self.callback)]);
                    req = req.query(&[("fields", &self.fields)]);
                    req = req.query(&[("key", &self.key)]);
                    req = req.query(&[("oauth_token", &self.oauth_token)]);
                    req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    req = req.query(&[("quotaUser", &self.quota_user)]);
                    req = req.query(&[("upload_protocol", &self.upload_protocol)]);
                    req = req.query(&[("uploadType", &self.upload_type)]);
                    req = req.query(&[("$.xgafv", &self.xgafv)]);
                    let access_token = self
                        .auth
                        .access_token()
                        .await
                        .map_err(|err| crate::Error::OAuth2(err))?;
                    req = req.bearer_auth(access_token);
                    Ok(req)
                }
            }
        }
    }
}
#[derive(Debug)]
pub enum Error {
    OAuth2(Box<dyn ::std::error::Error + Send + Sync>),
    JSON(::serde_json::Error),
    Reqwest {
        reqwest_err: ::reqwest::Error,
        body: Option<String>,
    },
    IO(std::io::Error),
    Other(Box<dyn ::std::error::Error + Send + Sync>),
}

impl Error {
    pub fn json_error(&self) -> Option<&::serde_json::Error> {
        match self {
            Error::OAuth2(_) => None,
            Error::JSON(err) => Some(err),
            Error::Reqwest { .. } => None,
            Error::IO(_) => None,
            Error::Other(_) => None,
        }
    }
}

impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            Error::OAuth2(err) => write!(f, "OAuth2 Error: {}", err),
            Error::JSON(err) => write!(f, "JSON Error: {}", err),
            Error::Reqwest { reqwest_err, body } => {
                write!(f, "Reqwest Error: {}", reqwest_err)?;
                if let Some(body) = body {
                    write!(f, ": {}", body)?;
                }
                Ok(())
            }
            Error::IO(err) => write!(f, "IO Error: {}", err),
            Error::Other(err) => write!(f, "Uknown Error: {}", err),
        }
    }
}

impl ::std::error::Error for Error {}

impl From<::serde_json::Error> for Error {
    fn from(err: ::serde_json::Error) -> Error {
        Error::JSON(err)
    }
}

impl From<::reqwest::Error> for Error {
    fn from(reqwest_err: ::reqwest::Error) -> Error {
        Error::Reqwest {
            reqwest_err,
            body: None,
        }
    }
}

impl From<std::io::Error> for Error {
    fn from(err: std::io::Error) -> Error {
        Error::IO(err)
    }
}
#[allow(dead_code)]
const SIMPLE: &::percent_encoding::AsciiSet = &::percent_encoding::NON_ALPHANUMERIC
    .remove(b'-')
    .remove(b'.')
    .remove(b'_')
    .remove(b'~');

#[allow(dead_code)]
const RESERVED: &::percent_encoding::AsciiSet = &SIMPLE
    .remove(b'%')
    .remove(b':')
    .remove(b'/')
    .remove(b'?')
    .remove(b'#')
    .remove(b'[')
    .remove(b']')
    .remove(b'@')
    .remove(b'!')
    .remove(b'$')
    .remove(b'&')
    .remove(b'\'')
    .remove(b'(')
    .remove(b')')
    .remove(b'*')
    .remove(b'+')
    .remove(b',')
    .remove(b';')
    .remove(b'=');
#[allow(dead_code)]
mod multipart {
    pub(crate) struct RelatedMultiPart {
        parts: Vec<Part>,
        boundary: String,
    }

    impl RelatedMultiPart {
        pub(crate) fn new() -> Self {
            RelatedMultiPart {
                parts: Vec::new(),
                boundary: ::textnonce::TextNonce::sized(68).unwrap().0,
            }
        }

        pub(crate) fn new_part(&mut self, part: Part) {
            self.parts.push(part);
        }

        pub(crate) fn boundary(&self) -> &str {
            &self.boundary
        }

        pub(crate) fn into_reader(self) -> RelatedMultiPartReader {
            let boundary_marker = boundary_marker(&self.boundary);
            RelatedMultiPartReader {
                state: RelatedMultiPartReaderState::WriteBoundary {
                    start: 0,
                    boundary: format!("{}\r\n", &boundary_marker),
                },
                boundary: boundary_marker,
                next_body: None,
                parts: self.parts.into_iter(),
            }
        }
    }

    pub(crate) struct Part {
        content_type: ::mime::Mime,
        body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
    }

    impl Part {
        pub(crate) fn new(
            content_type: ::mime::Mime,
            body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
        ) -> Part {
            Part { content_type, body }
        }
    }

    pub(crate) struct RelatedMultiPartReader {
        state: RelatedMultiPartReaderState,
        boundary: String,
        next_body: Option<Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>>,
        parts: std::vec::IntoIter<Part>,
    }

    enum RelatedMultiPartReaderState {
        WriteBoundary {
            start: usize,
            boundary: String,
        },
        WriteContentType {
            start: usize,
            content_type: Vec<u8>,
        },
        WriteBody {
            body: Box<dyn futures::io::AsyncRead + std::marker::Unpin + Send>,
        },
    }

    impl futures::io::AsyncRead for RelatedMultiPartReader {
        fn poll_read(
            mut self: std::pin::Pin<&mut Self>,
            ctx: &mut futures::task::Context,
            buf: &mut [u8],
        ) -> futures::task::Poll<Result<usize, futures::io::Error>> {
            use RelatedMultiPartReaderState::*;

            let mut bytes_written: usize = 0;
            loop {
                let rem_buf = &mut buf[bytes_written..];
                match &mut self.state {
                    WriteBoundary { start, boundary } => {
                        let bytes_to_copy = std::cmp::min(boundary.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&boundary.as_bytes()[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == boundary.len() {
                            let next_part = match self.parts.next() {
                                None => break,
                                Some(part) => part,
                            };
                            self.next_body = Some(next_part.body);
                            self.state = WriteContentType {
                                start: 0,
                                content_type: format!(
                                    "Content-Type: {}\r\n\r\n",
                                    next_part.content_type
                                )
                                .into_bytes(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteContentType {
                        start,
                        content_type,
                    } => {
                        let bytes_to_copy =
                            std::cmp::min(content_type.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&content_type[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == content_type.len() {
                            self.state = WriteBody {
                                body: self.next_body.take().unwrap(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteBody { body } => {
                        let body = std::pin::Pin::new(body);
                        let written = match futures::io::AsyncRead::poll_read(body, ctx, rem_buf) {
                            futures::task::Poll::Ready(Ok(n)) => n,
                            futures::task::Poll::Ready(Err(err)) => {
                                return futures::task::Poll::Ready(Err(err));
                            }
                            futures::task::Poll::Pending => return futures::task::Poll::Pending,
                        };
                        bytes_written += written;
                        if written == 0 {
                            self.state = WriteBoundary {
                                start: 0,
                                boundary: format!("\r\n{}\r\n", &self.boundary),
                            };
                        } else {
                            break;
                        }
                    }
                }
            }

            futures::task::Poll::Ready(Ok(bytes_written))
        }
    }

    fn boundary_marker(boundary: &str) -> String {
        let mut marker = String::with_capacity(boundary.len() + 2);
        marker.push_str("--");
        marker.push_str(boundary);
        marker
    }
}
// A serde helper module that can be used with the `with` attribute
// to deserialize any string to a FromStr type and serialize any
// Display type to a String. Google API's encode i64, u64 values as
// strings.
#[allow(dead_code)]
mod parsed_string {
    pub fn serialize<T, S>(
        value: &Option<T>,
        serializer: S,
    ) -> ::std::result::Result<S::Ok, S::Error>
    where
        T: ::std::fmt::Display,
        S: ::serde::Serializer,
    {
        use ::serde::Serialize;
        value.as_ref().map(|x| x.to_string()).serialize(serializer)
    }

    pub fn deserialize<'de, T, D>(deserializer: D) -> ::std::result::Result<Option<T>, D::Error>
    where
        T: ::std::str::FromStr,
        T::Err: ::std::fmt::Display,
        D: ::serde::de::Deserializer<'de>,
    {
        use ::serde::Deserialize;
        match Option::<String>::deserialize(deserializer)? {
            Some(x) => Ok(Some(x.parse().map_err(::serde::de::Error::custom)?)),
            None => Ok(None),
        }
    }
}
/// Represent the ability to extract the `nextPageToken` from a response.
pub trait GetNextPageToken {
    /// Get the `nextPageToken` from a response if present.
    fn next_page_token(&self) -> ::std::option::Option<String>;
}

impl GetNextPageToken for ::serde_json::Map<String, ::serde_json::Value> {
    fn next_page_token(&self) -> ::std::option::Option<String> {
        self.get("nextPageToken")
            .and_then(|t| t.as_str())
            .map(|s| s.to_owned())
    }
}
